;; xplDOS
;; unix-esque SD Card Navigation system.
;;
;; the first byte of path is 0 if there was an init error.
;; otherwise it is a index to PATH for the empty space after the last foldername
;; to calculate what value 0 is when v is PATH+0 and f is the amount of folders, use:
;; v = 11f+1
;; for example:
;; 23,"FOLDER     ", "TEST       ", $00 <--path points here (11+11+1=23)
;; BUG root usage is not possible, thus, it is required that we are in a folder (ls does not seem to like reading the SD root.)
;; TODO add path support to a typed command
;; TODO need to add /path support to file-based commands  
;; Commands:
;; CD
;; LS
;; LOAD
;; CAT
;; SAVE
;; RM
;; MV
;; upcoming commands (TODO):
;; MKDIR
;; EDIT (or VI?)
;; CP
;; TAR?
;; MAN?

; Jump to / dir
; jumps to a dir with a /
; temp addr at "tmp"

;jmpdir:
;.(
;  ; stash folderpointer
;  lda folderpointer
;  sta pathindex
;  lda folderpointer+1
;  sta pathindex+1
;  lda #<tmp
;  sta folderpointer
;  lda #>tmp
;  sta folderpointer+1
;  ; check if there is a slash at all
;  ldy #0
;chklp:
;  lda (pathindex),y
;  beq no
;  cmp '/'
;  beq css
;  iny
;  jmp chklp
;css:  
;  cpy #0	; was the / at the start? ex. "ls /folder"
;  beq root	;				  ^			
;  ; ok. the path is relative. (ls test/hi) NOT root (ls /test/hi)	 
;  ; now incrementally cd
;  ldy #0
;  jmp cse
;cslp:
;  lda (pathindex),y
;  beq csdone
;  cmp '/'	; / ?
;  beq csdn
;  iny
;  jmp cslp
;csdn:
;  iny
;cse:
;  ; a dot?
;;  lda (pathindex),y
;;  cmp #$2e
;;  bne csnd
;;  iny
;;  lda (pathindex),y 
;;  cmp #$2e
;;  bne csndd
;;  ; if .. then go back
;;  jsr backpath
;;  lda dircnt
;;  bne csnd
;;  ; auugh
;;  jmp csnd
;;csndd:
;;  ; if . then do nothing
;;  dey
;;csnd:
;  inc dircnt
;  ; convert to uppercase
;  ; first copy to temp addr
;  phy
;  ldx #0
;csclp:
;  lda (pathindex),y
;  beq scn
;  cmp #'/'
;  beq scn
;  sta tmp,x
;  iny
;  inx
;  jmp csclp
;scn:
;  lda #$2e
;  sta tmp,x
;  inx
;  lda #$20
;  ldy #0
;scnl:
;  sta tmp,x
;  inx
;  iny
;  cpy #3
;  bne scnl
;  ply
;  ; then convert
;  jsr shortconvert
;  jsr addpath	; add it
;  ; next folder
;  clc
;  tya
;  adc folderpointer
;  sta folderpointer
;  jmp cslp
;csdone:
;  lda pathindex
;  sta folderpointer
;  lda pathindex+1
;  sta folderpointer+1
;  jsr refreshpath	; load it
;  ; all done
;  clc
;  rts
;root:
;  ; root !!
;  ldx #<rootmsg
;  ldy #>rootmsg
;  jsr w_acia_full
;no:
;  ; no / dir
;  ; proceed normally
;  stz dircnt
;  lda pathindex
;  sta folderpointer
;  lda pathindex+1
;  sta folderpointer+1
;  sec
;  rts
;.)
;
;rootmsg:
;  .byte "Root Not Yet Supported! Use ", $22, "folder", $22, " instead", $0d, $0a, $00

; PATH refresh
; goes to the ROOT directory, and CDs to the directory at PATH.
;
; this is probably equivilent to "Refresh" in Microsoft Windows.
refreshpath:
.(
  ; No memory card?
  lda path
  beq patherr
  lda #1	; path+1 because path+0 is the path size variable
  sta pathindex
  ; If memory card, then goto dir
  jsr fat32_openroot
rloop:
  ; Open the directory
  ldx pathindex
  ldy #>path
  jsr fat32_finddirent
  bcc fine
  jmp rlerror
fine:
  jsr fat32_opendirent
  ; advance to the next directory
  clc
  lda pathindex
  adc #11
  sta pathindex
  ;lda (pathindex) ; end of path?
  lda path
  cmp pathindex
  bne rloop      ; if not, cd to the next directory
  clc
  rts
.)
patherr:
  ldx #<patherror
  ldy #>patherror
  jsr w_acia_full
  sec
  rts
rlerror:
  ldx #<foldermsg
  ldy #>foldermsg
  jsr w_acia_full
  sec
  rts

; add PATH
; adds a SHORT formatted folder at (folderpointer) to the PATH variable.
addpath:
.(
  pha
  phx
  phy
  ldy #0
  ldx path
aplp:
  lda (folderpointer),y
  sta path,x
  iny
  inx
  cpy #11
  bne aplp
  stz path,x
  stx path
  ply
  plx
  pla
  rts
.)

; delete PATH
; goes back a directory, used in cd ..
backpath:
.(
  phx
  pha
  sec
  lda path
  sbc #11	; remove dir
  sta path
  ldx path
  stz path,x
  pla
  plx
  rts
.)

patherror:
  .byte "No Memory Card.", $0d, $0a, $00

;; print PATH
;; prints the current directory, like linux/unix
;; for example,
;; /folder/test/>_
;;
printpath:
.(
  ; No memory card?
  lda path
  bne ppc
  sec
  rts
  ;jmp rlerror
ppc:
  lda #'/'
  jsr print_chara
  lda #1	     ; path+1 because path+0 is the path size variable
  sta pathindex
  lda #>path
  sta pathindex+1
  ldy #0
pplp:
  ; loop through path and print the folder, in lowercase
  lda (pathindex),y
  cmp #$20 	     ; space?
  beq ppd	
  ora #$20 	     ; if not, print (in lowercase)
  jsr print_chara
  iny
  jmp pplp
ppd:
  lda #'/' ; if space, dir done.
  jsr print_chara
ppdl:
  lda (pathindex),y  ; look for the next entry.
  cmp #$20
  bne notspace
  iny
  jmp ppdl
notspace:
  lda (pathindex),y  ; end of path?
  beq ppdone
  jmp pplp	     ; no, print another folder name.
ppdone:
  clc
  rts		     ; done!
.)

;; CD
;; Change the directory
;; if you use cdsub, folderpointer holds the address of the folder name

cdcmd:
.(
  phx
  lda path
  bne cdf
  jmp patherr
cdf:
  ;; check arguments
  lda ARGINDEX
  cmp #2	       ; if there's two arguments, change to the specified directory
  beq processparam
  jmp error
processparam           ; process the filename parameter
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta folderpointer
  lda #>INPUT
  sta folderpointer+1
.)
cdd:
.(
  ; handle dir
  ;jsr jmpdir 
  ;bcc cdbb
  ; check for . or ..
  jsr cdshort
  lda backdir
  cmp #$55
  beq cdbb
  ; ok, that should do it.
  ; Open root directory
  ;jsr fat32_openroot	
  ; Find the subdirectory by name
  ;ldx #<subdirname
  ;ldy #>subdirname
  ;jsr fat32_finddirent
  ;bcs error
  ; Open subdirectory
  ;jsr fat32_opendirent	; open folder
  jsr refreshpath
.)
cdsub:
  ; check if the folder exists + get info
  ldx folderpointer
  ldy folderpointer+1
  jsr fat32_finddirent
  bcs fileerror
  ; ok, it exists, now cd
  jsr fat32_opendirent
  ; all done.
  ; now add this to the current directory, only if no cd ..
  lda backdir
  beq cdbb
  jsr addpath
cdbb:
  plx
  rts

cdshort:
.(
  ; check for . or ..
  ldy #0
  lda (folderpointer),y
  cmp #$2e
  beq dotf
  lda #$ff
  sta backdir
  jmp nopd
dotf:
  iny
  lda (folderpointer),y
  cmp #$2e
  beq backdire
  lda #$55
  sta backdir
  rts ; do nothing if "cd ."
backdire:
  ; "cd .." means go back
  jsr backpath
  stz backdir
  ;jsr refreshpath
  ;rts
nopd:
  ; convert lowercase to uppercase
  ldy #0
cdlp:
  lda (folderpointer),y
  beq fill   ; if null, stop.
  cmp #$40  ; if numbers/symbols, skip.
  bcc dont
  cmp #$5f  ; if _ skip
  beq dont
  and #$df  ; otherwise convert to uppercase
  sta (folderpointer),y
dont:
  iny
  jmp cdlp
  ; we need to loop through the null-terminated string
  ; and convert it to SHORT format
fill:
  lda #$20
filllp:
  sta (folderpointer),y
  iny
  cpy #12 ; stop if index over 11
  bne filllp
  rts
.)

fileerror
  ; no such folder
  ldx #<foldermsg
  ldy #>foldermsg
  jsr w_acia_full
  rts

error
  ldx #<errormsg
  ldy #>errormsg
  jsr w_acia_full
  rts

;; CAT
;; prints out a file

catcmd:
.(
  lda path
  bne cdf
  jmp patherr
cdf:
  ;; check arguments
  lda ARGINDEX
  cmp #2
  bne error
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta folderpointer
  lda #>INPUT
  sta folderpointer+1
  ; Convert to SHORT
  jsr shortconvert
  ; Refresh Path
  jsr refreshpath
  ; Find the file
  ldx folderpointer
  ldy folderpointer+1
  jsr fat32_finddirent
  bcs error
  ; Open the file
  jsr fat32_opendirent
  ; Read file contents into buffer
  lda #<buffer
  sta fat32_address
  lda #>buffer
  sta fat32_address+1
redlp:
  jsr fat32_file_readbyte
  beq catd
  jsr print_chara
  jmp redlp
catd:
  ; Dump to screen
  ;ldx #<buffer
  ;ldy #>buffer
  ;jsr w_acia_full
  ; CR LF
  jsr crlf
  rts
.)

shortconvert:
.(
  ; loop through the null-terminated string at (folderpointer)
  ; and convert it to SHORT format.
  ; ex. "file.xpl",0 --> "FILE    XPL"
  ldy #22
  lda #0
  sta (folderpointer),y
  lda #19
  sta fileext
  ldy #0
shortlp:
  lda (folderpointer),y
  cmp #$2e		; find the dot	
  beq extst
  cmp #0
  beq nodot
  iny
  jmp shortlp
nodot
  ; no dot, this is a folder
  ; empty out the extension
  lda #$20
  ldy #$19
  sta (folderpointer),y
  iny
  sta (folderpointer),y
  iny
  sta (folderpointer),y
  jmp mvname  ; ok, go ahead and copy the name
extst:
  sty sc		; now move the file extension
ext:
  iny
  lda (folderpointer),y
  phy
  ldy fileext
  sta (folderpointer),y
  iny
  sty fileext
  cpy #22
  beq extd
  ply
  jmp ext
extd:
  ply
  clc
  lda sc	; add to sc
  adc #11
  sta sc
  lda #11
  sta fileext
mvname:
  ; move name
  ldy #0
  jmp mvlp+1
mvlp:
  iny
  lda (folderpointer),y
  phy
  ldy fileext
  sta (folderpointer),y
  iny
  sty fileext
  cpy sc
  beq ad2sc
  ply
  jmp mvlp
ad2sc:
  ply
  ldy sc
; the file extention is moved, now pad spaces from the end of the name
; to the start of the extension.
fill:
  lda #$20		
filllp:			
  sta (folderpointer),y
  iny
  cpy #19 		; stop if index over 18, we don't want to overwrite the file extension
  bne filllp
  ; add 11 to folderpointer
  clc
  lda folderpointer
  adc #11
  sta folderpointer
  ; now we need to convert lowercase to uppercase
  ldy #0
ldlp:
  lda (folderpointer),y
  beq ldd   ; if null, stop.
  cmp #$40  ; if numbers/symbols/space, skip.
  bcc dontl
  cmp #$5f  ; if _ skip
  beq dontl
  and #$df  ; otherwise convert to uppercase
  sta (folderpointer),y
dontl:
  iny
  jmp ldlp
ldd:
  ; ok! now we have a SHORT formatted filename at (folderpointer).
  rts
.)

other:
  ; Write a letter of the filename currently being read
  lda (zp_sd_address),y
  ora #$20		; convert uppercase to lowercase
  jsr print_chara
  iny
  rts

;; LS
;; print a directory listing

lscmd:
.(
  lda path
  bne cdf
  jmp patherr
cdf:
  ;; check arguments
  lda ARGINDEX
  cmp #2	       ; if there's two arguments, list the specified directory
  beq processparam
  lda ARGINDEX
  cmp #1	       ; if there's only one argument (ls) then list current directory 
  bne jmperror
  jsr refreshpath
  lda #$ff
  sta backdir
  jmp list
jmperror:
  jmp error
processparam           ; process the filename parameter
  stz backdir
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta folderpointer
  lda #>INPUT
  sta folderpointer+1
  ; get /
  ;jsr jmpdir
  ;bcc dontcd
  ; now cd
  jsr cdd
;dontcd:
  stz backdir
.)
list:			; list file dir
.(
  jsr fat32_readdirent	; files?
  bcs nofiles
  ;and #$40
  ;beq arc
ebut:
  ldx #0
  ldy #8
chklp:
  cpy #11
  beq no
  lda (zp_sd_address),y
  cmp #$20
  bne chky
  inx
chky:
  iny
  jmp chklp
no:
  cpx #3
  bne arc
dir:
  lda #$ff
  sta filetype		; directorys show up as 
  jmp name		; yourfilename     test		    folder  ...Etc
arc:
  stz filetype 		; files show up as
name:			; test.xpl         music.xpl        file.bin  ...Etc
  ; At this point, we know that there are no files, files, or a suddir
  ; Now for the name
  ldy #0
nameloop:
  cpy #8
  beq dot
  jsr other
  jmp nameloop
dot:
  lda filetype
  bne endthat		; if it's a file,
  lda #$2e		; shows its file extention
  jsr print_chara
lopii:
  cpy #11
  beq endthat		; print 3-letter file extention
  jsr other
  jmp lopii
endthat:
  lda #$09 ; Tab
  jsr print_chara	; tab
  jmp list ; go again	; next file if there are any left
nofiles:		; if not,
endlist:		; exit listing code
  jsr crlf
  lda backdir
  bne dontb
;  lda dircnt
;  beq nono
;  ldx #0
;dddl:
;  jsr backpath
;  inx
;  cpx dircnt
;  bne dddl
;  jmp dontb
;nono:
  jsr backpath		; cd .. if ls <folderpath>
dontb:
  jsr refreshpath	; refresh the directory
  rts
jumptolist:
  jsr crlf
  jmp list
.)

;; load
;; Here we load a file from the SD card.
;; .SAR stands for Start AddRess.

loadcmd
.(
  lda path
  bne cdf
  jmp patherr
cdf:
  ;; check arguments
  lda ARGINDEX
  cmp #2	       ; if there's two arguments, load the specified file
  beq lprocessparam
  lda ARGINDEX
  cmp #1	       ; if there's only one argument, do a handeler load.
  beq loadone
.)
lderror:
  ldx #<foldermsg	; if it was not found, error and return.
  ldy #>foldermsg
  jsr w_acia_full
  rts
lprocessparam           ; the user specified a file, process the filename parameter.
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta folderpointer
  lda #>INPUT		; argument buffer under 256 bytes, so no adc #0.
  sta folderpointer+1
loadlc:
.(
  ; convert string
  jsr shortconvert
  ; is this a .XPL file?
  ldy #$08
  lda (folderpointer),y
  cmp #'X'
  bne ldp
  iny
  cmp #'P'
  bne ldp
  iny
  cmp #'L'
  bne ldp
  lda #$ff
  sta buffer+4
ldp:
  stz buffer+4
.)
loadpath:
.(
  ; Refresh
  jsr refreshpath
  ; Loading..
  ldx #<loading_msg
  ldy #>loading_msg
  jsr w_acia_full
  ; BUG i need to add a start address header to the .XPL file format...
  ; at the moment it is assumed that the file will load and run at $0F00
  stz buffer
  stz buffer+2
  lda #$0f 		; $0F00
  sta buffer+1
  sta buffer+3
  ldx folderpointer
  ldy folderpointer+1	; find the file
  jsr fat32_finddirent
  bcc loadfoundcode
  jmp lderror
.)
loadone:
.(
  ; the user has not specified a filename, so load the SD card handeler program.

  jsr loadf

  ; Find file by name
  ldx #<loadname
  ldy #>loadname		; this is LOADADDR.SAR, which is what I plan 
  jsr fat32_finddirent		; to merge into a header of .XPL files.
  bcc foundfile			; it holds the load address and jump address
				; of CODE.XPL.
  ; File not found
  ldy #>filmsg
  ldx #<filmsg
  jsr w_acia_full
  jmp lo

foundfile
 
  ; Open file
  jsr fat32_opendirent

  ; Read file contents into buffer
  lda #<buffer
  sta fat32_address
  lda #>buffer
  sta fat32_address+1
				
  jsr fat32_file_read	

  stz buffer+4	

  jsr loadf		; BUG really?

  ldy #>lds
  ldx #<lds
  jsr w_acia_full

  ldx #<filename	; CODE.XPL is the sd card's loader
  ldy #>filename
  jsr fat32_finddirent
  bcc loadfoundcode

  ldy #>filmsg2
  ldx #<filmsg2
  jsr w_acia_full
  rts
  rts
  rts
.)
loadfoundcode
.(
  jsr fat32_opendirent	; open the file

  lda buffer		; and load it to the address
  sta fat32_address	; from LOADADDR.SAR
  lda buffer+1
  sta fat32_address+1

  jsr fat32_file_read

  ; All done.

  ldy #>ends
  ldx #<ends
  jsr w_acia_full

  ; Is this a XPL file?
  lda buffer+4
  bne lo

  jmp (buffer+2)	; jump to start address from LOADADDR.SAR

.)

lo:
  rts

loadf:
; Open root directory
  jsr fat32_openroot

  ; Find subdirectory by name
  ldx #<subdirname
  ldy #>subdirname
  jsr fat32_finddirent
  bcc foundsubdir

  ; Subdirectory not found
  ldy #>submsg
  ldx #<submsg
  jsr w_acia_full
  jmp lo

foundsubdir

  ; Open subdirectory
  jmp fat32_opendirent

savecmd:
.(
  ; Save a file.
  phx
  lda path
  bne sv
  jmp patherr
sv:
  lda ARGINDEX
  cmp #4
  beq proc
  jmp error
proc:
  ; filename
  clc
  lda #<INPUT
  adc ARGINDEX+4
  sta folderpointer
  lda #>INPUT
  sta folderpointer+1
  ; convert it to SHORT
  jsr shortconvert
  lda folderpointer
  sta savepoint 
  lda folderpointer+1
  sta savepoint+1
  ; second addr parameter
  clc 
  lda #<INPUT
  adc ARGINDEX+3
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read16hex
  ; first address parameter
  clc 
  lda #<INPUT
  adc ARGINDEX+2
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read16hex
  ; stash them
  jsr pop16
  lda stackaccess
  sta savestart
  lda stackaccess+1
  sta savestart+1
  jsr pop16
  jmp sg
.)
savekernal:
  phx
sg:
.(
  ; now lets begin 
  ; First, allocate a free cluster
  jsr fat32_allocatecluster
  ; Refresh PATH
  jsr refreshpath
  ; Open the filename
  ldx savepoint
  ldy savepoint+1
  ; Check if the file exists
  jsr fat32_finddirent
  bcc fileexists
  jmp nf
fileexists:
  ; If so, ask the user if they would like to overwrite the file.
  ldx #<femsg
  ldy #>femsg
  jsr w_acia_full
  jsr rxpoll
  lda $8000
  cmp #'y'  ; response = 'y'?
  beq yes
  jsr crlf  ; no, cancel save
  plx
  rts
yes
  ; we would like to overwrite the file.
  jsr crlf
  ; delete it to clean the FAT
  jsr fat32_deletefile
nf:
  jsr refreshpath
  ldx #<savemsg
  ldy #>savemsg
  jsr w_acia_full
  ; Calculate file size by subtracting the end address by the start address
  sec
  lda stackaccess
  sbc savestart
  sta fat32_bytesremaining
  lda stackaccess+1
  sbc savestart+1
  sta fat32_bytesremaining+1
  ; Put the filename at fat32_filenamepointer
  lda savepoint
  sta fat32_filenamepointer
  lda savepoint+1
  sta fat32_filenamepointer+1 
  ; Write a directory entry for this file
  jsr fat32_writedirent
  ; Now, to actually write the file...
  lda savestart
  sta fat32_address
  lda savestart+1
  sta fat32_address+1
  jsr fat32_file_write
  ; All Done!
  ldx #<ends
  ldy #>ends
  jsr w_acia_full
saveexit:
  plx
  rts
.)

rmcmd:
.(
; Remove a file
  phx
  lda path
  bne rm
  jmp patherr
rm:
  ;; check arguments
  lda ARGINDEX
  cmp #2	       ; if there's two arguments, load the specified file
  beq proc
  jmp error
proc: 
  ; filename
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta folderpointer
  lda #>INPUT
  sta folderpointer+1
  ; convert it to SHORT
  jsr shortconvert
  lda folderpointer
  sta savepoint
  lda folderpointer+1
  sta savepoint+1
  ; path refresh
  jsr refreshpath
  ; load
  ldx savepoint
  ldy savepoint+1
  ; find it
  jsr fat32_finddirent
  bcc foundfile
  jsr rlerror
  plx
  rts  
foundfile: 
  jsr fat32_deletefile
  ; done
  plx
  rts
.)

mvcmd:
.(
; Move a file.
  phx
  lda path
  bne mv
  jmp patherr
mv:
  ;; check arguments
  lda ARGINDEX
  cmp #3
  beq proc
  jmp error
proc: 
  ; fetch first filename
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta folderpointer
  lda #>INPUT
  sta folderpointer+1
  jsr overf
  ; convert it to SHORT
  jsr shortconvert
  ldx folderpointer
  phx
  ldy folderpointer+1
  phy
  ; path refresh
  jsr refreshpath
  ; load
  plx
  ply
  ; find it
  jsr fat32_finddirent
  bcc gotit
  jmp mvfail
gotit:
  ; carry already clear
  ; get the folder to move it to
  lda #<INPUT
  adc ARGINDEX+3
  sta folderpointer
  lda #>INPUT
  sta folderpointer+1
  jsr overf
  ; convert it to SHORT
  ldx folderpointer
  phx
  ldy folderpointer+1
  phy
  ; Now, for the copy
  ; Store the dirent temporaraly
  ldy #0
stlp
  lda (zp_sd_address),y
  sta buffer,y
  iny
  cpy #$20
  bne stlp
  ; Now, mark it a deleted file
  jsr fat32_markdeleted
  ; Find the directory
  lda backdir
  beq nono
nono:
  plx
  ply
  jsr fat32_finddirent
  bcc mvgotdirent 
mvfail
  ; The directory was not found
  jsr rlerror
  plx
  rts
mvgotdirent
  ; It was, open it.
  jsr fat32_opendirent
  ; Ok. now we need to find a free entry
mvlp
  jsr fat32_readdirent
  bcc mvlp
  ; Got it. now paste the file here
  ldy #0
mvpaste
  lda buffer,y
  sta (zp_sd_address),y
  iny
  cpy #$20
  bne mvpaste
  ; Just to be sure, zero out the next entry.
  lda #0
  sta (zp_sd_address),y
  ; Now write the sector
  jsr fat32_wrcurrent
  ; Done!
  plx
  rts
overf:
; copy it to the buffer so we don't overwrite the foldername
  ldy #0
mvff
  lda (folderpointer),y
  sta buffer+32,y
  iny
  cpy #13
  bne mvff
mvdn:
  ; store location
  lda #<buffer+32
  sta folderpointer
  lda #>buffer+32
  sta folderpointer+1
  rts
.)

submsg
  .byte "'folder' Not Found!", $00
filmsg
  .byte "'loadaddr.sar' Not Found!", $00
filmsg2
  .byte "'code.xpl' Not Found!", $00
lds
  .byte "Loading SD Handler...", $00
savemsg:
  .byte "Saving...", $00
ends
  .byte "Done.", $0d, $0a, $00
femsg:
  .byte "File exists. Overwrite? (y/n): ", $00  
foldermsg:
  .byte "No such file or directory.", $0d, $0a, $00


