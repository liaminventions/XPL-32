;;; __   ________ _      ___  ___            _ _             
;;; \ \ / /| ___ \ |     |  \/  |           (_) |            
;;;  \ V / | |_/ / |     | .  . | ___  _ __  _| |_ ___  _ __ 
;;;  /   \ |  __/| |     | |\/| |/ _ \| '_ \| | __/ _ \| '__|
;;; / /^\ \| |   | |_32_ | |  | | (_) | | | | | || (_) | |   
;;; \/   \/\_|   \_____/ \_|  |_/\___/|_| |_|_|\__\___/|_|   
;;;
;;; MITEMON (for XPL-32)
;;; 
;;; Very simple ROM monitor for the 6502 Mite single-board computer..
;;; But this version is for the XPL-32.
;;; Originally enough to poke around and make sure that things
;;; are working.
;;;
;;; There are also some loading and saving stuff as well.
;;;
;;; This also technically acts as an OS for the XPL...
;;;
;;; v3 parses command line arguments
;;; v4 does basic command dispatch and some simple commands
;;; v5 rebuilding around a stack-based calling convention
;;; v6 adding XMODEM to upload files and a memory test
;;; v7 finished XMODEM, added "zero" command, rationalized code, squashed bugs
;;; v8 added input command
;;; v9 added disassembler
;;; v10 software interrupt handling
;;; v11 xpl-32 support and sd and serial loading routines
;;;
;;; Paul Dourish, March-October 2017
;;; Waverider, 2020-2022

;;; My ROM is actually 32K, but half of the ROM is only visible at once.
;;; So, everything starts at $C000.
;;;

* = $C000

LCD_E  = %10000000
LCD_RW = %01000000
LCD_RS = %00100000

SD_CS   = %00010000
SD_SCK  = %00001000
SD_MOSI = %00000100
SD_MISO = %00000010

PORTA_OUTPUTPINS = SD_CS | SD_SCK | SD_MOSI

;;;;;;;;;;;;;;;;;
;;;
;;; Zero page and other storage areas. Various parts of the zero page
;;; are used for scratch and for key data.
;;;
;;; A line of entered text is stored in INPUT. ARGINDEX is used
;;; by the parser to record where each individual argument begins.
;;; ARGINDEX[0] is a count of the number of words on the command
;;; line. ARGINDEX[1-n] are pointers into where, inside INDEX, each
;;; word begins (ie, ARGINDEX[1] is the index inside INPUT where
;;; the first argument string begins).
;;;
;;;;;;;;;;;;;;;;;;

;; these 16 address are basic scratch memory, for use only inside
;; a few instructions... not guaranteed safe across a subroutine call,
;; for instance.
;;
SCRATCH    = $0010  ; through to $001F

ARGINDEX   = $0020  ; and on to $002F for up to 16 arguments
;; block $0030-003F for xmodem variables
;; $0040 is free
;; $0041 is free
PRINTVEC   = $0042  ; and $0043. for printing routine.
ENTRY	   = $0044  ; and $0045
MEMTESTBASE= $0046  ; and $0047
;; $0080-00FF is my operand stack
;; $0100-01FF is 6502 stack
INPUT      = $0200  ; block out this page for monitor command input
;; $0300-03FF is blocked for xmodem buffer
;; $0400-04FF is blocked for xmodem testing (temporary)
XYLODSAV2	= $10  ; temporary address for save command
STARTADDR	= $12  ; for start addr for receive
ENDADDR		= $14
serialvar	= $16
; only used in tape:
thing  		= $10 ; 1byt
tapest 		= $11 ; 1byt
cnt    		= $12 ; 2byt
len    		= $14 ; 2byt
cnt2		= $15 ; 2byt

SEN		= $7ffd

;;;;;;;;;;;;;;;;;
;;;
;;; Include standard startup code
;;;
;;;;;;;;;;;;;;;;;

reset
#include "decl.a65"
jmp startup

;;; Dispatch table
;;;
;;; each entry has a two-byte pointer to the next entry (or $0000 on end)
;;; then a null-terminated string that names the command
;;; then a two-type pointer for the code to execute the command
;;;
table
  .word table1
  .byte "about", $00
  .word aboutcmd
table1
  .word table2
  .byte "help", $00
  .word helpcmd
table2
  .word table3
  .byte "dump", $00
  .word dumpcmd
table3
  .word table4
  .byte "echo", $00
  .word echocmd
table4
  .word table5
  .byte "poke", $00
  .word pokecmd
table5
  .word table6
  .byte "go", $00
  .word gocmd
table6
  .word table7
  .byte "test", $00
  .word testcmd
table7
  .word table8
  .byte "memtest", $00
  .word memtestcmd
table8
  .word table9
  .byte "dis", $00
  .word discmd
table9
  .word table10
  .byte "xreceive", $00
  .word xreceivecmd
table10
  .word table11
  .byte "zero", $00
  .word zerocmd
table11
  .word table12
  .byte "input", $00
  .word inputcmd
table12
  .word table13
  .byte "receive", $00
  .word receivecmd
table13
  .word table14
  .byte "load", $00
  .word loadcmd
table14
  .word table15
  .byte "tsave", $00
  .word tsavecmd
table15
  .word table16
  .byte "tload", $00
  .word tloadcmd
table16
  .word $0000            ; this signals it's the last entry in the table
  .byte "rti", $00
  .word rticmd
; i would like to add a full-fleged DOS/Linux sort of thing here too-will do that at some point.
; eg. ls, cd, open(or ./), mkdir, maybe a text editor?

;; More utility routines
;;
#include "stack.a65"
#include "stackext.a65"

;; Finally -- we actually start executing code
;;
startup

  ;; the very first thing we do is to clear the memory
  ;; used to do this in a subrouting, but of course it trashes
  ;; the stack!
;clearmem
;.(
;  stz $00  
;  stz $01
;nextpage
;  ldy #0
;  lda #0
;clearloop
;  sta ($00),y
;  iny
;  bne clearloop
;  inx
;  stx $01
;  cpx #$80
;  bne nextpage
;.)

#include "init.a65"

;; Startup sound
;;

#include "startupsound.s"

;; Initialize the ACIA
;;

init_acia
  lda #%00001011		; No parity, no echo, no interrupt
  sta ACIA_COMMAND
  lda #%00011111		; 1 stop bit, 8 data bits, 19200 baud
  sta ACIA_CONTROL

  ldx #$FF

;; done with initialization. start actually being a monitor
;;

main
;;;
;;; first, display a greeting. through out a couple of newlines
;;; first just in case there's other gunk on the screen.
;;;
sayhello
  lda #<greeting
  sta PRINTVEC
  lda #>greeting
  sta PRINTVEC+1
  ldy #0
  jsr printvecstr

;  ldy #0
;.(
;next_char
;wait_txd_empty  
;  lda ACIA_STATUS
;  and #$10
;  beq wait_txd_empty
;  lda greeting,y
;  beq reploop
;  sta ACIA_DATA
;  iny
;  jmp next_char
;.)
  ;; greeting has CRLF included, so we don't need to print those.


;;;
;;; now down to business. this is the main entrypoint for the
;;; read/execution loop. print a prompt, read a line, parse, dispatch,
;;; repeat.
;;;
reploop
.(
  ;; print the prompt
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda prompt
  sta ACIA_DATA
.)

  jsr readline      ; read a line into INPUT
  jsr crlf          ; echo line feed/carriage return

  ;; nothing entered? loop again
  cpy #0
  beq reploop

  ;; parse and process the command line
  ;;
  lda #0           
  sta INPUT,y       ; null-terminate the string
  jsr parseinput    ; parse into individual arguments, indexed at ARGINDEX
; jsr testparse     ; debugging output for test purposes
  jsr matchcommand  ; match input command and execute
  jmp reploop       ; loop around




parseinput
  phx               ; preserve x, since it's our private stack pointer
  ldx #0
  ldy #0

.(
;; look for non-space
nextchar
  lda INPUT,x
  cmp #32
  bne nonspace
  inx
  jmp nextchar

;; mark the start of the word
nonspace
  iny               ; maintain a count of words in y
  stx ARGINDEX,y
;; look for space
lookforspace
  inx
  lda INPUT,x
  beq endofline     ; check for null termination
  cmp #32           ; only looking for spaces. Tab?
  beq endofword
  jmp lookforspace
;; didn't hit a terminator, so there must be more.
;; terminate this word with a zero and then continue
endofword
  lda #0
  sta INPUT,x         ; null-terminate
  inx
  jmp nextchar        ; repeat
endofline
  ;; we're done
  ;; cache the arg count
  sty ARGINDEX

  ;; restore x and return
  plx
  rts
.)


;;;
;;; just for testing. echo arguments, backwards.
;;;
testparse
  phx               ; preserve x
  cpy #0            ; test for no arguments
  beq donetestparse
  iny               ; add one to get a guard value
  sty SCRATCH       ; store in SCRATCH. when we get to this value, we stop
  ldy #1            ; start at 1
nextarg
  clc
  tya               ; grab the argument number
  adc #$30          ; add 48 to make it an ascii value
  jsr puta
  lda #$3A          ; ascii for ":"
  jsr puta
  ldx ARGINDEX,y    ; load the index of the next argument into x
nextletter
  ;; print null-terminated string from INPUT+x
  lda INPUT,x
  beq donearg
  jsr puta
  inx
  bne nextletter    ; use this as "branch always," will never be 0
donearg
  ;; output carriage return/line feed and see if there are more arguments
  jsr crlf
  iny
  cpy SCRATCH
  bne nextarg       ; not hit guard yet, so repeat
donetestparse
  plx
  rts


;;;;;;;;;;;;;
;;;
;;; Command lookup/dispatch
;;;
;;;;;;;;;;;;;


matchcommand
  lda #<table    ; low byte of table address
  sta ENTRY
  lda #>table    ; high byte of table address
  sta ENTRY+1

  phx            ; preserve x, since it's our private stack pointer

testentry
cacheptr
  ;; grab the pointer to the next entry and cache it in scratchpad
  ldy #0
  lda (ENTRY),Y  ; first byte
  sta SCRATCH
  iny
  lda (ENTRY),Y  ; second byte
  sta SCRATCH+1
  iny
  ldx #0         ;; will use X and Yas index for string
.(
nextchar
  lda INPUT,x
  beq endofword
  cmp (ENTRY),y
  bne nextentry
  inx
  iny
  jmp nextchar
.)

endofword
  ;; we got here because we hit the end of the word in the buffer
  ;; if it's also the end of the entry label, then we've found the right place
  lda (ENTRY),y
  beq successful
  ;; but if it's not, then we haven't.
  ;; continue to the next entry
  jmp nextentry

successful
  ;; we got a match! copy out the destination address, jump to it
  iny
  lda (ENTRY),Y
  sta SCRATCH+2
  iny
  lda (ENTRY),Y
  sta SCRATCH+3
  plx     ; restore stack pointer
  jmp (SCRATCH+2)
  rts  ;; never get here -- we rts from the command code
    
nextentry:
  lda SCRATCH           ;; copy the address of next entry from scratchpad
  sta ENTRY
  lda SCRATCH+1
  sta ENTRY+1
  ;; test for null here
  ora SCRATCH       ;; check if the entry was $0000
  beq endoftable    ;; if so, we're at the end of table
  jmp testentry

endoftable
  ;; got to the end of the table with no match
  ;; print an error message, and return to line input
  ;; ...

printerror
  lda #<nocmderrstr
  sta PRINTVEC
  lda #>nocmderrstr
  sta PRINTVEC+1
  jsr printvecstr
  ; no need for crlf
;  ldy #0
;.(
;next_char
;wait_txd_empty  
;  lda ACIA_STATUS
;  and #$10
;  beq wait_txd_empty
;  lda errorstring,y
;  beq end
;  sta ACIA_DATA
;  iny
;  jmp next_char
;end
;.)
  plx    ; restore the stack pointer
  rts



;;;;;;;;;;;;;
;;;
;;; Monitor commands
;;;
;;;;;;;;;;;;;

aboutcmd
  lda #<aboutstring
  sta PRINTVEC
  lda #>aboutstring
  sta PRINTVEC+1
  jsr printvecstr
  ldy #0
  rts

helpcmd
  lda #<helpstring
  sta PRINTVEC
  lda #>helpstring
  sta PRINTVEC+1
  jsr printvecstr
  lda #<helpstring2
  sta PRINTVEC
  lda #>helpstring2
  sta PRINTVEC+1
  jsr printvecstr
  lda #<helpstring3
  sta PRINTVEC
  lda #>helpstring3
  sta PRINTVEC+1
  jsr printvecstr
  rts

notimplcmd
  lda #<implementstring
  sta PRINTVEC
  lda #>implementstring
  sta PRINTVEC+1
  jsr printvecstr
  rts

echocmd
.(
  phx                     ; preserve x, since it's our private stack pointer
  ldy #1                  ; start at 1 because we ignore the command itself
echonext
  cpy ARGINDEX            ; have we just done the last?
  bne nottend                 ; yes, so end
  jmp end
nottend
  iny                     ; no, so move on to the next
  ldx ARGINDEX,y
  ;; not using printvecstr for this because we're printing
  ;; directly out of the input buffer  
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda INPUT,x
  beq endofarg
  sta ACIA_DATA
  inx
  jmp next_char
endofarg
  lda #32                  ; put a space at the end
  jsr puta
  jmp echonext
end
  jsr crlf                 ; carriage return/line feed
  plx                      ; restore the stack pointer
  rts
.)



pokecmd
.(
  ;; check arguments
  lda ARGINDEX
  cmp #3
  bne error        ; not three, so there's an error of some sort
  clc
  lda #<INPUT
  adc ARGINDEX+3
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read8hex
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read16hex

  jsr pop16
  lda stackbase+1,x
  sta (stackaccess)
  jsr putax
  jsr pop16
  bra ende

error
  lda #<pokeerrstring
  sta PRINTVEC
  lda #>pokeerrstring
  sta PRINTVEC+1
  jsr printvecstr
ende
.)
  jsr crlf
  rts

dumpcmd
.(
  ;; check arguments
  lda ARGINDEX
  cmp #2
  beq twoparam        ; two parameters (ie instruction plus address)
  cmp #3
  beq threeparam      ; three parameters (instruction, address, count)
  jmp error           ; neither 2 nor 3, so there's an error
twoparam              ; only two parameters specified, so fill in third
  lda #$10            ; default number of bytes to dump
  sta stackaccess
  stz stackaccess+1
  jsr push16
  bra finishparam
threeparam            ; grab both parameters and push them
  clc
  lda #<INPUT
  adc ARGINDEX+3
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read8hex
finishparam           ; process the (first) address parameter
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read16hex

  ;; now we actually do the work
  ;; stash base address at SCRATCH
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

nextline

  phx               ; push x. X is only protected for PART of this code.

  ldy #0

  ;; print one line

  ;; print the address
  lda SCRATCH+1
  jsr putax
  lda SCRATCH
  jsr putax

  ;; print separator
  lda #$3a         ; colon
  jsr puta
  lda #$20         ; space
  jsr puta

  ;; print first eight bytes
printbyte
  lda (SCRATCH),y
  jsr putax
  lda #$20
  jsr puta
  cpy #$07          ; if at the eighth, print extra separator
  bne nextbyte
  jsr puta
nextbyte            ; inc and move on to next byte
  iny
  cpy #$10          ; stop when we get to 16
  bne printbyte
  
  ;; print separator
  lda #$20
  jsr puta
  jsr puta
  lda #$7C          ; vertical bar
  jsr puta          ; faster to have that as a little character string!

  ;; print ascii values for 16 bytes
  ldy #0
nextascii
  cpy #$10
  beq endascii
  lda (SCRATCH),y
  ;; it's printable if it's over 32 and under 127
  cmp #32
  bmi unprintable
  cmp #127
  bmi printascii
unprintable
  lda #$2e          ; dot
printascii
  jsr puta
  iny
  bra nextascii
endascii
  lda #$7C          ; vertical bar
  jsr puta          ; faster to have that as a little character string!
  jsr crlf

  ;; now bump the address and check if we should go around again
  ;;
  plx               ; restore x so we can work with the stack again
  clc

  ;; subtract 16 from the count
  lda stackbase+3,x
  sbc #$10
  ;; don't bother with the second byte, since it's always a single byte
  sta stackbase+3,x
  bcc donedump
  beq donedump

  ;; going round again, so add 16 to the base address
  clc
  lda SCRATCH
  adc #$10
  sta SCRATCH
  lda SCRATCH+1
  adc #0
  sta SCRATCH+1
  jmp nextline

donedump
  ;; throw away last two items on the stack
  inx
  inx
  inx
  inx
  jmp enddumpcmd

error
  lda #<dumperrstring
  sta PRINTVEC
  lda #>dumperrstring
  sta PRINTVEC+1
  jsr printvecstr
;  ldy #0
;  ;; do error
;next_char
;wait_txd_empty  
;  lda ACIA_STATUS
;  and #$10
;  beq wait_txd_empty
;  lda dumperrstring,y
;  beq enderr
;  sta ACIA_DATA
;  iny
;  jmp next_char
;enderr
  jsr crlf

enddumpcmd
  rts
.)

;;; zero command -- zero out a block of memory. Two parameters just
;;; like dump.
;;;
zerocmd
.(
  ;; check arguments
  lda ARGINDEX
  cmp #2
  beq twoparam        ; two parameters (ie instruction plus address)
  cmp #3
  beq threeparam      ; three parameters (instruction, address, count)
  jmp error           ; neither 2 nor 3, so there's an error
twoparam              ; only two parameters specified, so fill in third
  lda #$10            ; default number of bytes to dump
  sta stackaccess
  stz stackaccess+1
  jsr push16
  bra finishparam
threeparam            ; grab both parameters and push them
  clc
  lda #<INPUT
  adc ARGINDEX+3
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read8hex
finishparam           ; process the (first) address parameter
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read16hex

  ;; now we actually do the work
  ;; stash base address at SCRATCH
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  
loop
  ldy stackbase+3,x ; the byte count is at stackbase+3,x
  beq donezero      ; if we're done, stop
  dey               ; otherwise, decrement the count in y
  sty stackbase+3,x ; put it back
  lda #0            ; and store a zero...
  sta (SCRATCH),y   ; in the base address plus y
  bra loop

donezero
  ;; finished, so pop two 16-bit values off the stack
  inx
  inx
  inx
  inx
  jmp endzerocmd

error
  ldy #0
  lda #<zeroerrstring
  sta PRINTVEC
  lda #>zeroerrstring
  sta PRINTVEC+1
  jsr printvecstr
;  ;; do error
;next_char
;wait_txd_empty  
;  lda ACIA_STATUS
;  and #$10
;  beq wait_txd_empty
;  lda zeroerrstring,y
;  beq enderr
;  sta ACIA_DATA
;  iny
;  jmp next_char
;enderr
  jsr crlf

endzerocmd
  rts
.)



;;; NEW go command, using stack-based parameter processing
;;;
gocmd
.(
  ;; check arguments
  lda ARGINDEX
  cmp #2
  beq processparam
  jmp error

processparam           ; process the (first) address parameter
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read16hex

  jsr pop16            ; put the address into stackaccess
  jmp (stackaccess)    ; jump directly
  ;; no rts here because we'll rts from the subroutine

error
  lda #<goerrstring
  sta PRINTVEC
  lda #>goerrstring
  sta PRINTVEC+1
  jsr printvecstr

  jsr crlf
  rts
.)

; Save to cassette tape
;
; Argumented with a start and end address
;

tsavecmd:
.(
  ;; check arguments
  lda ARGINDEX
  cmp #3
  beq processparam
  jmp error
processparam           ; process the (first) address parameter
  clc
  lda #<INPUT
  adc ARGINDEX+4
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read16hex
  clc			; process the (second) address parameter
  lda #<INPUT
  adc ARGINDEX+2
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read16hex

  ; stash the paramaters
  lda stackbase+1,x
  sta cnt
  lda stackbase+2,x
  sta cnt+1
  lda stackbase+3,x
  sta len
  lda stackbase+4,x
  sta len+1
  phx

  lda #%10111111
  sta DDRA
  stz $b00e
  stz tapest

  lda #$8f
  sta $b818

  ldx #0
lp1:
  lda reg,x
  sta $b802,x
  inx
  cpx #5
  bne lp1
  lda #$4c
  sta $b800
  lda #$9d
  sta $b801

  ldx #<tsavemsg
  ldy #>tsavemsg	; press rec and play
  jsr w_acia_full

  lda #$18		; 4 seconds
  jsr tape_delay	; (ye fumble)

  ldx #<saving_msg	; Saving...
  ldy #>saving_msg
  jsr w_acia_full

  ldy #$40
  jsr inout		; intro sound

  jsr zero

  lda #1
  sta thing
  ldy #0
begin:
  lda cnt,y		; read in the address param
  and thing
  bne head1
  jsr zero
head:
  lda thing
  cmp #$80
  beq header_done
  asl thing
  jmp begin
head1:
  jsr one
  jmp head
header_done:
  iny
  cpy #$04
  bne begin
  ldy #$20
  jsr inout
  ; now to send the actual data
  ldx #0
  lda #1
  sta thing		; first bit
wop:
  lda (cnt)		; load data
  and thing		; mask it
  bne jsrone		; one
  jsr zero		; or zero
oner:
  lda thing		; load the bitmask
  cmp #$80		; end of byte?
  beq noo
  asl thing
  jmp wop		; next bit
jsrone:
  jsr one		; a one
  jmp oner
noo:
  lda #1		; byte done
  sta thing
  jsr one
  jsr one
  inc cnt		; inc pointer
  bne notcnt
  inc cnt+1
notcnt:
  lda cnt		; are we done?
  cmp len
  beq nearly
  jsr zero
  jmp wop		; if not, go again for another byte
nearly:
  lda cnt+1
  cmp len+1
  beq savedone
  jsr zero
  jmp wop
savedone
  ldy #$40
  jsr inout		; we are done, ending sound  

  ; done
  ldx #<msg2
  ldy #>msg2		; "Done!"
  jsr w_acia_full

  plx
  inx
  inx
  inx
  inx
  rts			; return

; subs

inout:
outer:
  ldx #$10		; $40 * $10 times make the sound
starter:
  jsr one		; sound
  dex
  bne starter
  dey
  bne outer
  rts

one:			; 2400hz sound 8 cyc
  pha
  ;jsr togtap ; 1
  ;jsr onefreq
  ;jsr togtap
  ;jsr onefreq
  ;jsr togtap ; 2
  ;jsr onefreq
  ;jsr togtap
  ;jsr onefreq
  ;jsr togtap ; 3
  ;jsr onefreq
  ;jsr togtap
  ;jsr onefreq
  ;jsr togtap ; 4
  ;jsr onefreq
  ;jsr togtap
  ;jsr onefreq
  ;jsr togtap ; 5
  ;jsr onefreq
  ;jsr togtap
  ;jsr onefreq
  ;jsr togtap ; 6
  ;jsr onefreq
  ;jsr togtap
  ;jsr onefreq
  ;jsr togtap ; 7
  ;jsr onefreq
  ;jsr togtap
  ;jsr onefreq
  ;jsr togtap ; 8
  ;jsr onefreq
  ;jsr togtap
  ;jsr onefreq
  lda #%00000000
  sta $d404
  lda #$4c
  sta $b800
  lda #$9d
  sta $b801
  jsr tx_delay
  jsr tx_delay
  pla
  rts

reg:
  .byte $00, $08, $41, $00, $f0

;togtap:
;  lda tapest
;  eor #%10000000 	; data out on PA7
;  sta tapest
;  sta PORTA
;  rts

zero: 			; 1200hz sound 4 cyc
  pha 
  ;jsr togtap ; 1
  ;jsr zerofreq
  ;jsr togtap
  ;jsr zerofreq
  ;jsr togtap ; 2
  ;jsr zerofreq
  ;jsr togtap
  ;jsr zerofreq
  ;jsr togtap ; 3
  ;jsr zerofreq
  ;jsr togtap
  ;jsr zerofreq
  ;jsr togtap ; 4
  ;jsr zerofreq
  ;jsr togtap
  ;jsr zerofreq
  lda #%00000000
  sta $d404
  lda #$a6
  sta $b800
  lda #$4e
  sta $b801
  jsr tx_delay
  jsr tx_delay
  pla
  rts

onefreq:
  stz $b00b
  lda #$ae
  sta $b004		; freq
  lda #$00
  sta $b005
intro:
  bit $b00d		; delay complete?
  bvc intro
  rts

zerofreq:
  stz $b00b
  lda #$3f
  sta $b004
  lda #$01
  sta $b005
intro2:
  bit $b00d
  bvc intro2
  rts

error
  lda #<tsaveerrstring
  sta PRINTVEC
  lda #>tsaveerrstring
  sta PRINTVEC+1
  jsr printvecstr

  jsr crlf
  rts

.)

tx_delay:
  phx
  phy
  ldx #$7e
tx_delay_inner:
  lda $b81c
  sta PORTA
  dex
  bne rx_delay_inner
  ply
  plx
  rts

tape_delay:
  ldx #$ff		; wait for ye fumble.
rd1:
  lda #$7a		; (Y times through inner loop,
rd2:     
  sbc #$01		;  Y * $FF * 650uS = uS / 1e-6 = S )
  bne rd2
rd3:
  dex
  bne rd1
  dey
  bne tape_delay
  rts

tsavemsg:
  .byte $02, $ff, "Press Record And play on Tape.", $0d, $0a, $00
tloadmsg:
  .byte $02, $ff, "Press Play On Tape.", $0d, $0a, $00
loading_msg:
  .byte "Loading...", $00
saving_msg:
  .byte "Saving...", $00
msg2:
  .byte "Done!", $0d, $0a, $02, $5f, $00
loadedmsg:
  .byte "Loaded from ", $00
tomsg:
  .byte " to ", $00

; Load from a cassette tape.
;
; Needs no arguments because start and end addresses are encoded in tape.
;

tloadcmd:
.(
  lda #%10111111
  sta DDRA
  lda #%11111111
  sta DDRB

  ldx #<tloadmsg	; PRESS PLAY ON TAPE
  ldy #>tloadmsg
  jsr w_acia_full

  lda #$18		; ye fumble
  jsr tape_delay	; 4 second delay

  ldx #<loading_msg	; Loading...
  ldy #>loading_msg
  jsr w_acia_full

  ldy #0

  ; thanks to ben eater for help with this code

rx_wait_start:
  bit PORTA	; wait until PORTB.6 = 0 (start bit)
  bvs rx_wait_start

  jsr rx_delay  ; half-bit delay
  ldx #8
read_bita:
  jsr rx_delay	; run full-bit delay for 300 baud serial stream
  jsr rx_delay
  bit PORTA	; read in the state
  bvs recv_1a	; if it's not a one,
  clc		; it's a zero.
  jmp rx_donea
recv_1a:	; otherwise,
  sec		; it's a one.
  nop		; nops for timing
  nop
rx_donea:
  ror		; rotate carry into accumulator
  dex
  bne read_bita	; repeat until 8 bits read
  sta cnt,y
  iny
  cpy #$04
  beq got_len
  lda cnt
  sta cnt2
  lda cnt+1
  sta cnt2+1
  jsr rx_delay
  jsr rx_delay
  jmp rx_wait_start
got_len:
  jsr rx_delay
  jsr rx_delay
rx_wait:
  bit PORTA	; wait until PORTB.6 = 0 (start bit)
  bvs rx_wait
  jsr rx_delay
  ldx #8
read_bit:
  jsr rx_delay	; run bit delay for 300 baud serial stream
  jsr rx_delay
  bit PORTA	; read in the state
  bvs recv_1	; if it's not a one,
  clc		; it's a zero.
  jmp rx_done
recv_1:
  sec		; it's a one.
  nop		; nops for timing
  nop
rx_done:
  ror		; rotate carry into accumulator
  dex
  bne read_bit	; repeat until 8 bits read
  sta (cnt)	; store data
  jsr rx_delay
  jsr rx_delay
  inc cnt
  bne declen
  inc cnt+1
declen:
  lda cnt		; are we done?
  cmp len
  bne rx_wait_delay
  lda cnt+1
  cmp len+1
  bne rx_wait_delay	; if not, get another byte
load_done:
  ldx #<loadedmsg	; Done!
  ldy #>loadedmsg
  jsr w_acia_full
  lda cnt2+1
  jsr print_hex_acia
  lda cnt2
  jsr print_hex_acia
  ldx #<tomsg
  ldy #>tomsg
  jsr w_acia_full
  lda len+1
  jsr print_hex_acia
  lda len
  jsr print_hex_acia
  jsr crlf
  rts

rx_wait_delay:
  jsr rx_delay
  jsr rx_delay
  jmp rx_wait
.)

rx_delay:
  phx
  phy
  ldy #$02
rx_delay_outer:
  ldx #$A4
rx_delay_inner:
  dex
  bne rx_delay_inner
  dey
  bne rx_delay_outer
  ply
  plx
  rts


testcmd
  ;jsr xmodemtest
  rts

xreceivecmd
.(
  ;; check arguments
  lda ARGINDEX
  cmp #2
  beq processparam
  jmp error

processparam           ; process the address parameter
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta stackaccess
  lda #>INPUT
  ;; BUG?? shouldn't there be an ADC #0 in here?
  ;; it works as long as INPUT starts low on a page and so the
  ;; upper byte never changes.. but this is an error!
  sta stackaccess+1

  jsr push16        ; put the string address on the stack
  jsr read16hex     ; convert string to a number value
  jsr pop16         ; pop number, leave in stackaccess

  lda stackaccess   ; copy 16 bit address into XDESTADDR
  sta XDESTADDR
  lda stackaccess+1
  sta XDESTADDR+1

  jsr xmodemrecv    ; call the receive command
  jmp xmreturn

error
  lda #<xrecverrstring
  sta PRINTVEC
  lda #>xrecverrstring+1
  sta PRINTVEC+1
  jsr printvecstr
  jsr crlf

.)
xmreturn
  rts

#include "xmodem.a65"

rticmd
  ;; we got here via a JSR, so we need to drop the return
  ;; address from the stack
  pla
  pla
  ;; now return from interrupt
  rti

inputcmd
.(
  ;; check arguments
  lda ARGINDEX
  cmp #2
  beq printhelp
  jmp error

printhelp
  ;; print a help message
  lda #<inputhelpstring
  sta PRINTVEC
  lda #>inputhelpstring
  sta PRINTVEC+1
  jsr printvecstr
  jsr crlf

processparam           ; process the address parameter
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta stackaccess
  lda #>INPUT
  ;; BUG?? shouldn't there be an ADC #0 in here?
  ;; it works as long as INPUT starts low on a page and so the
  ;; upper byte never changes.. but this is an error!
  sta stackaccess+1

  jsr push16        ; put the string address on the stack
  jsr read16hex     ; convert string to a number value
  jsr pop16         ; pop number, leave in stackaccess

  lda stackaccess   ; copy 16 bit address into SCRATCH
  sta SCRATCH
  lda stackaccess+1
  sta SCRATCH+1

start
  lda SCRATCH       ; first, print the current address as a prompt
  sta stackaccess   
  lda SCRATCH+1
  sta stackaccess+1
  jsr push16        ; put it onto the stack
  jsr print16hex    ; print it in hex
  lda #$20          ; output a space
  jsr puta

  jsr readline      ; read a line of input into the buffer
  jsr crlf          ; echo newline

  cpy #0            ; is the line blank?
  beq endinput      ; if so, then end the routine
  jsr parseinput    ; otherwise, parse the input into byte strings

  ;; write those bytes into memory starting at the address
  ;; begin a new line with the next address
  ldy #1
  inc ARGINDEX      ; change from count to sentinel value

nextbyte
  cpy ARGINDEX      ; have we done all the arguments?
  beq donebytes     ; if so, jump to the end of this round

  clc
  lda #<INPUT       ; load the base address for the input buffer
  adc ARGINDEX,y    ; and add the offset to the y'th argument
  sta stackaccess   ; store at stackaccess
  lda #>INPUT       ; then the upper byte
  adc #0            ; in case we cross page boundary (but we shouldn't)
  sta stackaccess+1
  jsr push16        ; push the address for the byte string
  jsr read8hex      ; interpret as an eight-bit hex value
  jsr pop16         ; pull off the stack
  lda stackaccess   ; this is the byte, in the lower 8 bits
  phx
  ldx #0            ; needed  because there's no non-index indirect mode
  sta (SCRATCH,x)   ; store it at the address pointed to by SCRATCH
  inc SCRATCH       ; increment SCRATCH (and possibly SCRATCH+1)
  bne endloop
  inc SCRATCH+1
endloop
  plx               ; restore X before we use the stack routines again
  iny               ; move on to next entered type
  jmp nextbyte

donebytes
  bra start         ; again with the next line

endinput
  jmp inputreturn

error
  lda #<inputerrstring
  sta PRINTVEC
  lda #>inputerrstring+1
  sta PRINTVEC+1
  jsr printvecstr
  jsr crlf
inputreturn
  rts               ; return (x already restored)
.)


;;;;;;;;;;;;;
;;;
;;; Disassembler
;;;
;;; Handles all original 6502 opcodes and (almost) all of the 65C02
;;; opcodes. It may occasionally interpret things overly generously,
;;; ie take a nonsense byte and give it a meaning... but such a byte
;;; shouldn't be in a program anyway, right?
;;;
;;; Paul Dourish, October 2017
;;;
;;;
;;;;;;;;;;;;;

discmd
.(
  ;; check arguments
  lda ARGINDEX
  cmp #2
  beq twoparam        ; two parameters (ie instruction plus address)
  cmp #3
  beq threeparam      ; three parameters (instruction, address, count)
  jmp error           ; neither 2 nor 3, so there's an error
twoparam              ; only two parameters specified, so fill in third
  lda #$10            ; default number of instructions to decode
  sta stackaccess
  stz stackaccess+1
  jsr push16
  bra finishparam
threeparam            ; grab both parameters and push them
  clc
  lda #<INPUT
  adc ARGINDEX+3
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read8hex
finishparam           ; process the (first) address parameter
  clc
  lda #<INPUT
  adc ARGINDEX+2
  sta stackaccess
  lda #>INPUT
  sta stackaccess+1
  jsr push16
  jsr read16hex

  ;; now we actually do the work
  ;; stash base address at BASE (upper area of scratch memory)

BASE=SCRATCH+$0A
  lda stackbase+1,x
  sta BASE
  lda stackbase+2,x
  sta BASE+1

  ;; and stash the count at COUNT (also upper area of scratch memory)
COUNT=SCRATCH+$0C
  lda stackbase+3,x
  sta COUNT
  jmp begindis

error
  lda #<diserrorstring
  sta PRINTVEC
  lda #>diserrorstring
  sta PRINTVEC+1
  jsr printvecstr

enddis
  jmp exitdis



;;; I'm following details and logic from
;;; http://www.llx.com/~nparker/a2/opcodes.html
;;;
;;; Most instructions are of the form aaabbbcc, where cc signals
;;; a block of instructons that operate in a similar way, with aaa
;;; indicating the instructoon and bbb indicating the addressing mode.
;;; Each of those blocks is handled by two tables, one of which
;;; indicates the opcode strings and one of which handles the
;;; addressing modes (by storing entry points into the processing
;;; routines).
;;;

begindis
  phx               ; preserve X (it's a stack pointer elsewhere)
  ldy #0            ; y will track bytes as we go

start
nextinst
  ;; start the line by printing the address and a couple of spaces
  ;;
  lda BASE+1
  jsr putax
  lda BASE
  jsr putax
  lda #$20
  jsr puta
  jsr puta
  jsr puta

  ;; before we handle the regular cases, check the table
  ;; of special cases which are harder to detect via regular
  ;; patterns
  ldx #0
nextspecial
  lda specialcasetable,x     ; load item from table
  cmp #$FF          ; check if it's the end of the table
  beq endspecial    ; if so, exit
  cmp (BASE),y      ; compare table item to instruction
  beq foundspecial  ; match?
  inx               ; move on to next table -- three bytes
  inx
  inx
  bra nextspecial   ; loop
foundspecial
  inx               ; when we find a match, jump to address in table
  jmp (specialcasetable,x)
endspecial          ; got to the end of the table without a match
  lda (BASE),y      ; re-load instruction
  
  and #%00011111    ; checking if it's a branch
  cmp #%00010000
  beq jbranch       ; jump to code for branches

  ;; block of single byte instructions where the lower nybble is 8
  ;;
testlow8
  lda (BASE),y      ; get the instruction again (last test was destructive)
  and #%00001111
  cmp #$08          ; single-byte instructions with 8 in lower nybble
  bne testxa
  jmp single8

  ;; block of single byte instructions at 8A, 9A, etc
testxa
  lda (BASE),y      ; get the instruction again (last test was destructive)
  and #%10001111
  cmp #$8A          ; 8A, 9A, etc
  bne testcc00
  jmp singlexa

  ;; otherwise, process according to the regular scheme of aaabbbcc
  ;;
testcc00
  lda (BASE),y      ; get the instruction again (last test was destructive)
  and #%00000011    ; look at the "cc" bits -- what sort of opcode?
  bne testcc10
  jmp branch00      ; go to branch for cc=00
testcc10
  cmp #%00000010
  bne testcc01
  jmp branch10     ; go to branch for cc=10
testcc01
  cmp #%00000001
  bne jothers       ; go to branch for remaining opcodes
  jmp branch01

jbranch
  jmp branch
jothers
  jmp others

;;; interpret according to the pattern for cc=01
;;;
branch01
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax
  ; so now cc01optable,x is the pointer to the right string
  lda cc01optable,x
  sta SCRATCH
  lda cc01optable+1,x
  sta SCRATCH+1
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply
  
  ;; handle each addressing mode
  ;; the addressing mode is going to determine how many
  ;; bytes we need to consume overall
  ;; so we do something similar... grab the bits, shift them down
  ;; and use that to look up a table which will tell us where
  ;; to jump to to interpret it correctly.
  
  lda (BASE),y      ; get the instruction again
  and #%00011100    ; extract the bbb bits -- addressing mode
  lsr               ; shift just once
  ;; acc now holds the offset of the right entry in the table
  ;; now add in the base address of the table, and store it in SCRATCH
  clc
  adc #<cc01adtable
  sta SCRATCH       ; less significant byte
  lda #>cc01adtable
  adc #0
  sta SCRATCH+1     ; most significant byte
  ;; one more level of indirection -- fetch the address listed there
  phy
  ldy #0
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  ply
  jmp (SCRATCH+2)   ; jump to address specified in table
  

;;;
;;; Routines to handle the output for different addressing modes.
;;; Each addressing mode has its own entry point; entries in the
;;; addressing tables for each instruction block point here directly.
;;; On entry and exit, Y indicates the last byte processed.
;;;

acc
  ;; accumulator
  lda #'A
  jsr puta
  jmp endline

absx                ; absolute, X -- consumes two more bytes
  lda #'$
  jsr puta
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny               ; leave Y pointing to last byte consumed
  lda #',
  jsr puta
  lda #'X
  jsr puta
  jmp endline

izpx                ; (zero page,X), consumes one more byte
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #',
  jsr puta
  lda #'X
  jsr puta
  lda #')
  jsr puta
  jmp endline

zp                  ; zero page, consumes one more byte
  iny
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

izp                 ; indirect zero page, only on 65C02, consumes 1 byte
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #')
  jsr puta
  jmp endline

imm                 ; immediate mode, consumes one byte
  iny
  lda #'#
  jsr puta
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

immb                ; like immediate, but for branches (so ditch the "#")
  iny
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  jmp endline

abs
  ;; absolute -- consumes two more bytes
  lda #'$
  jsr puta
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny
  jmp endline

izpy
  ;; (zero page),Y -- consumes one more byte
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #')
  jsr puta
  lda #',
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

ind
  ;; (addr) -- consumes two more bytes
  iny
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  dey
  lda (BASE),y
  jsr putax
  lda #')
  jsr puta
  iny
  jmp endline

indx                ; only the JMP on 65C02?
  iny
  iny
  lda #'(
  jsr puta
  lda #'$
  jsr puta
  lda (BASE),y
  jsr putax
  dey
  lda (BASE),y
  jsr putax
  lda #',
  jsr puta
  lda #'X
  jsr puta
  lda #')
  jsr puta
  iny
  jmp endline

zpx
  ;; zero page,X -- consumes one more byte
  iny
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #',
  jsr puta
  lda #'X
  jsr puta
  jmp endline

zpy
  ;; zero page,Y -- consumes one more byte
  iny
  lda #'$
  jsr puta
  lda #'0
  jsr puta
  jsr puta
  lda (BASE),y
  jsr putax
  lda #',
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

absy
  ;; absolute,Y -- consumes two more bytes
  lda #'$
  jsr puta
  iny               ; get the second (most-sig) byte first
  iny
  lda (BASE),y
  jsr putax
  dey               ; then the less-significant byte
  lda (BASE),y
  jsr putax
  iny               ; leave Y pointing to last byte consumed
  lda #',
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

err
  ;; can't interpret the opcode
  lda #'?
  jsr puta
  jsr puta
  jsr puta
  jmp endline

;;; the next major block of addresses is those where the two
;;; bottom bits are 10. Processing is very similar to those
;;; where cc=01, above.
;;; almost all this code is just reproduced from above.
;;; TODO-- restructure to share more of the mechanics.
;;;
branch10

  ;; first, take care of the unusual case of the 65C02 instructions
  ;; which use a different logic

  ;; look up and process opcode
  ;;
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax

  ;; before we proceed, decide which table to look up. the 65C02 codes
  ;; in the range bbb=100 use a differnt logic
  lda (BASE),y
  and #%00011100
  cmp #%00010000
  beq specialb10

  ; so now cc10optable,x is the pointer to the right string
  lda cc10optable,x
  sta SCRATCH
  lda cc10optable+1,x
  sta SCRATCH+1
  jmp b10opcode

specialb10
  lda cc01optable,x ; not an error... we're using the cc01 table for 65c02
  sta SCRATCH
  lda cc01optable+1,x
  sta SCRATCH+1

b10opcode
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply

  ;; handle each addressing mode
  ;;
  lda (BASE),y      ; get the instruction again
  cmp #$96          ; check fos special cases
  beq specialstx    ; STX in ZP,X mode becomes ZP,Y
  cmp #$b6
  beq specialldx1   ; LDX in ZP,X mode becomes ZP,Y
  cmp #$be
  beq specialldx2   ; LDX in ZP,X mode becomes ZP,Y

  ;; otherwise, proceed as usual
  and #%00011100    ; extract the bbb bits -- addressing mode
  lsr               ; shift just once
  ;; acc now holds the offset of the right entry in the table
  ;; now add in the base address of the table, and store it in SCRATCH
  clc
  adc #<cc10adtable
  sta SCRATCH       ; less significant byte
  lda #>cc10adtable
  adc #0
  sta SCRATCH+1     ; most significant byte
  ;; one more level of indirection -- fetch the address listed there
  phy
  ldy #0
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  ply
  jmp (SCRATCH+2)   ; jump to address specified in table

specialstx
specialldx1
  jmp zpy
specialldx2
  jmp absy

;;; This code for the block of instructions with cc=00. Note again
;;; that this is simply repeated from above and should be fixed.
;;; TODO-- refactor this code to eliminate duplication
;;;
branch00
  lda (BASE),y      ; reload instruction
  and #%11100000    ; grab top three bits
  lsr               ; shift right for times
  lsr
  lsr               ; result is the aaa code * 2, ...
  lsr               ; ... the better to use as index into opcode table
  tax
  ; so now cc00optable,x is the pointer to the right string
  lda cc00optable,x
  sta SCRATCH
  lda cc00optable+1,x
  sta SCRATCH+1
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply

  ;; handle each addressing mode
  ;;
  lda (BASE),y      ; get the instruction again
  cmp #$89          ; special case for BIT #
  beq specialbit
  cmp #$6C          ; indirect JMP is a special case, handle separately
  beq specialindjmp 
  cmp #$7C          ; similarly for indirect JMP,X
  beq specialindxjmp  
  and #%00011100    ; extract the bbb bits -- addressing mode
  lsr               ; shift just once
  ;; acc now holds the offset of the right entry in the table
  ;; now add in the base address of the table, and store it in SCRATCH
  clc
  adc #<cc00adtable
  sta SCRATCH       ; less significant byte
  lda #>cc00adtable
  adc #0
  sta SCRATCH+1     ; most significant byte
  ;; one more level of indirection -- fetch the address listed there
  phy
  ldy #0
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  ply
  jmp (SCRATCH+2)   ; jump to address specified in table

specialbit
  ;; treat this specially -- 65C02 opcode slightly out of place
  jmp imm

specialindjmp
  ;; treat JMP (address) specially
  jmp ind

specialindxjmp
  ;; treat JMP (address,X) specially
  jmp indx


;;; branch instructions -- actually, these don't follow pattern so do FIRST
;;; branches have the form xxy10000
;;; xxy*2 should index into branchtable
branch
  lda (BASE),y
  and #%11100000
  lsr
  lsr
  lsr
  lsr
  tax

  ;; now index into table
  ; so now branchoptable,x is the pointer to the right string
  lda branchoptable,x
  sta SCRATCH
  lda branchoptable+1,x
  sta SCRATCH+1
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply

  ;; we use a variant form of immediate mode to print the operand
  ;; for branch instructions
  jmp immb

;;; these are the single-byte instructions with 8 in their lower nybble
;;; again, code borrowed from above (branch) -- TODO -- refactor.
single8
  lda (BASE),y
  and #%11110000
  lsr
  lsr
  lsr
  tax

  ;; now index into table
  ;; so now single08table,x is the pointer to the right string
  lda single08table,x
  sta SCRATCH
  lda single08table+1,x
  sta SCRATCH+1
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply
  jmp endline

;;; these are the single-byte instructions at 8A, 9A, etc.
;;; again, code borrowed from above (branch) -- TODO -- refactor.
singlexa
  lda (BASE),y
  and #%01110000
  lsr
  lsr
  lsr
  tax

  ;; now index into table
  ;; so now singlexatable,x is the pointer to the right string
  lda singlexatable,x
  sta SCRATCH
  lda singlexatable+1,x
  sta SCRATCH+1
  phy
  ; print the three characters pointed to there
  ldy #0
  lda (SCRATCH),y   ; first character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; second character...
  jsr puta          ; print it
  iny
  lda (SCRATCH),y   ; third character...
  jsr puta          ; print it
  lda #$20          ; print a space
  jsr puta
  ply
  jmp endline

;;; this is where we end up if we haven't figured anything else out
;;;
others
  lda #'?
  jsr puta
  jsr puta
  jsr puta
  jmp endline

;; special cases go here
;;
dobrk
  lda #'B
  jsr puta
  lda #'R
  jsr puta
  lda #'K
  jsr puta
  jmp endline

dojsr
  lda #'J
  jsr puta
  lda #'S
  jsr puta
  lda #'R
  jsr puta
  lda #$20
  jsr puta
  jmp abs

dorti
  lda #'R
  jsr puta
  lda #'T
  jsr puta
  lda #'I
  jsr puta
  jmp endline

dorts
  lda #'R
  jsr puta
  lda #'T
  jsr puta
  lda #'S
  jsr puta
  jmp endline

dobra
  lda #'B
  jsr puta
  lda #'R
  jsr puta
  lda #'A
  jsr puta
  lda #$20
  jsr puta
  jmp immb

dotrbzp
  lda #'T
  jsr puta
  lda #'R
  jsr puta
  lda #'B
  jsr puta
  lda #$20
  jsr puta
  jmp zp

dotrbabs
  lda #'T
  jsr puta
  lda #'R
  jsr puta
  lda #'B
  jsr puta
  lda #$20
  jsr puta
  jmp abs

dostzzp
  lda #'S
  jsr puta
  lda #'T
  jsr puta
  lda #'Z
  jsr puta
  lda #$20
  jsr puta
  jmp zp

dostzabs
  lda #'S
  jsr puta
  lda #'T
  jsr puta
  lda #'Z
  jsr puta
  lda #$20
  jsr puta
  jmp abs

dostzzpx
  lda #'S
  jsr puta
  lda #'T
  jsr puta
  lda #'Z
  jsr puta
  lda #$20
  jsr puta
  jmp zpx

dostzabsx
  lda #'S
  jsr puta
  lda #'T
  jsr puta
  lda #'Z
  jsr puta
  lda #$20
  jsr puta
  jmp absx

doplx
  lda #'P
  jsr puta
  lda #'L
  jsr puta
  lda #'X
  jsr puta
  jmp endline

dophx
  lda #'P
  jsr puta
  lda #'H
  jsr puta
  lda #'X
  jsr puta
  jmp endline

doply
  lda #'P
  jsr puta
  lda #'L
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

dophy
  lda #'P
  jsr puta
  lda #'H
  jsr puta
  lda #'Y
  jsr puta
  jmp endline

doinca
  lda #'I
  jsr puta
  lda #'N
  jsr puta
  lda #'C
  jsr puta
  lda #$20
  jsr puta
  lda #'A
  jsr puta
  jmp endline

dodeca
  lda #'I
  jsr puta
  lda #'N
  jsr puta
  lda #'C
  jsr puta
  lda #$20
  jsr puta
  lda #'A
  jsr puta
  jmp endline


endline
  jsr crlf

  ;; at this point, Y points to the last processed byte. Increment
  ;; to move on, and add it to base.
  iny
  clc
  tya               ; move Y to ACC and add to BASE address
  adc BASE
  sta BASE          ; low byte
  lda BASE+1
  adc #0
  sta BASE+1        ; high byte
  ldy #0            ; reset Y

  ;; test if we should terminate... goes here...
  dec COUNT
  beq finishdis

  jmp nextinst

finishdis
  plx               ; restore the stack pointer
exitdis
  inx               ; pop one item off stack (one param)
  inx
  inx               ; pop second item off stack (other param)
  inx
  rts


cc01optable
  .word ORAstr, ANDstr, EORstr, ADCstr, STAstr, LDAstr, CMPstr, SBCstr
cc01adtable
  .word izpx, zp, imm, abs, izpy, zpx, absy, absx

cc10optable
  .word ASLstr, ROLstr, LSRstr, RORstr, STXstr, LDXstr, DECstr, INCstr
cc10adtable
  .word imm, zp, acc, abs, izp, zpx, err, absx

cc00optable
  ;; yes, JMP appears here twice... it's not a mistake...
  .word TSBstr, BITstr, JMPstr, JMPstr, STYstr, LDYstr, CPYstr, CPXstr
cc00adtable
  .word imm, zp, err, abs, err, zpx, err, absx

branchoptable
  .word BPLstr, BMIstr, BVCstr, BVSstr, BCCstr, BCSstr, BNEstr, BEQstr

single08table
  .word PHPstr, CLCstr, PLPstr, SECstr, PHAstr, CLIstr, PLAstr, SEIstr
  .word DEYstr, TYAstr, TAYstr, CLVstr, INYstr, CLDstr, INXstr, SEDstr

singlexatable
  .word TXAstr, TXSstr, TAXstr, TSXstr, DEXstr, PHXstr, NOPstr, PLXstr

specialcasetable
  .byte $00
  .word dobrk
  .byte $20
  .word dojsr
  .byte $40
  .word dorti
  .byte $60
  .word dorts
  .byte $80
  .word dobra
  .byte $14
  .word dotrbzp
  .byte $1C
  .word dotrbabs
  .byte $64
  .word dostzzp
  .byte $9C
  .word dostzabs
  .byte $74
  .word dostzzpx
  .byte $9E
  .word dostzabsx
  .byte $1A
  .word doinca
  .byte $3A
  .word dodeca
  .byte $5A
  .word dophy
  .byte $7A
  .word doply
  .byte $DA
  .word dophx
  .byte $FA
  .word doplx
  .byte $FF
  .word $FFFF


ORAstr .byte "ORA"
ANDstr .byte "AND"
EORstr .byte "EOR"
ADCstr .byte "ADC"
STAstr .byte "STA"
LDAstr .byte "LDA"
CMPstr .byte "CMP"
SBCstr .byte "SBC"
ASLstr .byte "ASL"
ROLstr .byte "ROL"
LSRstr .byte "LSR"
RORstr .byte "ROR"
STXstr .byte "STX"
LDXstr .byte "LDX"
DECstr .byte "DEC"
INCstr .byte "INC"
NONstr .byte "???"
BITstr .byte "BIT"
JMPstr .byte "JMP"
STYstr .byte "STY"
LDYstr .byte "LDY"
CPYstr .byte "CPY"
CPXstr .byte "CPX"
BPLstr .byte "BPL"
BMIstr .byte "BMI"
BVCstr .byte "BVC"
BVSstr .byte "BVS"
BCCstr .byte "BCC"
BCSstr .byte "BCS"
BNEstr .byte "BNE"
BEQstr .byte "BEQ"

PHPstr .byte "PHP"
CLCstr .byte "CLC"
PLPstr .byte "PLP"
SECstr .byte "SEC"
PHAstr .byte "PHA"
CLIstr .byte "CLI"
PLAstr .byte "PLA"
SEIstr .byte "SEI"
DEYstr .byte "DEY"
TYAstr .byte "TYA"
TAYstr .byte "TAY"
CLVstr .byte "CLV"
INYstr .byte "INY"
CLDstr .byte "CLD"
INXstr .byte "INX"
SEDstr .byte "SED"

TXAstr .byte "TXA"
TXSstr .byte "TXS"
TAXstr .byte "TAX"
TSXstr .byte "TSX"
DEXstr .byte "DEX"
NOPstr .byte "NOP"

PLXstr .byte "PLA"
PHXstr .byte "PHX"
TSBstr .byte "TSB"

errstr .byte "???"

.)

;;;;;;;;;;;;;
;;;
;;; END OF DISASSEMBLER
;;;
;;;;;;;;;;;;;


;;;;;;;;;;;;;
;;;
;;; Various utility routines
;;;
;;;;;;;;;;;;;

;;;
;;; Ouptut carriage return and line feed
;;;
crlf
  pha
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0d
  sta ACIA_DATA
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0a
  sta ACIA_DATA
  pla
  rts


;;;
;;; output the character code in the accumulator
;;;
puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

;;;
;;; output the value in the accumulator as a hex pattern
;;; NB x cannot be guaranteed to be stack ptr during this... check...
;;;
putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts


;;; read a line of input from the serial interface
;;; leaves data in the buffer at INPUT
;;; y is the number of characters in the line, so it will fail if
;;; more then 255 characters are entered
;;; line terminated by carriage return. backspaces processed internally.
;;;
readline
  ldy #0
readchar
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  cmp #$08           ; check for backspace
  beq backspace
  cmp #$0D           ; check for newline
  beq done
  sta INPUT,y        ; track the input
  iny
  jsr puta           ; echo the typed character
  jmp readchar       ; loop to repeat
backspace
  cpy #0             ; beginning of line?
  beq readchar
  dey                ; if not, go back one character
  jsr puta           ; move cursor back
  jmp readchar

  ;; this is where we land if the line input has finished
  ;;
done
  rts

;; data receive
;; receives data from serial
receivecmd
  pha
  phx  ; save registers
  phy
  lda XYLODSAV2
  pha
  lda XYLODSAV2+1
  pha
;  ldx #<transferstring
;  ldy #>transferstring
;  jsr w_acia_full
END_LOAD_MSG
SERIAL_LOAD
  ldx #0
WRMSG
  ldx #<serialstring
  ldy #>serialstring	; Start serial load. <CRLF>
  jsr w_acia_full
receive_serial
  lda #$55
  sta serialvar
  lda $0208		; if "receive h"
  cmp #'h'
  bne rcloopstart	; then header mode
  lda #0		; otherwize, receive <addr>
  sta serialvar		; let rsl know
  jmp serialheader
rcloopstart
  ldx #$04		; 4 bytes
rcloopadd
  lda $0207,x		; operand addr -1 (because of the loop)
  pha			; preserve a
  cmp #$41		; alphabet? (operand >= $41)
  bcc rcloopadd1	; no
  pla			; yes, restore a
  sec			; $57 cuz $A = #10
  sbc #$57		; $61 - $A = $57
  jmp rcloopadd2	; continue
rcloopadd1		; it is a number
  pla			; restore a so we can compare it
  sec			; (operand - $30)
  sbc #$30
rcloopadd2
  sta $0207,x		; store the created nibble, one per byte...
  dex
  bne rcloopadd

  lda $0208		; load the 4 nibbles into 2 bytes
  asl			; a nibble per byte to 2 nibbles per byte
  asl			; so it can be readable (little endian)
  asl
  asl
  ora $0209
  sta XYLODSAV2+1
  lda $020a
  asl
  asl
  asl
  asl
  ora $020b
  sta XYLODSAV2

  ldy #0
  jmp rsl

wop:
  jsr MONRDKEY		; read a byte
  bcc wop
  lda ACIA_DATA
  rts
serialheader:
  jsr wop		; load addr
  sta XYLODSAV2		; (where the load to)
  jsr wop
  sta XYLODSAV2+1
  jsr wop		; start addr
  sta STARTADDR		; (where to jump to)
  jsr wop
  sta STARTADDR+1
  jsr wop		; end addr
  sta ENDADDR		; (when the program ends)
  jsr wop
  sta ENDADDR+1
  stz serialvar		; a zero here means header mode
  ldy #0
rsl
  jsr MONRDKEY		; byte received?
  bcc rsl
  ldy #0
  lda ACIA_DATA		; then load it,
  sta (XYLODSAV2),y	; and store it at the address (indexed because "sta (XYLODSAV2)" is illegal)
  lda #$2e		; print a period
  jsr MONCOUT		; to show it is working
  inc XYLODSAV2
  lda XYLODSAV2		; increment 16-bit address
  bne checkit
  inc XYLODSAV2+1
checkit:
  lda serialvar		; header mode?
  bne rsl
			; if so,
  lda XYLODSAV2		; check if we are done.
  cmp ENDADDR
  bne rsl
  lda XYLODSAV2+1
  cmp ENDADDR+1
  bne rsl

  ; done
  jmp (STARTADDR)	; jump to the start address.

serialdone:
  ldx #0
sdone
  lda loaddonestring,x
  beq esl2		; idk
  jsr MONCOUT		; not used
  inx
  jmp sdone
esl2
  pla
  sta XYLODSAV2+1
  pla
  sta XYLODSAV2
  ply
  plx
  pla
  rts

MONCOUT
  PHA
SerialOutWait
  LDA ACIA_STATUS
  AND #$10
  CMP #$10
  BNE SerialOutWait
  PLA
  STA ACIA_DATA
  RTS

MONRDKEY
  LDA ACIA_STATUS
  AND #$08
  CMP #$08
  BNE NoDataIn
  LDA ACIA_DATA
  SEC		
  RTS
NoDataIn
  CLC		
  RTS

MONISCNTC
  JSR MONRDKEY
  BCC NotCTRLC  ; If no key pressed then exit
  CMP #3
  BNE NotCTRLC  ; if CTRL-C not pressed then exit
  SEC           ; Carry set if control C pressed
  RTS
NotCTRLC
  CLC           ; Carry clear if control C not pressed
  RTS

via_init:
  lda #%11111111          ; Set all pins on port B to output
  sta VIA_DDRB
  lda #PORTA_OUTPUTPINS   ; Set various pins on port A to output
  sta VIA_DDRA
  rts

; SD card interface module
;
; Requires zero-page variable storage:
;   zp_sd_address - 2 bytes
;   zp_sd_currentsector - 4 bytes

cmsg
  .byte "Command: ", $00

sd_init
  ; Let the SD card boot up, by pumping the clock with SD CS disabled

  ; We need to apply around 80 clock pulses with CS and MOSI high.
  ; Normally MOSI doesn't matter when CS is high, but the card is
  ; not yet is SPI mode, and in this non-SPI state it does care.

  lda #SD_CS | SD_MOSI
  ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
preinitloop
  eor #SD_SCK
  sta VIA_PORTA
  dex
  bne preinitloop
  

cmd0 ; GO_IDLE_STATE - resets card to idle state, and SPI mode
  lda #<sd_cmd0_bytes
  sta zp_sd_address
  lda #>sd_cmd0_bytes
  sta zp_sd_address+1

  jsr sd_sendcommand

  ; Expect status response $01 (not initialized)
 ; cmp #$01
 ; bne initfailed

cmd8 ; SEND_IF_COND - tell the card how we want it to operate (3.3V, etc)
  lda #<sd_cmd8_bytes
  sta zp_sd_address
  lda #>sd_cmd8_bytes
  sta zp_sd_address+1

  jsr sd_sendcommand

  ; Expect status response $01 (not initialized)
  cmp #$01
  bne initfailed

  ; Read 32-bit return value, but ignore it
  jsr sd_readbyte
  jsr sd_readbyte
  jsr sd_readbyte
  jsr sd_readbyte

cmd55 ; APP_CMD - required prefix for ACMD commands
  lda #<sd_cmd55_bytes
  sta zp_sd_address
  lda #>sd_cmd55_bytes
  sta zp_sd_address+1

  jsr sd_sendcommand

  ; Expect status response $01 (not initialized)
  cmp #$01
  bne initfailed

cmd41 ; APP_SEND_OP_COND - send operating conditions, initialize card
  lda #<sd_cmd41_bytes
  sta zp_sd_address
  lda #>sd_cmd41_bytes
  sta zp_sd_address+1

  jsr sd_sendcommand

  ; Status response $00 means initialised
  cmp #$00
  beq initialized

  ; Otherwise expect status response $01 (not initialized)
  cmp #$01
  bne initfailed

  ; Not initialized yet, so wait a while then try again.
  ; This retry is important, to give the card time to initialize.

  ldx #0
  ldy #0
delayloop
  dey
  bne delayloop
  dex
  bne delayloop

  jmp cmd55


initialized
;  ldy #>initmsg
;  ldx #<initmsg
;  jsr w_acia_full
  clc
  rts

initfailed
  ldy #>initfailedmsg
  ldx #<initfailedmsg
  jsr w_acia_full
  sec
  rts

sd_cmd0_bytes
  .byte $40, $00, $00, $00, $00, $95
sd_cmd8_bytes
  .byte $48, $00, $00, $01, $aa, $87
sd_cmd55_bytes
  .byte $77, $00, $00, $00, $00, $01
sd_cmd41_bytes
  .byte $69, $40, $00, $00, $00, $01



sd_readbyte
  ; Enable the card and tick the clock 8 times with MOSI high, 
  ; capturing bits from MISO and returning them

  ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits

looop

  lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
  sta VIA_PORTA

  lda #SD_MOSI | SD_SCK       ; toggle the clock high
  sta VIA_PORTA

  lda VIA_PORTA                   ; read next bit
  and #SD_MISO

  clc                         ; default to clearing the bottom bit
  beq bitnotset              ; unless MISO was set
  sec                         ; in which case get ready to set the bottom bit
bitnotset

  txa                         ; transfer partial result from X
  rol                         ; rotate carry bit into read result, and loop bit into carry
  tax                         ; save partial result back to X
  
  bcs looop                   ; loop if we need to read more bits

  rts


sd_writebyte
  ; Tick the clock 8 times with descending bits on MOSI
  ; SD communication is mostly half-duplex so we ignore anything it sends back here

  ldx #8                      ; send 8 bits

loopp
  asl                         ; shift next bit into carry
  tay                         ; save remaining bits for later

  lda #0
  bcc sendbit                ; if carry clear, don't set MOSI for this bit
  ora #SD_MOSI

sendbit
  sta VIA_PORTA                   ; set MOSI (or not) first with SCK low
  eor #SD_SCK
  sta VIA_PORTA                   ; raise SCK keeping MOSI the same, to send the bit

  tya                         ; restore remaining bits to send

  dex
  bne loopp                   ; loop if there are more bits to send

  rts


sd_waitresult
  ; Wait for the SD card to return something other than $ff
  jsr sd_readbyte
  cmp #$ff
  beq sd_waitresult
  rts

loadtable:
	.byte $08,"-",$08,"\",$08,"|",$08,"/", $00

sd_sendcommand 

  lda #SD_MOSI           ; pull CS low to begin command
  sta VIA_PORTA

  ldy #0
  lda (zp_sd_address),y    ; command byte
  jsr sd_writebyte
  ldy #1
  lda (zp_sd_address),y    ; data 1
  jsr sd_writebyte
  ldy #2
  lda (zp_sd_address),y    ; data 2
  jsr sd_writebyte
  ldy #3
  lda (zp_sd_address),y    ; data 3
  jsr sd_writebyte
  ldy #4
  lda (zp_sd_address),y    ; data 4
  jsr sd_writebyte
  ldy #5
  lda (zp_sd_address),y    ; crc
  jsr sd_writebyte

  jsr sd_waitresult
  pha

  ; End command
  lda #SD_CS | SD_MOSI   ; set CS high again
  sta VIA_PORTA

  pla   ; restore result code
  rts


sd_readsector
  ; Read a sector from the SD card.  A sector is 512 bytes.
  ;
  ; Parameters:
  ;    zp_sd_currentsector   32-bit sector number
  ;    zp_sd_address     address of buffer to receive data
  
  lda #SD_MOSI
  sta VIA_PORTA

  ; Command 17, arg is sector number, crc not checked
  lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
  jsr sd_writebyte
  lda zp_sd_currentsector+3   
  jsr sd_writebyte
  lda zp_sd_currentsector+2  
  jsr sd_writebyte
  lda zp_sd_currentsector+1  
  jsr sd_writebyte
  lda zp_sd_currentsector 
  jsr sd_writebyte
  lda #$01                    ; crc (not checked)
  jsr sd_writebyte

  jsr sd_waitresult
  cmp #$00
  bne faill

  ; wait for data
  jsr sd_waitresult
  cmp #$fe
  bne faill

  ; Need to read 512 bytes - two pages of 256 bytes each
  jsr readpage
  inc zp_sd_address+1
  jsr readpage
  dec zp_sd_address+1

  ; End command
  lda #SD_CS | SD_MOSI
  sta VIA_PORTA

  rts


faill
;  ldx #<statusmsg
;  ldy #>statusmsg  ; Status:
;  jsr w_acia_full

  ldx #<failedmsg
  ldy #>failedmsg  ; Failed!
  jsr w_acia_full
failloop
  jmp ($fffc)

readpage
  ; Read 256 bytes to the address at zp_sd_address
  ldy #0
readloop
  jsr sd_readbyte
  sta (zp_sd_address),y
  iny
  bne readloop
  rts

statusmsg
  .byte "Status: ", $00
initfailedmsg
  .byte "Init "
failedmsg
  .byte "Failed!", $0d, $0a, $00
respmsg
  .byte "Response: ", $00
initmsg
  .byte "Initialized!", $0d, $0a, $00

; FAT32/SD interface library
;
; This module requires some RAM workspace to be defined elsewhere:
; 
; fat32_workspace    - a large page-aligned 512-byte workspace
; zp_fat32_variables - 24 bytes of zero-page storage for variables etc

fat32_readbuffer = fat32_workspace

fat32_fatstart          = zp_fat32_variables + $00  ; 4 bytes
fat32_datastart         = zp_fat32_variables + $04  ; 4 bytes
fat32_rootcluster       = zp_fat32_variables + $08  ; 4 bytes
fat32_sectorspercluster = zp_fat32_variables + $0c  ; 1 byte
fat32_pendingsectors    = zp_fat32_variables + $0d  ; 1 byte
fat32_address           = zp_fat32_variables + $0e  ; 2 bytes
fat32_nextcluster       = zp_fat32_variables + $10  ; 4 bytes
fat32_bytesremaining    = zp_fat32_variables + $14  ; 4 bytes 

fat32_errorstage        = fat32_bytesremaining  ; only used during initializatio
fat32_filenamepointer   = fat32_bytesremaining  ; only used when searching for a file


fat32_init
  ; Initialize the module - read the MBR etc, find the partition,
  ; and set up the variables ready for navigating the filesystem

  ; Read the MBR and extract pertinent information

  lda #0
  sta fat32_errorstage

  ; Sector 0
  lda #0
  sta zp_sd_currentsector
  sta zp_sd_currentsector+1
  sta zp_sd_currentsector+2
  sta zp_sd_currentsector+3

  ; Target buffer
  lda #<fat32_readbuffer
  sta zp_sd_address
  lda #>fat32_readbuffer
  sta zp_sd_address+1

  ; Do the read
  jsr sd_readsector


  inc fat32_errorstage ; stage 1 = boot sector signature check

  ; Check some things
  lda fat32_readbuffer+510 ; Boot sector signature 55
  cmp #$55
  bne fail32
  lda fat32_readbuffer+511 ; Boot sector signature aa
  cmp #$aa
  bne fail32


  inc fat32_errorstage ; stage 2 = finding partition

  ; Find a FAT32 partition
FSTYPE_FAT32 = 12
  ldx #0
  lda fat32_readbuffer+$1c2,x
  cmp #FSTYPE_FAT32
  beq foundpart
  ldx #16
  lda fat32_readbuffer+$1c2,x
  cmp #FSTYPE_FAT32
  beq foundpart
  ldx #32
  lda fat32_readbuffer+$1c2,x
  cmp #FSTYPE_FAT32
  beq foundpart
  ldx #48
  lda fat32_readbuffer+$1c2,x
  cmp #FSTYPE_FAT32
  beq foundpart

fail32
  jmp error

foundpart

  ; Read the FAT32 BPB
  lda fat32_readbuffer+$1c6,x
  sta zp_sd_currentsector
  lda fat32_readbuffer+$1c7,x
  sta zp_sd_currentsector+1
  lda fat32_readbuffer+$1c8,x
  sta zp_sd_currentsector+2
  lda fat32_readbuffer+$1c9,x
  sta zp_sd_currentsector+3

  jsr sd_readsector


  inc fat32_errorstage ; stage 3 = BPB signature check

  ; Check some things
  lda fat32_readbuffer+510 ; BPB sector signature 55
  cmp #$55
  bne fail32
  lda fat32_readbuffer+511 ; BPB sector signature aa
  cmp #$aa
  bne fail32

  inc fat32_errorstage ; stage 4 = RootEntCnt check

  lda fat32_readbuffer+17 ; RootEntCnt should be 0 for FAT32
  ora fat32_readbuffer+18
  bne fail32

  inc fat32_errorstage ; stage 5 = TotSec16 check

  lda fat32_readbuffer+19 ; TotSec16 should be 0 for FAT32
  ora fat32_readbuffer+20
  bne fail32

  inc fat32_errorstage ; stage 6 = SectorsPerCluster check

  ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
  lda fat32_readbuffer+11 ; low byte should be zero
  bne fail32
  lda fat32_readbuffer+12 ; high byte is 2 (512), 4, 8, or 16
  cmp #2
  bne fail32


  ; Calculate the starting sector of the FAT
  clc
  lda zp_sd_currentsector
  adc fat32_readbuffer+14    ; reserved sectors lo
  sta fat32_fatstart
  sta fat32_datastart
  lda zp_sd_currentsector+1
  adc fat32_readbuffer+15    ; reserved sectors hi
  sta fat32_fatstart+1
  sta fat32_datastart+1
  lda zp_sd_currentsector+2
  adc #0
  sta fat32_fatstart+2
  sta fat32_datastart+2
  lda zp_sd_currentsector+3
  adc #0
  sta fat32_fatstart+3
  sta fat32_datastart+3

  ; Calculate the starting sector of the data area
  ldx fat32_readbuffer+16   ; number of FATs
skipfatsloop
  clc
  lda fat32_datastart
  adc fat32_readbuffer+36 ; fatsize 0
  sta fat32_datastart
  lda fat32_datastart+1
  adc fat32_readbuffer+37 ; fatsize 1
  sta fat32_datastart+1
  lda fat32_datastart+2
  adc fat32_readbuffer+38 ; fatsize 2
  sta fat32_datastart+2
  lda fat32_datastart+3
  adc fat32_readbuffer+39 ; fatsize 3
  sta fat32_datastart+3
  dex
  bne skipfatsloop

  ; Sectors-per-cluster is a power of two from 1 to 128
  lda fat32_readbuffer+13
  sta fat32_sectorspercluster

  ; Remember the root cluster
  lda fat32_readbuffer+44
  sta fat32_rootcluster
  lda fat32_readbuffer+45
  sta fat32_rootcluster+1
  lda fat32_readbuffer+46
  sta fat32_rootcluster+2
  lda fat32_readbuffer+47
  sta fat32_rootcluster+3

  clc
  rts

error
  sec
  rts


fat32_seekcluster
  ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
  
  ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
  lda fat32_nextcluster
  asl
  lda fat32_nextcluster+1
  rol
  sta zp_sd_currentsector
  lda fat32_nextcluster+2
  rol
  sta zp_sd_currentsector+1
  lda fat32_nextcluster+3
  rol
  sta zp_sd_currentsector+2

  ; Add FAT starting sector
  lda zp_sd_currentsector
  adc fat32_fatstart
  sta zp_sd_currentsector
  lda zp_sd_currentsector+1
  adc fat32_fatstart+1
  sta zp_sd_currentsector+1
  lda zp_sd_currentsector+2
  adc fat32_fatstart+2
  sta zp_sd_currentsector+2
  lda #0
  adc fat32_fatstart+3
  sta zp_sd_currentsector+3

  ; Target buffer
  lda #<fat32_readbuffer
  sta zp_sd_address
  lda #>fat32_readbuffer
  sta zp_sd_address+1

  ; Read the sector from the FAT
  jsr sd_readsector

  ; Before using this FAT data, set currentsector ready to read the cluster itself
  ; We need to multiply the cluster number minus two by the number of sectors per 
  ; cluster, then add the data region start sector

  ; Subtract two from cluster number
  sec
  lda fat32_nextcluster
  sbc #2
  sta zp_sd_currentsector
  lda fat32_nextcluster+1
  sbc #0
  sta zp_sd_currentsector+1
  lda fat32_nextcluster+2
  sbc #0
  sta zp_sd_currentsector+2
  lda fat32_nextcluster+3
  sbc #0
  sta zp_sd_currentsector+3
  
  ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
  lda fat32_sectorspercluster
spcshiftloop
  lsr
  bcs spcshiftloopdone
  asl zp_sd_currentsector
  rol zp_sd_currentsector+1
  rol zp_sd_currentsector+2
  rol zp_sd_currentsector+3
  jmp spcshiftloop
spcshiftloopdone

  ; Add the data region start sector
  clc
  lda zp_sd_currentsector
  adc fat32_datastart
  sta zp_sd_currentsector
  lda zp_sd_currentsector+1
  adc fat32_datastart+1
  sta zp_sd_currentsector+1
  lda zp_sd_currentsector+2
  adc fat32_datastart+2
  sta zp_sd_currentsector+2
  lda zp_sd_currentsector+3
  adc fat32_datastart+3
  sta zp_sd_currentsector+3

  ; That's now ready for later code to read this sector in - tell it how many consecutive
  ; sectors it can now read
  lda fat32_sectorspercluster
  sta fat32_pendingsectors

  ; Now go back to looking up the next cluster in the chain
  ; Find the offset to this cluster's entry in the FAT sector we loaded earlier

  ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
  lda fat32_nextcluster
  and #$7f
  asl
  asl
  tay ; Y = low byte of offset

  ; Add the potentially carried bit to the high byte of the address
  lda zp_sd_address+1
  adc #0
  sta zp_sd_address+1

  ; Copy out the next cluster in the chain for later use
  lda (zp_sd_address),y
  sta fat32_nextcluster
  iny
  lda (zp_sd_address),y
  sta fat32_nextcluster+1
  iny
  lda (zp_sd_address),y
  sta fat32_nextcluster+2
  iny
  lda (zp_sd_address),y
  and #$0f
  sta fat32_nextcluster+3

  ; See if it's the end of the chain
  ora #$f0
  and fat32_nextcluster+2
  and fat32_nextcluster+1
  cmp #$ff
  bne notendofchain
  lda fat32_nextcluster
  cmp #$f8
  bcc notendofchain

  ; It's the end of the chain, set the top bits so that we can tell this later on
  sta fat32_nextcluster+3
notendofchain

  rts


fat32_readnextsector
  ; Reads the next sector from a cluster chain into the buffer at fat32_address.
  ;
  ; Advances the current sector ready for the next read and looks up the next cluster
  ; in the chain when necessary.
  ;
  ; On return, carry is clear if data was read, or set if the cluster chain has ended.

  ; Maybe there are pending sectors in the current cluster
  lda fat32_pendingsectors
  bne readsector

  ; No pending sectors, check for end of cluster chain
  lda fat32_nextcluster+3
  bmi endofchain

  ; Prepare to read the next cluster
  jsr fat32_seekcluster

readsector
  dec fat32_pendingsectors

  ; Set up target address  
  lda fat32_address
  sta zp_sd_address
  lda fat32_address+1
  sta zp_sd_address+1

  ; Read the sector
  jsr sd_readsector

  ; Advance to next sector
  inc zp_sd_currentsector
  bne sectorincrementdone
  inc zp_sd_currentsector+1
  bne sectorincrementdone
  inc zp_sd_currentsector+2
  bne sectorincrementdone
  inc zp_sd_currentsector+3
sectorincrementdone

  ; Success - clear carry and return
  clc
  rts

endofchain
  ; End of chain - set carry and return
  sec
  rts


fat32_openroot
  ; Prepare to read the root directory

  lda fat32_rootcluster
  sta fat32_nextcluster
  lda fat32_rootcluster+1
  sta fat32_nextcluster+1
  lda fat32_rootcluster+2
  sta fat32_nextcluster+2
  lda fat32_rootcluster+3
  sta fat32_nextcluster+3

  jsr fat32_seekcluster

  ; Set the pointer to a large value so we always read a sector the first time through
  lda #$ff
  sta zp_sd_address+1

  rts


fat32_opendirent
  ; Prepare to read from a file or directory based on a dirent
  ;
  ; Point zp_sd_address at the dirent

  ; Remember file size in bytes remaining
  ldy #28
  lda (zp_sd_address),y
  sta fat32_bytesremaining
  iny
  lda (zp_sd_address),y
  sta fat32_bytesremaining+1
  iny
  lda (zp_sd_address),y
  sta fat32_bytesremaining+2
  iny
  lda (zp_sd_address),y
  sta fat32_bytesremaining+3

  ; Seek to first cluster
  ldy #26
  lda (zp_sd_address),y
  sta fat32_nextcluster
  iny
  lda (zp_sd_address),y
  sta fat32_nextcluster+1
  ldy #20
  lda (zp_sd_address),y
  sta fat32_nextcluster+2
  iny
  lda (zp_sd_address),y
  sta fat32_nextcluster+3

  jsr fat32_seekcluster

  ; Set the pointer to a large value so we always read a sector the first time through
  lda #$ff
  sta zp_sd_address+1

  rts


fat32_readdirent
  ; Read a directory entry from the open directory
  ;
  ; On exit the carry is set if there were no more directory entries.
  ;
  ; Otherwise, A is set to the file's attribute byte and
  ; zp_sd_address points at the returned directory entry.
  ; LFNs and empty entries are ignored automatically.

  ; Increment pointer by 32 to point to next entry
  clc
  lda zp_sd_address
  adc #32
  sta zp_sd_address
  lda zp_sd_address+1
  adc #0
  sta zp_sd_address+1

  ; If it's not at the end of the buffer, we have data already
  cmp #>(fat32_readbuffer+$200)
  bcc gotdata3

  ; Read another sector
  lda #<fat32_readbuffer
  sta fat32_address
  lda #>fat32_readbuffer
  sta fat32_address+1

  jsr fat32_readnextsector
  bcc gotdata3

endofdirectory
  sec
  rts

gotdata3
  ; Check first character
  ldy #0
  lda (zp_sd_address),y

  ; End of directory => abort
  beq endofdirectory

  ; Empty entry => start again
  cmp #$e5
  beq fat32_readdirent

  ; Check attributes
  ldy #11
  lda (zp_sd_address),y
  and #$3f
  cmp #$0f ; LFN => start again
  beq fat32_readdirent

  ; Yield this result
  clc
  rts


fat32_finddirent
  ; Finds a particular directory entry.  X,Y point to the 11-character filename to seek.
  ; The directory should already be open for iteration.

  ; Form ZP pointer to user's filename
  stx fat32_filenamepointer
  sty fat32_filenamepointer+1
  
  ; Iterate until name is found or end of directory
direntloop
  jsr fat32_readdirent
  ldy #10
  bcc comparenameloop
  rts ; with carry set

comparenameloop
  lda (zp_sd_address),y
  cmp (fat32_filenamepointer),y
  bne direntloop ; no match
  dey
  bpl comparenameloop

  ; Found it
  clc
  rts


fat32_file_readbyte
  ; Read a byte from an open file
  ;
  ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead

  sec

  ; Is there any data to read at all?
  lda fat32_bytesremaining
  ora fat32_bytesremaining+1
  ora fat32_bytesremaining+2
  ora fat32_bytesremaining+3
  beq ret

  ; Decrement the remaining byte count
  lda fat32_bytesremaining
  sbc #1
  sta fat32_bytesremaining
  lda fat32_bytesremaining+1
  sbc #0
  sta fat32_bytesremaining+1
  lda fat32_bytesremaining+2
  sbc #0
  sta fat32_bytesremaining+2
  lda fat32_bytesremaining+3
  sbc #0
  sta fat32_bytesremaining+3
  
  ; Need to read a new sector?
  lda zp_sd_address+1
  cmp #>(fat32_readbuffer+$200)
  bcc gotdata2

  ; Read another sector
  lda #<fat32_readbuffer
  sta fat32_address
  lda #>fat32_readbuffer
  sta fat32_address+1

  jsr fat32_readnextsector
  bcs ret                   ; this shouldn't happen

gotdata2
  ldy #0
  lda (zp_sd_address),y

  inc zp_sd_address
  bne ret
  inc zp_sd_address+1
  bne ret
  inc zp_sd_address+2
  bne ret
  inc zp_sd_address+3

ret
  rts

fat32_file_read
  ; Read a whole file into memory.  It's assumed the file has just been opened 
  ; and no data has been read yet.
  ;
  ; Also we read whole sectors, so data in the target region beyond the end of the 
  ; file may get overwritten, up to the next 512-byte boundary.
  ;
  ; And we don't properly support 64k+ files, as it's unnecessary complication given
  ; the 6502's small address space

  ; Round the size up to the next whole sector
  lda fat32_bytesremaining
  cmp #1                      ; set carry if bottom 8 bits not zero
  lda fat32_bytesremaining+1
  adc #0                      ; add carry, if any
  lsr                         ; divide by 2
  adc #0                      ; round up

  ; No data?
  beq donee

  ; Store sector count - not a byte count any more
  sta fat32_bytesremaining

  ; Read entire sectors to the user-supplied buffer
wholesectorreadloop
  ; Read a sector to fat32_address
  jsr fat32_readnextsector

  ; Advance fat32_address by 512 bytes
  lda fat32_address+1
  adc #2                      ; carry already clear
  sta fat32_address+1

  ldx fat32_bytesremaining    ; note - actually loads sectors remaining
  dex
  stx fat32_bytesremaining    ; note - actually stores sectors remaining

  bne wholesectorreadloop

donee
  rts


;;;       ------------------ 6551 ACIA Subroutine Library -------------------
;;; Includes:
;;; acia_init       - Initializes the ACIA
;;; print_hex_acia  - Prints a hex value in A
;;; clear_display   - Sends a <CLS> command
;;; txpoll          - Polls the TX bit to see if the ACIA is ready
;;; print_chara     - Prints a Character that is stored in A
;;; print_char_acia - Same as print_chara
;;; ascii_home      - Home the cursor
;;; w_acia_full     - Print a NULL-Termintated String with >HIGH in Y and <LOW in X

acia_init
  pha
  lda #%00001011          ; No parity, no echo, no interrupt
  sta $8002
  lda #%00011111          ; 1 stop bit, 8 data bits, 19200 baud
  sta $8003
  pla
  rts

print_hex_acia
  pha
  ror
  ror
  ror
  ror
  jsr print_nybble   ; This is just som usful hex cod
  pla
print_nybble
  and #15
  cmp #10
  bmi skipletter
  adc #6
skipletter
  adc #48
 ; jsr print_char
  jsr print_chara
  rts

cleardisplay
  pha
  jsr txpoll  ; Poll the TX bit
  lda #12     ; Print decimal 12 (CLS)
  sta $8000
  pla
  rts

txpoll
  lda $8001
  and #$10    ; Poll the TX bit
  beq txpoll
  rts

print_chara
  pha
  jsr txpoll  ; Poll the TX bit
  pla
  sta $8000   ; Print character from A
  rts

print_char_acia
  jmp print_chara  ; Same as "print_chara"

ascii_home
  pha
  lda #1
  jsr print_chara  ; Print 1 (HOME)
  pla
  rts

w_acia_full
  pha
  lda $ff
  pha        ; Push Previous States onto the stack
  lda $fe
  pha
  sty $ff    ; Set Y as the Upper Address (8-15)
  stx $fe    ; Set X as the Lower Adderss (0-7)
  ldy #0
acia_man
  jsr txpoll   ; Poll TX
  lda ($fe),y  ; Load the Address
  sta $8000    ; Print what is at the address
  beq endwacia ; If Done, End
  iny          ; Next Character
  jmp acia_man ; Back to the top
endwacia
  pla
  sta $fe
  pla          ; Restore Variables
  sta $ff
  pla
  rts

error_sound:
  jsr clear_sid
  lda #$0f
  sta $b818
  lda #$e7
  sta $b802
  lda #$0f
  sta $b805
  lda #$f8
  sta $b806
  lda freq_table
  sta $b800
  lda freq_table+1
  sta $b801
  lda #$41
  sta $b804

outer
  ldy #$ff
inner
  ldx #$ff

innerloop
  dex
  bne innerloop

  dey
  beq ende
  jmp inner
ende
  lda #$40
  sta $b804
  rts
	
freq_table:
  .byte $50, $50

clear_sid
  ldx #$17
csid
  stz $b800,x
  dex
  bne csid
  rts

zp_sd_address = $40         ; 2 bytes
zp_sd_currentsector = $42   ; 4 bytes
zp_fat32_variables = $46    ; 24 bytes

fat32_workspace = $200      ; two pages

buffer = $400


subdirname
  .byte "FOLDER     "
filename
  .byte "CODE    XPL"
loadname
  .byte "LOADADDRSAR"

fat_error
  .byte "FAT32 Error At Stage ", $00

loadcmd

  ; Initialise
 ; jsr acia_init
  jsr via_init
 ; jsr lcd_init
  jsr sd_init
  bcc load1
  rts
  rts
  rts
load1:
  jsr fat32_init
  bcc initsuccess
 
  ; Error during FAT32 initialization

  ldy #>fat_error
  ldx #<fat_error
  jsr w_acia_full
  lda fat32_errorstage
  jsr print_hex_acia
  lda #'!'
  jsr print_chara

 ; rts
 ; rts
 ; rts

  jmp looopp

initsuccess

  ; Open root directory
  jsr fat32_openroot

  ; Find subdirectory by name
  ldx #<subdirname
  ldy #>subdirname
  jsr fat32_finddirent
  bcc foundsubdir

  ; Subdirectory not found
  ldy #>submsg
  ldx #<submsg
  jsr w_acia_full
  jmp looopp

foundsubdir

  ; Open subdirectory
  jsr fat32_opendirent

  ; Find file by name
  ldx #<loadname
  ldy #>loadname
  jsr fat32_finddirent
  bcc foundfile

  ; File not found
  ldy #>filmsg
  ldx #<filmsg
  jsr w_acia_full
  jmp looopp

foundfile
 
  ; Open file
  jsr fat32_opendirent

  ; Read file contents into buffer
  lda #<buffer
  sta fat32_address
  lda #>buffer
  sta fat32_address+1

  jsr fat32_file_read

  ; Open root directory
  jsr fat32_openroot

  ; Find subdirectory by name
  ldx #<subdirname
  ldy #>subdirname
  jsr fat32_finddirent
  bcc startload

  ; Subdirectory not found
  ldy #>submsg
  ldx #<submsg
  jsr w_acia_full
  jmp looopp
 
startload

  ; Open subdirectory
  jsr fat32_opendirent

  ldy #>lds
  ldx #<lds
  jsr w_acia_full

  ldx #<filename
  ldy #>filename
  jsr fat32_finddirent
  bcc foundcode

  ldy #>filmsg2
  ldx #<filmsg2
  jsr w_acia_full
  jmp looopp

foundcode

  jsr fat32_opendirent

  lda buffer
  sta fat32_address
  lda buffer+1
  sta fat32_address+1


  jsr fat32_file_read

  ldy #>ends
  ldx #<ends
  jsr w_acia_full

  jmp (buffer+2)

looopp
  rts

submsg
  .byte "'folder' Not Found!", $00
filmsg
  .byte "'loadaddr.sar' Not Found!", $00
filmsg2
  .byte "'code.xpl' Not Found!", $00
lds
  .byte "Loading SD Handler...", $00
ends
  .byte "Done.", $0d, $0a, $0d, $0a, $00
  

;; memory test
;; the process is, for each page of memory (and MEMTESTBASE points
;; to the starting point), we write the number of that page into
;; each byte of that page (ie, each byte on page $1200 gets written
;; with $12, each byte on page $4600 gets written with $46).
;; then we read back and report errors. Leave the memory as it
;; is at the end of the test so that I can poke around with the
;; monitor later
;;
memtestcmd
  phx               ; preserve the stack, we're going to need x...
  ;; stage one is the write
writetest
  stz MEMTESTBASE
  lda #$05         ;; we start at page $05
  sta MEMTESTBASE+1

  ;; for page x, write x into each byte
.(
fillpage
  ldy #$00
  lda MEMTESTBASE+1 ; load bit pattern
loop
  sta (MEMTESTBASE),y
  iny
  bne loop

  ;; move onto the next page, as long as we're still in the RAM
nextpage
  ;lda BASE+1
  inc               ; accumulator still holds page numner
  cmp #$80          ; stop when we hit the upper half of memory
  beq readtest
  sta MEMTESTBASE+1
  bra fillpage
.)

  ;; stage two. read it back and check.
readtest
  ;; start at the beginning again
  stz MEMTESTBASE
  lda #$05
  sta MEMTESTBASE+1

.(
  ;; each byte should be the same as the page
nextpage
  ldy #$00
loop
  lda (MEMTESTBASE),y
  cmp MEMTESTBASE+1
  bne testerr
  iny
  bne loop

  lda MEMTESTBASE+1
  inc
  cmp #$80
  beq exit
  sta MEMTESTBASE+1
  bra nextpage
testerr
  lda MEMTESTBASE+1
  jsr putax
  tya
  jsr putax
  jsr memtesterr
exit
  plx
  rts
.)  


memtesterr
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda memerrstr,y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
  jsr crlf
.)
  rts


;;; print the string pointed to at PRINTVEC
;;;
printvecstr
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (PRINTVEC),y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
.)
  rts


;;;
;;; Various string constants
;;;

hextable:	 .byte "0123456789ABCDEF"
greeting:	 .byte "XPL-32 monitor", $0d, $0a, $00
prompt:		 .byte ">"
aboutstring:	 .byte "XPL-32 monitor - a command prompt for the XPL-32.", $0d, $0a 
		 .byte "This program was original developed by Paul Dourish, and it was called Mitemon.", $0d, $0a, $0d, $0a
                 .byte "In this version, I have added XPL-32 support, and a couple new commands.", $0d, $0a, $00
helpstring:	 .byte "Commands available:", $0d, $0a, $0d, $0a
		 .byte "echo", $09, " - Echos a string to the screen.", $0d, $0a
		 .byte "help", $09, " - displays this screen", $0d, $0a
		 .byte "about", $09, " - displays information about this software", $0d, $0a
		 .byte "dump", $09, " - dumps memory contents at a specific address", $0d, $0a
		 .byte "poke", $09, " - puts a value at an address", $0d, $0a, $00
helpstring2:	 .byte "zero", $09, " - fills a memory range with zeros", $0d, $0a
		 .byte "go", $09, " - jumps to an address", $0d, $0a
		 .byte "xreceive - receive from the serial port with xmodem to a specified address", $0d, $0a
		 .byte "dis", $09, " - disassembles machine code a memory range into assembly, and prints that onto the screen", $0d, $0a, $00
		 .byte "input", $09, " - inputs hexadecimal bytes from the keyboard to an address. terminated by a double return.", $0d, $0a
helpstring3:	 .byte "memtest  - tests memory integrity", $0d, $0a
		 .byte "receive  - like xreceive, but no protocol is used", $0d, $0a
		 .byte "load", $09, " - load a memory card's automatic loading system", $0d, $0a
		 .byte "rti", $09, " - return from any pending interuppts. warning-might crash", $0d, $0a, $00
nocmderrstr:	 .byte "Command not recognized", $0d, $0a, $00
implementstring: .byte "Not yet implemented", $0d, $0a, $00
dumperrstring:   .byte "Usage: dump hexaddress [count:10]", $00
pokeerrstring:   .byte "Usage: poke hexaddress hexvalue", $00
goerrstring:	 .byte "Usage: go hexaddress", $00
zeroerrstring:	 .byte "Usage: zero hexaddress [count:10]", $00
xrecverrstring:  .byte "Usage: xreceive hexaddress", $00
tsaveerrstring:	 .byte "Usage: tsave startaddr endaddr", $00
inputhelpstring: .byte "Enter two-digit hex bytes. Blank line to end.", $00
inputerrstring:  .byte "Usage: input hexaddress", $00
memerrstr:	 .byte "Memory test failed", $00
diserrorstring:  .byte "Usage: dis hexaddress [count: 10]",$00
transferstring:  .byte "Serial [S] or Memory Card [M] Transfer?", $0d, $0a, $00
serialstring:    .byte "Start Serial Load.", $0d, $0a, $00
loaddonestring:  .byte "Load Complete.", $0d, $0a, $00
char:		 .byte "."

rxpoll:
  lda ACIA_STATUS
  and #$08
  beq rxpoll
  rts

interrupt
  jmp ($7ffe)  
  rti

  .dsb 7027,$00

; ----KERNAL----

* = $FFB2

; inits

KERNAL_acia_init:
  jmp acia_init
KERNAL_via_init:
  jmp via_init
KERNAL_sd_init:
  jmp sd_init
KERNAL_fat32_init:
  jmp fat32_init

; acia

KERNAL_print_hex_acia:
  jmp print_hex_acia
KERNAL_crlf:
  jmp crlf
KERNAL_cleardisplay:
  jmp cleardisplay
KERNAL_rxpoll:
  jmp rxpoll
KERNAL_txpoll:
  jmp txpoll
KERNAL_print_chara:
KERNAL_print_char_acia:
  jmp print_chara
KERNAL_ascii_home:
  jmp ascii_home
KERNAL_w_acia_full
  jmp w_acia_full

; fat32

KERNAL_fat32_seekcluster:
  jmp fat32_seekcluster
KERNAL_fat32_readnextsector
  jmp fat32_readnextsector
KERNAL_fat32_openroot:
  jmp fat32_openroot
KERNAL_fat32_opendirent:
  jmp fat32_opendirent
KERNAL_fat32_readdirent
  jmp fat32_readdirent
KERNAL_fat32_finddirent:
  jmp fat32_finddirent
KERNAL_fat32_file_readbyte:
  jmp fat32_file_readbyte
KERNAL_fat32_file_read:
  jmp fat32_file_read

; sd

KERNAL_sd_readbyte:
  jmp sd_readbyte
KERNAL_sd_sendcommand:
  jmp sd_sendcommand
KERNAL_sd_readsector:
  jmp sd_readsector

; other

KERNAL_loadcmd:
  jmp loadcmd

   * = $FFFA
  .word interrupt
  .word reset
  .word interrupt

