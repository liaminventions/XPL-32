00001  ; version 2.10
00002  ; two pass assembler, dissembler and tracer- inspiration with permission from A1 by San Bergmans
00003  ; REGB bits 0-3 are connected to LED's
00004  ; tested in Michael Kowalski 6502 Simulator - using 65C02 Code 
00005  ; "Programmed" by Joe DiMeglio
00006  ; https://github.com/jdimeglio/6502-Monitor
00007  
00008  			.OPT proc65C02,swapbin		;Michal Kowaski Simulator
00009    F8DF              			.START	RESET_VECTOR		;version 1.3.2
00010  			.IO_WND 80,25			;
00011  		
00012  ;------------------------------------------------------------------------
00013  ; Compiler Options/Directives
00014  ;------------------------------------------------------------------------
00015  
00016    0000              BRKAS2		= 0					;Add a second BRK byte
00017    0000              MYWYM		= 0					;has MYWYM Board settings/Chips
00018    0000              LCD_ROUTINES	= 0					;Compile with LCD 16x2 lines 	
00019    0000              SYMON		= 0					;used for SYMON to define CIA and VIA
00020  	
00021  		.INCLUDE	"constants.65s"
00022  ; LIBRARY FILE
00023  ; version 2.09
00024  ; two pass assembler, dissembler and tracer- inspiration with permission from A1 by San Bergmans
00025  ; REGB bits 0-3 are connected to LED's
00026  ; tested in Michael Kowalski 6502 Simulator - using 65C02 Code 
00027  ; "Programmed" by Joe DiMeglio
00028  		
00029  
00030  ;------------------------------------------------------------------------
00031  ; Symbols used in source code
00032  ;------------------------------------------------------------------------
00033  
00034    0023              IMV		='#'				;Indicates immediate mode value
00035    0024              HEX		='$'				;Indicates a hex value
00036    0028              OPEN		='('				;Open bracket for indirect addressing
00037    0029              CLOSE		=')'				;Close bracket for indirect addressing
00038    002A              PCREL		='*'				;Indicates PC relative addressing
00039    003C              LOBYTE		='<'				;Indicates lo-byte of following word
00040    003E              HIBYTE		='>'				;Indicates hi-byte of following word
00041    002B              PLUS		='+'				;Plus in simple expressions
00042    002D              MINUS		='-'				;Minus in simple expressions
00043    002E              DOT		='.'				;Indicates a local label
00044    0027              QUOTE		='''				;delimits a string
00045    002C              COMMA		=','				
00046    003B              CMNT		=';'				;indicates a full line comment
00047    002E              PROMPT		='.'				;The assembler prompt character
00048    002D              DASH		='-'				;Dash for crued graphics
00049    0000              EOL		=$00				;End of line marker
00050    0000              EOS		=$00				;End of string marker
00051    0001              EOFLD		=$01				;End of field in tokenised source line
00052    0002              BLANK		=$02				;used to mark a blank line
00053    00FE              PRGEND		=$FE				;used to flag end of program parsing
00054    00FF              FAIL		=$FF				;used to flag failure in various searches
00055    000D              CR		=$0D				;CR character
00056    001B              ESC		=$1B				;ESC character
00057    0007              BELL		=$07				;BELL should be $07 but $20 for testing 
00058    0008              BS		=$08				;Back space key
00059    0009              TAB		=$09				;TAB character
00060    000A              LF		=$0a				;Line feed
00061    0020              SP		=$20				;Space
00062  
00063    000C              TAB1            =12				;1st tab stop 8
00064    0010              TAB2            =16				;2nd tab stop 12
00065    0014              TAB3            =20				;3rd tab stop 21
00066    001A              TAB4		=26				;4th tab
00067  
00068  
00069  ;------------------------------------------------------------------------
00070  ; Constants
00071  ;------------------------------------------------------------------------
00072  
00073    0004              DEF_LOMEM       =     	$04             	;Default lomem page
00074    03E8              DEF_AUTO        =     	1000            	;Default Auto line number start
00075    000A              DEF_INC         =     	10              	;Default Auto increment step
00076    1000              DEF_ORG         =     	$1000         	;Default .OR
00077    0200              DEF_OBJLOW      =     	$0200           	;Default lowest object address
00078  
00079  
00080  
00081  ;------------------------------------------------------------------------
00082  ; Zero page memory
00083  ; Input buffer placed in ZP because of the many references to it. Must be
00084  ;  completely in ZP because address + index remains only one byte address
00085  ; PASS must remain the first label here! See INIT routine
00086  ;------------------------------------------------------------------------
00087  
00088  000019                                .ORG    $0019          		;Leave 1st part of ZP free
00089  000099                IN              .RS     128            		;Input and parse buffer 128 Characters input
00090  	
00091  	.IF LCD_ROUTINES
00092  ;------------------------------------------------------------------------
00093  ; Tracing/debuging varials
00094  ;------------------------------------------------------------------------
00095  0000A8                XQT		.RS	15			;Used for tacing
00096  0000A9                SAVP		.RS	1			;registers save - 5 locations must be contiguous1
00097  0000AA                SAVS		.RS	1		
00098  0000AB                SAVY		.RS	1
00099  0000AC                SAVX		.RS	1
00100  0000AD                SAVA		.RS	1
00101  	
00102  ;------------------------------------------------------------------------
00103  ; Assembler registers
00104  
00105  0000AE                PASS            .RS     1               	;Assembler pass 0=1, 1=2
00106  0000B0                GLOBAL          .RS     2               	;Last defined Global label
00107  0000B2                GLOBAL_VAL      .RS     2              	 	;Last defined Global's value
00108  0000B3                LABEL_FLAG      .RS     1              		;Found label's assigned flag (b7)
00109  0000B5                PNTR            .RS     2             		;Pointer in source
00110  0000B6                INDEX           .RS     1               	;Index mode 0, X or Y
00111  0000B8                PC              .RS     2              		;Current program counter
00112  0000BA                TA              .RS     2              		;Current target address
00113  0000BC                TA_BEGIN        .RS     2               	;Begin of target address block
00114  0000BE                PC_BEG          .RS     2               	;Program counter at start of line
00115  0000BF                ASM_ERR         .RS     1               	;Assemble errors (max 255)
00116  0000C0                UNDEF           .RS     1               	;Undefined label if <> 0
00117  0000C1                FORWARD         .RS     1               	;Forward referenced label if <> 0
00118  0000C2                LL_NUM          .RS     1               	;Local label's number
00119  0000C3                FIRST_CHAR      .RS     1               	;First character of a label
00120  
00121  0000C4                CURMNE		.RS	1			;Holds the current mne index
00122  0000C5                CURADM		.RS	1			;Holds the current addressing mode
00123  
00124  ;------------------------------------------------------------------------
00125  ; Editor's registers
00126  
00127  0000C6                CMD_CHR         .RS     1               	;First character of command
00128  0000C7                ERROR           .RS     1               	;Latest error
00129  0000C8                DUMP            .RS     1               	;Dump mode in list command
00130  0000CA                PARM1           .RS     2               	;Parameter 1
00131  0000CC                PARM2           .RS     2               	;Parameter 2
00132  
00133  ;------------------------------------------------------------------------
00134  ; General purpose registers
00135  
00136  0000CD                NEG_FLAG        .RS     1               	;Negative flag (if <> 0)
00137  0000CE                COUNT           .RS     1               	;GP counter
00138  0000CF                DELIM           .RS     1               	;String/ASCII delimiter
00139  0000D1                HEXVAL          .RS     2               	;16-bit value of expression
00140  0000D2                LEAD0           .RS     1               	;Leading 0 flag
00141  0000D3                CHAR            .RS     1               	;Character compilation register
00142  0000D5                MULDIV          .RS     2               	;Multiply/divide temp
00143  0000D7                EXP_SAVE        .RS     2               	;Expression save value
00144  0000D9                DEC_SAVE        .RS     2               	;Decimal convert save value
00145  0000DA                SAVE_Y          .RS     1               	;Save Y pointer
00146  0000DC                LENG            .RS     2               	;Length of block move
00147  0000DE                SRCE            .RS     2               	;Source for block move
00148  0000E0                DEST            .RS     2			;Destination for block move
00149  
00150  ;------------------------------------------------------------------------
00151  ; for disassembler
00152  
00153  0000E2                PRFLAG		.RS	2
00154  0000E3                TEMP1		.RS	1			;general purpose storage
00155  0000E4                TEMP2		.RS	1
00156  
00157  ;------------------------------------------------------------------------
00158  ; Registers which are best NOT to be disturbed by user's program!
00159  
00160  0000E5                OLD_SAVE        .RS     1               	;OLD possible if <> 0
00161  0000E7                AUTO            .RS     2               	;Next Auto line number
00162  0000E8                AUTO_INC        .RS     1               	;Auto increment
00163  0000E9                AUTO_FLAG       .RS     1               	;Auto mode flag (if <> -)
00164  0000EB                SYM_TABLE       .RS     2               	;Symbol table (if MSB <> 0)
00165  0000ED                USR_OBJLO       .RS     2               	;User's safe object begin
00166  0000EF                USR_OBJHI       .RS     2			;User's safe object end	
00167  0000F1                LOMEM           .RS     2			;Lomem address   | Don't
00168  0000F3                HIMEM        	.RS     2			;Himem address |  change order
00169  0000F5                XEC_LAST        .RS     2			;Last Xec address
00170  0000F7                USERKEYDEF	.RS	2			;User defined @keys 
00171  0000F9                USIRQ		.RS     2			;User IRQ vector
00172  0000FB                USBRK		.RS     2			;User BRK vector
00173  0000FD                USMNI		.RS     2			;User NMI vector
00174  000100                USRRST		.RS     3			;User RESET vector + checksum
00175  
00176  
00177  ;------------------------------------------------------------------------
00178  ; Hardware mapping
00179  ;------------------------------------------------------------------------
00180  	.IF LCD_ROUTINES
00181  
00182  
00183  
00184  
00185  ;------------------------------------------------------------------------
00186  ; My board settings
00187  ;------------------------------------------------------------------------	
00188  	.IF MYWYM
00189  	
00190  
00191  ;------------------------------------------------------------------------
00192  ; Simulator or HARDWARE Mapping 6502 Simulator
00193  ;------------------------------------------------------------------------
00194    8000              VIA     	= $8000
00195    8800              ACIA   	 	= io_area		
00196    8800              io_cls	 	= io_area + 0 			;writing to this clears the output window
00197    8801              io_putc 	= io_area + 1 			;a "glass teletype" output window. BS, CR and LF are actioned
00198    8802              io_putr 	= io_area + 2 			;raw output, bytes are output as their
00199  						;characters and not actioned.
00200    8803              io_puth 	= io_area + 3 			;hex output, bytes are output as their hex code
00201    8804              io_getc 	= io_area + 4 			;SCAN_ESCing character get, will wait for input
00202    8805              io_posx 	= io_area + 5 			;set cursor x position by writing here
00203    8806              io_posy 	= io_area + 6 			;set cursor y position by writing here        
00204  	
00205    8804              KBD             = io_getc       		;Keyboard input register
00206    8804              KBDCR           = io_getc 	        	;Keyboard control register
00207  
00208  		
00209  	.ENDIF
00210  	
00211  	
00212  		
00213  		
00214  	
00215  	
00216  00E000                 			*= $e000			;ROM location
00217   		
00218  ;------------------------------------------------------------------------
00219  ; Lets get going
00220  ; Cold and Warm program entry points
00221  ;------------------------------------------------------------------------
00222  
00223  00E000  20 B2 E5      COLD            	JSR     INIT            	;Initialise assembler
00224  00E003  D8            WARM            	CLD                     	;You'll probably know why
00225  00E004  20 A2 F6                      	JSR     WRCRLF          	;Print CR & LF before we do anything                
00226  00E007  64 E8                         	STZ     AUTO_FLAG       	;Clear auto flag
00227                  
00228  ;------------------------------------------------------------------------
00229  ; Get input line (main program loop)
00230  ;------------------------------------------------------------------------
00231  
00232  00E009  A2 00         GETLINE         	LDX	#$00			;reset buffer index
00233  00E00B  A9 2E         			LDA     #PROMPT         	;Print the assembler prompt
00234  00E00D  20 A9 F6                      	JSR     WRCHAR		
00235  00E010  20 46 E8                      	JSR     AUTONUM         	;Generate line number if auto=on
00236  00E013  20 E5 F6      .IN             	JSR	RDCHAR			;Was a key pressed?
00237  00E016  C9 1B         .found	               	CMP     #ESC            	;Is it the ESC key?
00238  00E018  F0 23                         	BEQ     .ESC         		;Nope!
00239  00E01A  C9 08         			CMP     #BS             	;Back space key then?
00240  00E01C  F0 26         			BEQ	.BS
00241  00E01E  C9 09         			CMP     #TAB            	;Is it the TAB character?
00242  00E020  F0 2B         			BEQ	.TABS 
00243  00E022  C9 0D         			CMP     #CR             	;Is it a CR then?
00244  00E024  F0 45                         	BEQ     .CR             	;Yes!                
00245  00E026  C9 3A                         	CMP	#':'			;INTEL Hex loader
00246  00E028  D0 05         	                BNE	.LF			;nope then skip
00247  00E02A  20 16 E1      	   		JSR     CMD_INTELHEX
00248  00E02D  80 DA         	   		BRA	GETLINE          
00249                  
00250  00E02F  C9 0A         .LF             	CMP     #LF             	;Is it a CR then?
00251  00E031  F0 E0                         	BEQ	.IN			;Strip LF useful for pasting code                                
00252  00E033  95 19                         	STA     IN,X            	;Save new character in input buffer
00253  00E035  20 A9 F6                      	JSR     WRCHAR          	; and display it
00254  00E038  E8                            	INX
00255  00E039  10 D8                         	BPL     .IN             	;Get next character unless its 128 characters
00256  00E03B  80 02                         	BRA     .CANCEL         	;Always taken! Too many chars.
00257  
00258  00E03D  64 E8         .ESC            	STZ     AUTO_FLAG       	;Clear auto flag and therefore OFF
00259  		
00260  			
00261  ;		.IF MYWYM
00262  ;		.IF SYMON	
00263  ;			JSR     RDCHAR     		;get the unwanted arrow keys	
00264  ;			
00265  ;		.ELSE			
00266  ;			;JSR     RDCHAR        		        			
00267  ;			;JSR     RDCHAR  
00268  ;		.ENDIF			
00269  ;		.ENDIF	
00270  		
00271  00E03F  20 A2 F6      .CANCEL         	JSR     WRCRLF     		;Print CRLF
00272  00E042  80 C5                         	BRA     GETLINE         	;Always taken! Restart line
00273  	
00274  00E044  20 A9 F6      .BS             	JSR     WRCHAR			;Process Back SPACE   
00275  00E047  CA                            	DEX                     	;Decrement input pointer
00276  00E048  10 C9                         	BPL     .IN             	;Still positive!
00277  00E04A  E8                            	INX                     	;Don't allow it to go negative
00278  00E04B  80 C6                         	BRA     .IN             	;Always taken!
00279  
00280  00E04D  A0 00         .TABS           	LDY     #0              	;Point to 1st tab stop
00281  00E04F  B9 93 E0      .TABS_NEXT      	LDA     TABS,Y          	;It X smaller than this one?
00282  00E052  85 CD                         	STA     COUNT
00283  00E054  A9 20                         	LDA     #SP			;replace with SPACE probably dont need this
00284  00E056  E4 CD                         	CPX     COUNT
00285  00E058  90 05                         	BCC     .DOTAB         	 	;Yes! Tab to this position
00286  00E05A  C8                            	INY	
00287  00E05B  C0 04                         	CPY     #NUMTABS        	;Maximum number of tab stops
00288  00E05D  90 F0                         	BCC     .TABS_NEXT      	;Try next!
00289  
00290  00E05F  95 19         .DOTAB          	STA     IN,X            	;Save this character
00291  00E061  E8                            	INX
00292  00E062  20 A9 F6                      	JSR     WRCHAR            	; and WRCHAR it
00293  00E065  E4 CD                         	CPX     COUNT           	;At tab stop?
00294  00E067  90 F6                         	BCC     .DOTAB          	;Not yet!
00295  00E069  80 A8                         	BRA     .IN             	;Always taken!
00296  	
00297  00E06B  95 19         .CR             	STA     IN,X            	;Mark end of line now with CR
00298  00E06D  20 2A F7      			JSR	UPPERCASE		;convert to upper case
00299  00E070  20 A2 F6                      	JSR     WRCRLF          	;CR new line    
00300  00E073  20 A4 E5                      	JSR     FIRSTNONSPC     	;Find first non space
00301  00E076  F0 91         	                BEQ     GETLINE         	;End of line reached!
00302  
00303  00E078  C9 30                 	        CMP     #'0'            	;Is it a line number?
00304  00E07A  90 04                         	BCC     .NOLINE         	;No!
00305  00E07C  C9 3A                         	CMP     #'9'+1
00306  00E07E  90 0D                         	BCC     .LINENUM        	;It is! Add it to the program
00307  00E080  20 97 E0      .NOLINE         	JSR     KEYDEF         		;Parse command, or line number
00308  00E083  A5 C6         .CHK_ERROR      	LDA     ERROR           	;Was there an error?
00309  00E085  F0 03                         	BEQ     .GETLINE        	;Nope!
00310  00E087  20 6D E4                      	JSR     PRINT_MSGS     		;Print error
00311  00E08A  4C 09 E0      .GETLINE        	JMP     GETLINE         	;Stay in main program loop
00312  
00313  00E08D  20 3C EC      .LINENUM        	JSR     ADDLINE         	;Add line to program
00314  00E090  4C 83 E0                      	JMP     .CHK_ERROR      	;Check if an error occurred
00315  
00316  TABS            .BYTE     TAB1           		;1st tab stop
00317                  .BYTE     TAB2          	 	;2nd tab stop
00318                  .BYTE     TAB3 
00319                  .BYTE     TAB4         	  		;3rd tab stop
00320    0004              NUMTABS         =     4              		 	;Number of tab stops
00321  
00322  ;------------------------------------------------------------------------
00323  ; Parse command or line number
00324  ; A holds the command character
00325  ;------------------------------------------------------------------------
00326  
00327  00E097  A0 00         KEYDEF         		LDY     #0              	;Find command in table
00328  00E099  84 C6                         	STY     ERROR           	;Clear error		
00329  00E09B  85 C5                         	STA     CMD_CHR
00330  
00331  00E09D  B9 C3 E0      .LOOP          	 	LDA     .TABLE,Y	
00332  00E0A0  F0 1C                         	BEQ     .SYNERR         	;End of table! Syntax errorv 
00333  00E0A2  C5 C5                         	CMP     CMD_CHR         	;Is it this command
00334  00E0A4  F0 03                         	BEQ     .FOUND          	;Found our command!
00335  00E0A6  C8                            	INY                     	;Next command from table
00336  00E0A7  80 F4                         	BRA     .LOOP           	;Always taken!
00337  
00338  00E0A9  20 32 EC      .FOUND          	JSR     IN_BLANK        	;Get next and see if it's blank
00339  00E0AC  D0 FB                         	BNE     .FOUND          	;A CR would have been too!
00340  00E0AE  98                            	TYA                     	;Point to command handler's
00341  00E0AF  0A                            	ASL                     	; address in table                
00342  00E0B0  A8                            	TAY     	          
00343  00E0B1  B9 DB E0                      	LDA     FUNCTIONS+1,Y   	; Get the address and use it MSB first
00344  00E0B4  48                            	PHA                     	; as return address                
00345  00E0B5  B9 DA E0                      	LDA     FUNCTIONS,Y
00346  00E0B8  48                            	PHA
00347  00E0B9  A0 00                         	LDY     #0              	;Some commands may benefit from this
00348  00E0BB  4C A6 E5                      	JMP     NNONSPC         	;Find next non space and exec cmd XR points to IN.X
00349                  	
00350  00E0BE  A9 08         .SYNERR         	LDA     #ERR_SYN        	;Exit with syntax error
00351  00E0C0  85 C6                         	STA     ERROR
00352  00E0C2  60                            	RTS
00353  
00354  ;------------------------------------------------------------------------
00355  ; Table of commands
00356  ; 
00357  ;------------------------------------------------------------------------
00358  
00359  .TABLE       		.BYTE     	'A'            	;Auto line numbering
00360  			.BYTE		'B'		;Break command
00361                  	.BYTE     	'C'            	;Copy command
00362                  	.BYTE		'D'		;Dissassembler
00363                  	.BYTE     	'E'            	;Erase command
00364                  	.BYTE		'F'		;Fill Command - future
00365    			.BYTE		'G'		;GO command - future
00366    			.BYTE		'H'		;Hunt Command - future
00367                  	.BYTE     	'?'            	;Help command
00368                  	.BYTE	  	'I'		;ASCII Dump	
00369                  	.BYTE     	'L'            	;List command
00370                  	.BYTE     	'M'            	;Memory command
00371                  	.BYTE     	'N'            	;New command
00372                  	.BYTE     	'O'            	;Old command
00373                  	.BYTE     	'R'            	;Renumber command
00374                  	.BYTE     	'S'            	;Start assembling
00375                  	.BYTE		'T'		;Trace code
00376                  	.BYTE     	'V'            	;Value command
00377                  	.BYTE		"W"		;Display registers                	
00378                  	.BYTE		'Y'		;memory configuraion
00379  			.BYTE		'Z'		;Clear Screen
00380                  	.BYTE		'@'		;User commands	
00381  CMD_BRK			.BYTE     	0             	;End of table & BRK
00382  
00383  ;------------------------------------------------------------------------
00384  ; Table of commands
00385  ;   RTS will a +1 to the address
00386  ;------------------------------------------------------------------------
00387  					 		
00388  FUNCTIONS       	.WORD   CMD_AUT-1  		;Auto line numbering
00389  			.WORD	CMD_BRK-1		;Break command
00390                  	.WORD   CMD_COP-1      		;Copy command
00391                  	.WORD	CMD_DISSASSEMBLER-1	;Dissassembler
00392                  	.WORD   CMD_ERASE-1      	;Erase command                	
00393                  	.WORD	CMD_FILL-1		;Fill memory
00394  			.WORD   CMD_XEC-1      		;eXecute command
00395                  	.WORD	CMD_HUNT-1		;hunt command
00396                  	.WORD   CMD_HLP-1      		;Help command
00397                  	.WORD	CMD_ASCIIDUMP-1		;ASCII DUMP
00398                  	.WORD   CMD_LST-1      		;List command                
00399                  	.WORD	CMD_MEMORY_DUMP-1	;Memory command
00400                  	.WORD   CMD_NEW-1      		;New command
00401                  	.WORD   CMD_OLD-1      		;Old command
00402                  	.WORD   CMD_REN-1      		;Renumber command
00403                  	.WORD   CMD_ASM-1      		;Start assembling
00404                  	.WORD	CMD_TRACE-1		;Trace Code
00405                  	.WORD   CMD_VAL-1      		;Value command 
00406                  	.WORD	CMD_SHOWREG-1		;Display registers                	
00407  			.WORD   CMD_MEM-1      		;Memory command	
00408  			.WORD   CMD_CLS-1      		;Clrscreen command	
00409  			.WORD	CMD_USERKEYS-1		;Allows users to add more keys after @
00410  
00411  ;----------------------------------------------------------------------------------------
00412  ; Allows users to add more keys after @
00413  ;----------------------------------------------------------------------------------------
00414  
00415  00E106  6C F5 00      CMD_USERKEYS 		JMP    (USERKEYDEF) 
00416  
00417  ;----------------------------------------------------------------------------------------
00418  ;Clear the screen
00419  ;----------------------------------------------------------------------------------------
00420  
00421  00E109  4C 73 F6      CMD_CLS			JMP	CLS
00422  
00423  ;----------------------------------------------------------------------------------------
00424  00E10C  64 E8         CMD_ESC            	STZ     AUTO_FLAG       	;Clear auto flag and therefore OFF
00425  00E10E  A9 07         .CANCEL         	LDA	#BELL			;play bell
00426  00E110  20 A9 F6      			JSR	WRCHAR
00427  00E113  4C A2 F6      			JMP     WRCRLF     		;Print CRLF
00428  			
00429  ;----------------------------------------------------------------------------------------
00430  ;Intel HEX loader
00431  		
00432  		.INCLUDE	"INTELHEX.65s"
00433  ; LIBRARY FILE
00434  ; version 2.09
00435  ; two pass assembler, dissembler and tracer- inspiration with permission from A1 by San Bergmans
00436  ; REGB bits 0-3 are connected to LED's
00437  ; tested in Michael Kowalski 6502 Simulator - using 65C02 Code 
00438  ; "Programmed" by Joe DiMeglio
00439  		
00440  
00441  ;----------------------------------------------------------------------------------------
00442  ;Intel HEX loader
00443  ;----------------------------------------------------------------------------------------
00444  
00445    00DA              CHECKSUM	=	LENG		
00446  
00447  00E116  78            CMD_INTELHEX		SEI				;stop Interrupts			
00448  00E117  D8            			CLD				;binary mode additons			
00449  00E118  64 D5         			STZ	EXP_SAVE		;temp			
00450  00E11A  64 D7         			STZ	DEC_SAVE		;Bytes count
00451  00E11C  64 D8         			STZ	DEC_SAVE+1						
00452  00E11E  64 DA         			STZ	CHECKSUM		;checksum	
00453  00E120  A9 0D         			LDA	#CR			
00454  00E122  8D 00 88      			STA     ACIA			;dont wait on port status			
00455  00E125  A9 0A         			LDA	#LF			
00456  00E127  8D 00 88      			STA     ACIA			;dont wait on port status			  						
00457  00E12A  80 33                 		BRA     CONTINUE        		        		
00458          		
00459  00E12C  20 E5 F6      NEXTRECORD 		JSR 	RDCHAR
00460  00E12F  C9 0D                 		CMP     #CR        		
00461  00E131  D0 0E                 		BNE     PROTOCOLERROR        		
00462  00E133  20 E5 F6              		JSR     RDCHAR			;CRLF and end of line (BUG there's a CHECKSUM)        		
00463  00E136  C9 0A                 		CMP     #LF        		
00464  00E138  D0 07                 		BNE     PROTOCOLERROR        		
00465  00E13A  20 E5 F6              		JSR     RDCHAR        		
00466  00E13D  C9 3A                 		CMP     #':'        		
00467  00E13F  F0 1E                 		BEQ     CONTINUE        		
00468          		
00469  00E141  20 A9 F6      PROTOCOLERROR 		JSR 	WRCHAR
00470  00E144  20 15 F6              		JSR     STRING        		
00471          		.ASCII    BELL,CR,LF," :PROTOCOL ERROR",CR,LF + $80
00472  00E15C  4C 4A E2              		JMP     TERMINATE        		
00473  
00474  00E15F  20 4D E2      CONTINUE 		JSR    	READ_DATA		;read rcord length with checksum add
00475  00E162  85 CD                 		STA     COUNT			;load the amount of bytes to load into memory        		
00476  00E164  20 4D E2              		JSR     READ_DATA		;read hgh byte of memory location         		       		
00477  00E167  85 DD                 		STA     SRCE+1			;store hgh byte of memory location        		        		
00478  00E169  20 4D E2              		JSR     READ_DATA		;read low byte with checksum add			        		
00479  00E16C  85 DC                 		STA     SRCE			;store			        		        		
00480  00E16E  20 4D E2              		JSR     READ_DATA		;get record type 01 = end        		
00481          		;CMP     #$00			;check if 00 if yes then type #00        		
00482  00E171  F0 27                 		BEQ     .DATARECORD		;get the data frame        		        		
00483  00E173  C9 01                 		CMP     #$01			;is it type #01 ie: end of record        		
00484  00E175  D0 03                 		BNE     .INVREC			;else invalid        		
00485  00E177  4C 01 E2              		JMP     .END_RECORD        		
00486  
00487  00E17A  20 15 F6      .INVREC  		JSR     STRING
00488          		.ASCII    BELL,CR,LF," :INVALID RECORD TYPE",CR,LF +$80
00489  00E197  4C 4A E2              		JMP     TERMINATE
00490          		
00491  
00492  		.IF	MYWYM
00493  
00494  00E19A  A6 CD         .DATARECORD 		LDX  	COUNT			;DATASIZE
00495  00E19C  A0 00                 		LDY     #$00        		
00496  00E19E  20 4D E2      .NEXT_BYTE 		JSR   	READ_DATA		;read two hex characters
00497  00E1A1  91 DC                 		STA     (SRCE),y		;store in RAM        		
00498  00E1A3  D1 DC                 		CMP     (SRCE),y		;did it actually store			
00499  00E1A5  D0 0F                 		BNE     .WRITEERROR		;no then error - probably no ram there        		
00500  00E1A7  A9 23         			LDA	#'#'			;write fast			
00501  00E1A9  8D 00 88      			STA     ACIA			;dont wait on port status							
00502  00E1AC  C8                    		INY				;next address        		
00503  00E1AD  CA                    		DEX				;next byte to recieve        		
00504          		;CPX     #$00			;all bytes recieved?         		
00505  00E1AE  D0 EE                 		BNE     .NEXT_BYTE		;no then get next record        		
00506  00E1B0  20 4D E2              		JSR     READ_DATA		;get checksum	        
00507  
00508  		.IF	MYWYM        					
00509  00E1B3  4C 2C E1      .LEDCNT  		JMP    NEXTRECORD
00510  
00511  00E1B6  20 15 F6      .WRITEERROR 		JSR  	STRING
00512          		.ASCII   BELL,CR,LF
00513  			.ASCIS   " :CANNOT WRITE AT ADDRESS $"
00514  
00515  00E1D7  A5 DD                 		LDA	SRCE+1        		
00516  00E1D9  20 BC F6              		JSR	WR2HEX        		
00517  00E1DC  A5 DC                 		LDA	SRCE        		
00518  00E1DE  20 BC F6              		JSR	WR2HEX        		
00519  00E1E1  20 A2 F6              		JSR	WRCRLF        		        			
00520  00E1E4  80 64                 		BRA     TERMINATE	
00521  
00522  00E1E6  20 15 F6      .CHECKSUMERR        	JSR     STRING
00523          		.ASCII    BELL,LF,CR," :CHECK SUM ERROR",LF,CR  +$80       		
00524  00E1FF  80 49                 		BRA     TERMINATE        		
00525          		
00526  00E201  20 F0 F6      .END_RECORD  		JSR    	RD2HEX			;last two byes the CheckSUM
00527  00E204  18            			CLC			
00528  00E205  65 DA         			ADC	CHECKSUM			
00529  00E207  D0 DD         			BNE	.CHECKSUMERR				
00530  00E209  20 15 F6              		JSR     STRING
00531          		.ASCII  BELL,CR,LF        		
00532          		.ASCIS   " :INTEL-HEX SUCCESSFUL"        		
00533  00E225  20 15 F6              		JSR     STRING    		        		
00534          		.ASCII   CR,LF
00535          		.ASCIS   " :TOTAL BYTES WRITTEN "			
00536  00E240  A4 D7         			LDY	DEC_SAVE
00537  00E242  A5 D8         			LDA	DEC_SAVE+1
00538  00E244  20 AB E7      			JSR	WRDECI        	        		
00539  			
00540          	.IF	MYWYM        						
00541  00E247  58                    		CLI        		
00542  00E248  18                    		CLC        		
00543  00E249  60                    		RTS				;return to caller
00544          			
00545  TERMINATE  
00546  		.IF	MYWYM   
00547  00E24A  38                    		SEC        		
00548  00E24B  58                    		CLI        		
00549  00E24C  60                    		RTS 	       		        ;return to caller
00550          		
00551  ;---------------------------------------------------------------------------------
00552  00E24D  20 F0 F6      READ_DATA 		JSR   	RD2HEX			;read two hex characters & checksum
00553          		;bcs     ERRS
00554  00E250  48                    		PHA        		
00555  00E251  18                    		CLC        		
00556  00E252  65 DA                 		ADC     CHECKSUM		;add to checksum        		
00557  00E254  85 DA                 		STA     CHECKSUM        		        		
00558  00E256  18                    		CLC
00559  00E257  A5 D7                 		LDA	DEC_SAVE
00560  00E259  69 01                 		ADC	#01
00561  00E25B  85 D7                 		STA	DEC_SAVE
00562  00E25D  A5 D8                 		LDA	DEC_SAVE+1		;add the carry	
00563  00E25F  69 00                 		ADC	#00
00564  00E261  85 D8                 		STA	DEC_SAVE+1
00565  00E263  68                    		PLA        		
00566  00E264  60                    		RTS
00567          		
00568  ;ERRS    		tsx				;remove the last RTS from stack
00569  ;        		inx
00570  ;        		inx
00571  ;        		txs
00572  ;        		jsr     STRING     ;read error from RS232
00573  ;        		.ASCIS   BELL,CR,LF," :READ ERROR FROM ACIA",CR,LF
00574  ;        		BRA     TERMINATE
00575          		        			
00576          		        			
00577  
00578  ;------------------------------------------------------------------------	
00579  ;Bump Address by AC
00580  ;------------------------------------------------------------------------	
00581  
00582  00E265  18            BUMPSRCE        	CLC
00583  00E266  65 DC         			ADC     SRCE 
00584  00E268  85 DC                 		STA	SRCE  
00585  00E26A  90 02                 		BCC	.BUMPSRCE     		        	        		        		
00586  00E26C  E6 DD                 		INC     SRCE+1                 		
00587  00E26E  60            .BUMPSRCE     		RTS     		
00588          		        		
00589  ;------------------------------------------------------------------------	
00590  ;Instruction display - orginal code seems to come from MOS
00591  ;------------------------------------------------------------------------	
00592  
00593  00E26F  A8            INSTDSP			TAY   				;Save op code
00594  00E270  4A            			LSR   				;* Even/odd test
00595  00E271  90 05         			BCC 	.IEVEN
00596  00E273  6A            			ROR  				;* Test B1
00597  00E274  B0 11         			BCS 	.ERR			;XXXXXX11 instr invalid
00598  			;CMP 	#$A2	
00599  			;BEQ 	ERR			;10001001 instr invalid
00600  00E276  29 87         			AND 	#$87			;Mask 3 bits for address mode
00601  			;ORA 	#$80			;* add indexing offset
00602  00E278  4A            .IEVEN			LSR   				;* LSB into carry for
00603  00E279  AA            			TAX   				;Left/right test below
00604  00E27A  BD FD F3      			LDA 	MODE,X			;Index into address mode table
00605  00E27D  90 04         			BCC 	.RTMODE			;If carry set use LSD for
00606  00E27F  4A            			LSR   				;* print format index
00607  00E280  4A            			LSR   		
00608  00E281  4A            			LSR   				;If carry clear use MSD
00609  00E282  4A            			LSR   
00610  00E283  29 0F         .RTMODE			AND 	#$0F			;Mask for 4-bit index
00611  00E285  D0 04         			BNE 	.GETFMT			;$0 for invalid opcodes
00612  00E287  A0 FC         .ERR			LDY 	#$FC			;Substitute $FC for invalid op,
00613  00E289  A9 00         			LDA 	#$00			;set print format index to 0
00614  00E28B  AA            .GETFMT			TAX   
00615  00E28C  BD 41 F4      			LDA 	MODE2,X			;Index into print format table
00616  00E28F  85 D9         			STA 	SAVE_Y			;Save for address field format
00617  00E291  29 03         			AND 	#$03			;Mask 2-bit length.  0=1-byte
00618  00E293  85 DA         			STA 	LENG			;*  1=2-byte, 2=3 byte
00619  00E295  98            			TYA   				;* op code
00620  00E296  20 B2 F5      			JSR 	GETMNE			;Lookup the mnemonic
00621  00E299  A0 00         			LDY 	#$00
00622  00E29B  48            			PHA   				;Save mnemonic table index
00623  00E29C  B1 DC         .PROP			LDA 	(SRCE),Y
00624  00E29E  20 BC F6      			JSR 	WR2HEX
00625  00E2A1  A2 01         			LDX 	#$01
00626  00E2A3  20 31 E3      .PROPBL			JSR 	PRBL2
00627  00E2A6  C4 DA         			CPY 	LENG			;Print instr (1 to 3 bytes)
00628  00E2A8  C8            			INY   				;*  in a 12-character field
00629  00E2A9  90 F1         			BCC 	.PROP
00630  00E2AB  A2 03         			LDX 	#$03			;char count for mnemonic print
00631  00E2AD  86 E0         			STX 	PRFLAG			;So EXPMNE prints the mnemonic
00632  00E2AF  C0 04         			CPY 	#$04
00633  00E2B1  90 F0         			BCC 	.PROPBL
00634  00E2B3  68            			PLA   				;Recover mnemonic index
00635  00E2B4  AA            			TAX
00636  00E2B5  20 08 E3      			JSR 	EXPMNE			;Expand the Memonic
00637  00E2B8  20 2F E3      			JSR 	PRBLNK			;Output 3 blanks
00638  00E2BB  A4 DA         			LDY 	LENG			
00639  00E2BD  A2 06         			LDX 	#$06			;Count for 6 print format bits
00640  00E2BF  E0 03         .PPADR1			CPX 	#$03
00641  00E2C1  F0 1E         			BEQ 	.PPADR5			;If X=3 then print address val
00642  00E2C3  06 D9         .PPADR2			ASL 	SAVE_Y			;Test next print format bit
00643  00E2C5  90 0E         			BCC 	.PPADR3			;If 0 don't print
00644  00E2C7  BD 54 F4      			LDA 	CHAR1-1,X			; *  corresponding chars
00645  00E2CA  20 A9 F6      			JSR 	WRCHAR			;Output 1 or 2 chars
00646  00E2CD  BD 4E F4      			LDA 	CHAR2-1,X		;*  (If char from char2 is 0,
00647  00E2D0  F0 03         			BEQ 	.PPADR3			;*   don't output it)
00648  00E2D2  20 A9 F6      			JSR 	WRCHAR
00649  			;LDA 	UNDEF
00650  			;JSR 	WRDECI	
00651  00E2D5  CA            .PPADR3			DEX   
00652  00E2D6  D0 E7         			BNE 	.PPADR1
00653  00E2D8  86 E0         			STX 	PRFLAG			;reset flag to 0
00654  00E2DA  60            			RTS  				;Return if done 6 format bits
00655  00E2DB  88            .PPADR4			DEY
00656  00E2DC  30 E5         			BMI 	.PPADR2
00657  00E2DE  20 BC F6      			JSR 	WR2HEX			;Output 1- or 2-byte address
00658  00E2E1  A5 D9         .PPADR5			LDA 	SAVE_Y
00659  00E2E3  C9 E8         			CMP 	#$E8			;Handle rel addressing mode
00660  00E2E5  B1 DC         			LDA 	(SRCE),Y		;Special print target adr
00661  00E2E7  90 F2         			BCC 	.PPADR4			;*  (not displacement)
00662  00E2E9  20 FC E2      .RELADR			JSR 	PCADJ3			;PCL,H + DISPL + 1 to A,Y
00663  00E2EC  AA            			TAX 
00664  00E2ED  E8            			INX				;adjust  			   
00665  00E2EE  D0 01         			BNE 	PRNTYX			;*     +1 to X,Y
00666  00E2F0  C8            			INY   		
00667  00E2F1  98            PRNTYX			TYA   				;falls through
00668  
00669  ;------------------------------------------------------------------------	
00670  ;print AX as a HEX word
00671  ;------------------------------------------------------------------------	
00672  
00673  00E2F2  20 BC F6      PRNTAX			JSR	WR2HEX			;Print target adr of branch (DUPLICATE FUNCTION to WRWORDAY)
00674  00E2F5  8A            PRNTX			TXA   				; *  and return
00675  00E2F6  4C BC F6      			JMP 	WR2HEX        		
00676  
00677  
00678  ;------------------------------------------------------------------------------------------	
00679  ;PC Adjust
00680  ;------------------------------------------------------------------------------------------		
00681  
00682  00E2F9  38            PCADJ			SEC
00683  00E2FA  A5 DA         PCADJ2			LDA 	LENG			;0=1-byte, 1=2-byte, 2=3-byte
00684  00E2FC  A4 DD         PCADJ3			LDY 	SRCE+1
00685  00E2FE  AA            			TAX   				;* test displ sign (for rel
00686  00E2FF  10 01         			BPL 	.PCADJ4			;*  branch).  Extend neg
00687  00E301  88            			DEY   				;*  by decrementing PCH
00688  			;SEC				;*  by incrementin PCL
00689  			;CLC			
00690  00E302  65 DC         .PCADJ4			ADC 	SRCE
00691  00E304  90 01         			BCC 	.RTS			;PCL+LENGTH (or displ) + 1 to A
00692  00E306  C8            			INY   				;*  carry into Y (PCH)
00693  00E307  60            .RTS			RTS 
00694  
00695  ;------------------------------------------------------------------------	
00696  ; Expand Mnemic
00697  ; copy the 2 chars at R/LMNETB,X
00698  ; into LMNE and RMNE, and expand 
00699  ; into 3 chars at MNE to MNE+2
00700  ;------------------------------------------------------------------------
00701  	
00702  00E308  BD 0A F3      EXPMNE			LDA 	LMNETB,X		;Expand Mnemic
00703  00E30B  85 C8         			STA 	PARM1
00704  00E30D  BD 4C F3      			LDA 	RMNETB,X
00705  00E310  85 C9         			STA 	PARM1+1
00706  00E312  A2 00         			LDX 	#$00
00707  00E314  A9 00         .NEXT			LDA 	#$00
00708  00E316  A0 05         			LDY 	#$05
00709  00E318  06 C9         .LOOP			ASL 	PARM1+1
00710  00E31A  26 C8         			ROL 	PARM1
00711  00E31C  2A            			ROL
00712  00E31D  88            			DEY
00713  00E31E  D0 F8         			BNE 	.LOOP
00714  00E320  69 40         			ADC 	#'A'-1
00715  			;STA 	MNE,X
00716  00E322  A4 E0         			LDY 	PRFLAG
00717  00E324  F0 03         			BEQ 	.SKIP
00718  00E326  20 A9 F6      			JSR	 WRCHAR			;print the mnemonic as well
00719  00E329  E8            .SKIP			INX
00720  00E32A  E0 03         			CPX 	#$03
00721  00E32C  D0 E6         			BNE 	.NEXT
00722  00E32E  60            			RTS	
00723  			
00724  ;------------------------------------------------------------------------       		
00725  ;Print Blank Lines 
00726  ;------------------------------------------------------------------------   	
00727  
00728  00E32F  A2 03         PRBLNK			LDX 	#$03			;Blank count
00729  00E331  20 9E F6      PRBL2			JSR 	WRSPACE			;Output a blank
00730  00E334  CA            			DEX   
00731  00E335  D0 FA         			BNE 	PRBL2			;Loop until count = 0
00732  00E337  60            			RTS           		
00733  			
00734  ;------------------------------------------------------------------------
00735  ;Hunt F start end value
00736  ;------------------------------------------------------------------------ 
00737    
00738  00E338  20 DE E5      CMD_HUNT		JSR     GET_VAL    		;Fill Memory
00739  00E33B  84 DC         			STY     SRCE			;Get start address
00740  00E33D  85 DD                         	STA     SRCE+1  
00741  00E33F  E8                            	INX
00742  00E340  20 DE E5      			JSR     GET_VAL     		;FILL end address
00743  00E343  84 DE         			STY	DEST
00744  00E345  85 DF         			STA	DEST+1
00745  00E347  E8            			INX
00746  00E348  20 DE E5      			JSR     GET_VAL     		;FILL value
00747  00E34B  84 D2         			STY	CHAR
00748  			
00749  00E34D  38            			SEC				;find length add +1
00750  00E34E  A5 DE         			LDA	DEST
00751  00E350  E5 DC         			SBC	SRCE
00752  00E352  85 DA         			STA	LENG
00753  00E354  A5 DF         			LDA	DEST+1
00754  00E356  E5 DD         			SBC	SRCE+1
00755  00E358  85 DB         			STA	LENG+1
00756  00E35A  98            			TYA				;the value				
00757  			
00758  00E35B  A4 DB         			LDY	LENG+1										
00759  00E35D  F0 12         			BEQ	.partpg			;compare partpage			
00760  							
00761  00E35F  A0 00         			LDY	#00			;another way is keep y=0 and increment
00762  00E361  D1 DC         .fullpg			CMP	(SRCE),Y
00763  00E363  D0 03         			BNE	.skip1 			;probably should be write error
00764  00E365  20 C3 E3      			JSR	DISPLAY_ADDR
00765  00E368  C8            .skip1			INY	
00766  00E369  D0 F6         			BNE	.fullpg
00767  00E36B  E6 DD         			INC	SRCE+1
00768  00E36D  C6 DB         			DEC	LENG+1			;are we done
00769  00E36F  D0 F0         			BNE	.fullpg
00770  			
00771  00E371  A4 DA         .partpg			LDY	LENG			
00772  00E373  D1 DC         .loop1			CMP	(SRCE),Y
00773  00E375  D0 05         			BNE	.skip2 
00774  			;savey
00775  			;savya
00776  			;add + y to A
00777  			
00778  			;better of inc source until equals dest				;probably should be write error
00779  00E377  20 C3 E3      			JSR	DISPLAY_ADDR 
00780  00E37A  A5 D2         			LDA	CHAR			;get the value			
00781  00E37C  88            .skip2			DEY	
00782  00E37D  D0 F4         			BNE	.loop1
00783  			;STA	(SRCE),Y		;last byte
00784  00E37F  60            			RTS
00785                 	
00786                 	
00787                 	
00788                 	
00789  ;------------------------------------------------------------------------
00790  ;ASCII DUMP 
00791  ;------------------------------------------------------------------------
00792  
00793  00E380  20 E3 E6      CMD_ASCIIDUMP 		JSR     GET_EXPRES         	;Get Source aka get expression 
00794  00E383  D0 04                         	BNE	.CONT
00795  00E385  84 DC                         	STY     SRCE
00796  00E387  85 DD                         	STA     SRCE+1                   	
00797  00E389  A9 42         .CONT	        	LDA     #$42        	
00798  00E38B  85 CD                 		STA     COUNT        		
00799  00E38D  A0 14         			LDY     #$14        		
00800  00E38F  5A            .NEXTLINE 		PHY        		
00801  00E390  20 C3 E3                     		JSR	DISPLAY_ADDR        	; display address format	  	
00802  00E393  20 A5 E3              		JSR     ASCII_DUMP        	
00803  00E396  20 A2 F6              		JSR     WRCRLF        	
00804  00E399  A9 2A                 		LDA	#42
00805  00E39B  20 65 E2              		JSR	BUMPSRCE		; Add to SRCE
00806  00E39E  7A                    		PLY        	
00807  00E39F  88                    		DEY        	
00808  00E3A0  D0 ED                 		BNE     .NEXTLINE        	
00809  00E3A2  64 C6                 		STZ	ERROR			; No Error
00810  00E3A4  60                    		RTS
00811          		
00812  ;------------------------------------------------------------------------
00813  ;ASCII DUMP one line
00814  ;------------------------------------------------------------------------ 
00815  
00816  00E3A5  A9 2F         ASCII_DUMP 		LDA  	#'/'       		;ASCII DUMP - Dumps ASCII onto the screen
00817  00E3A7  20 A9 F6              		JSR     WRCHAR        	
00818  00E3AA  A0 00                 		LDY     #$00            	    	
00819  00E3AC  B1 DC         .NEXTCHAR1 		LDA   	(SRCE),y
00820  00E3AE  C9 1F                 		CMP     #$1f        		
00821  00E3B0  90 06                 		BCC     .NOTASCII        		
00822  00E3B2  C9 7F                 		CMP     #$7f        	
00823  00E3B4  B0 02                 		BCS     .NOTASCII        	
00824  00E3B6  80 02                 		BRA     .WRITE       	      	
00825  00E3B8  A9 2E         .NOTASCII 		LDA    	#'.'
00826  00E3BA  20 A9 F6      .WRITE   		JSR     WRCHAR
00827  00E3BD  C8                    		INY        	
00828  00E3BE  C4 CD                 		CPY     COUNT        	
00829  00E3C0  D0 EA                 		BNE     .NEXTCHAR1        	
00830  00E3C2  60                    		RTS 
00831        	
00832  ;------------------------------------------------------------------------       	
00833  ; display address without the $ A=MSD y=LSB
00834  ;------------------------------------------------------------------------ 
00835  
00836  00E3C3  A9 2E         DISPLAY_ADDR   		LDA     #'.'        		
00837  00E3C5  20 A9 F6              		JSR     WRCHAR        		
00838  00E3C8  A9 3A                 		LDA     #':'        		
00839  00E3CA  20 A9 F6              		JSR     WRCHAR        		
00840  00E3CD  A9 20         DISPLAY_ADDR_B 		LDA     #SP        		;basic version	
00841  00E3CF  20 A9 F6      	 		JSR     WRCHAR 
00842  00E3D2  A5 DD                 		LDA	SRCE+1
00843  00E3D4  A4 DC                 		LDY	SRCE       		
00844  00E3D6  20 D9 F6              		JSR	WRWORDAY		;print address AY	        	
00845  00E3D9  A9 20                 		lda     #SP			;TABS HERE
00846  00E3DB  20 A9 F6              		JSR     WRCHAR        		
00847  00E3DE  4C A9 F6              		JMP     WRCHAR     		;return to caller
00848  			
00849  ;------------------------------------------------------------------------
00850  ;Memory DUMP one line
00851  ;------------------------------------------------------------------------ 
00852  
00853  00E3E1  20 E3 E6      CMD_MEMORY_DUMP		JSR     GET_EXPRES     		;DUMPS MEMORY TO THE SCREEN
00854  00E3E4  D0 04         			BNE	.CONT
00855  00E3E6  84 DC         			STY     SRCE
00856  00E3E8  85 DD                         	STA     SRCE+1                 	 		        	        	
00857  00E3EA  A0 14         .CONT        		LDY     #$14			;lines to draw        
00858  00E3EC  A2 04                 		LDX	#04			;divided by 4
00859  00E3EE  5A            .NEWLINE 		PHY
00860  00E3EF  20 C3 E3              		JSR	DISPLAY_ADDR		
00861  00E3F2  A0 00                			LDY     #$00       		
00862  00E3F4  B1 DC         .DUMP    		LDA     (SRCE),y
00863  00E3F6  20 BC F6              		JSR     WR2HEX        	
00864  00E3F9  A9 20                 		LDA     #SP        	
00865  00E3FB  20 A9 F6              		JSR     WRCHAR        	
00866  00E3FE  CA                    		DEX
00867  00E3FF  D0 05                 		BNE	.SKIPSP	        	
00868  00E401  A2 04                 		LDX	#04        	
00869  00E403  20 A9 F6              		JSR     WRCHAR        	
00870  00E406  C8            .SKIPSP  		INY
00871  00E407  C0 10                 		CPY     #$10        	
00872  00E409  D0 E9                 		BNE     .DUMP        	
00873  00E40B  20 9E F6              		JSR     WRSPACE        	
00874  00E40E  84 CD                 		STY     COUNT        		
00875  00E410  20 A5 E3              		JSR     ASCII_DUMP        	
00876  00E413  20 A2 F6              		JSR     WRCRLF    
00877  00E416  A9 10                 		LDA	#$10
00878  00E418  20 65 E2              		JSR	BUMPSRCE    		;Add to SRCE	        		
00879  00E41B  7A                    		PLY       	        	
00880  00E41C  88                    		DEY        	
00881  00E41D  D0 CF                 		BNE     .NEWLINE  
00882  00E41F  64 C6                 		STZ	ERROR      	        	
00883  00E421  60                    		RTS
00884     
00885  ;------------------------------------------------------------------------
00886  ; Move a part of memory down (to delete or shorten source lines)
00887  ;
00888  ; SRCE  2       Address of source data (destroyed)
00889  ; DEST  2       Address of destination data (destroyed)
00890  ; LENG  2       Holds the number of bytes to move
00891  ;------------------------------------------------------------------------
00892  
00893  00E422  A0 00         MOV_DOWN        	LDY     #0              	;Clear index in 256 byte blocks
00894  00E424  A6 DB                         	LDX     LENG+1          	;Get number of blocks to be moved
00895  00E426  F0 0E                         	BEQ     .LAST           	;Move last (partial) block
00896  
00897  00E428  B1 DC         .LOOP1          	LDA     (SRCE),Y        	;Move this byte
00898  00E42A  91 DE                         	STA     (DEST),Y
00899  00E42C  C8                            	INY                     	;Point to next byte in block
00900  00E42D  D0 F9                         	BNE     .LOOP1          	;Block not done yet!
00901  00E42F  E6 DD                         	INC     SRCE+1          	;Point to next block
00902  00E431  E6 DF                         	INC     DEST+1
00903  00E433  CA                            	DEX                     	;Count down blocks
00904  00E434  D0 F2                         	BNE     .LOOP1          	;Not all blocs done yet!
00905  
00906  00E436  A6 DA         .LAST           	LDX     LENG            	;Count remainder of last block
00907  00E438  F0 08                         	BEQ     .EXIT           	;Oh, there is no remainder!
00908  
00909  00E43A  B1 DC         .LOOP2          	LDA     (SRCE),Y        	;Move this byte
00910  00E43C  91 DE                         	STA     (DEST),Y
00911  00E43E  C8                            	INY                     	;Point to next byte in last block
00912  00E43F  CA                            	DEX                     	;Count down the bytes
00913  00E440  D0 F8                         	BNE     .LOOP2          	;Last block not done yet!
00914  00E442  60            .EXIT           	RTS
00915  
00916  ;------------------------------------------------------------------------
00917  ; Move a part of memory up (to make room for new or longer source line)
00918  ;
00919  ; SRCE  2       Address of source data
00920  ; DEST  2       Address of destination data
00921  ; LENG  2       Holds number of bytes to move
00922  ;
00923  ;------------------------------------------------------------------------
00924  
00925  00E443  A6 DB         MOV_UP          	LDX     LENG+1          	;We have started the move at the
00926  00E445  18                            	CLC                   		;end otherwise we risk
00927  00E446  8A                            	TXA                     	;overwriting the source
00928  00E447  65 DD                         	ADC     SRCE+1
00929  00E449  85 DD                         	STA     SRCE+1          	;So add Length-High to source and
00930  00E44B  18                            	CLC                     	;destination address
00931  00E44C  8A                            	TXA
00932  00E44D  65 DF                         	ADC     DEST+1
00933  00E44F  85 DF                         	STA     DEST+1
00934  00E451  E8                            	INX                     	;Allow BNE to signal the end
00935  00E452  A4 DA                         	LDY     LENG
00936  00E454  F0 0E                         	BEQ     .PAGE           	;Only entire pages to be moved!
00937  00E456  88                            	DEY
00938  00E457  F0 07                         	BEQ     .PART           	;Move last, partial, page first!
00939  00E459  B1 DC         .LOOP1          	LDA     (SRCE),Y        	;Move one entire page
00940  00E45B  91 DE                         	STA     (DEST),Y
00941  00E45D  88                            	DEY                     	; backwards
00942  00E45E  D0 F9                         	BNE     .LOOP1          	;Page not done yet
00943  00E460  B1 DC         .PART           	LDA     (SRCE),Y        	;Move first byte of page too
00944  00E462  91 DE                         	STA     (DEST),Y
00945  00E464  88            .PAGE      	       	DEY
00946  00E465  C6 DD         	                DEC     SRCE+1          	;Decrement source and destination
00947  00E467  C6 DF                         	DEC     DEST+1
00948  00E469  CA                            	DEX
00949  00E46A  D0 ED                         	BNE     .LOOP1          	;Move all pages!
00950  00E46C  60                            	RTS
00951  
00952  ;------------------------------------------------------------------------
00953  ; Print error c=1 means its ERROR messages
00954  ;------------------------------------------------------------------------
00955  
00956  00E46D  A4 C6         PRINT_MSGS     		LDY	ERROR
00957  00E46F  D0 0B         			BNE	ERRORMSGS		;normal string		
00958  00E471  A0 57         PRINT_ERR		LDY	#<TEXT1			;Error texts
00959  00E473  84 DC         			STY	SRCE
00960  00E475  A0 E5         			LDY	#>TEXT1 
00961  00E477  84 DD         			STY	SRCE+1
00962  00E479  A8            			TAY				;index to message string
00963  00E47A  80 0F         			BRA	PRINT_SRCE
00964  		
00965  00E47C  A9 98         ERRORMSGS		LDA	#<TEXT			;noramal texts		
00966  00E47E  85 DC         			STA	SRCE
00967  00E480  A9 E4         			LDA	#>TEXT 
00968  00E482  85 DD         			STA	SRCE+1				
00969  00E484  20 8B E4      			JSR     PRINT_SRCE      	;Print 3 characters                
00970  00E487  A0 00         			LDY     #0              	;Save A
00971  00E489  84 C6                         	STY     ERROR           	;Clear the error now                                                    
00972  
00973  00E48B  B1 DC         PRINT_SRCE     		LDA     (SRCE),Y       		;Get character (also GLobal Print)			
00974  00E48D  48            			PHA	
00975  00E48E  29 7F         			AND	#%01111111			
00976  00E490  20 A9 F6                      	JSR     WRCHAR          	; and print it
00977  00E493  C8                            	INY				;check if it exceed 127
00978  00E494  68                            	PLA                
00979  00E495  10 F4                         	BPL	PRINT_SRCE      	; is bit=8 =1                   	       
00980  00E497  60                            	RTS
00981                  	
00982  ;------------------------------------------------------------------------
00983  ; Error Messages - TODO
00984  ;------------------------------------------------------------------------
00985  
00986  TEXT			.ASCII    	" ERROR",CR,LF + $80                	                
00987  PNTR_ERR_SYN		.ASCIS    	" :SYNTAX"        			;Syntax error
00988  PNTR_ERR_LBL 		.ASCIS    	" :LABEL"         			;Label error / no global 
00989  PNTR_ERR_RNG    	.ASCIS     	" :INVALID RANGE"          		;Range error
00990  PNTR_ERR_MIS    	.ASCIS     	" :MISSING PARAMETER or OPERAND"     	;Missing parameter/operand
00991  PNTR_ERR_DIV    	.ASCIS     	" :DIVIDE by 0"          		;Divide by 0 error
00992  PNTR_ERR_MEM 		.ASCIS     	" :MEMORY FULL"        			;Memory full / illegal TA 
00993  PNTR_ERR_DEF    	.ASCIS     	" :UNDEFINED LABEL"          		;Undefined label
00994  PNTR_ERR_DIR    	.ASCIS     	" :ILLEGAL DIRECTIVE"          		;Illegal directive error
00995  PNTR_ERR_OPE    	.ASCIS     	" :OPERAND"          			;Operand error
00996  PNTR_ERR_MNE    	.ASCIS     	" :MNEMONIC "          			;Mnemonic error
00997  PNTR_ERR_EXT    	.ASCIS     	" :EXTRAT DEFINATION"          		;Extra definition error
00998  PNTR_ERR_WRT    	.ASCIS     	" :UNABLE TO WRITE/READ"          	;Read/Write Error
00999  
01000  TEXT1        		.ASCIS     	"--------------------------"
01001  PNTR_AUTOTEXT		.ASCIS		"AUTONUM ENABLE starting "
01002  PNTR_ERRORS     	.ASCII     	" COMPILE ERROR(s)",CR,LF + $80
01003  PNTR_CANCEL     	.ASCIS     	"/"		
01004  PNTR_CODE_ORG  		.ASCIS     	".ORG ->"
01005  
01006  
01007    0008              ERR_SYN		=	PNTR_ERR_SYN - TEXT	
01008    0010              ERR_LBL		=	PNTR_ERR_LBL - TEXT		
01009    0017              ERR_RNG		=	PNTR_ERR_RNG - TEXT	   
01010    0026              ERR_MIS		=	PNTR_ERR_MIS - TEXT	   
01011    0044              ERR_DIV		=	PNTR_ERR_DIV - TEXT	   
01012    0051              ERR_MEM		=	PNTR_ERR_MEM - TEXT		
01013    005E              ERR_DEF		=	PNTR_ERR_DEF - TEXT	    
01014    006F              ERR_DIR		=	PNTR_ERR_DIR - TEXT	    
01015    0082              ERR_OPE		=	PNTR_ERR_OPE - TEXT	   
01016    008B              ERR_MNE		=	PNTR_ERR_MNE - TEXT	    
01017    0096              ERR_EXT		=	PNTR_ERR_EXT - TEXT	   
01018    00A9              ERR_WRT		=	PNTR_ERR_WRT - TEXT	   
01019  
01020  ;standard messages
01021  
01022    001A              AUTOTEXT	=	PNTR_AUTOTEXT  - TEXT1
01023    0032              STR_ERRORS      =     	PNTR_ERRORS  - TEXT1	
01024    0045              STR_CANCEL      =     	PNTR_CANCEL  - TEXT1
01025    0046              CODE_ORG	=	PNTR_CODE_ORG  - TEXT1
01026          
01027  ;------------------------------------------------------------------------
01028  ; Find next non space
01029  ; Z=1 if EOL found
01030  ;------------------------------------------------------------------------
01031  
01032  00E5A4  A2 00         FIRSTNONSPC     	LDX     #0              	;Start at the begin of the line
01033  00E5A6  B5 19         NNONSPC         	LDA     IN,X            	;Is this a space?
01034  00E5A8  C9 20                         	CMP     #SP
01035  00E5AA  D0 03                         	BNE     .NOSPACE        	;It is not!
01036  00E5AC  E8                            	INX
01037  00E5AD  80 F7                         	BRA     NNONSPC         	;Always taken!
01038  00E5AF  C9 0D         .NOSPACE        	CMP     #CR             	;Set Z if we're at EOL
01039  00E5B1  60                            	RTS
01040  
01041  ;------------------------------------------------------------------------
01042  ; Initialise the assembler before we can start
01043  ;------------------------------------------------------------------------
01044  
01045  00E5B2  D8            INIT            	CLD                     	;You'll never know
01046  		.IF LCD_ROUTINES		
01047                  					;Memory scan
01048  00E5B3  A5 F2         .LOOP           	LDA     HIMEM+1         	;Stop if we run into our own code (himem +1)
01049  00E5B5  C9 E0                         	CMP     #>COLD			;/COLD
01050  00E5B7  F0 18                         	BEQ     .THATSIT
01051  00E5B9  B1 F1                         	LDA     (HIMEM),Y       	;See if this memory page exists
01052  00E5BB  AA                            	TAX                     	;Save original value
01053  00E5BC  A9 55                         	LDA     #%01010101     		;Try this value first
01054  00E5BE  20 D9 E5                      	JSR     PROBE
01055  00E5C1  D0 0E                         	BNE     .THATSIT        	;End of RAM!
01056  00E5C3  A9 AA                         	LDA     #%10101010   		;Then try this value
01057  00E5C5  20 D9 E5                      	JSR     PROBE
01058  00E5C8  D0 07                         	BNE     .THATSIT        	;End of RAM!
01059  00E5CA  8A                            	TXA                     	;Restore original value
01060  00E5CB  91 F1                         	STA     (HIMEM),Y
01061  00E5CD  E6 F2                         	INC     HIMEM+1        		;Try next memory page
01062  00E5CF  10 E2                         	BPL     .LOOP           	;No need to proceed beyond $8000!
01063  00E5D1  20 EB E9      .THATSIT        	JSR	SHOWMEM
01064  00E5D4  A0 00         			LDY 	#$00			;set EOR flag to zero	
01065  00E5D6  4C D3 EA      			JMP     DONEW           	;Do new command (Y must be $00)
01066           
01067  ;------------------------------------------------------------------------
01068  ; Probe memory location
01069  ;------------------------------------------------------------------------
01070  00E5D9  91 F1         PROBE         		STA     (HIMEM),Y       	;Store this value
01071  00E5DB  D1 F1                         	CMP     (HIMEM),Y       	;See if it was accepted
01072  00E5DD  60            XEC_RTS        		RTS             
01073          
01074  ;------------------------------------------------------------------------
01075  ; Get a single 16-bit value from input line
01076  ;------------------------------------------------------------------------
01077  
01078  00E5DE  64 CC         GET_VAL         	STZ     NEG_FLAG        	;Clear negative flag
01079  00E5E0  64 CF                         	STZ     HEXVAL          	;Clear end result
01080  00E5E2  64 D0                         	STZ     HEXVAL+1
01081  00E5E4  64 CE                         	STZ     DELIM           	;Clear digit entered flag                                                              
01082  00E5E6  B5 19                         	LDA     IN,X            	;Read character from IN
01083  00E5E8  C9 2B                         	CMP     #'+'            	;Is it explicit positive?
01084  00E5EA  F0 06                         	BEQ     .POS            	;Yes!
01085  00E5EC  C9 2D                         	CMP     #'-'            	;Is it a negative number?
01086  00E5EE  D0 05                         	BNE     .NOSIGN         	;No! No prefix sign given
01087  00E5F0  85 CC                         	STA     NEG_FLAG        	;Set negative flag
01088  00E5F2  E8            .POS    	        INX                     	;Point to next byte in IN
01089  00E5F3  B5 19         	                LDA     IN,X            	; and get it
01090  
01091  00E5F5  C9 30         .NOSIGN 	        CMP     #'0'            	;Could it be a decimal number?
01092  00E5F7  90 40                         	BCC     .HEX            	;Nope!
01093  00E5F9  C9 3A                         	CMP     #'9'+1
01094  00E5FB  B0 3C                         	BCS     .HEX            	;Nope!
01095  
01096  ;------------------------------------------------------------------------
01097  ; Convert a decimal number to binary
01098  ;------------------------------------------------------------------------
01099  00E5FD  49 30         .DECLOOP  	      	EOR     #'0'            	;Strip ASCII part
01100  00E5FF  C9 0A                         	CMP     #9+1            	;Is it still a decimal digit?
01101  00E601  B0 64                         	BCS     .DONEG1         	;Nope!
01102  00E603  A8                            	TAY                     	;Save new digit
01103  00E604  06 CF                         	ASL     HEXVAL          	;Multiply previous value by 10
01104  00E606  26 D0                         	ROL     HEXVAL+1
01105  00E608  B0 60                         	BCS     .RANGE          	;Exit with range error!
01106  00E60A  A5 CF                         	LDA     HEXVAL
01107  00E60C  0A                            	ASL
01108  00E60D  85 D7                         	STA     DEC_SAVE
01109  00E60F  A5 D0                        	 	LDA     HEXVAL+1
01110  00E611  2A                            	ROL
01111  00E612  B0 56                         	BCS     .RANGE          	;Exit with range error!
01112  00E614  06 D7                         	ASL     DEC_SAVE
01113  00E616  2A                            	ROL
01114  00E617  85 D8                         	STA     DEC_SAVE+1
01115  00E619  B0 4F                         	BCS     .RANGE          	;Exit with range error!
01116  00E61B  A5 D7                         	LDA     DEC_SAVE
01117  00E61D  65 CF                         	ADC     HEXVAL
01118  00E61F  85 CF                         	STA     HEXVAL
01119  00E621  A5 D8                         	LDA     DEC_SAVE+1
01120  00E623  65 D0                         	ADC     HEXVAL+1
01121  00E625  85 D0                         	STA     HEXVAL+1
01122  00E627  B0 41                         	BCS     .RANGE          	;Exit with range error!
01123  00E629  98                            	TYA                     	;Add new digit to result
01124  00E62A  65 CF                         	ADC     HEXVAL
01125  00E62C  85 CF                         	STA     HEXVAL
01126  00E62E  90 04                         	BCC     .NOCY           	;No carry to high byte
01127  00E630  E6 D0                         	INC     HEXVAL+1
01128  00E632  F0 36                         	BEQ     .RANGE  	        ;Exit with range error!
01129  00E634  E8            .NOCY           	INX                     	;Point to next digit
01130  00E635  B5 19                         	LDA     IN,X            	; and get it
01131  00E637  80 C4                         	BRA     .DECLOOP        	;Always taken!
01132  
01133  ;------------------------------------------------------------------------
01134  ; Convert a hex number 16bit
01135  ;------------------------------------------------------------------------
01136  
01137  00E639  C9 24         .HEX            	CMP     #'$'            	;Is it a hex number?
01138  00E63B  D0 30                         	BNE     .BIN            	;Nope!
01139  
01140  00E63D  E8            .HEXLOOP        	INX                     	;Get next character from IN
01141  00E63E  B5 19                         	LDA     IN,X
01142  00E640  20 FF F6                      	JSR	HEX2BIN                
01143  00E643  C9 FF         	        	CMP	#FAIL
01144  00E645  F0 14                         	BEQ     .NOTHEX         	;No hex digit anymore!
01145  00E647  0A            .DIG            	ASL                     	;Left justify new nibble
01146  00E648  0A                            	ASL
01147  00E649  0A                            	ASL
01148  00E64A  0A                            	ASL
01149  00E64B  A0 04                         	LDY     #4              	;Set shift counter
01150  00E64D  84 CE                         	STY     DELIM           	;Indicate that input is correct
01151  00E64F  0A            .HEXSHIFT       	ASL                     	;Shift new bit into result
01152  00E650  26 CF                         	ROL     HEXVAL
01153  00E652  26 D0                         	ROL     HEXVAL+1
01154  00E654  B0 14                         	BCS     .RANGE          	;Exit with range error!
01155  00E656  88                            	DEY                     	;Decrement counter
01156  00E657  D0 F6                         	BNE     .HEXSHIFT       	;Do all 4 bits
01157  00E659  F0 E2                         	BEQ     .HEXLOOP        	;Do next nibble (if any)!
01158  
01159  00E65B  A5 CE         .NOTHEX         	LDA     DELIM           	;Was a digit entered?
01160  00E65D  D0 08                         	BNE     .DONEG1         	;Yes!
01161  00E65F  A5 BC                         	LDA     PC_BEG         	 	;If not it was the PC value!
01162  00E661  85 CF                         	STA     HEXVAL
01163  00E663  A5 BD                         	LDA     PC_BEG+1
01164  00E665  85 D0                         	STA     HEXVAL+1
01165  00E667  4C BD E6      .DONEG1         	JMP     .DONEG          	;Check negative flag & we're done
01166  00E66A  4C 38 F2      .RANGE          	JMP     RANGE_ERROR     	;Exit with range error
01167  
01168  ;------------------------------------------------------------------------
01169  ; Convert ASCII a binary number eg %..1.01.. 
01170  ;------------------------------------------------------------------------
01171  
01172  00E66D  C9 25         .BIN            	CMP     #'%'            	;Is it a binary number?
01173  00E66F  D0 38                         	BNE     .PASC           	;Nope!
01174  00E671  E8            .BINLOOP        	INX                     	;Point to next char
01175  00E672  B5 19                         	LDA     IN,X            	; and get it
01176  00E674  C9 2E                         	CMP     #'.'            	;Ignore dots (for human eyes only)
01177  00E676  F0 F9                         	BEQ     .BINLOOP
01178  00E678  49 30                         	EOR     #'0'            	;Ignore ASCII part
01179  00E67A  4A                            	LSR                     	;Shift bit to Carry
01180  00E67B  D0 0A                         	BNE     .EXIT           	;End of binary number
01181  00E67D  26 CF                         	ROL     HEXVAL          	;Roll new bit into end result
01182  00E67F  26 D0                         	ROL     HEXVAL+1
01183  00E681  B0 E7                         	BCS     .RANGE          	;Range error!
01184  00E683  E6 CE                         	INC     DELIM           	;Signal that bits were entered
01185  00E685  80 EA                         	BRA     .BINLOOP        	;Always taken! (reasonably)
01186  
01187  00E687  A5 CE         .EXIT           	LDA     DELIM           	;Was a number entered?
01188  00E689  D0 32                         	BNE     .DONEG          	;Yes! Check negative flag now
01189  00E68B  4C 93 EF                      	JMP     DIR_OPE         	;Exit with operand error
01190  
01191  ;------------------------------------------------------------------------
01192  ; Now it must be a label!
01193  ;------------------------------------------------------------------------
01194  
01195  00E68E  20 BB F0      .LABEL          	JSR     FIND_LABEL      	;Find this label
01196  00E691  B0 13                         	BCS     .OPE_ERROR      	;Exit with operand error!
01197  00E693  F0 09                         	BEQ     .NOT_FOUND      	;Label not found!
01198  00E695  A5 B2                         	LDA     LABEL_FLAG      	;Copy assigned flag to
01199  00E697  05 C0                         	ORA     FORWARD         	; forward referenced flag
01200  00E699  85 C0                         	STA     FORWARD
01201  00E69B  4C BD E6      .LBL_EXIT       	JMP     .DONEG          	;Check negative flag & we're done
01202  
01203  00E69E  85 CF         .NOT_FOUND      	STA     HEXVAL          	;A=0, clear hex val
01204  00E6A0  85 D0                         	STA     HEXVAL+1
01205  00E6A2  C6 BF                         	DEC     UNDEF           	;Set undefined label flag
01206  00E6A4  D0 F5                         	BNE     .LBL_EXIT       	;Always taken!
01207  
01208  ;------------------------------------------------------------------------
01209  ; It's none of the above! Operand error
01210  ;------------------------------------------------------------------------
01211  
01212  00E6A6  4C 93 EF      .OPE_ERROR      	JMP     DIR_OPE         	;Exit with operand error
01213  
01214  ;------------------------------------------------------------------------
01215  ; Convert a positive ASCII
01216  ;------------------------------------------------------------------------
01217  
01218  00E6A9  C9 27         .PASC           	CMP     #'''            	;Is it a positive ASCII?
01219  00E6AB  D0 07         	                BNE     .NASC           	;Nope!
01220  
01221  00E6AD  20 CD E6              	        JSR     .GETASC         	;Get ASCII character
01222  00E6B0  29 7F         	                AND     #%01111111     		;Make it positive
01223  00E6B2  10 07                         	BPL     .ASC_END        	;Always taken!
01224  
01225  ;------------------------------------------------------------------------
01226  ; Convert a negative ASCII
01227  ;------------------------------------------------------------------------
01228  
01229  00E6B4  C9 27         .NASC           	CMP     #'''            	;Is it negative ASCII?
01230  00E6B6  D0 D6                         	BNE     .LABEL          	;Nope!
01231  00E6B8  20 CD E6                      	JSR     .GETASC         	;Get ASCII character
01232  00E6BB  85 CF         .ASC_END        	STA     HEXVAL          	;And save it
01233  							;Falls through to .DONEG
01234  
01235  ;------------------------------------------------------------------------
01236  ; Check negative flag and we're done
01237  ;------------------------------------------------------------------------
01238  00E6BD  A5 CC         .DONEG         		LDA     NEG_FLAG        	;Is the negative flag set?
01239  00E6BF  F0 03                         	BEQ     .RTS            	;Nope!
01240  00E6C1  20 35 E8                      	JSR     NEGATE          	;Make hexval negative;
01241  
01242  00E6C4  A5 C6         .RTS   	         	LDA     ERROR           	;Set error flag upon exit
01243  00E6C6  08                            	PHP                     	;Save status
01244  00E6C7  A5 D0                         	LDA     HEXVAL+1        	;Preload new value
01245  00E6C9  A4 CF                         	LDY     HEXVAL
01246  00E6CB  28                            	PLP                     	;Restore status
01247  00E6CC  60                            	RTS
01248  
01249  ;------------------------------------------------------------------------
01250  ;Get input until delimiter
01251  ;------------------------------------------------------------------------
01252  
01253  00E6CD  85 CE         .GETASC         	STA     DELIM           	;Save delimiter char ( ' or ' )
01254  00E6CF  E8                            	INX                     	;Point to actual ASCII character
01255  00E6D0  B5 19                         	LDA     IN,X            	; and get it
01256  00E6D2  C9 0D                         	CMP     #CR             	;Replace CR by a space
01257  00E6D4  D0 02                         	BNE     .NOTCR         	 	;Don't bother!
01258  00E6D6  A9 20                         	LDA     #SP
01259  00E6D8  A8            .NOTCR          	TAY                     	;Temporarily save character
01260  00E6D9  E8                            	INX                     	;See if ASCII is terminated by
01261  00E6DA  B5 19                         	LDA     IN,X            	; delimiter
01262  00E6DC  C5 CE                         	CMP     DELIM
01263  00E6DE  D0 01                         	BNE     .DELIM          	;No, don't bother to increment
01264  00E6E0  E8                            	INX                     	; pointer once more
01265  00E6E1  98            .DELIM          	TYA                     	;Get character back
01266  00E6E2  60                            	RTS
01267  
01268  ;------------------------------------------------------------------------
01269  ; Get expression
01270  ;------------------------------------------------------------------------
01271  
01272  00E6E3  20 DE E5      GET_EXPRES      	JSR     GET_VAL         	;Get value A=hi Y=lo address
01273  00E6E6  D0 1E                         	BNE     .RTS            	;An error occurred!
01274  
01275  00E6E8  85 D6         .NEXT           	STA     EXP_SAVE+1      	;Save this value for later
01276  00E6EA  84 D5                         	STY     EXP_SAVE
01277  00E6EC  B5 19                         	LDA     IN,X            	;Did an operator follow the value?
01278  00E6EE  E8                            	INX
01279  00E6EF  C9 2B                         	CMP     #'+'
01280  00E6F1  F0 14                         	BEQ     .ADD            	;Addition!
01281  00E6F3  C9 2D                         	CMP     #'-'
01282  00E6F5  F0 26                         	BEQ     .SUB            	;Subtraction!
01283  00E6F7  C9 2A                         	CMP     #'*'
01284  00E6F9  F0 38                         	BEQ     .MUL            	;Multiplication!
01285  00E6FB  C9 2F                         	CMP     #'/'
01286  00E6FD  F0 63                         	BEQ     .DIV            	;Division!
01287  00E6FF  CA                            	DEX                     	;End of expression. One too far
01288  00E700  A5 D0                         	LDA     HEXVAL+1        	;Load value now
01289  00E702  A4 CF                         	LDY     HEXVAL
01290  00E704  C4 CF                         	CPY     HEXVAL          	;Make Z=0 (No errors)
01291  00E706  60            .RTS            	RTS                     	;None of the above! We're done!
01292  
01293  00E707  20 DE E5      .ADD           	 	JSR     GET_VAL         	;Get next value
01294  00E70A  D0 FA                         	BNE     .RTS            	;An error occurred!
01295  00E70C  18                            	CLC                     	;Perform add function
01296  00E70D  A5 CF                         	LDA     HEXVAL
01297  00E70F  65 D5                         	ADC     EXP_SAVE
01298  00E711  85 CF                         	STA     HEXVAL
01299  00E713  A8                            	TAY
01300  00E714  A5 D0                         	LDA     HEXVAL+1
01301  00E716  65 D6                         	ADC     EXP_SAVE+1
01302  00E718  85 D0                         	STA     HEXVAL+1
01303  00E71A  4C E8 E6                      	JMP     .NEXT           	;More operands can follow
01304  
01305  00E71D  20 DE E5      .SUB            	JSR     GET_VAL         	;Get next value
01306  00E720  D0 E4                         	BNE     .RTS            	;An error occurred!
01307  00E722  38                            	SEC                     	;Perform subtract function
01308  00E723  A5 D5                         	LDA     EXP_SAVE
01309  00E725  E5 CF                         	SBC     HEXVAL
01310  00E727  85 CF                         	STA     HEXVAL
01311  00E729  A8                            	TAY
01312  00E72A  A5 D6                         	LDA     EXP_SAVE+1
01313  00E72C  E5 D0                         	SBC     HEXVAL+1
01314  00E72E  85 D0                         	STA     HEXVAL+1
01315  00E730  4C E8 E6                      	JMP     .NEXT           	;More operands can follow!
01316  
01317  00E733  20 DE E5      .MUL            	JSR     GET_VAL         	;Get next value
01318  00E736  D0 CE                         	BNE     .RTS            	;An error occurred!
01319  
01320  00E738  64 D3                         	STZ     MULDIV          	;Clear temp result
01321  00E73A  64 D4                         	STZ     MULDIV+1
01322  00E73C  A0 10                         	LDY     #16             	;Do 16-bit multiply
01323  
01324  00E73E  A5 CF         .MULLOOP        	LDA     HEXVAL          	;Get LSB of operand 2 in carry
01325  00E740  4A                            	LSR
01326  00E741  90 0D                         	BCC     .MULZERO        	;Multiply by 0! Forget about it
01327  00E743  18                            	CLC                     	;Add shifted operand 1 to temp
01328  00E744  A5 D3                         	LDA     MULDIV
01329  00E746  65 D5                         	ADC     EXP_SAVE
01330  00E748  85 D3                         	STA     MULDIV
01331  00E74A  A5 D4                         	LDA     MULDIV+1
01332  00E74C  65 D6                         	ADC     EXP_SAVE+1
01333  00E74E  85 D4                         	STA     MULDIV+1
01334  00E750  66 D4         .MULZERO        	ROR     MULDIV+1        	;Roll temp result bit into
01335  00E752  66 D3                         	ROR     MULDIV          	; end result
01336  00E754  66 D0                         	ROR     HEXVAL+1
01337  00E756  66 CF                         	ROR     HEXVAL
01338  00E758  88                            	DEY
01339  00E759  D0 E3                         	BNE     .MULLOOP        	;Do all 16 bits!
01340  	
01341  00E75B  A4 CF                 	        LDY     HEXVAL          	;Preload the value
01342  00E75D  A5 D0         	                LDA     HEXVAL+1
01343  00E75F  4C E8 E6                      	JMP     .NEXT           	;More operands can follow!
01344  
01345  00E762  20 DE E5      .DIV            	JSR     GET_VAL         	;Get next value
01346  00E765  D0 9F                         	BNE     .RTS            	;An error occurred
01347  00E767  A5 CF                         	LDA     HEXVAL          	;Avoid divide by 0
01348  00E769  05 D0                         	ORA     HEXVAL+1
01349  00E76B  F0 31                         	BEQ     .DIVERR         	;It is divide by 0!
01350  
01351  00E76D  64 D3                      		STZ     MULDIV          	;Clear temp result
01352  00E76F  64 D4                         	STZ     MULDIV+1           
01353  00E771  A0 10                         	LDY     #16             	;Do 16-bit multiply
01354  
01355  00E773  06 D5         .DIVLOOP        	ASL     EXP_SAVE        	;Roll 1 bit out of operand 1
01356  00E775  26 D6                         	ROL     EXP_SAVE+1
01357  00E777  26 D3                         	ROL     MULDIV
01358  00E779  26 D4                         	ROL     MULDIV+1
01359  00E77B  38                            	SEC                     	;Does operand 2 go into temp?
01360  00E77C  A5 D3                         	LDA     MULDIV
01361  00E77E  E5 CF                         	SBC     HEXVAL
01362  00E780  48                            	PHA                     	;Don't save temp yet
01363  00E781  A5 D4                         	LDA     MULDIV+1
01364  00E783  E5 D0                         	SBC     HEXVAL+1
01365  00E785  90 08                         	BCC     .DIVSKIP        	;It didn't go!
01366  00E787  E6 D5                         	INC     EXP_SAVE        	;Set low bit of result
01367  00E789  85 D4                         	STA     MULDIV+1        	;Save new temp result
01368  00E78B  68                            	PLA                     	;Save low byte too without
01369  00E78C  48                            	PHA                     	; affecting the stack
01370  00E78D  85 D3                         	STA     MULDIV
01371  00E78F  68            .DIVSKIP        	PLA                     	;Clear stack
01372  00E790  88                            	DEY
01373  00E791  D0 E0                         	BNE     .DIVLOOP       	 	;Do all 16 bits!
01374  
01375  00E793  A4 D5         	                LDY     EXP_SAVE        	;Preload the value
01376  00E795  84 CF                         	STY     HEXVAL
01377  00E797  A5 D6                         	LDA     EXP_SAVE+1
01378  00E799  85 D0                         	STA     HEXVAL+1
01379  00E79B  4C E8 E6      .NEXT_STEP      	JMP     .NEXT           	;More operands can follow!
01380  
01381  00E79E  A5 AD         .DIVERR         	LDA     PASS            	;Ignore div 0 during pass 1
01382  00E7A0  F0 F9                         	BEQ     .NEXT_STEP      	;It is pass 0!
01383  00E7A2  A9 44                         	LDA     #ERR_DIV        	;Exit with divide by 0 error
01384  00E7A4  85 C6                         	STA     ERROR
01385  00E7A6  60                            	RTS
01386  
01387  ;------------------------------------------------------------------------
01388  ; Print decimal number and/or write value to IN,X 
01389  ; HEXVAL  holds the value to be printed 16bit wide
01390  ;------------------------------------------------------------------------
01391  
01392  00E7A7  A4 CF         PRDECI_HEXVAL   	LDY     HEXVAL          	;Copy value to work registers
01393  00E7A9  A5 D0         			LDA	HEXVAL+1
01394  
01395  ;------------------------------------------------------------------------
01396  ; Print decimal number and/or write value to IN,X 
01397  ; A & Y  holds the value to be printed 16bit wide
01398  ;------------------------------------------------------------------------
01399  		
01400  00E7AB  84 D5         WRDECI         		STY     EXP_SAVE        	;       	
01401  00E7AD  85 D6                         	STA     EXP_SAVE+1
01402  00E7AF  A0 04                         	LDY     #4              	;A maximum of 5 decades and 4
01403  00E7B1  64 D1                         	STZ     LEAD0           	; leading zeroes
01404  
01405  00E7B3  A9 30         .DECLOOP        	LDA     #'0'            	;Start with 0
01406  00E7B5  85 D2                         	STA     CHAR
01407  00E7B7  A5 D5         .LOOP           	LDA     EXP_SAVE        	;Try to subtract decade from
01408  00E7B9  D9 EE E7                      	CMP     .DECIL,Y        	; value
01409  00E7BC  A5 D6                         	LDA     EXP_SAVE+1
01410  00E7BE  F9 F3 E7                      	SBC     .DECIH,Y
01411  00E7C1  90 0D                         	BCC     .DONE           	;Didn't go! Done this decade
01412  00E7C3  85 D6                         	STA     EXP_SAVE+1      	;Save new intermediate result
01413  00E7C5  A5 D5                         	LDA     EXP_SAVE
01414  00E7C7  F9 EE E7                      	SBC     .DECIL,Y
01415  00E7CA  85 D5                         	STA     EXP_SAVE
01416  00E7CC  E6 D2                         	INC     CHAR            	;Increment counter
01417  00E7CE  D0 E7                         	BNE     .LOOP
01418  
01419  00E7D0  A5 D2         .DONE           	LDA     CHAR            	;Get decade character
01420  00E7D2  C8                            	INY                     	;Last digit?
01421  00E7D3  88                            	DEY
01422  00E7D4  F0 0A                         	BEQ     .PRINT          	;Yes! Simply print it
01423  00E7D6  C9 30                         	CMP     #'0'            	;Is it a 0?
01424  00E7D8  F0 02                         	BEQ     .LEAD0          	;Yep!
01425  00E7DA  C6 D1                         	DEC    	LEAD0          		;B7=1, no more leading zeroes
01426  00E7DC  24 D1         .LEAD0          	BIT     LEAD0           	;Still leading zeroes?
01427  00E7DE  10 0A                         	BPL     .NEXT           	;Yes! Skip them
01428  
01429  00E7E0  20 A9 F6      .PRINT          	JSR     WRCHAR          	;Print character
01430  00E7E3  24 E8                         	BIT     AUTO_FLAG       	;Auto line number?
01431  00E7E5  10 03                         	BPL     .NEXT           	;Nope!
01432  00E7E7  95 19                         	STA     IN,X            	;Save character in input line
01433  00E7E9  E8                            	INX
01434  00E7EA  88            .NEXT           	DEY                     	;Do all 5 digits (except the LSD)
01435  00E7EB  10 C6                         	BPL     .DECLOOP        	;Not done them all yet!
01436  00E7ED  60                            	RTS
01437  
01438  .DECIL          .BYTE     $01,$0a,$64,$e8,$10
01439  .DECIH          .BYTE     $00,$00,$00,$03,$27
01440  
01441  ;------------------------------------------------------------------------
01442  ; Check object if code was generated
01443  ;------------------------------------------------------------------------
01444  
01445  00E7F8  18            CHECK_OBJ       	CLC
01446  00E7F9  A5 B8         			LDA     TA              	;See if code was generated
01447  00E7FB  45 BA                         	EOR     TA_BEGIN
01448  00E7FD  F0 02                         	BEQ	.NOK			;no code 		
01449  00E7FF  80 06                         	BRA	.CODE
01450                   		
01451  00E801  A5 B9         .NOK 			LDA     TA+1			;what about high byte	
01452  00E803  45 BB                         	EOR     TA_BEGIN+1
01453  00E805  F0 01                         	BEQ     .CHECK_OBJ_RTS  	; No code!                           
01454  00E807  38            .CODE	        	SEC	        
01455  00E808  60            .CHECK_OBJ_RTS		RTS
01456  
01457  ;------------------------------------------------------------------------
01458  ; Print object range
01459  ;------------------------------------------------------------------------
01460  
01461  00E809  A5 B8         PRINT_OBJ      		LDA     TA            	  	;See if code was generated
01462  00E80B  45 BA                         	EOR     TA_BEGIN
01463  00E80D  D0 06                         	BNE	.OK			;no code 
01464  00E80F  A5 B9                         	LDA     TA+1
01465  00E811  45 BB                         	EOR     TA_BEGIN+1
01466  00E813  F0 1F                         	BEQ     .PRINT_OBJ_RTS  	;No code!
01467                  
01468  00E815  A9 46         .OK             	LDA 	#CODE_ORG
01469  00E817  20 6D E4      			JSR	PRINT_MSGS
01470  		
01471  00E81A  A4 BA         			LDY     TA_BEGIN        	;First print begin address
01472  00E81C  A5 BB                         	LDA     TA_BEGIN+1
01473  00E81E  20 D2 F6                      	JSR     WRWORD 
01474  00E821  20 8F F6                      	JSR     WRDOT
01475  00E824  38                            	SEC                     	;Then print end address
01476  00E825  A5 B9                         	LDA     TA+1            	; (but this time one less)
01477  00E827  A4 B8                         	LDY     TA
01478  00E829  D0 02                         	BNE     .NOBOR          	;No borrow from high byte
01479  00E82B  E9 01                         	SBC     #1
01480  00E82D  88            .NOBOR          	DEY                     	;Decrement low byte
01481  00E82E  20 D2 F6                      	JSR     WRWORD 
01482  00E831  4C A2 F6                      	JMP     WRCRLF           	;Followed by CR
01483  00E834  60            .PRINT_OBJ_RTS		RTS
01484  
01485  ;------------------------------------------------------------------------
01486  ; Make HEXVAL negative
01487  ;------------------------------------------------------------------------
01488  
01489  00E835  A5 CF         NEGATE          	LDA     HEXVAL          	;Negate value
01490  00E837  49 FF                         	EOR     #$FF
01491  00E839  85 CF                         	STA     HEXVAL
01492  00E83B  A5 D0                         	LDA     HEXVAL+1
01493  00E83D  49 FF                         	EOR     #$FF
01494  00E83F  E6 CF                         	INC     HEXVAL
01495  00E841  D0 00                         	BNE     .RTS            	;No carry to high byte!
01496   	        	;INC             		;?????????????? 
01497  00E843  85 D0         .RTS            	STA     HEXVAL+1
01498  00E845  60                            	RTS
01499  
01500  ;------------------------------------------------------------------------
01501  ; Commands file
01502  ;------------------------------------------------------------------------
01503  
01504  ;------------------------------------------------------------------------
01505  ; Auto line numbering
01506  ; Increment is done once line is accepted
01507  ;------------------------------------------------------------------------
01508  
01509  00E846  24 E8         AUTONUM         	BIT     AUTO_FLAG       	;Is auto line number enabled?
01510  00E848  10 11                         	BPL     .RTS            	;Nope!
01511  00E84A  A5 E5                         	LDA     AUTO            	;Setup next line number
01512  00E84C  85 CF                         	STA     HEXVAL
01513  00E84E  A5 E6                         	LDA     AUTO+1
01514  00E850  85 D0                         	STA     HEXVAL+1
01515  00E852  20 A7 E7                      	JSR     PRDECI_HEXVAL 		;Print decimal value
01516  00E855  20 9E F6                      	JSR     WRSPACE         	;Followed by a space
01517  00E858  95 19                         	STA     IN,X
01518  00E85A  E8                            	INX
01519  00E85B  60            .RTS            	RTS
01520  
01521  ;------------------------------------------------------------------------
01522  ; Auto command
01523  ;------------------------------------------------------------------------
01524  
01525  00E85C  F0 2F         CMD_AUT       		BEQ     SET            		;Nope!
01526  00E85E  C9 2C         	                CMP     #','           	 	;Is line number given?
01527  00E860  F0 1E         	                BEQ     .INC            	;Nope!
01528  00E862  20 DE E5      	                JSR     GET_VAL         	;Get the line number value
01529  00E865  D0 28         	                BNE     _RTS            	;An error occurred!
01530  00E867  84 E5         	                STY     AUTO            	;Save new value
01531  00E869  85 E6         	                STA     AUTO+1
01532  00E86B  A9 1A         	                LDA	#AUTOTEXT
01533  00E86D  20 6D E4      	                JSR	PRINT_MSGS
01534  00E870  A4 E5         	                LDY	AUTO
01535  00E872  A5 E6         	                LDA	AUTO+1
01536  00E874  20 AB E7      	                JSR	WRDECI 	
01537  00E877  20 AD F6      			JSR	DRAWLINE		;draw line                                
01538  	                
01539  00E87A  B5 19         	                LDA     IN,X            	;Does the increment follow?
01540  00E87C  C9 2C         	                CMP     #','
01541  00E87E  D0 0D         	                BNE     SET             	;Nope!
01542  	
01543  00E880  E8            .INC            	INX
01544  00E881  20 DE E5      	                JSR     GET_VAL         	;Get the increment value
01545  00E884  D0 09         	                BNE     _RTS            	;An error occurred!
01546  00E886  C0 00         	                CPY     #0              	;Inc of 0 not allowed
01547  00E888  D0 01         	                BNE     .NOT0           	;It is not 0!
01548  00E88A  C8                            	INY                     	;Zero was not allowed
01549  00E88B  84 E7         .NOT0           	STY     AUTO_INC        	;Save increment
01550  00E88D  C6 E8         SET            		DEC     AUTO_FLAG       	;Make b7=1 (It was 0 before!)
01551  		
01552  00E88F  60            _RTS            	RTS
01553  
01554  ;------------------------------------------------------------------------
01555  ; Copy command
01556  ;------------------------------------------------------------------------
01557  
01558  00E890  84 BF         CMD_COP         	STY     UNDEF           	;Clear undefined label flag
01559  00E892  20 C5 E8      	                JSR     .GETVAL         	;Get Source
01560  00E895  F0 58         	                BEQ     ERROR_MISSING   	;Missing parameter!
01561  00E897  84 DC         	                STY     SRCE
01562  00E899  A5 D0         	                LDA     HEXVAL+1
01563  00E89B  85 DD         	                STA     SRCE+1
01564  00E89D  20 C5 E8      	                JSR     .GETVAL         	;Get Destination
01565  00E8A0  F0 4D         	                BEQ     ERROR_MISSING   	;Missing parameter!
01566  00E8A2  84 DE         	                STY     DEST
01567  00E8A4  A5 D0         	                LDA     HEXVAL+1
01568  00E8A6  85 DF         	                STA     DEST+1
01569  00E8A8  20 C5 E8      	                JSR     .GETVAL         	;Get length
01570  00E8AB  84 DA         	                STY     LENG
01571  00E8AD  A5 D0         	                LDA     HEXVAL+1
01572  00E8AF  85 DB         	                STA     LENG+1
01573  00E8B1  05 DA         	                ORA     LENG
01574  00E8B3  F0 29         	                BEQ     .RTS            	;Length is 0! We're done
01575  	
01576  00E8B5  A5 DC         	                LDA     SRCE            	;Copy up or down?
01577  00E8B7  C5 DE         	                CMP     DEST
01578  00E8B9  A5 DD         	                LDA     SRCE+1
01579  00E8BB  E5 DF         	                SBC     DEST+1
01580  00E8BD  90 03         	                BCC     .MOVEUP         	;Move up!
01581  00E8BF  4C 22 E4      	                JMP     MOV_DOWN        	;Move memory block down
01582  
01583  00E8C2  4C 43 E4      .MOVEUP         	JMP     MOV_UP          	;Move memory block up
01584  
01585  00E8C5  20 A6 E5      .GETVAL         	JSR     NNONSPC         	;See if end of line
01586  00E8C8  F0 15         	                BEQ     .MIS            	;Yes!
01587  00E8CA  20 E3 E6      	                JSR     GET_EXPRES      	;Get value
01588  00E8CD  D0 18         	                BNE     _ERROR          	;An error occurred
01589  00E8CF  A5 BF         	                LDA     UNDEF           	;Undefined label used?
01590  00E8D1  D0 10         	                BNE     .UNDEF          	;Yes!
01591  00E8D3  B5 19         	                LDA     IN,X
01592  00E8D5  C9 0D         	                CMP     #CR             	;End of line?
01593  00E8D7  F0 05         	                BEQ     .RTS            	;Yes! Z=1 now!
01594  00E8D9  C9 2C         	                CMP     #','            	;Must be a comma now
01595  00E8DB  D0 02         	                BNE     .MIS            	;It's not!
01596  00E8DD  E8            	                INX                     	;Z=0 now!
01597  00E8DE  60            .RTS            	RTS
01598  
01599  00E8DF  A9 26         .MIS            	LDA     #ERR_MIS        	;Exit with missing error
01600  00E8E1  D0 02                         	BNE     .SKIP           	;Always taken
01601  
01602  00E8E3  A9 5E         .UNDEF          	LDA     #ERR_DEF        	;Exit with undefined label
01603  00E8E5  85 C6         .SKIP          		STA     ERROR
01604  00E8E7  68            _ERROR          	PLA                     	;Pull return address from stack
01605  00E8E8  68                            	PLA
01606  00E8E9  60                            	RTS
01607  
01608  
01609  ;------------------------------------------------------------------------
01610  ; Erase command - erase  line from editer
01611  ;------------------------------------------------------------------------
01612  
01613  00E8EA  20 37 E9      CMD_ERASE         	JSR     BEG_END         	;Get begin and end line parameters
01614  00E8ED  B0 05                         	BCS     DELETE          	;Parameters given! Do delete
01615  
01616  00E8EF  A9 26         ERROR_MISSING   	LDA     #ERR_MIS        	;Exit with missing parameter
01617  00E8F1  85 C6                         	STA     ERROR
01618  00E8F3  60            ERASE_RTS         	RTS
01619        	
01620                  	
01621                  	
01622  
01623  ;------------------------------------------------------------------------
01624  ; Delete block of lines
01625  ;------------------------------------------------------------------------
01626  
01627  00E8F4  A5 CA         DELETE         		LDA     PARM2           	;Don't delete anything if
01628  00E8F6  C5 C8         	                CMP     PARM1           	; begin > end
01629  00E8F8  A5 CB         	                LDA     PARM2+1
01630  00E8FA  E5 C9         	                SBC     PARM1+1
01631  00E8FC  90 F5         	                BCC     ERASE_RTS         	;Begin is indeed > end!
01632  	
01633  00E8FE  A0 C8         	                LDY     #PARM1          	;Find this line number
01634  00E900  20 90 ED      	                JSR     FIND_LINE
01635  00E903  90 EE         	                BCC     ERASE_RTS         	;EOF reached! Line not found
01636  	
01637  00E905  A5 B3         	                LDA     PNTR            	;Current pointer is going to be
01638  00E907  85 DE         	                STA     DEST            	; the move's destination anyway
01639  00E909  A5 B4         	                LDA     PNTR+1
01640  00E90B  85 DF         	                STA     DEST+1
01641  
01642  00E90D  A0 01         .LOOP           	LDY     #1              	;See if we're already past end
01643  00E90F  A5 CA         	                LDA     PARM2
01644  00E911  D1 B3         	                CMP     (PNTR),Y
01645  00E913  C8            	                INY
01646  00E914  A5 CB         	                LDA     PARM2+1
01647  00E916  F1 B3         	                SBC     (PNTR),Y
01648  00E918  90 05         	                BCC     .FOUNDEND       	;Yes!
01649  00E91A  20 BB ED      	                JSR     NEXT_LINE       	;Find next line
01650  00E91D  D0 EE         	                BNE     .LOOP           	;Do until end line found!
01651  
01652  00E91F  A5 B3         .FOUNDEND       	LDA     PNTR            	;This pointer is going to be
01653  00E921  85 DC         	                STA     SRCE            	; the source
01654  00E923  45 DE         	                EOR     DEST            	;And see if source and dest are
01655  00E925  85 CD         	                STA     COUNT           	; the same
01656  00E927  A5 B4         	                LDA     PNTR+1
01657  00E929  85 DD         	                STA     SRCE+1
01658  00E92B  45 DF         	                EOR     DEST+1
01659  00E92D  05 CD         	                ORA     COUNT
01660  00E92F  F0 C2         	                BEQ     ERASE_RTS         	;They are the same! Why bother
01661  00E931  20 5B ED      	                JSR     CALC_LENG       	;Calculate number of bytes to move
01662  00E934  4C 22 E4      	                JMP     MOV_DOWN        	;Move from next line to end down
01663  
01664  ;------------------------------------------------------------------------
01665  ; Get begin and end line number from user
01666  ;------------------------------------------------------------------------
01667  
01668  00E937  84 C7         BEG_END         	STY     DUMP            	;Disable dump mode
01669  00E939  84 C8         	                STY     PARM1           	;Set default begin and end lines
01670  00E93B  84 C9         	                STY     PARM1+1         	; Y=0
01671  00E93D  88            	                DEY
01672  00E93E  84 CA         	                STY     PARM2
01673  00E940  84 CB         	                STY     PARM2+1
01674  00E942  20 A6 E5      	                JSR     NNONSPC         	;Are there any parameters?
01675  00E945  F0 2E         	                BEQ     .NOPARM         	;No parameters given!
01676  00E947  C9 44         	                CMP     #'D'            	;Dump mode?
01677  00E949  F0 28         	                BEQ     .DUMP           	;Yes!
01678  		
01679  00E94B  C9 2C         	                CMP     #','            	;Is begin line given?
01680  00E94D  F0 17         	                BEQ     .ENDLIN        		;Nope!
01681  00E94F  20 DE E5      	                JSR     GET_VAL         	;Get begin line number
01682  00E952  D0 1C         	                BNE     .ERRORLB        	;An error occurred
01683  00E954  84 C8         	                STY     PARM1           	;Save begin line number
01684  00E956  85 C9         	                STA     PARM1+1
01685  	
01686  00E958  B5 19         	                LDA     IN,X           	 	;Does the end line number follow?
01687  00E95A  C9 2C         	                CMP     #','
01688  00E95C  F0 08         	                BEQ     .ENDLIN         	;Yes! Get it
01689  00E95E  A5 D0         	                LDA     HEXVAL+1        	;If not make begin = end
01690  00E960  85 CB         .SAVE_DONE      	STA     PARM2+1
01691  00E962  84 CA                         	STY     PARM2
01692  00E964  38            .DONE           	SEC                     	;Indicate parameter given
01693  00E965  60                            	RTS
01694  
01695  00E966  20 32 EC      .ENDLIN         	JSR     IN_BLANK        	;Get next and see if it's blank
01696  00E969  F0 F9         	                BEQ     .DONE           	;EOL! No line number
01697  00E96B  20 DE E5      	                JSR     GET_VAL
01698  00E96E  F0 F0         	                BEQ     .SAVE_DONE      	;No error occurred
01699  
01700  00E970  68            .ERRORLB        	PLA                     	;An error occurred, pop return
01701  00E971  68                            	PLA                     	; address from stack
01702  00E972  60                            	RTS
01703  
01704  00E973  85 C7         .DUMP           	STA     DUMP            	;Activate dump mode and CY=0
01705  00E975  18            .NOPARM         	CLC                     	;Indicate no parameters are given
01706  00E976  60                            	RTS                     	; (DEL requires them!)
01707  
01708  
01709   
01710  
01711  ;------------------------------------------------------------------------
01712  ; LIST command
01713  ;------------------------------------------------------------------------
01714  
01715  00E977  20 37 E9      CMD_LST         	JSR     BEG_END         	;Get begin and end line parameters
01716  00E97A  A0 C8                         	LDY     #PARM1          	;Find first line
01717  00E97C  20 90 ED                      	JSR     FIND_LINE
01718  
01719  00E97F  20 DF F6      .LOOP           	JSR     SCAN_ESC            	;SCAN_ESC if key pressed
01720  00E982  F0 3E         	                BEQ     DORTS            	;ESC pressed!
01721  00E984  A0 00         	                LDY     #0              	;Check EOF
01722  00E986  B1 B3         	                LDA     (PNTR),Y
01723  00E988  F0 38         	                BEQ     DORTS            	;Yes!
01724  00E98A  C8            	                INY                     	;See if we're past end line
01725  00E98B  38            	                SEC
01726  00E98C  B1 B3         	                LDA     (PNTR),Y
01727  00E98E  85 CF         	                STA     HEXVAL
01728  00E990  E5 CA         	                SBC     PARM2
01729  00E992  85 CE         	                STA     DELIM           	;Used to see if equal
01730  00E994  C8            	                INY
01731  00E995  B1 B3         	                LDA     (PNTR),Y
01732  00E997  85 D0         	                STA     HEXVAL+1
01733  00E999  E5 CB         	                SBC     PARM2+1
01734  00E99B  05 CE         	                ORA     DELIM
01735  00E99D  F0 02         	                BEQ     .EQUAL          	;Hey, last line to list!
01736  00E99F  B0 21         	                BCS     DORTS            	;We're done!
01737  
01738  00E9A1  A5 C7         .EQUAL          	LDA     DUMP            	;Dump mode?
01739  00E9A3  D0 06                         	BNE     .SKIP           	;Yes! Skip line number printing
01740  00E9A5  20 A7 E7                      	JSR     PRDECI_HEXVAL
01741  00E9A8  20 9E F6                      	JSR     WRSPACE
01742  
01743  00E9AB  20 CB ED      .SKIP           	JSR     UNPACK_IN          	;Unpack current line into keyboard buffer
01744  00E9AE  A2 00                         	LDX     #0              	;Print the entire unpacked line
01745  00E9B0  B5 19         .PRINT          	LDA     IN,X
01746  00E9B2  E8            	                INX
01747  00E9B3  20 A9 F6      	                JSR     WRCHAR
01748  00E9B6  C9 0D         	                CMP     #CR             	;End of line?
01749  00E9B8  D0 F6         	                BNE     .PRINT          	;Not yet!
01750  00E9BA  20 A7 F6      	                JSR	PRLF			;New line on screen	
01751  00E9BD  20 BB ED      	                JSR     NEXT_LINE       	;Set pointer to next line
01752  00E9C0  D0 BD         	                BNE     .LOOP           	;Repeat if not EOF!
01753  00E9C2  60            DORTS            	RTS
01754  
01755  ;------------------------------------------------------------------------
01756  ; MEMORY command
01757  ; Warning! Range is not checked! It's your own responsibility to set the
01758  ; range. Illegal ranges are belowe $0200, above RAM, inside own source,
01759  ; lomem => himem.
01760  ;------------------------------------------------------------------------
01761  
01762  00E9C3  F0 26         CMD_MEM         	BEQ     SHOWMEM         	;Yes! Set Lomem,Himem
01763  00E9C5  B5 19         	                LDA     IN,X            	;Is lomem given?
01764  00E9C7  C9 2C         	                CMP     #','
01765  00E9C9  F0 0F         	                BEQ     .HIMEM          	;Nope!
01766  	
01767  00E9CB  20 DE E5      	                JSR     GET_VAL         	;Get lomem value
01768  00E9CE  D0 F2         	                BNE     DORTS         		;An error occurred!
01769  00E9D0  84 EF         	                STY     LOMEM           	;Copy new lomem value
01770  00E9D2  85 F0         	                STA     LOMEM+1
01771  	
01772  00E9D4  B5 19         	                LDA     IN,X            	;Is highmem given? (soft)
01773  00E9D6  C9 2C         	                CMP     #','
01774  00E9D8  D0 0A         	                BNE     .DONE           	;Nope! Leave it
01775  
01776  00E9DA  E8            .HIMEM          	INX
01777  00E9DB  20 DE E5      	                JSR     GET_VAL         	;Get himem value
01778  00E9DE  D0 E2         	                BNE     DORTS	         	;An error occurred!
01779  00E9E0  84 F1         	                STY     HIMEM           	;Copy new himem value
01780  00E9E2  85 F2         	                STA     HIMEM+1
01781  
01782  00E9E4  A0 00         .DONE          		LDY     #0              	;Perform a new command
01783  00E9E6  84 E4                         	STY     OLD_SAVE        	;However OLD will not work now
01784  00E9E8  20 D3 EA                      	JSR     DONEW           	;Clear source program
01785   
01786                  
01787  00E9EB  20 15 F6      SHOWMEM         	JSR	STRING
01788  			
01789  			.db	$e1,$a5,$e1,$a2,$e1,$a2,$e1,$a5,$e1,$a5,$e1,$a5,$e1,$a5,$e1,$a3
01790  			.db	$e1,$a3,$e1,$0d,$0a,$7c,$e3,$a2,$7c,$e2,$7c,$e2,$7c,$e3,$a2,$7c
01791  			.db	$e5,$7c,$e5,$7c,$e3,$7c,$e1,$7c,$e2,$a1,$7c,$e2,$a1,$7c,$e1,$4c
01792  			.db	$4f,$57,$45,$52,$e1,$6c,$69,$6d,$69,$74,$3a,$e1,$00
01793  			
01794  00EA2B  A5 F0          			LDA     LOMEM+1         	;Print lomem
01795  00EA2D  A4 EF         	                LDY     LOMEM
01796  00EA2F  20 D2 F6      	                JSR     WRWORD	        	
01797  00EA32  20 15 F6      	        	JSR      STRING
01798  	        
01799  	               	.DB	CR,LF
01800  			.DB	$7c,$a2,$e3,$7c,$a1,$e3,$a1,$7c,$a2,$e3,$7c,$e1,$7c,$e1,$7c,$e1
01801  			.DB	$7c,$e2,$7c,$e2,$7c,$e1,$7c,$e1,$7c,$e1,$7c,$e1,$2e,$e1,$7c,$a1
01802  			.DB	$e2,$7c,$e1,$54,$4f,$54,$41,$4c,$e1,$52,$41,$4d,$3a,$e3,$00
01803  	               	
01804  			
01805  00EA66  A5 F2         	                LDA     HIMEM+1         	;And himem
01806  00EA68  A4 F1         	                LDY     HIMEM
01807  00EA6A  20 D2 F6      	                JSR     WRWORD
01808  	                
01809  	        
01810  00EA6D  20 15 F6      	        	JSR	STRING
01811  	        	
01812  	        	.DB	LF,CR
01813  			.DB	$7c,$a5,$7c,$e1,$7c,$a1,$7c,$e1,$7c,$a5,$7c,$a1,$7c,$a1,$7c,$a1
01814  			.DB	$7c,$a5,$7c,$a1,$7c,$a3,$7c,$a3,$7c,$a3,$7c,$e1,$55,$50,$50,$45
01815  			.DB	$52,$e1,$73,$70,$65,$6e,$74,$3a,$e1,$00
01816  				
01817   	
01818  00EA9C  20 7B ED      	                JSR     FIND_EOFZ       	;Find end of source file
01819  00EA9F  A4 B3         	                LDY     PNTR
01820  00EAA1  A5 B4         	                LDA     PNTR+1                
01821  00EAA3  20 D2 F6                      	JSR     WRWORD
01822  00EAA6  20 15 F6      			JSR	STRING
01823  			.ASCII	LF,CR 
01824  			.ASCII "All rights reserved v2.10",CR,LF,EOS
01825  
01826  .PRWORDCR       	;JSR     WRWORD
01827  00EAC7  60                            	RTS
01828  
01829  
01830  ;------------------------------------------------------------------------
01831  ; NEW command (or N -f force)
01832  ;------------------------------------------------------------------------
01833  
01834  00EAC8  20 A6 E5      CMD_NEW        		JSR     NNONSPC  		;if there's value after N
01835  00EACB  D0 06         			BNE	DONEW
01836  00EACD  B1 EF         			LDA     (LOMEM),Y       	;Save first byte of program (OLD)
01837  00EACF  F0 13                         	BEQ     RTS_MEM         	;But don't do it if already 0!
01838  00EAD1  85 E4                         	STA     OLD_SAVE
01839  
01840  00EAD3  98            DONEW           	TYA                     	;Make A=0
01841  00EAD4  91 EF                         	STA     (LOMEM),Y       	;Clear first byte of program
01842  00EAD6  85 EA                         	STA     SYM_TABLE+1     	;Invalidate symbol table
01843  00EAD8  A9 E8                         	LDA     #<DEF_AUTO       	;Set default AUTO line number
01844  00EADA  85 E5         	                STA     AUTO
01845  00EADC  A9 03         	                LDA     #>DEF_AUTO
01846  00EADE  85 E6         	                STA     AUTO+1
01847  00EAE0  A9 0A         	                LDA     #DEF_INC        	;Set default AUTO increment
01848  00EAE2  85 E7         	                STA     AUTO_INC
01849  00EAE4  60            RTS_MEM         	RTS
01850  
01851  ;------------------------------------------------------------------------
01852  ; OLD command 
01853  ;------------------------------------------------------------------------
01854                     					;Save some space by omitting error
01855  00EAE5  A5 E4         CMD_OLD         	LDA     OLD_SAVE        	;Is it possible to do OLD?
01856  00EAE7  F0 04         	                BEQ     ._ERROR         	;OLD not possible!
01857  00EAE9  91 EF         	                STA     (LOMEM),Y       	;Save old value into program
01858  00EAEB  84 E4         	                STY     OLD_SAVE        	;Clear old flag
01859  00EAED  60            ._ERROR         	RTS
01860  
01861  ;------------------------------------------------------------------------
01862  ; Renumber command
01863  ;------------------------------------------------------------------------
01864  
01865  00EAEE  84 C8         CMD_REN         	STY     PARM1           	;Set default values
01866  00EAF0  84 C9         	                STY     PARM1+1         	;Start renumbering from line 0
01867  00EAF2  A9 E8         	                LDA     #<DEF_AUTO       	;Set default renumber start addr.
01868  00EAF4  85 CA         	                STA     PARM2
01869  00EAF6  A9 03         	                LDA     #>DEF_AUTO
01870  00EAF8  85 CB         	                STA     PARM2+1
01871  00EAFA  A9 0A         	                LDA     #DEF_INC        	;Set default increment
01872  00EAFC  85 DA         	                STA     LENG
01873  	
01874  00EAFE  20 A6 E5      	                JSR     NNONSPC         	;Are there any parameters?
01875  00EB01  F0 2F         	                BEQ     .RENUMBER       	;No parameters given!
01876  00EB03  C9 2C         	                CMP     #','            	;Is begin line given?
01877  00EB05  F0 0F         	                BEQ     .STRTLIN        	;Nope!
01878  	
01879  00EB07  20 DE E5      	                JSR     GET_VAL         	;Get begin line number
01880  00EB0A  D0 5D         	                BNE     .DONE           	;An error occurred
01881  00EB0C  84 C8         	                STY     PARM1           	;Save begin line number
01882  00EB0E  85 C9         	                STA     PARM1+1
01883  	
01884  00EB10  B5 19         	                LDA     IN,X            	;Does the start line number follow?
01885  00EB12  C9 2C         	                CMP     #','
01886  00EB14  D0 1C         	                BNE     .RENUMBER       	;Nope! Get going
01887  
01888  00EB16  E8            .STRTLIN        	INX                     	;Get start line
01889  00EB17  20 DE E5      	                JSR     GET_VAL
01890  00EB1A  D0 4D         	                BNE     .DONE
01891  00EB1C  84 CA         	                STY     PARM2
01892  00EB1E  85 CB         	                STA     PARM2+1
01893  	
01894  00EB20  B5 19         	                LDA     IN,X            	;Is increment given?
01895  00EB22  C9 2C         	                CMP     #','
01896  00EB24  D0 0C         	                BNE     .RENUMBER       	;Nope! Get going
01897  	
01898  00EB26  E8            	                INX
01899  00EB27  20 DE E5      	                JSR     GET_VAL         	;Get increment value
01900  00EB2A  D0 3D         	                BNE     .DONE
01901  00EB2C  C0 00         	                CPY     #0              	;May not be zero!
01902  00EB2E  F0 3A         	                BEQ     .RANGE          	;Exit with range error
01903  00EB30  84 DA         	                STY     LENG            	;Save increment
01904  
01905  00EB32  A5 CA         .RENUMBER       	LDA     PARM2           	;See if begin line <= start line
01906  00EB34  C5 C8         	                CMP     PARM1           	; to avoid double line numbers
01907  00EB36  A5 CB         	                LDA     PARM2+1
01908  00EB38  E5 C9         	                SBC     PARM1+1
01909  00EB3A  90 2E         	                BCC     .RANGE          	;Nope! Exit with range error
01910  	
01911  00EB3C  A5 CA         	                LDA     PARM2           	;Copy parm2 to auto number
01912  00EB3E  85 E5         	                STA     AUTO
01913  00EB40  A5 CB         	                LDA     PARM2+1
01914  00EB42  85 E6         	                STA     AUTO+1
01915  00EB44  A5 DA         	                LDA     LENG            	;Copy increment to auto_inc
01916  00EB46  85 E7         	                STA     AUTO_INC
01917  	
01918  00EB48  A0 C8         	                LDY     #PARM1          	;Find first line number
01919  00EB4A  20 90 ED      	                JSR     FIND_LINE
01920  00EB4D  90 1A         	                BCC     .DONE           	;End of file!
01921  00EB4F  A0 00         	                LDY     #0
01922  
01923  00EB51  C8            .LOOP           	INY                     	;Set new line number
01924  00EB52  18            	                CLC                     	; and calculate next number
01925  00EB53  A5 E5         	                LDA     AUTO
01926  00EB55  91 B3         	                STA     (PNTR),Y
01927  00EB57  65 E7         	                ADC     AUTO_INC
01928  00EB59  85 E5         	                STA     AUTO
01929  00EB5B  C8            	                INY
01930  00EB5C  A5 E6         	                LDA     AUTO+1
01931  00EB5E  91 B3         	                STA     (PNTR),Y
01932  00EB60  69 00         	                ADC     #0
01933  00EB62  85 E6         	                STA     AUTO+1
01934  00EB64  20 BB ED      	                JSR     NEXT_LINE       	;Set pointer to next line
01935  00EB67  D0 E8         	                BNE     .LOOP           	;Nope!
01936  00EB69  60            .DONE           	RTS
01937  00EB6A  4C 38 F2      .RANGE          	JMP     RANGE_ERROR     	;Exit with range error
01938  
01939  ;------------------------------------------------------------------------
01940  ; Value command
01941  ;------------------------------------------------------------------------
01942  
01943  00EB6D  F0 58         CMD_VAL         	BEQ     .RTS            	;EOL! Missing operand error!
01944  00EB6F  A9 00         .LOOP           	LDA     #0
01945  00EB71  85 BF         	                STA     UNDEF           	;Clear undefined label flag
01946  00EB73  20 E3 E6      	                JSR     GET_EXPRES      	;Get value
01947  00EB76  D0 4F         	                BNE     .RTS            	;An error occurred!
01948  00EB78  A5 BF         	                LDA     UNDEF           	;Undefined label used?
01949  00EB7A  D0 62         	                BNE     VAL_UNDEF       	;Yes!
01950  	
01951  00EB7C  20 A7 E7      			JSR     PRDECI_HEXVAL		;Print value in decimal (ABS)
01952  00EB7F  20 9E F6      	                JSR     WRSPACE
01953  	
01954  00EB82  A5 D0         	                LDA     HEXVAL+1        	;Save original value
01955  00EB84  48            	                PHA
01956  00EB85  A5 CF         	                LDA     HEXVAL
01957  00EB87  48            	                PHA
01958  00EB88  A9 2B         	                LDA     #'+'            	;Print same value, but this time
01959  00EB8A  24 D0         	                BIT     HEXVAL+1        	; it may be negative
01960  00EB8C  10 05         	                BPL     .POS            	;It is positive!
01961  00EB8E  20 35 E8      	                JSR     NEGATE          	;Make value positive again
01962  00EB91  A9 2D         	                LDA     #'-'
01963  00EB93  20 A9 F6      .POS            	JSR     WRCHAR            	;Print sign
01964  00EB96  20 A7 E7      	                JSR     PRDECI_HEXVAL          	;Print value
01965  00EB99  20 9E F6      	                JSR     WRSPACE
01966  	
01967  00EB9C  68            	                PLA                     	;Restore hexval
01968  00EB9D  A8            	                TAY
01969  00EB9E  85 CF         	                STA     HEXVAL
01970  00EBA0  68            	                PLA
01971  00EBA1  85 D0         	                STA     HEXVAL+1
01972  00EBA3  20 D2 F6      	                JSR     WRWORD           	;Write value as hex
01973  00EBA6  20 9E F6      	                JSR     WRSPACE
01974  	
01975  00EBA9  A9 25         	                LDA     #'%'            	;Print percent aka binary
01976  00EBAB  20 A9 F6      	                JSR     WRCHAR
01977  00EBAE  A5 D0         	                LDA     HEXVAL+1        	;Is high byte 0?
01978  00EBB0  F0 06         	                BEQ     .LOW            	;Yes! Do only the low byte
01979  00EBB2  20 C8 EB      	                JSR     WRBIN         	 	;Print this byte binary
01980  00EBB5  20 8F F6      	                JSR     WRDOT
01981  00EBB8  A5 CF         .LOW            	LDA     HEXVAL          	;Print low byte in binary too
01982  00EBBA  20 C8 EB      	                JSR     WRBIN
01983  	
01984  00EBBD  20 A2 F6      	                JSR     WRCRLF
01985  00EBC0  B5 19         	                LDA     IN,X            	;Is next char a comma?
01986  00EBC2  E8            	                INX
01987  00EBC3  C9 2C         	                CMP     #','
01988  00EBC5  F0 A8         	                BEQ     .LOOP           	;Yes! Then more will follow!
01989  00EBC7  60            .RTS            	RTS                     	;Ignore rest (soft error check)
01990  
01991  ;------------------------------------------------------------------------
01992  ; Print binary  IN = AC
01993  ;------------------------------------------------------------------------
01994  				
01995  00EBC8  85 D2         WRBIN          		STA     CHAR			;
01996  00EBCA  20 D0 EB                      	JSR     .PRNIB          	;Print nibble
01997  00EBCD  20 8F F6                      	JSR     WRDOT
01998  00EBD0  A0 04         .PRNIB          	LDY     #4              	;Setup bit counter
01999  00EBD2  A9 18         .BITLOOP       		LDA     #'0'/2          	;Start with ASCII 0
02000  00EBD4  06 D2                         	ASL     CHAR            	;Move next bit to CY
02001  00EBD6  2A                            	ROL                     	;Add bit to ASCII
02002  00EBD7  20 A9 F6                      	JSR     WRCHAR            	; and print it
02003  00EBDA  88                            	DEY
02004  00EBDB  D0 F5                         	BNE     .BITLOOP        	;Do all 4 bits
02005  00EBDD  60            VAL_RTS         	RTS
02006  00EBDE  4C F7 EF      VAL_UNDEF       	JMP     UNDEF_ERROR     	;Exit with undefined label used
02007  		
02008  ;------------------------------------------------------------------------
02009  ;DISSASSEMBLER
02010  ;------------------------------------------------------------------------
02011  
02012  00EBE1  64 BF         CMD_DISSASSEMBLER	STZ	UNDEF
02013  00EBE3  20 E3 E6      			JSR     GET_EXPRES         	;Get Source aka get expression 
02014  00EBE6  D0 08                         	BNE	.CONT
02015  00EBE8  A6 BF                         	LDX     UNDEF           	;Undefined label used?
02016  00EBEA  D0 F2         	                BNE     VAL_UNDEF       	;Yes!
02017  00EBEC  84 DC                         	STY     SRCE			;else continue 
02018  00EBEE  85 DD                         	STA     SRCE+1      	                	
02019                  	
02020  00EBF0  A0 10         .CONT			LDY     #16
02021  00EBF2  5A            DECODE_ONE 		PHY				;identical to ASCIIDUMP and MEM DUM s        		
02022  00EBF3  20 C3 E3                     		JSR	DISPLAY_ADDR        	;display SOURCE address (could remove A&Y)              		               		               		
02023  00EBF6  B2 DC         			LDA	(SRCE)			;Get OpCode
02024  00EBF8  20 6F E2      			JSR 	INSTDSP			  		
02025  
02026  DISPLYASIC        	
02027  		.IF MYWYM
02028  00EBFB  A9 2D         			LDA	#45
02029  00EBFD  8D 05 88      			STA 	io_posx
02030  		.ENDIF	
02031  			
02032  00EC00  E6 DA         			INC	LENG
02033  00EC02  A5 DA         			LDA 	LENG
02034  00EC04  85 CD         			STA	COUNT			;add 1 to total length to include opcode				
02035  00EC06  20 A5 E3              		JSR	ASCII_DUMP		;display 
02036  00EC09  A5 DA                 		LDA 	LENG  		
02037  00EC0B  20 65 E2      			JSR	BUMPSRCE		;Added Length to Source
02038  00EC0E  7A            .BUMPEX        		PLY
02039  00EC0F  20 A2 F6      			JSR     WRCRLF
02040  00EC12  88                            	DEY
02041  00EC13  D0 DD                         	BNE	DECODE_ONE 		;decode one line
02042  00EC15  64 C6                         	STZ	ERROR
02043  00EC17  60                    		RTS
02044          		
02045  ;------------------------------------------------------------------------
02046  ; Go command or Excute code command
02047  ;------------------------------------------------------------------------
02048  
02049  00EC18  F0 0F         CMD_XEC         	BEQ     .RUN            	;Nope! Run from last known addr.
02050  00EC1A  64 BF         			STZ	UNDEF			;CLear it
02051  00EC1C  20 E3 E6                      	JSR     GET_EXPRES      	;Get address to run from
02052  00EC1F  D0 BC                         	BNE     VAL_RTS         	;An error occurred!
02053  00EC21  A6 BF                         	LDX     UNDEF           	;Undefined label used?
02054  00EC23  D0 B9                         	BNE     VAL_UNDEF       	;Yep!
02055  00EC25  84 F3                         	STY     XEC_LAST        	;Save XEC address
02056  00EC27  85 F4                         	STA     XEC_LAST+1
02057  
02058  00EC29  20 2F EC      .RUN            	JSR     .JSRIND         	;Imitate JSR (IND)
02059  00EC2C  4C A2 F6                      	JMP     WRCRLF			;print CR LF
02060  00EC2F  6C F3 00      .JSRIND         	JMP     (XEC_LAST)      ;GO!
02061  
02062  ;------------------------------------------------------------------------
02063  ; IN_BLANK  - Get next and see if it's blank
02064  ;------------------------------------------------------------------------
02065  
02066  00EC32  E8            IN_BLANK        	INX                     	;Find end of command in IN
02067  00EC33  B5 19                         	LDA     IN,X            	;Get character
02068  00EC35  C9 20                         	CMP     #SP
02069  00EC37  F0 02                         	BEQ     .RTS            	;A space is the end!
02070  00EC39  C9 0D                         	CMP     #CR			;CR is EOL
02071  00EC3B  60            .RTS            	RTS
02072  
02073  ;------------------------------------------------------------------------
02074  ; ADDLINE - Add line to the program 
02075  ; - todo remove PACK into subroutine and add more optoins aka any repitable chars
02076  ; [LENGTH][LINE NUMBER][PACKED LINE] [EOL]
02077  ;------------------------------------------------------------------------
02078  
02079  00EC3C  20 DE E5      ADDLINE         	JSR     GET_VAL         	;Get line number eg: 1000
02080  00EC3F  F0 01                         	BEQ     .NOERR          	;No error occurred!
02081  00EC41  60                            	RTS
02082  
02083  00EC42  18            .NOERR          	CLC
02084  00EC43  A5 CF         	                LDA     HEXVAL          	;Calculate next auto line number
02085  00EC45  65 E7         	                ADC     AUTO_INC
02086  00EC47  85 E5         	                STA     AUTO
02087  00EC49  A9 00         	                LDA     #0              	;Invalidate symbol table
02088  00EC4B  85 EA         	                STA     SYM_TABLE+1
02089  00EC4D  85 E4         	                STA     OLD_SAVE        	;Invalidate OLD command
02090  00EC4F  65 D0         	                ADC     HEXVAL+1       	 	;Oh yes, we were busy adding
02091  00EC51  85 E6         	                STA     AUTO+1          	; something!	
02092  00EC53  8A            	                TXA                     	;Save read index
02093  00EC54  A8            	                TAY
02094  00EC55  20 A6 E5      	                JSR     NNONSPC         	;See if line contains text
02095  00EC58  D0 0F         	                BNE     .OK             	;It does!
02096  00EC5A  A5 CF         	                LDA     HEXVAL          	;Set begin and end line to linenum
02097  00EC5C  85 C8         	                STA     PARM1           	; to delete this line from source
02098  00EC5E  85 CA         	                STA     PARM2
02099  00EC60  A5 D0         	                LDA     HEXVAL+1
02100  00EC62  85 C9         	                STA     PARM1+1
02101  00EC64  85 CB         	                STA     PARM2+1
02102  00EC66  4C F4 E8      	                JMP     DELETE          	;Delete this line!
02103  
02104  00EC69  98            .OK             	TYA                     	;Restore read index
02105  00EC6A  AA            	                TAX
02106  00EC6B  A0 00         	                LDY     #0              	;Clear write index
02107  00EC6D  B5 19         	                LDA     IN,X            	;Ignore first space after linenum
02108  00EC6F  C9 20         	                CMP     #SP             	; (not part of source)
02109  00EC71  D0 01         	                BNE     .LOOP1          	;Forget about 1st space!
02110  00EC73  E8            .LOOP           	INX                    		;Get next character
02111  00EC74  B5 19         .LOOP1          	LDA     IN,X
02112  00EC76  C9 20         	                CMP     #SP             	;Is it a space?
02113  00EC78  F0 12         	                BEQ     .PACK           	;Yes! Pack it!
02114  00EC7A  C9 2D         	                CMP     #DASH           	;Is it a dash?
02115  00EC7C  F0 0E         	                BEQ     .PACK           	;Yes! Pack it!
02116  00EC7E  C9 5F         	                CMP	#'_'			;It it horizontal grz	
02117  00EC80  F0 0A         			BEQ	.PACK			;Yes! Pack it!	
02118  00EC82  C9 0D         	                CMP     #CR             	;Is it end of line?
02119  00EC84  F0 35         	                BEQ     .EOL            	;Yes! Packed entire line now!
02120  00EC86  99 19 00      .WRITE          	STA     IN,Y            	;Save normal character
02121  00EC89  C8            	                INY                     	;Increment write pointer
02122  00EC8A  80 E7         	                BRA     .LOOP           	;Always taken!
02123  
02124  00EC8C  85 CE         .PACK           	STA     DELIM           	;Save character to pack
02125  00EC8E  A9 01                        		LDA     #1              	;Init repetition counter
02126  00EC90  85 CD                         	STA     COUNT
02127  00EC92  E8            .PCKLOOP        	INX                     	;Count number of same characters
02128  00EC93  B5 19                         	LDA     IN,X
02129  00EC95  C5 CE         	                CMP     DELIM
02130  00EC97  D0 09         	                BNE     .PCKEXIT        	;It's not the same anymore!
02131  00EC99  E6 CD         	                INC     COUNT           	;Increment counter
02132  00EC9B  A5 CD         	                LDA     COUNT           	;Don't allow it to exceed 63
02133  00EC9D  C9 3F         	                CMP     #63
02134  00EC9F  90 F1         	                BCC     .PCKLOOP        	;Still OK!
02135  00ECA1  E8            	                INX                     	;Compensate for normal exit
02136  00ECA2  CA            .PCKEXIT        	DEX                     	;We're too far now
02137  00ECA3  A5 CE                         	LDA     DELIM           	;Was it space or dash?
02138  00ECA5  C9 20         	                CMP     #' '            	;                  
02139  00ECA7  F0 0C         	                BEQ     .SPACE          	;It was space!	                
02140  00ECA9  C9 2D         	                CMP	#DASH
02141  00ECAB  F0 04         	                BEQ	.DASH	                
02142  00ECAD  A9 A0         			LDA	#%10100000		;Set dash flag
02143  00ECAF  80 06         			BRA	.ADDCOUNT
02144  00ECB1  A9 C0         .DASH	                LDA     #%11000000      	;Set dash flag
02145  00ECB3  80 02         			BRA	.ADDCOUNT
02146  00ECB5  A9 E0         .SPACE          	LDA	#%11100000      	;Set dash flag
02147  00ECB7  05 CD         .ADDCOUNT		ORA     COUNT           	;Combine with counter			
02148  00ECB9  80 CB         	                BRA     .WRITE          	;Always taken!
02149  
02150  00ECBB  98            .EOL            	TYA                     	;Add 3 byte overhead to length
02151  00ECBC  18            	                CLC
02152  00ECBD  69 03         	                ADC     #3
02153  00ECBF  85 DA         	                STA     LENG            	;Save length
02154  00ECC1  85 CD         	                STA     COUNT
02155  00ECC3  A0 CF         	                LDY     #HEXVAL         	;Find line in program memory
02156  00ECC5  20 90 ED      	                JSR     FIND_LINE
02157  00ECC8  90 31         	                BCC     .NEWLINE        	;EOF! Line does not exist yet
02158  00ECCA  D0 2F         	                BNE     .NEWLINE        	;Line does not exist yet
02159  
02160  ; The line number already exists. Compare both line lengths
02161  
02162  00ECCC  A0 00                        	 	LDY     #0              	;Is new line longer or shorter?
02163  00ECCE  38                            	SEC
02164  00ECCF  A5 DA                         	LDA     LENG
02165  00ECD1  F1 B3                         	SBC     (PNTR),Y
02166  00ECD3  F0 5C                         	BEQ     .INSERT         	;Line length did not change!
02167  00ECD5  85 DA                         	STA     LENG            	;Save number of bytes difference
02168  00ECD7  B0 22                         	BCS     .NEWLINE        	;Make room for longer line
02169  
02170  00ECD9  38            .SHORTER        	SEC                     	;Setup source and destination to
02171  00ECDA  A5 B3         	                LDA     PNTR            	; move the source down
02172  00ECDC  48            	                PHA
02173  00ECDD  85 DE         	                STA     DEST
02174  00ECDF  E5 DA         	                SBC     LENG            	;(length is negative!)
02175  00ECE1  85 DC         	                STA     SRCE
02176  00ECE3  A5 B4         	                LDA     PNTR+1
02177  00ECE5  48            	                PHA
02178  00ECE6  85 DF         	                STA     DEST+1
02179  00ECE8  E9 FF         	                SBC     #-1             	;(keep high byte negative too!)
02180  00ECEA  85 DD         	                STA     SRCE+1
02181  00ECEC  20 5B ED      	                JSR     CALC_LENG       	;Get the number of bytes to move
02182  00ECEF  68            	                PLA                     	;Restore PNTR (was destroyed by
02183  00ECF0  85 B4         	                STA     PNTR+1          	; CALC_LENG)
02184  00ECF2  68            	                PLA
02185  00ECF3  85 B3         	                STA     PNTR
02186  00ECF5  20 22 E4      	                JSR     MOV_DOWN        	;Move rest of program down
02187  00ECF8  4C 31 ED      	                JMP     .INSERT         	;Insert new, shorter, line
02188  
02189  00ECFB  A5 B3         .NEWLINE        	LDA     PNTR            	;Use current pointer as
02190  00ECFD  48            	                PHA                     	; source
02191  00ECFE  85 DC         	                STA     SRCE
02192  00ED00  18            	                CLC                     	;Add new line's length to it
02193  00ED01  65 DA         	                ADC     LENG            	; to find the destination
02194  00ED03  85 DE         	                STA     DEST
02195  00ED05  A5 B4         	                LDA     PNTR+1
02196  00ED07  48            	                PHA
02197  00ED08  85 DD         	                STA     SRCE+1
02198  00ED0A  69 00         	                ADC     #0
02199  00ED0C  85 DF         	                STA     DEST+1
02200  00ED0E  20 5B ED      	                JSR     CALC_LENG       	;Calculate number of bytes to move
02201  	
02202  00ED11  18            	                CLC                     	;See if there's enough room in
02203  00ED12  A5 DE         	                LDA     DEST            	; memory until HIMEM
02204  00ED14  65 DA         	                ADC     LENG
02205  00ED16  85 B3         	                STA     PNTR
02206  00ED18  A5 DF         	                LDA     DEST+1
02207  00ED1A  65 DB         	                ADC     LENG+1
02208  00ED1C  85 B4         	                STA     PNTR+1
02209  00ED1E  A5 F1         	                LDA     HIMEM
02210  00ED20  C5 B3         	                CMP     PNTR
02211  00ED22  A5 F2         	                LDA     HIMEM+1
02212  00ED24  E5 B4         	                SBC     PNTR+1
02213  00ED26  90 2C         	                BCC     .MEMFUL         	;Memory full!
02214  00ED28  20 43 E4      	                JSR     MOV_UP          	;Move them! (move end marker to end)
02215  00ED2B  68            	                PLA                     	;Restore pointer
02216  00ED2C  85 B4         	                STA     PNTR+1
02217  00ED2E  68            	                PLA
02218  00ED2F  85 B3         	                STA     PNTR
02219  
02220  00ED31  A0 00         .INSERT         	LDY     #0              	;Insert new line to freed space
02221  00ED33  A2 00         	                LDX     #0
02222  00ED35  A5 CD         	                LDA     COUNT           	;Start with length byte
02223  00ED37  91 B3         	                STA     (PNTR),Y
02224  00ED39  38            	                SEC                     	;Subtract header length
02225  00ED3A  E9 03         	                SBC     #3
02226  00ED3C  85 CD         	                STA     COUNT
02227  00ED3E  C8            	                INY
02228  00ED3F  A5 CF         	                LDA     HEXVAL          	;Then comes the line number
02229  00ED41  91 B3         	                STA     (PNTR),Y
02230  00ED43  C8            	                INY
02231  00ED44  A5 D0         	                LDA     HEXVAL+1
02232  00ED46  91 B3         	                STA     (PNTR),Y
02233  00ED48  C8            	                INY
02234  00ED49  B5 19         .INSLOOP        	LDA     IN,X            	;Get byte from new line
02235  00ED4B  91 B3         	                STA     (PNTR),Y        	; and store it
02236  00ED4D  E8            	                INX
02237  00ED4E  C8            	                INY
02238  00ED4F  C6 CD         	                DEC     COUNT
02239  00ED51  D0 F6         	                BNE     .INSLOOP        	;Not all bytes done yet!
02240  00ED53  60            	                RTS
02241  
02242  00ED54  A9 51         .MEMFUL        	 	LDA     #ERR_MEM        	;Exit with memory full error
02243  00ED56  85 C6                         	STA     ERROR
02244  00ED58  68                            	PLA                     	;Clear stack
02245  00ED59  68                            	PLA
02246  00ED5A  60                            	RTS
02247  
02248  ;------------------------------------------------------------------------
02249  ; Calculate the length of the memory block to be moved
02250  ;------------------------------------------------------------------------
02251  
02252  00ED5B  20 7E ED      CALC_LENG       	JSR     FIND_EOF        	;Find end of source
02253  00ED5E  38            	                SEC                     	;Calculate number of bytes to
02254  00ED5F  A5 B3         	                LDA     PNTR            	; be moved
02255  00ED61  E5 DC         	                SBC     SRCE
02256  00ED63  85 DA         	                STA     LENG
02257  00ED65  A5 B4         	                LDA     PNTR+1
02258  00ED67  E5 DD         	                SBC     SRCE+1
02259  00ED69  85 DB         	                STA     LENG+1
02260  00ED6B  E6 DA         	                INC     LENG            	;Move end byte too!
02261  00ED6D  D0 02         	                BNE     .NOCY
02262  00ED6F  E6 DB         	                INC     LENG+1
02263  00ED71  60            .NOCY           	RTS
02264  
02265  ;------------------------------------------------------------------------
02266  ; Set pointer to begin of file
02267  ;------------------------------------------------------------------------
02268  
02269  00ED72  A5 EF         SET_BOF         	LDA     LOMEM           	;Set pointer to begin of program
02270  00ED74  85 B3         	                STA     PNTR            	; memory
02271  00ED76  A5 F0         	                LDA     LOMEM+1
02272  00ED78  85 B4         	                STA     PNTR+1
02273  00ED7A  60            	                RTS
02274  
02275  ;------------------------------------------------------------------------
02276  ; Find end of program memory
02277  ;------------------------------------------------------------------------
02278  
02279  00ED7B  20 72 ED      FIND_EOFZ       	JSR     SET_BOF         	;Set pointer to begin of file
02280  00ED7E  A0 00         FIND_EOF        	LDY     #0              	;Point to line length
02281  00ED80  B1 B3         .LOOP           	LDA     (PNTR),Y        	;Get current line's length
02282  00ED82  F0 0B         	                BEQ     .EOF            	;EOF found!
02283  00ED84  18            	                CLC                     	;Add line length to current pntr
02284  00ED85  65 B3         	                ADC     PNTR
02285  00ED87  85 B3         	                STA     PNTR
02286  00ED89  90 F5         	                BCC     .LOOP           	;Carry is not set!
02287  00ED8B  E6 B4         	                INC     PNTR+1
02288  00ED8D  B0 F1         	                BCS     .LOOP           	;Always taken
02289  00ED8F  60            .EOF            	RTS
02290  
02291  ;------------------------------------------------------------------------
02292  ; Find line in program memory
02293  ; Line number to search for is located at 0,Y
02294  ; EOF -> C=0
02295  ; Line found -> C=1 & Z=1
02296  ; Line not found, pointing at next higher line -> C=1 & Z=0
02297  ;------------------------------------------------------------------------
02298  
02299  00ED90  B9 00 00      FIND_LINE       	LDA     0,Y             	;Get line number to find eg 1000
02300  00ED93  85 CF         	                STA     HEXVAL
02301  00ED95  B9 01 00      	                LDA     1,Y
02302  00ED98  85 D0         	                STA     HEXVAL+1
02303  00ED9A  20 72 ED      	                JSR     SET_BOF         	;Start looking at begin of program eg 0600
02304  00ED9D  A0 00         	                LDY     #0              	;Empty program?
02305  00ED9F  B1 B3         	                LDA     (PNTR),Y
02306  00EDA1  F0 16         	                BEQ     .EOF            	;Yes!
02307  
02308  00EDA3  C8            .LOOP           	INY                     	;Point to line number
02309  00EDA4  38                            	SEC                     	;Subtract wanted line from this
02310  00EDA5  B1 B3         	                LDA     (PNTR),Y        	; line number
02311  00EDA7  E5 CF         	                SBC     HEXVAL
02312  00EDA9  85 CE         	                STA     DELIM
02313  00EDAB  C8            	                INY
02314  00EDAC  B1 B3         	                LDA     (PNTR),Y
02315  00EDAE  E5 D0         	                SBC     HEXVAL+1
02316  00EDB0  05 CE         	                ORA     DELIM           	;Z=1 if line is found
02317  00EDB2  B0 06         	                BCS     .QUIT           	;Found it or past it!
02318  00EDB4  20 BB ED      	                JSR     NEXT_LINE       	;Find next line
02319  00EDB7  D0 EA         	                BNE     .LOOP           	;Not end of file yet!
02320  00EDB9  18            .EOF            	CLC                     	;Indicate EOF
02321  00EDBA  60            .QUIT           	RTS
02322  
02323  ;------------------------------------------------------------------------
02324  ; Set pointer to the next line
02325  ;------------------------------------------------------------------------
02326  
02327  00EDBB  A0 00         NEXT_LINE       	LDY     #0              	;Point to line length
02328  00EDBD  B1 B3         	                LDA     (PNTR),Y        	;Add length to pointer
02329  00EDBF  18            	                CLC
02330  00EDC0  65 B3         	                ADC     PNTR
02331  00EDC2  85 B3         	                STA     PNTR
02332  00EDC4  90 02         	                BCC     .SKIP           	;No carry!
02333  00EDC6  E6 B4         	                INC     PNTR+1
02334  00EDC8  B1 B3         .SKIP           	LDA     (PNTR),Y        	;Set Z if this is EOF
02335  00EDCA  60                            	RTS
02336  
02337  ;------------------------------------------------------------------------
02338  ; Unpack source line to IN (Without line number)
02339  ;------------------------------------------------------------------------
02340  
02341  00EDCB  A0 00         UNPACK_IN          	LDY     #0              	;Get line length
02342  00EDCD  B1 B3         	                LDA     (PNTR),Y
02343  00EDCF  38            	                SEC
02344  00EDD0  E9 03         	                SBC     #3              	;Subtract length and line-num
02345  00EDD2  85 CD         	                STA     COUNT
02346  00EDD4  A2 00         	                LDX     #0              	;Start at IN
02347  00EDD6  A0 03         	                LDY     #3              	;This is where the fun is
02348  00EDD8  B1 B3         .LOOP           	LDA     (PNTR),Y        	;Get byte from source
02349  00EDDA  30 0D         	                BMI     .UNPACK         	;It's a packed byte! was bpl
02350  00EDDC  95 19         	                STA     IN,X            	;It's a normal character
02351  00EDDE  E8            	                INX
02352  00EDDF  C8            .NEXT           	INY                     	;Point to next source byte
02353  00EDE0  C6 CD         	                DEC     COUNT           	;Decrement length counter
02354  00EDE2  D0 F4         	                BNE     .LOOP           	;Not done yet!
02355  	
02356  00EDE4  A9 0D         	                LDA     #CR             	;Terminate unpacked line with CR
02357  00EDE6  95 19         	                STA     IN,X
02358  00EDE8  60            	                RTS
02359  
02360  00EDE9  84 CE         .UNPACK         	STY     DELIM           	;Save source code pointer
02361  00EDEB  20 F8 ED      	                JSR	UNPACK_DECODE		;return character and count
02362  
02363  00EDEE  95 19         .EXPAND         	STA     IN,X            	; Save character to IN
02364  00EDF0  E8            	                INX
02365  00EDF1  88            	                DEY                     	;Decrement counter
02366  00EDF2  D0 FA         	                BNE     .EXPAND         	;Not done yet!
02367  00EDF4  A4 CE         	                LDY     DELIM           	;Restore index in source
02368  00EDF6  D0 E7         	                BNE     .NEXT           	;Always taken!
02369  
02370  ;------------------------------------------------------------------------
02371  ; Decode unpack ; returns y = count A= character Z=1 if EOL
02372  ; 	100 count future 
02373  ; 	110 count -
02374  ; 	101 count _
02375  ; 	111 count SPACE
02376  ;------------------------------------------------------------------------
02377  
02378  00EDF8  48            UNPACK_DECODE		PHA                     	;Save packed type (space or -)	                
02379  00EDF9  29 1F         	                AND     #%00011111     		;Strip away type flag
02380  00EDFB  A8            	                TAY                     	;to keep repeat counter
02381  00EDFC  68            	                PLA                     	;Find out what type it was	                	                             
02382  00EDFD  29 E0         	                AND	#%11100000		;mask flags
02383  00EDFF  C9 E0         	                CMP	#%11100000
02384  00EE01  F0 07         	                BEQ	.SPACE
02385  00EE03  C9 C0         	                CMP	#%11000000
02386  00EE05  F0 06         			BEQ	.DASH			;must be HDASH
02387  			;CMP	#%10100000
02388  			;BEQ	.HDASH
02389  			;RTS				;return z=0 must be %10000000			
02390  00EE07  A9 5F         .HDASH			LDA	#'_'
02391  00EE09  60            			RTS				;
02392  00EE0A  A9 20         .SPACE			LDA     #' '            	;Expand a space
02393  00EE0C  60            			RTS
02394  00EE0D  A9 2D         .DASH			LDA	#DASH
02395  00EE0F  60            			RTS
02396  
02397  ;------------------------------------------------------------------------
02398  ; Assemble command
02399  ;------------------------------------------------------------------------
02400  
02401  00EE10  20 AD F6      CMD_ASM         	JSR 	DRAWLINE             
02402  00EE13  20 7B ED      			JSR     FIND_EOFZ       	;Find end of file
02403  00EE16  A4 B3         	                LDY     PNTR            	;Set begin of symbol table
02404  00EE18  A6 B4         	                LDX     PNTR+1
02405  00EE1A  C8            	                INY                     	;Symtab starts 1 byte after EOF
02406  00EE1B  D0 01         	                BNE     .NOCY           	;No carry!
02407  00EE1D  E8            	                INX
02408  00EE1E  84 E9         .NOCY           	STY     SYM_TABLE
02409  00EE20  86 EA                         	STX     SYM_TABLE+1
02410  
02411  00EE22  A0 00         	                LDY     #0              	;I presume that we're not beyond
02412  00EE24  98            	                TYA                     	; himem already for memory's sake
02413  00EE25  91 E9         	                STA     (SYM_TABLE),Y   	;Clear symbol table
02414  00EE27  85 AD         	                STA     PASS            	;Set pass 0
02415  00EE29  85 BE         	                STA     ASM_ERR         	;Clear error counter
02416  	
02417  00EE2B  20 4B EE      	                JSR     ASSEMBLE        	;Start pass 1
02418  00EE2E  A5 BE         	                LDA     ASM_ERR         	;Were there any errors?
02419  00EE30  D0 08         	                BNE     .ERRORS         	;Yep!
02420  00EE32  C6 AD         	                DEC     PASS            	;Start pass 2 (Must be $FF !)
02421  00EE34  20 4B EE      	                JSR     ASSEMBLE                   
02422  00EE37  20 09 E8      	                JSR     PRINT_OBJ       	;Print last object range
02423                  
02424  00EE3A  20 AD F6      .ERRORS         	JSR	DRAWLINE
02425  00EE3D  A5 BE         			LDA     ASM_ERR         	;Print number of errors
02426  00EE3F  85 CF         	                STA     HEXVAL
02427  00EE41  64 D0         	                STZ     HEXVAL+1
02428  00EE43  20 A7 E7      	                JSR     PRDECI_HEXVAL
02429  00EE46  A9 32         	                LDA     #STR_ERRORS     	;Print errors string behind it
02430  00EE48  4C 6D E4      	                JMP     PRINT_MSGS
02431  
02432  ;------------------------------------------------------------------------
02433  ; This is what we came for, assembling!!!!
02434  ;------------------------------------------------------------------------
02435  
02436  00EE4B  20 72 ED      ASSEMBLE        	JSR     SET_BOF         	;Start at begin of program
02437  00EE4E  64 AF         		        STZ     GLOBAL+1        	;Make last global label invalid        
02438  00EE50  A9 00         	                LDA     #<DEF_ORG        		;Setup default PC
02439  00EE52  85 B6         	                STA     PC
02440  00EE54  85 B8         	                STA     TA
02441  00EE56  85 BA         	                STA     TA_BEGIN
02442  00EE58  A9 10         	                LDA     #>DEF_ORG
02443  00EE5A  85 B7         	                STA     PC+1
02444  00EE5C  85 B9         	                STA     TA+1
02445  00EE5E  85 BB         	                STA     TA_BEGIN+1
02446  
02447  00EE60  20 DF F6      .LINE           	JSR     SCAN_ESC        	;SCAN_ESC output if necessary
02448  00EE63  F0 48         	                BEQ     .DONE           	;ESC was pressed!
02449  00EE65  A5 B6         	                LDA     PC              	;Copy PC at begin of line
02450  00EE67  85 BC         	                STA     PC_BEG
02451  00EE69  A5 B7         	                LDA     PC+1
02452  00EE6B  85 BD         	                STA     PC_BEG+1
02453  00EE6D  A0 00         	                LDY     #0              	;End of program?
02454  00EE6F  B1 B3         	                LDA     (PNTR),Y
02455  00EE71  F0 3A         	                BEQ     .DONE           	;Yes! We're done (with this pass)
02456  00EE73  84 BF         	                STY     UNDEF           	;Clear undefined label flag
02457  00EE75  84 C0         	                STY     FORWARD         	;and forward ref. label flag
02458  00EE77  84 C6         	                STY     ERROR           	;Clear error number
02459  00EE79  20 CB ED      	                JSR     UNPACK_IN          	;Unpack this line to IN
02460  	
02461  00EE7C  A2 00         	                LDX     #0
02462  00EE7E  A5 19         	                LDA     IN              	;Can it be a label?
02463  00EE80  C9 20         	                CMP     #' '
02464  00EE82  F0 0B         	                BEQ     .NO_LABEL       	;Nope!
02465  00EE84  C9 0D         	                CMP     #CR             	;Can't be CR, but just in case
02466  00EE86  F0 1D         	                BEQ     .NEXT           	;Do next line!
02467  00EE88  C9 3B         	                CMP     #';'
02468  00EE8A  F0 19         	                BEQ     .NEXT           	;It's a comment, ignore line
02469  00EE8C  20 BD F1      	                JSR     ADD_LABEL       	;Add this label to symbol table
02470  
02471  00EE8F  20 A6 E5      .NO_LABEL       	JSR     NNONSPC         	;Find next non space now
02472  00EE92  F0 11         	                BEQ     .NEXT           	;That was all, next line please!
02473  00EE94  C9 3B         	                CMP     #';'			;Compare if its a comment
02474  00EE96  F0 0D         	                BEQ     .NEXT           	;The rest is comment!
02475  00EE98  C9 2E         	                CMP     #'.'            	;Can it be a directive?
02476  00EE9A  F0 06         	                BEQ     .DIRECT         	;Yes! Handle it
02477  00EE9C  20 54 F2      	                JSR     MNEMON          	;Decode mnemonic and operand  
02478  00EE9F  4C A5 EE      	                JMP     .NEXT           	;That's it!
02479  
02480  00EEA2  20 D6 EE      .DIRECT         	JSR     DIRECT          	;Decode directive
02481  
02482  00EEA5  20 AE EE      .NEXT           	JSR     CHCK_ERROR      	;Handle errors
02483  00EEA8  20 BB ED                      	JSR     NEXT_LINE       	;Point to next line
02484  00EEAB  D0 B3                         	BNE     .LINE           	;Not EOF!
02485  00EEAD  60            .DONE           	RTS
02486  
02487  ;------------------------------------------------------------------------
02488  ; Check error
02489  ; If ERROR<>0 print line number and error behind it
02490  ; Also increment error counter
02491  ;------------------------------------------------------------------------
02492  
02493  00EEAE  A5 C6         CHCK_ERROR      	LDA     ERROR           	;Did an error occur?
02494  00EEB0  D0 09                         	BNE     .ERRORS         	;Yes!
02495  00EEB2  A5 BF                         	LDA     UNDEF           	;Undefined label used in pass 2?
02496  00EEB4  25 AD                         	AND     PASS            	; (0 if pass 1)
02497  00EEB6  F0 1D                         	BEQ     .RTS            	;Nope!
02498  00EEB8  20 F7 EF                      	JSR     UNDEF_ERROR     	;Exit with undefined label error
02499  
02500  00EEBB  A0 01         .ERRORS         	LDY     #1              	;Print line number
02501  00EEBD  B1 B3                         	LDA     (PNTR),Y
02502  00EEBF  85 CF                         	STA     HEXVAL
02503  00EEC1  C8                            	INY
02504  00EEC2  B1 B3                         	LDA     (PNTR),Y
02505  00EEC4  85 D0                         	STA     HEXVAL+1
02506  00EEC6  20 A7 E7                      	JSR     PRDECI_HEXVAL
02507  00EEC9  20 9E F6                      	JSR     WRSPACE
02508  00EECC  20 6D E4                      	JSR     PRINT_MSGS     		;Print the error
02509  00EECF  E6 BE                         	INC     ASM_ERR         	;Increment error counter
02510  00EED1  D0 02                         	BNE     .RTS            	;No error overflow!
02511  00EED3  C6 BE                         	DEC     ASM_ERR         	;Max indicator is 255 errors.
02512  00EED5  60            .RTS           		RTS
02513  
02514  ;------------------------------------------------------------------------
02515  ; Decode directive
02516  ;------------------------------------------------------------------------
02517  
02518  00EED6  20 41 F2      DIRECT          	JSR     NEXT_IN         	;Get directive's name
02519  00EED9  F0 31                         	BEQ     .EERROR        		;It may not be CR already!
02520  00EEDB  85 C8                         	STA     PARM1
02521  00EEDD  20 3F F2                      	JSR     NEXT_IN_Y0
02522  00EEE0  F0 2A                         	BEQ     .EERROR         	;It may not be CR already!
02523                  	
02524  00EEE2  85 C9                         	STA     PARM1+1
02525  00EEE4  B9 11 EF      .SEARCH         	LDA     .TABLE,Y        	;Could it be this one?
02526  00EEE7  F0 23                         	BEQ     .EERROR         	;Nope! Directive not found!
02527  00EEE9  C5 C8                         	CMP     PARM1
02528  00EEEB  D0 07                         	BNE     .NEXT           	;Nope!
02529  00EEED  B9 12 EF                      	LDA     .TABLE+1,Y
02530  00EEF0  C5 C9                         	CMP     PARM1+1
02531  00EEF2  F0 04                         	BEQ     .GOTIT         	 	;Found directive!
02532  00EEF4  C8            .NEXT           	INY                     	;Point to next directive in table
02533  00EEF5  C8                            	INY
02534  00EEF6  80 EC                         	BRA     .SEARCH         	;Always taken!
02535  
02536  00EEF8  B9 23 EF      .GOTIT          	LDA     .JUMPS+1,Y      	;Get directive handler's address
02537  00EEFB  48                            	PHA
02538  00EEFC  B9 22 EF                      	LDA     .JUMPS,Y
02539  00EEFF  48                            	PHA
02540  00EF00  20 3F F2      .EOF_DIR        	JSR     NEXT_IN_Y0      	;Find end of directive first
02541  00EF03  F0 0B                         	BEQ     .JUMP           	;Execute directive!
02542  00EF05  C9 20                         	CMP     #SP            		; Is it a space already?
02543  00EF07  D0 F7                         	BNE     .EOF_DIR        	; Nope, not end of directive yet!
02544  00EF09  4C A6 E5                      	JMP     NNONSPC         	; Find next non space
02545  
02546  00EF0C  A9 6F         .EERROR         	LDA     #ERR_DIR        	; Exit with directive ERROR
02547  00EF0E  85 C6                         	STA     ERROR
02548  00EF10  60            .JUMP           	RTS
02549  
02550  .TABLE          	.BYTE     "AS"          	;ASCII string
02551                  	.BYTE     "AT"          	;ASCII string terminated
02552                  	.BYTE     "BS"          	;Block skip
02553                  	.BYTE     "DA"          	;Data directive
02554                  	.BYTE     "EQ"          	;Word directive
02555                  	.BYTE     "OR"          	;ORG directive
02556                  	.BYTE     "TA"          	;Target address directive
02557                  	.BYTE	  "DB"			;Byte directive	FUTUr
02558                  	.BYTE     00            	;End of table
02559  
02560  .JUMPS          	.DW     DIR_AS-1        	;ASCII string
02561                  	.DW     DIR_AT-1        	;ASCII string terminated
02562                  	.DW     DIR_BS-1        	;Block skip
02563                  	.DW     DIR_DA-1        	;Data directive
02564                  	.DW     DIR_EQ-1        	;Word directive
02565                  	.DW     DIR_OR-1        	;ORG directive
02566                  	.DW     DIR_TA-1        	;Target address directive
02567                  	.DW	DIR_DB-1		;Byte directive
02568  
02569  ;------------------------------------------------------------------------
02570  ; .BYTE and .AT directives
02571  ;------------------------------------------------------------------------
02572  
02573  00EF32  A0 80         DIR_AT          	LDY     #%10000000     		;Set end flag
02574  00EF34  84 D1         DIR_AS          	STY     LEAD0          		;Save end flag
02575  00EF36  A0 7F                         	LDY     #%01111111     		;In case of positive ASCII
02576  00EF38  C9 2D                         	CMP     #'-'           		;Is it the sign flag?
02577  00EF3A  D0 07                         	BNE     .POS           		;No! Positive ASCII
02578  00EF3C  A0 FF                         	LDY     #%11111111     		;Set negative ASCII flag
02579  00EF3E  20 41 F2                      	JSR     NEXT_IN         	;Point to next character
02580  00EF41  F0 50                         	BEQ     DIR_OPE         	;Premature EOL!
02581  00EF43  84 D2         .POS            	STY     CHAR            	;Save ASCII polarity
02582  00EF45  85 CE                         	STA     DELIM           	;Save delimiter character
02583  00EF47  20 41 F2      .LOOP           	JSR     NEXT_IN         	;Get next char
02584  00EF4A  F0 47                         	BEQ     DIR_OPE         	;Sudden EOL!
02585  00EF4C  C5 CE                         	CMP     DELIM           	;End of string?
02586  00EF4E  F0 10                         	BEQ     .EXIT           	;Yes!
02587  00EF50  25 D2                         	AND     CHAR            	;Set/clear b7
02588  00EF52  B4 1A                         	LDY     IN+1,X          	;Is next char the delimiter?
02589  00EF54  C4 CE                         	CPY     DELIM
02590  00EF56  D0 02                         	BNE     .NOT_END        	;Nope!
02591  00EF58  45 D1                         	EOR     LEAD0           	;Invert b7 if end flag set
02592  00EF5A  20 2B F0      .NOT_END        	JSR     SAVE_OBJ        	;Save byte to object
02593  00EF5D  4C 47 EF                      	JMP     .LOOP           	;Do all characters
02594  
02595  00EF60  20 41 F2      .EXIT           	JSR     NEXT_IN         	;Next char must be blank or EOL
02596  00EF63  F0 04                         	BEQ     .RTS            	;It is!
02597  00EF65  C9 20                         	CMP     #SP
02598  00EF67  D0 2A                         	BNE     DIR_OPE         	;It is not!
02599  00EF69  60            .RTS            	RTS
02600  
02601  ;------------------------------------------------------------------------
02602  ; .BS directive
02603  ;------------------------------------------------------------------------
02604  
02605  00EF6A  20 E3 E6      DIR_BS          	JSR     GET_EXPRES      	;Evaluate expression
02606  00EF6D  D0 28                         	BNE     DIR_EXIT        	;An ERROR occurred
02607  00EF6F  A5 BF                         	LDA     UNDEF
02608  00EF71  D0 1D                         	BNE     .UNDEF          	;Undefined labels not allowed
02609  00EF73  A5 AD                         	LDA     PASS            	;Don't increment TA during pass 1
02610  00EF75  F0 05                         	BEQ     .PC
02611  00EF77  A0 B8                         	LDY     #TA             	;Add expression to TA
02612  00EF79  20 7E EF                      	JSR     .ADD
02613  00EF7C  A0 B6         .PC             	LDY     #PC             	;Add expression to PC
02614  00EF7E  18            .ADD 		      	CLC
02615  00EF7F  B9 00 00      	                LDA     0,Y
02616  00EF82  65 CF                 	        ADC     HEXVAL
02617  00EF84  99 00 00                      	STA     0,Y
02618  00EF87  B9 01 00                      	LDA     1,Y
02619  00EF8A  65 D0                         	ADC     HEXVAL+1
02620  00EF8C  99 01 00                      	STA     1,Y
02621  00EF8F  60                            	RTS
02622  00EF90  4C 1E F0      .UNDEF          	JMP     DIR_UNDEF       	;Undefined label used!
02623  
02624  00EF93  A9 82         DIR_OPE         	LDA     #ERR_OPE        	;Exit with operand EERROR
02625  00EF95  85 C6                         	STA     ERROR
02626  00EF97  60            DIR_EXIT        	RTS
02627  
02628  ;------------------------------------------------------------------------
02629  ; .BYTE directive Data directive
02630  ;------------------------------------------------------------------------
02631  
02632  00EF98  A9 3C         DIR_DB          	LDA 	#'<'
02633  00EF9A  85 D2         			STA     CHAR            	;Save prefix
02634  00EF9C  80 0A         			BRA	PREFIXDA		;get single bytes
02635  
02636  ;------------------------------------------------------------------------
02637  ; .BYTE directive Data directive
02638  ;------------------------------------------------------------------------
02639  
02640  00EF9E  85 D2         DIR_DA          	STA     CHAR            	;Save prefix
02641  00EFA0  C9 3C                         	CMP     #'<'            	;Low byte only?
02642  00EFA2  F0 04                         	BEQ     PREFIXDA        	;Yes!
02643  00EFA4  C9 3E                         	CMP     #'>'            	;High byte only?
02644  00EFA6  D0 03                         	BNE     NOPREFIX       		;Nope!
02645  00EFA8  E8            PREFIXDA        	INX                     	;Get next character
02646  00EFA9  B5 19                         	LDA     IN,X
02647  00EFAB  20 E3 E6      NOPREFIX        	JSR     GET_EXPRES      	;Evaluate expression
02648  00EFAE  D0 E7                         	BNE     DIR_EXIT        	;An ERROR occurred!
02649  00EFB0  A4 D2                         	LDY     CHAR            	;What prefix was used?
02650  00EFB2  A5 CF                         	LDA     HEXVAL
02651  00EFB4  C0 3C                         	CPY     #'<'
02652  00EFB6  F0 09                         	BEQ     .LOW            	;Low byte only!
02653  00EFB8  C0 3E                         	CPY     #'>'
02654  00EFBA  F0 03                         	BEQ     .HIGH           	;High byte only!
02655  00EFBC  20 2B F0                      	JSR     SAVE_OBJ        	;Save low byte first
02656  00EFBF  A5 D0         .HIGH           	LDA     HEXVAL+1        	;Then save high byte
02657  00EFC1  20 2B F0      .LOW            	JSR     SAVE_OBJ
02658  00EFC4  B5 19                         	LDA     IN,X            	;More parameters
02659  00EFC6  C9 2C                         	CMP     #','
02660  00EFC8  D0 CD                         	BNE     DIR_EXIT        	;Nope!
02661  00EFCA  E8                            	INX
02662  00EFCB  B5 19                         	LDA     IN,X
02663  00EFCD  80 CF                         	BRA     DIR_DA          	;Always taken!
02664  	
02665  ;------------------------------------------------------------------------
02666  ; .EQ directive
02667  ;------------------------------------------------------------------------
02668  
02669  00EFCF  A5 AD         DIR_EQ          	LDA     PASS            	;What pass are we in?
02670  00EFD1  D0 1E                         	BNE     .RTS            	;Don't bother about .EQ during 2!
02671  00EFD3  20 E3 E6                      	JSR     GET_EXPRES      	;Evaluate expression
02672  00EFD6  D0 BB                         	BNE     DIR_OPE         	;An ERROR occurred!
02673  00EFD8  A5 BF                         	LDA     UNDEF           	;Undefined labels are not allowed
02674  00EFDA  D0 1B                         	BNE     UNDEF_ERROR     	;Yes!
02675  00EFDC  A5 19                         	LDA     IN              	;Was a label declared here?
02676  00EFDE  C9 41                         	CMP     #'A'
02677  00EFE0  90 10                         	BCC     NOLABEL         	;Nope!
02678  00EFE2  C9 5B                         	CMP     #'Z'+1
02679  00EFE4  B0 0C                         	BCS     NOLABEL         	;Nope!
02680  00EFE6  A0 01                         	LDY     #1              	;Point to label's value
02681  00EFE8  A5 CF                         	LDA     HEXVAL          	;and change it
02682  00EFEA  91 AE                         	STA     (GLOBAL),Y
02683  00EFEC  C8                            	INY
02684  00EFED  A5 D0                         	LDA     HEXVAL+1
02685  00EFEF  91 AE                         	STA     (GLOBAL),Y
02686  00EFF1  60            .RTS            	RTS
02687  
02688  00EFF2  A9 10         NOLABEL         	LDA     #ERR_LBL        	;Exit with label EERROR		
02689  00EFF4  85 C6                        	 	STA     ERROR
02690  00EFF6  60            DIR_EXIT2       	RTS
02691  
02692  00EFF7  A9 5E         UNDEF_ERROR     	LDA     #ERR_DEF        	;Exit with undefined label ERROR
02693  00EFF9  85 C6                         	STA     ERROR
02694  00EFFB  60                            	RTS
02695  
02696  ;------------------------------------------------------------------------
02697  ; .OR directive
02698  ;------------------------------------------------------------------------
02699  
02700  00EFFC  20 09 E8      DIR_OR       		JSR     PRINT_OBJ       	;Print length of previous block
02701  00EFFF  20 E3 E6                      	JSR     GET_EXPRES      	;Evaluate expression
02702  00F002  D0 1E                         	BNE     FATAL_ERROR2    	;Can't accept errors here!
02703  00F004  84 B6                         	STY     PC              	;Save PC and TA
02704  00F006  85 B7                         	STA     PC+1
02705  00F008  80 08                         	BRA     DIR_TA2         	;Always taken!
02706  
02707  ;------------------------------------------------------------------------
02708  ; .TA directive
02709  ;------------------------------------------------------------------------
02710  
02711  00F00A  20 09 E8      DIR_TA          	JSR     PRINT_OBJ       	;Print length of previous block
02712  00F00D  20 E3 E6                      	JSR     GET_EXPRES      	;Evaluate expression
02713  00F010  D0 16                         	BNE     DIR_OPE2        	;An EERROR occurred!
02714  00F012  84 B8         DIR_TA2         	STY     TA              	;Save target address
02715  00F014  84 BA                         	STY     TA_BEGIN
02716  00F016  85 B9                         	STA     TA+1
02717  00F018  85 BB                         	STA     TA_BEGIN+1
02718  00F01A  A5 BF                         	LDA     UNDEF           	;Undefined label used?
02719  00F01C  F0 D8                         	BEQ     DIR_EXIT2       	;Nope! We're done now
02720  
02721  00F01E  A9 5E         DIR_UNDEF       	LDA     #ERR_DEF        	;Can't allow undefined labels!
02722  00F020  85 C6         FATAL_ERROR     	STA     ERROR
02723  00F022  20 AE EE      FATAL_ERROR2    	JSR     CHCK_ERROR      	;Print the error
02724  00F025  4C 09 E0                      	JMP     GETLINE         	;And abort assembly! Fatal EERROR
02725  00F028  4C 93 EF      DIR_OPE2        	JMP     DIR_OPE         	;Operand EERROR
02726  
02727  
02728  
02729  ;------------------------------------------------------------------------
02730  ; Save byte to target
02731  ;------------------------------------------------------------------------
02732  
02733  00F02B  A4 AD         SAVE_OBJ   		LDY     PASS            	;What pass?
02734  00F02D  F0 2E         	                BEQ     .INCPC          	;Pass 1! Don't save anything
02735  00F02F  48                    	        PHA
02736  00F030  A4 B8                         	LDY     TA              	;See if below standard safe limit
02737  00F032  C4 00                         	CPY     <DEF_OBJLOW
02738  00F034  A5 B9                         	LDA     TA+1
02739  00F036  E5 02                         	SBC     >DEF_OBJLOW
02740  00F038  90 08                         	BCC     .USR            	;Below default safe range!
02741  00F03A  C4 EF                         	CPY     LOMEM           	;See if it's above LOMEM now
02742  00F03C  A5 B9                         	LDA     TA+1
02743  00F03E  E5 F0                         	SBC     LOMEM+1
02744  00F040  90 10                         	BCC     .SAFE           	;We're in safe range!
02745  
02746  00F042  C4 EB         .USR            	CPY     USR_OBJLO       	;See if below user safe limit
02747  00F044  A5 B9                         	LDA     TA+1
02748  00F046  E5 EC                         	SBC     USR_OBJLO+1
02749  00F048  90 1A                         	BCC     MEM_FULL        	;Yes! Exit with ERROR
02750  00F04A  C4 ED                         	CPY     USR_OBJHI       	;See if it's above user safe limit
02751  00F04C  A5 B9                         	LDA     TA+1
02752  00F04E  E5 EE                         	SBC     USR_OBJHI+1
02753  00F050  B0 12                         	BCS     MEM_FULL        	;Yes! Exit with ERROR
02754  
02755  00F052  68            .SAFE           	PLA
02756  00F053  A0 00                         	LDY     #0
02757  00F055  91 B8                         	STA     (TA),Y          	;Save byte
02758  00F057  E6 B8                         	INC     TA              	;Increment target address
02759  00F059  D0 02                         	BNE     .INCPC          	;No carry!
02760  00F05B  E6 B9                         	INC     TA+1
02761  
02762  00F05D  E6 B6         .INCPC          	INC     PC              	;Increment PC
02763  00F05F  D0 02                         	BNE     .RTS            	;No carry!
02764  00F061  E6 B7                         	INC     PC+1
02765  00F063  60            .RTS            	RTS
02766  
02767  00F064  A9 51         MEM_FULL        	LDA     #ERR_MEM        	;Exit with fatal memory ERROR
02768  00F066  80 B8                         	BRA     FATAL_ERROR     	;(ignoring the stack)
02769                  	
02770  ;------------------------------------------------------------------------
02771  ;Fill F start range value
02772  ;------------------------------------------------------------------------ 
02773    
02774  00F068  20 DE E5      CMD_FILL		JSR     GET_VAL    		;Fill Memory
02775  00F06B  84 F1         			STY     HIMEM			;Get start address
02776  00F06D  85 F2                         	STA     HIMEM+1  
02777  00F06F  E8                            	INX
02778  00F070  20 DE E5      			JSR     GET_VAL     		;Get RANGE 
02779  00F073  84 DA         			STY	LENG
02780  00F075  85 DB         			STA	LENG+1
02781  00F077  E8            			INX
02782  00F078  20 DE E5      			JSR     GET_VAL     		;FILL value
02783  00F07B  98            		        TYA 
02784  00F07C  A6 DB         .USERFILL 		LDX  	LENG+1		
02785  00F07E  F0 0F                  		BEQ  	.FILEFT   	
02786  00F080  A0 00                  		LDY  	#$00     	
02787  00F082  20 D9 E5      .PGFILL   		JSR	PROBE
02788  00F085  D0 18         			BNE	.WRERROR	
02789  00F087  C8                     		INY           		
02790  00F088  D0 F8                  		BNE  	.PGFILL   	
02791  00F08A  E6 F2                  		INC 	HIMEM+1   
02792  00F08C  CA                     		DEX           
02793  00F08D  D0 F3                  		BNE  	.PGFILL   
02794  00F08F  A6 DA         .FILEFT   		LDX  	LENG    
02795  00F091  F0 0B                  		BEQ  	.DONEFILL 
02796  00F093  A0 00                  		LDY  	#$00     
02797  00F095  20 D9 E5      .FILAST   		JSR	PROBE
02798  00F098  D0 05         			BNE	.WRERROR
02799  00F09A  C8                     		INY           
02800  00F09B  CA                     		DEX           
02801  00F09C  D0 F7                  		BNE  	.FILAST   
02802  00F09E  60            .DONEFILL 		RTS           	
02803  00F09F  A9 A9         .WRERROR		LDA 	#ERR_WRT					
02804  00F0A1  85 C6         			STA	ERROR			
02805  00F0A3  60            			RTS
02806  		
02807  ;------------------------------------------------------------------------
02808  ;  Expand the size of the symbol table by A
02809  ;  Presuming DEST points to current end flag ($00)
02810  ;  Warning END flag is not moved! Must be done by calling routine!
02811  ;------------------------------------------------------------------------
02812  
02813  00F0A4  18            EXP_SYM        	 	CLC                     	;See if there's enough room to
02814  00F0A5  65 DE                         	ADC     DEST            	;expand
02815  00F0A7  85 DA                         	STA     LENG
02816  00F0A9  A9 00                         	LDA     #0
02817  00F0AB  A8                            	TAY                     	;Point to first byte in new space
02818  00F0AC  65 DF                         	ADC     DEST+1
02819  00F0AE  85 DB                         	STA     LENG+1
02820  00F0B0  A5 F1                 	        LDA     HIMEM           	;See if there's enough room
02821  00F0B2  C5 DA         	                CMP     LENG            	;for it
02822  00F0B4  A5 F2                         	LDA     HIMEM+1
02823  00F0B6  E5 DB                         	SBC     LENG+1
02824  00F0B8  90 AA                         	BCC     MEM_FULL        	;Memory full!
02825  00F0BA  60                            	RTS
02826  
02827  ;------------------------------------------------------------------------
02828  ; Find label in symbol table
02829  ; Upon exit:
02830  ; C=1 if not a legal label name was given
02831  ; Z=1 if label not found
02832  ; X will always point to end of label name + 1 in parse buffer
02833  ; Y will always be 0
02834  ; DEST will point at global label (or end of symbol table $00)
02835  ; DEST will point at local label (or end of local labels $FF)
02836  ;------------------------------------------------------------------------
02837  
02838  00F0BB  A5 EA         FIND_LABEL      	LDA     SYM_TABLE+1     	;Is symbol table valid?
02839  00F0BD  F0 13                         	BEQ     .NOSYM          	;Nope!
02840  00F0BF  B5 19                         	LDA     IN,X            	;Save first character of label
02841  00F0C1  85 C2                         	STA     FIRST_CHAR
02842  00F0C3  C9 2E                         	CMP     #'.'            	;Is it a local label?
02843  00F0C5  F0 14                         	BEQ     FIND_LOCAL      	;Yes!
02844  	
02845  00F0C7  C9 41         	                CMP     #'A'            	;First character must be A-Z
02846  00F0C9  90 0E                 	        BCC     NO_LABEL        	;It's not!
02847  00F0CB  C9 5B                         	CMP     #'Z'+1
02848  00F0CD  B0 0A                         	BCS     NO_LABEL        	;It's not!
02849  	
02850  00F0CF  4C 30 F1              	        JMP     FIND_GLOBAL     	;Find global label
02851  ;        	       	BEQ	.CHECK_ROM_GLOBAL	;didnt find 
02852  ;        	       	RTS
02853          	        
02854  ;.CHECK_ROM_GLOBAL      	LDX     SAVE_Y 
02855  ;			JMP 	FIND_GLOBAL_ROM	        ;check ROM libray        
02856  ;			BNE	.RTS		
02857  	
02858  00F0D2  18            .NOSYM          	CLC                     	;Indicate label given
02859  00F0D3  20 F7 EF                      	JSR     UNDEF_ERROR     	;Exit with undefined label ERROR
02860  00F0D6  A9 00                         	LDA     #0              	;Make Z=0 meaning label not found
02861  00F0D8  60            .RTS                	RTS
02862  
02863  00F0D9  38            NO_LABEL        	SEC                    	 	;Indicate no label given
02864  00F0DA  60            	               	RTS
02865  
02866  ;------------------------------------------------------------------------
02867  ; Find a local label in the symbol table
02868  ;------------------------------------------------------------------------
02869  
02870  00F0DB  A5 AE         FIND_LOCAL      	LDA     GLOBAL          	;Start looking from the begin of
02871  00F0DD  85 DE         	                STA     DEST            	;the last assigned global label
02872  00F0DF  A5 AF         	                LDA     GLOBAL+1
02873  00F0E1  85 DF         	                STA     DEST+1
02874  00F0E3  F0 F4         	                BEQ     NO_LABEL        	;No global label ERROR!
02875  00F0E5  E8            	                INX                     	;Next char must be a digit!
02876  00F0E6  B5 19         	                LDA     IN,X
02877  00F0E8  C9 30         	                CMP     #'0'
02878  00F0EA  90 ED         	                BCC     NO_LABEL        	;It's not!
02879  00F0EC  C9 3A         	                CMP     #'9'+1
02880  00F0EE  B0 E9         	                BCS     NO_LABEL        	;It's not!
02881  	
02882  00F0F0  20 DE E5      	                JSR     GET_VAL         	;Get local label number
02883  00F0F3  A5 CF         	                LDA     HEXVAL
02884  00F0F5  85 C1         	                STA     LL_NUM
02885  00F0F7  C9 64         	                CMP     #100            	;Value must be below 100!
02886  00F0F9  B0 DE         	                BCS     NO_LABEL        	;It is not!
02887  00F0FB  A5 D0         	                LDA     HEXVAL+1
02888  00F0FD  D0 DA         	                BNE     NO_LABEL        	;It is not!
02889  	
02890  00F0FF  A0 03         	                LDY     #5-2            	;Point to start of local labels
02891  00F101  C8            .LOOP           	INY                     	;Each record contains 2 bytes
02892  00F102  C8            	                INY
02893  00F103  B1 DE         	                LDA     (DEST),Y        	;Could it be this one?
02894  00F105  C9 FF         	                CMP     #$FF
02895  00F107  F0 15         	                BEQ     .DONE           	;Nope! End of record
02896  00F109  29 7F         	                AND     #%01111111      	;Ignore label declared flag !!!
02897  00F10B  C5 C1         	                CMP     LL_NUM
02898  00F10D  D0 F2         	                BNE     .LOOP           	;It's not this one!
02899  	
02900  00F10F  C8            	                INY
02901  00F110  18            	                CLC                     	;Add label's offset to global
02902  00F111  A5 B0         	                LDA     GLOBAL_VAL      	; label's value
02903  00F113  71 DE         	                ADC     (DEST),Y
02904  00F115  85 CF         	                STA     HEXVAL
02905  00F117  A5 B1         	                LDA     GLOBAL_VAL+1
02906  00F119  69 00         	                ADC     #0
02907  00F11B  85 D0         	                STA     HEXVAL+1
02908  00F11D  88            	                DEY
02909  
02910  00F11E  18            .DONE           	CLC                     	;Add offset to pointer
02911  00F11F  98            	                TYA
02912  00F120  65 DE         	                ADC     DEST
02913  00F122  85 DE         	                STA     DEST
02914  00F124  90 02         	                BCC     .NOCY           	;No carry
02915  00F126  E6 DF         	                INC     DEST+1
02916  00F128  A0 00         .NOCY           	LDY     #0              	;Now clear Y (points to same addr)
02917  00F12A  B1 DE         	                LDA     (DEST),Y        	;Set/clear label found flag
02918  00F12C  C9 FF         	                CMP     #$FF            	;Z=1 if label not found
02919  00F12E  18            	                CLC                     	;There was no EERROR in label name
02920  00F12F  60            	                RTS
02921  ;------------------------------------------------------------------------
02922  ; Find a global label in the symbol table
02923  ; Record is: {first letter + $80, Address lo, hi, ptr string lo, hi, $ff} 
02924  ;------------------------------------------------------------------------
02925  ;FIND_GLOBAL_ROM     	LDA     #<SYM_TABLE_ROM       	;Start looking from the begin of
02926  ;	                STA     DEST            	; the symbol table
02927  ;	                LDA     #>SYM_TABLE_ROM
02928  ;	                STA     DEST+1
02929  ;	                BRA	FIND_GLOBAL_SRCH
02930  
02931  
02932  ;.FND_GLOBAL     	STX     SAVE_Y 
02933  ;			JSR	SEEK_END
02934  ;
02935  ;			LDY     #0              	;Outer search loop
02936  ;	                LDA     (DEST),Y
02937  ;	                BEQ     .EXIT           	;End of symbol table reached!	                
02938  ;	                AND     #%01111111      	;Ignore declared flag
02939  ;	                CMP     FIRST_CHAR      	;Should we bother looking further?
02940  ;	                BNE     .FAIL           	;Nope! Find next global label
02941  ;	
02942  ;	                LDX     SAVE_Y          	;Point to begin of label again
02943  ;	                ;LDY     #01              	;Get pointer to label's name
02944  ;	                LDA     DEST+1        		; in source file
02945  ;	                STA     SRCE+1          	;(Going backwards leaves Y=3)	                
02946  ;	                LDA     DEST
02947  ;	                STA     SRCE
02948  ;	                JSR	CMP_STRING 
02949   ;               
02950  ;			BMI	EXIT_FIND_GLOBAL               
02951  ;.FAIL			JSR	FIND_NEXT
02952  ;			BCC     .FND_GLOBAL     	;No carry needed!
02953  ;	                INC     DEST+1
02954  ;	                BRA     .FND_GLOBAL     	;Always taken!	                
02955  
02956  ;------------------------------------------------------------------------
02957  ; Find a End of record 
02958  ; Record is: {first letter + $80, Address lo, hi, ptr string lo, hi, $ff} 
02959  ;------------------------------------------------------------------------
02960  
02961  ;SEEK_END       		STX     SAVE_Y 			;Save start of label name
02962  ;			INX                     	;Find end of label we're looking
02963  ;	                LDA     IN,X            	; for
02964  ;	                CMP     #'.'
02965  ;	                BEQ     .SEEK_END       	;Not end yet!
02966  ;	                CMP     #'0'
02967  ;	                BCC     .FOUND_END      	;End!
02968  ;	                CMP     #'9'+1
02969  ;	                BCC     .SEEK_END
02970  ;	                CMP     #'A'
02971  ;	                BCC     .FOUND_END      	;End!
02972  ;	                CMP     #'Z'+1
02973  ;	                BCC     .SEEK_END
02974  ;.FOUND_END              STX     DELIM           	;Character must be restored later!
02975  ;			RTS
02976  
02977  ;------------------------------------------------------------------------
02978  ; Find a End of record 
02979  ; Record is: {first letter + $80, Address lo, hi, ptr string lo, hi, $ff} 
02980  ;------------------------------------------------------------------------
02981  
02982  ;FIND_NEXT		LDY     #5              	;Find next label
02983  ;.NXT_GLOBAL    		LDA     (DEST),Y        	;Try to find $FF which signals
02984  ;	                INY                     	; the end of this label
02985  ;	                CMP     #$FF
02986  ;	                BNE     .NXT_GLOBAL     	;Not yet!
02987  ;	                TYA                     	;Add current offset to DEST
02988  ;	                CLC
02989  ;	                ADC     DEST
02990  ;	                STA     DEST
02991  ;	                RTS
02992  		
02993  ;------------------------------------------------------------------------
02994  ; Find a global label in the symbol table
02995  ; Record is: {first letter + $80, Address lo, hi, ptr string lo, hi, $ff} 
02996  ;------------------------------------------------------------------------
02997  
02998  ;CMP_STRING     		LDA     IN,X            	;Compare strings
02999  ;	                BMI     .EOL            	;End of label reached! 
03000  ;	                CMP     (SRCE),Y        	;Do they still match?
03001  ;	                BNE     .EOL	           	;Nope!
03002  ;	                INX
03003  ;	                INY
03004  ;	                BNE     .CMP_GLOBAL     	;Keep trying! Always taken until 00
03005  ;.FAIL			SEC	                
03006  ;.EOL			RTS
03007  			
03008  
03009  ;------------------------------------------------------------------------
03010  ; Find a global label in the symbol table
03011  ;------------------------------------------------------------------------
03012  
03013  00F130  A5 E9         FIND_GLOBAL     	LDA     SYM_TABLE       	;Start looking from the begin of
03014  00F132  85 DE         	                STA     DEST            	; the symbol table
03015  00F134  A5 EA         	                LDA     SYM_TABLE+1
03016  00F136  85 DF         	                STA     DEST+1
03017  
03018  00F138  86 D9         FIND_GLOBAL_SRCH       	STX     SAVE_Y          	;Save start of label name
03019  00F13A  E8            .MARK_END       	INX                     	;Find end of label we're looking
03020  00F13B  B5 19         	                LDA     IN,X            	; for
03021  00F13D  C9 2E         	                CMP     #'.'
03022  00F13F  F0 F9         	                BEQ     .MARK_END       	;Not end yet!
03023  00F141  C9 30         	                CMP     #'0'
03024  00F143  90 0C         	                BCC     .FOUND_END      	;End!
03025  00F145  C9 3A         	                CMP     #'9'+1
03026  00F147  90 F1         	                BCC     .MARK_END
03027  00F149  C9 41         	                CMP     #'A'
03028  00F14B  90 04         	                BCC     .FOUND_END      	;End!
03029  00F14D  C9 5B         	                CMP     #'Z'+1
03030  00F14F  90 E9         	                BCC     .MARK_END
03031  00F151  86 CE         .FOUND_END      	STX     DELIM           	;Character must be restored later!
03032                  	;AND     #%01111111      	;Temporarily mark end of label = z=1
03033  00F153  09 80                         	ORA     #%10000000     		;Ignore declared flag
03034  00F155  95 19                         	STA     IN,X
03035  
03036  00F157  A0 00         .FND_GLOBAL     	LDY     #0              	;Outer search loop
03037  00F159  B1 DE         	                LDA     (DEST),Y
03038  00F15B  F0 27         	                BEQ     .EXIT           	;End of symbol table reached!
03039  	                ;ORA     #%10000000     	;Ignore declared flag
03040  00F15D  29 7F         	                AND     #%01111111      	;Ignore declared flag
03041  00F15F  C5 C2         	                CMP     FIRST_CHAR      	;Should we bother looking further?
03042  00F161  D0 45         	                BNE     .FAIL           	;Nope! Find next global label
03043  	
03044  00F163  A6 D9         	                LDX     SAVE_Y          	;Point to begin of label again
03045  00F165  A0 04         	                LDY     #4              	;Get pointer to label's name
03046  00F167  B1 DE         	                LDA     (DEST),Y        	; in source file
03047  00F169  85 DD         	                STA     SRCE+1          	;(Going backwards leaves Y=3)
03048  00F16B  88            	                DEY
03049  00F16C  B1 DE         	                LDA     (DEST),Y
03050  00F16E  85 DC         	                STA     SRCE
03051  
03052  00F170  B5 19         .CMP_GLOBAL     	LDA     IN,X            	;Compare strings
03053  00F172  30 08         	                BMI     .EOL            	;End of label reached! 
03054  00F174  D1 DC         	                CMP     (SRCE),Y        	;Do they still match?
03055  00F176  D0 30         	                BNE     .FAIL           	;Nope!
03056  00F178  E8            	                INX
03057  00F179  C8            	                INY
03058  00F17A  D0 F4         	                BNE     .CMP_GLOBAL     	;Keep trying! Always taken
03059  
03060  00F17C  B1 DC         .EOL            	LDA     (SRCE),Y        	;Is label in source also at end?
03061  00F17E  30 04                         	BMI     .EXIT          	 	;Yes! (packed space or LineLeng)
03062  00F180  C9 3A                         	CMP     #':'
03063  00F182  D0 24                         	BNE     .FAIL           	;Nope!
03064  
03065  00F184  A6 CE         .EXIT           	LDX     DELIM           	;Label found or at end of symtab
03066  00F186  B5 19                        	 	LDA     IN,X            	;Restore end of label marker
03067  	                ;ORA     #%10000000		;only used for apple
03068  00F188  29 7F         	                AND     #%01111111
03069  00F18A  95 19         	                STA     IN,X
03070  00F18C  A0 00         	                LDY     #0
03071  00F18E  B1 DE         	                LDA     (DEST),Y        	;A will be 0 if label not found
03072  00F190  F0 14         	                BEQ     .RTS            	;Label not found!
03073  00F192  49 80         	                EOR     #%10000000      	;Save label's assigned flag
03074  	                ;AND     #%10000000      	;  (inverted!)
03075  00F194  25 AD         	                AND     PASS            	;Remains 0 if pass 1
03076  00F196  85 B2         	                STA     LABEL_FLAG
03077  00F198  C8            	                INY
03078  00F199  B1 DE         	                LDA     (DEST),Y        	;Save label's value
03079  00F19B  85 CF         	                STA     HEXVAL
03080  00F19D  C8            	                INY
03081  00F19E  B1 DE         	                LDA     (DEST),Y
03082  00F1A0  85 D0         	                STA     HEXVAL+1
03083  00F1A2  A0 00         	                LDY     #0              	;Restore pointer
03084  00F1A4  A5 C2         	                LDA     FIRST_CHAR      	; and first char (Z=0)
03085  00F1A6  18            .RTS            	CLC                     	;There was no EERROR in label name
03086  00F1A7  60            	                RTS
03087  	
03088  00F1A8  A0 05         .FAIL          	 	LDY     #5              	;Find next label
03089  00F1AA  B1 DE         .NXT_GLOBAL    		LDA     (DEST),Y        	;Try to find $FF which signals
03090  00F1AC  C8            	                INY                     	; the end of this label
03091  00F1AD  C9 FF         	                CMP     #$FF
03092  00F1AF  D0 F9         	                BNE     .NXT_GLOBAL     	;Not yet!
03093  00F1B1  98            	                TYA                     	;Add current offset to DEST
03094  00F1B2  18            	                CLC
03095  00F1B3  65 DE         	                ADC     DEST
03096  00F1B5  85 DE         	                STA     DEST
03097  00F1B7  90 9E         	                BCC     .FND_GLOBAL     	;No carry needed!
03098  00F1B9  E6 DF         	                INC     DEST+1
03099  00F1BB  80 9A         	                BRA     .FND_GLOBAL     	;Always taken!		
03100  ;------------------------------------------------------------------------
03101  ; Find a global label in the symbol table
03102  ; Record is: {first letter + $80, Address lo, hi, ptr string lo, hi, $ff} 
03103  ;------------------------------------------------------------------------
03104  
03105  ;NEWFIND_GLOBAL     	LDA     SYM_TABLE       	;Start looking from the begin of
03106  ;	                STA     DEST            	; the symbol table
03107  ;	                LDA     SYM_TABLE+1
03108  ;	                STA     DEST+1
03109  ;
03110  ;               	JSR	SEEK_END		;find end of label     	
03111  ;	              	ORA     #%10000000     		;Ignore declared flag
03112  ;                	STA     IN,X			; mark the
03113  ;
03114  ;.FND_GLOBAL     	LDY     #0              	;Outer search loop
03115  ;	                LDA     (DEST),Y
03116  ;	                BEQ     .EXIT           	;End of symbol table reached!	                
03117  ;	                AND     #%01111111      	;Ignore declared flag
03118  ;	                CMP     FIRST_CHAR      	;Should we bother looking further?
03119  ;	                BNE     .FAIL           	;Nope! Find next global label
03120  ;	
03121  ;	                LDX     SAVE_Y          	;Point to begin of label again
03122  ;	                LDY     #4              	;Get pointer to label's name
03123  ;	                LDA     (DEST),Y        	; in source file
03124  ;	                STA     SRCE+1          	;(Going backwards leaves Y=3)
03125  ;	                DEY
03126  ;	                LDA     (DEST),Y
03127  ;	                STA     SRCE
03128  ;
03129  ;			JSR	CMP_STRING 
03130  ;			BPL	.FAIL
03131  ;			
03132  ;.EOL            	LDA     (SRCE),Y        	;Is label in source also at end?
03133  ;                	BMI     .EXIT          	 	;Yes! (packed space or LineLeng)
03134  ;               	CMP     #':'
03135  ;                	BNE     .FAIL           	;Nope!
03136  ;
03137  ;EXIT_FIND_GLOBAL      	LDX     DELIM           	;Label found or at end of symtab
03138  ;               	 	LDA     IN,X            	;Restore end of label marker	                
03139  ;	                AND     #%01111111
03140  ;	                STA     IN,X
03141  ;	                LDY     #0
03142  ;	                LDA     (DEST),Y        	;A will be 0 if label not found
03143  ;	                BEQ     .RTS     		;Label not found!
03144  ;	                EOR     #%10000000      	;Save label's assigned flag	                
03145  ;	                AND     PASS            	;Remains 0 if pass 1
03146  ;	                STA     LABEL_FLAG
03147  ;	                INY
03148  ;	                LDA     (DEST),Y        	;Save label's value
03149  ;	                STA     HEXVAL
03150  ;	                INY
03151  ;	                LDA     (DEST),Y
03152  ;	                STA     HEXVAL+1
03153  ;	                LDY     #0              	;Restore pointer
03154  ;	                LDA     FIRST_CHAR      	; and first char (Z=0)
03155  ;.RTS            	CLC                     	;There was no ERROR in label name
03156  ;	                RTS
03157  ;	
03158  ;.FAIL          	 	JSR	FIND_NEXT
03159  ;	                BCC     .FND_GLOBAL     	;No carry needed!
03160  ;	                INC     DEST+1
03161  ;	                BRA     .FND_GLOBAL     	;Always taken!
03162  ;
03163  ;------------------------------------------------------------------------
03164  ; Add label
03165  ;------------------------------------------------------------------------
03166  
03167  00F1BD  20 BB F0      ADD_LABEL       	JSR     FIND_LABEL      	;Find label in symbol table
03168  00F1C0  B0 44         	                BCS     .LBL_ERR        	;It was not a valid label!
03169  00F1C2  D0 47         	                BNE     .FOUND_IT       	;Found the label!
03170  00F1C4  A5 C2         	                LDA     FIRST_CHAR      	;What type of label is it?
03171  00F1C6  C9 2E         	                CMP     #'.'
03172  00F1C8  F0 56         	                BEQ     .ADD_LOCAL      	;It is a local label!
03173  	
03174  00F1CA  A9 06         	                LDA     #6              	;Make room for 6 bytes in the
03175  00F1CC  20 A4 F0      	                JSR     EXP_SYM         	; symbol table
03176  00F1CF  A5 C2         	                LDA     FIRST_CHAR      	;Save first character of label
03177  ; 		         AND     #%01111111     	; in symbol table (clear declared
03178  00F1D1  91 DE         	                STA     (DEST),Y        	;  flag first)
03179  00F1D3  C8            	                INY
03180  00F1D4  A5 B6         	                LDA     PC              	;Place current PC into symbol
03181  00F1D6  91 DE         	                STA     (DEST),Y        	; table
03182  00F1D8  C8            	                INY
03183  00F1D9  A5 B7         	                LDA     PC+1
03184  00F1DB  91 DE         	                STA     (DEST),Y
03185  00F1DD  C8            	                INY                     	;Place source pointer in symbol
03186  00F1DE  A5 B3         	                LDA     PNTR            	; table (where the label name
03187  00F1E0  91 DE         	                STA     (DEST),Y        	;  can be found)
03188  00F1E2  C8            	                INY
03189  00F1E3  A5 B4         	                LDA     PNTR+1
03190  00F1E5  20 47 F2      	                JSR     SAVE_ENDSYM     	;Save last 3 bytes of symbol table
03191  
03192  00F1E8  A5 DE         .COPY_GLOBAL    	LDA     DEST            	;Copy symbol table pointer
03193  00F1EA  85 AE         	                STA     GLOBAL          	; to last global label
03194  00F1EC  A5 DF         	                LDA     DEST+1
03195  00F1EE  85 AF         	                STA     GLOBAL+1
03196  00F1F0  A0 01         	                LDY     #1              	;Copy last global label's value
03197  00F1F2  B1 DE         	                LDA     (DEST),Y
03198  00F1F4  85 B0         	                STA     GLOBAL_VAL
03199  00F1F6  C8            	                INY
03200  00F1F7  B1 DE         	                LDA     (DEST),Y
03201  00F1F9  85 B1         	                STA     GLOBAL_VAL+1
03202  00F1FB  CA            	                DEX
03203  
03204  00F1FC  20 41 F2      .BLANK          	JSR     NEXT_IN         	;Find first blank or EOL
03205  00F1FF  F0 04                         	BEQ     .RTS            	;EOL!
03206  00F201  C9 20                         	CMP     #SP
03207  00F203  D0 F7                         	BNE     .BLANK          	;Try again!
03208  00F205  60            .RTS            	RTS
03209  
03210  00F206  20 F2 EF      .LBL_ERR        	JSR     NOLABEL         	;Exit with label EERROR
03211  00F209  D0 F1                         	BNE     .BLANK          	;Always taken!
03212  
03213  00F20B  A5 AD         .FOUND_IT       	LDA     PASS            	;What pass are we in?
03214  00F20D  F0 0D         	                BEQ     .EXT_DEF        	;Pass 1! Extra definition
03215  	
03216  00F20F  B1 DE         	                LDA     (DEST),Y        	;Set declared flag in pass 2
03217  00F211  09 80         	                ORA     #%10000000
03218  00F213  91 DE         	                STA     (DEST),Y
03219  	
03220  00F215  A5 C2         	                LDA     FIRST_CHAR      	;What type was the label?
03221  00F217  C9 2E         	                CMP     #'.'
03222  00F219  D0 CD         	                BNE     .COPY_GLOBAL    	;Copy last global label pointer
03223  00F21B  60            	                RTS
03224  
03225  00F21C  A9 96         .EXT_DEF        	LDA     #ERR_EXT        	;Exit with extra definition EERROR
03226  00F21E  80 1A                         	BRA	SET_ERROR
03227  
03228  00F220  A9 02         .ADD_LOCAL      	LDA     #2              	;Make room for 2 bytes in the
03229  00F222  20 A4 F0                      	JSR     EXP_SYM         	; symbol table
03230  00F225  A5 C1                         	LDA     LL_NUM          	;Save label number in symbol
03231  00F227  91 DE                         	STA     (DEST),Y        	;  table
03232  00F229  C8                            	INY
03233  00F22A  38                            	SEC                     	;Calculate offset from last global
03234  00F22B  A5 B6                         	LDA     PC
03235  00F22D  E5 B0                         	SBC     GLOBAL_VAL
03236  00F22F  20 47 F2                      	JSR     SAVE_ENDSYM     	;Save last 3 bytes of symbol table
03237  
03238  00F232  A5 B7                         	LDA     PC+1            	;Check offset range now
03239  00F234  E5 B1                         	SBC     GLOBAL_VAL+1
03240  00F236  F0 CD                         	BEQ     .RTS            	;Range is OK!
03241  
03242  ;------------------------------------------------------------------------
03243  ; Set RANGE and set ERRRO
03244  ;------------------------------------------------------------------------
03245  00F238  A9 17         RANGE_ERROR     	LDA     #ERR_RNG        	;Exit with range EERROR
03246  00F23A  85 C6         SET_ERROR       	STA     ERROR
03247  00F23C  4C 0C F5                      	JMP	BAD			;set Y=FAIL
03248  
03249  ;------------------------------------------------------------------------
03250  ; Get next char from input buffer and compare it with CR
03251  ;------------------------------------------------------------------------
03252  
03253  00F23F  A0 00         NEXT_IN_Y0      	LDY     #0              	;Clear Y for different purposes
03254  00F241  E8            NEXT_IN         	INX                     	;Well, let's do just that!
03255  00F242  B5 19         IN_CR           	LDA     IN,X
03256  00F244  C9 0D                         	CMP     #CR
03257  00F246  60                            	RTS
03258  
03259  ;------------------------------------------------------------------------
03260  ; Save last 3 bytes to symbol table to save some code
03261  ;------------------------------------------------------------------------
03262  
03263  00F247  91 DE         SAVE_ENDSYM     	STA     (DEST),Y        	;Save low byte of offset only
03264  00F249  C8                            	INY
03265  00F24A  A9 FF                         	LDA     #$FF            	;Save end of label marker
03266  00F24C  91 DE                         	STA     (DEST),Y
03267  00F24E  C8                            	INY
03268  00F24F  A9 00                         	LDA     #0              	;Save new end of symbol table flag
03269  00F251  91 DE                         	STA     (DEST),Y
03270  00F253  60                            	RTS
03271  
03272  
03273  	.include	"Dissassembler Lib.65s"
03274  ; LIBRARY FILE
03275  ; version 2.09
03276  ; two pass assembler, dissembler and tracer- inspiration with permission from A1 by San Bergmans
03277  ; REGB bits 0-3 are connected to LED's
03278  ; tested in Michael Kowalski 6502 Simulator - using 65C02 Code 
03279  ; "Programmed" by Joe DiMeglio
03280  		 
03281  
03282  ;------------------------------------------------------------------------
03283  ; Decode mnemonic and operand
03284  ;------------------------------------------------------------------------
03285  
03286  00F254  20 5B F2      MNEMON         		JSR	CMPMNE			;AC = has left MNE :THEN FND INDEX AND SAVE IT IN	
03287  00F257  20 E8 F2      			JSR	CALCAM			;Calculate addres 		
03288  00F25A  60            .MNE_ERR        	RTS
03289  
03290  ;------------------------------------------------------------------------
03291  ; Compress MEN into PARM1 & PARM1+1
03292  ; X points to the index in the keyboard IN
03293  ;------------------------------------------------------------------------
03294  
03295  00F25B  DA            CMPMNE			PHX				;save X index to keyboard buffer
03296  00F25C  18            			CLC				;AC = has left MNE
03297  00F25D  66 C8         			ROR 	PARM1						
03298  00F25F  8A            			TXA
03299  00F260  18            			CLC
03300  00F261  69 19         			ADC	#IN			;Calc IN address + X
03301  00F263  85 DC         			STA	SRCE
03302  00F265  64 DD         			STZ	SRCE+1			;*** Could be removed if ZP load
03303  00F267  A0 02         			LDY 	#$02			;Three letters
03304  00F269  38            .NEXT2			SEC
03305  00F26A  B1 DC         			LDA     (SRCE),Y 		;get the letters SHOULD BE ZERO Page load
03306  00F26C  E9 40         			SBC 	#'A'-1
03307  00F26E  A2 05         			LDX 	#$05			;shift
03308  00F270  4A            .NEXTROT		LSR
03309  00F271  66 C8         			ROR 	PARM1
03310  00F273  66 C9         			ROR 	PARM1+1
03311  00F275  CA            			DEX
03312  00F276  D0 F8         			BNE 	.NEXTROT
03313  00F278  88            			DEY
03314  00F279  10 EE         			BPL 	.NEXT2			;Nemonic now compressed		
03315  00F27B  A2 42         			LDX 	#NUMMN			;Number of mnemonics to search through
03316  00F27D  BD 09 F3      .LOOP			LDA 	LMNETB-1,X		;search 
03317  00F280  C5 C8         			CMP 	PARM1
03318  00F282  D0 07         			BNE 	.NXT
03319  00F284  BD 4B F3      			LDA 	RMNETB-1,X
03320  00F287  C5 C9         			CMP 	PARM1+1
03321  00F289  F0 03         			BEQ 	.FND
03322  00F28B  CA            .NXT			DEX
03323  00F28C  D0 EF         			BNE 	.LOOP
03324  00F28E  CA            .FND			DEX				;X = $FF for failure
03325  00F28F  86 C3         			STX	CURMNE 
03326  00F291  FA            			PLX				;restore X 
03327  00F292  E8            			INX
03328  00F293  E8            			INX
03329  00F294  E8            			INX				;Adjust the buffer index to point to next Char
03330  00F295  60            			RTS		
03331  
03332  ;.ERR		LDA	#01
03333  		;STA	ERROR		
03334  		;RTS
03335  
03336  
03337  ;------------------------------------------------------------------------
03338  ; Make Object code from NME
03339  ; MNE is in CURMNE, addr mode is in CURADM
03340  ; and the args are in HEXVAL,H
03341  ; calculate the object code, and update PC
03342  ;------------------------------------------------------------------------
03343  
03344  00F296  A4 C3         MKOBJC			LDY 	CURMNE			;Index to the table
03345  00F298  B9 AC F3      			LDA 	BASE,Y			;get base value for current mnemonic
03346  00F29B  A6 C4         			LDX 	CURADM			;ADdress mode
03347  00F29D  18            			CLC
03348  00F29E  7D EE F3      			ADC 	OFFSET,X		;add in the offset	
03349  00F2A1  E0 0C         .NOSTZ			CPX 	#ABY			;handle exceptions
03350  00F2A3  F0 14         			BEQ 	.CHABY
03351  00F2A5  E0 02         			CPX 	#IMM
03352  00F2A7  D0 17         			BNE 	.CONT
03353  00F2A9  C0 22         			CPY 	#$22			;check if BIT first
03354  00F2AB  D0 02         			BNE 	.NOBIT
03355  00F2AD  69 68         			ADC 	#ADJBIT
03356  00F2AF  C0 28         .NOBIT			CPY 	#$28			;immediate mode need to adjust a range
03357  00F2B1  30 0D         			BMI 	.CONT
03358  00F2B3  C0 30         			CPY 	#$2F+1
03359  00F2B5  B0 09         			BCS 	.CONT
03360  00F2B7  69 08         			ADC 	#ADJIMM			;carry is clear
03361  		;	BNE .CONT	
03362  00F2B9  C0 35         .CHABY			CPY 	#$35			;LDX check
03363  00F2BB  D0 03         			BNE 	.CONT
03364  00F2BD  18            			CLC
03365  00F2BE  69 04         			ADC 	#ADJABY
03366  00F2C0  C0 23         .CONT			CPY 	#$23			;STZ needs special handling
03367  00F2C2  D0 0A         			BNE 	.DONE
03368  00F2C4  E0 0A         			CPX 	#ABS
03369  00F2C6  30 06         			BMI 	.DONE
03370  00F2C8  F0 02         			BEQ 	.SKIP
03371  00F2CA  69 F1         			ADC 	#$1-$10			;carry is set
03372  00F2CC  69 2F         .SKIP			ADC 	#$30-1			;carry is set
03373  00F2CE  20 2B F0      .DONE			JSR 	SAVE_OBJ		;we have the object code
03374  
03375  		.IF 	BRKAS2				;if we want to add two BRK
03376  
03377  .MKARG							;where appropriate, the arg value is in HEXVAL,H
03378  							;copy to ARGS and null terminate
03379  00F2D1  8A            			TXA				;quick check for X=0
03380  00F2D2  F0 13         			BEQ 	.DORTS			;IMP - no args
03381  00F2D4  CA            			DEX
03382  00F2D5  F0 10         			BEQ 	.DORTS			;ACC - no args		
03383  00F2D7  A5 CF         			LDA	HEXVAL
03384  00F2D9  E0 09         			CPX 	#ABS-1			;word arg if X is greater than or equal to ABS
03385  00F2DB  30 05         			BMI 	.DOBYTE			;X < #ABS	
03386  00F2DD  20 2B F0      .DOWORD			JSR 	SAVE_OBJ		;Save byte(s)
03387  00F2E0  A5 D0         			LDA 	HEXVAL+1
03388  00F2E2  20 2B F0      .DOBYTE			JSR 	SAVE_OBJ
03389  00F2E5  64 C6         			STZ	ERROR			;no
03390  00F2E7  60            .DORTS			RTS
03391  
03392  
03393  ;------------------------------------------------------------------------
03394  ; work out the addressing mode
03395  ;------------------------------------------------------------------------	
03396  
03397  CALCAM			; work out the addressing mode
03398  00F2E8  20 73 F4      			JSR 	ADDMOD	
03399  00F2EB  E0 FF         			CPX 	#FAIL
03400  00F2ED  D0 A7         			BNE 	MKOBJC
03401  			;LDY 	#$FF	; Illegal address mode error
03402  00F2EF  60            			RTS
03403  
03404  ;------------------------------------------------------------------------------------------		
03405  ; lookup table for disassembly special cases
03406  ;------------------------------------------------------------------------------------------	
03407    001A              TBLSZ	= $1A
03408  DISTBL	.BYTE $80, $41, $4C, $38, $6C, $38, $7C, $38
03409  	.BYTE $0A, $30, $2A, $31, $4A, $32, $6A, $33
03410  	.BYTE $9C, $23, $9E, $23, $04, $20, $0C, $20
03411  	.BYTE $89, $22
03412  
03413  ; Data and related constants
03414  
03415  MODES			; Addressing mode constants
03416    0000              IMP = $00		;
03417    0001              ACC = $01
03418    0002              IMM = $02		; #$nn or #'<char>' or #LABEL
03419    0003              REL = $03		; *+nn or LABEL
03420    0004              ZPG = $04		; $nn or LABEL
03421    0005              ZPX = $05		; $nn,X or LABEL,X
03422    0006              ZPY = $06		; $nn,Y or LABEL,Y
03423    0007              IDZ = $07		; ($nn) or (LABEL)
03424    0008              IDX = $08		; ($nn,X) or (LABEL,X)
03425    0009              IDY = $09		; ($nn),Y or (LABEL),Y
03426    000A              ABS = $0A		; $nnnn or LABEL
03427    000B              ABX = $0B		; $nnnn,X or LABEL,X
03428    000C              ABY = $0C		; $nnnn,Y or LABEL,Y
03429    000D              IND = $0D		; ($nnnn) or (LABEL)
03430    000E              IAX = $0E		; ($nnnn,X) or (LABEL,X)
03431  
03432    0042              NUMMN 	=$42		; number of mnemonics
03433  
03434  
03435  ;------------------------------------------------------------------------------------------		
03436  ; lookup table Assembler and Dissambler
03437  ;------------------------------------------------------------------------------------------
03438  
03439  ; Tables
03440  
03441  LMNETB		
03442  		.BYTE $82	; PHP
03443  		.BYTE $1B	; CLC
03444  		.BYTE $83	; PLP
03445  		.BYTE $99	; SEC
03446  		.BYTE $82	; PHA
03447  		.BYTE $1B	; CLI
03448  		.BYTE $83	; PLA
03449  		.BYTE $99	; SEI
03450  		.BYTE $21	; DEY
03451  		.BYTE $A6	; TYA
03452  		.BYTE $A0	; TAY
03453  		.BYTE $1B	; CLV
03454  		.BYTE $4B	; INY
03455  		.BYTE $1B	; CLD
03456  		.BYTE $4B	; INX
03457  		.BYTE $99	; SED
03458  		.BYTE $14	; BRK	
03459  		.BYTE $4B	; INA
03460  		.BYTE $54	; JSR
03461  		.BYTE $21	; DEA	
03462  		.BYTE $95	; RTI
03463  		.BYTE $82	; PHY
03464  		.BYTE $95	; RTS
03465  		.BYTE $83	; PLY
03466  		.BYTE $A6	; TXA
03467  		.BYTE $A6	; TXS
03468  		.BYTE $A0	; TAX
03469  		.BYTE $A4	; TSX
03470  		.BYTE $21	; DEX
03471  		.BYTE $82	; PHX
03472  		.BYTE $73	; NOP
03473  		.BYTE $83	; PLX
03474  		.BYTE $A4	; TSB
03475  		.BYTE $A4	; TRB
03476  		.BYTE $12	; BIT
03477  		.BYTE $9D	; STZ
03478  		.BYTE $9D	; STY
03479  		.BYTE $61	; LDY
03480  		.BYTE $1C	; CPY
03481  		.BYTE $1C	; CPX
03482  		.BYTE $7C	; ORA
03483  		.BYTE $0B	; AND
03484  		.BYTE $2B	; EOR
03485  		.BYTE $9	; ADC
03486  		.BYTE $9D	; STA
03487  		.BYTE $61	; LDA
03488  		.BYTE $1B	; CMP
03489  		.BYTE $98	; SBC
03490  		.BYTE $0C	; ASL
03491  		.BYTE $93	; ROL
03492  		.BYTE $64	; LSR
03493  		.BYTE $93	; ROR
03494  		.BYTE $9D	; STX
03495  		.BYTE $61	; LDX
03496  		.BYTE $21	; DEC
03497  		.BYTE $4B	; INC
03498  		.BYTE $53	; JMP
03499  		.BYTE $14	; BPL
03500  		.BYTE $13	; BMI
03501  		.BYTE $15	; BVC
03502  		.BYTE $15	; BVS
03503  		.BYTE $10	; BCC
03504  		.BYTE $10	; BCS
03505  		.BYTE $13	; BNE
03506  		.BYTE $11	; BEQ
03507  		.BYTE $14	; BRA
03508  RMNETB
03509  		.BYTE $20	; PHP
03510  		.BYTE $06	; CLC
03511  		.BYTE $20	; PLP
03512  		.BYTE $46	; SEC
03513  		.BYTE $02	; PHA
03514  		.BYTE $12	; CLI
03515  		.BYTE $02	; PLA
03516  		.BYTE $52	; SEI
03517  		.BYTE $72	; DEY
03518  		.BYTE $42	; TYA
03519  		.BYTE $72	; TAY
03520  		.BYTE $2C	; CLV
03521  		.BYTE $B2	; INY
03522  		.BYTE $08	; CLD
03523  		.BYTE $B0	; INX
03524  		.BYTE $48	; SED
03525  		.BYTE $96	; BRK	
03526  		.BYTE $82	; INA
03527  		.BYTE $E4	; JSR
03528  		.BYTE $42	; DEA	
03529  		.BYTE $12	; RTI
03530  		.BYTE $32	; PHY
03531  		.BYTE $26	; RTS
03532  		.BYTE $32	; PLY
03533  		.BYTE $02	; TXA
03534  		.BYTE $26	; TXS
03535  		.BYTE $70	; TAX
03536  		.BYTE $F0	; TSX
03537  		.BYTE $70	; DEX
03538  		.BYTE $30	; PHX
03539  		.BYTE $E0	; NOP
03540  		.BYTE $30	; PLX
03541  		.BYTE $C4	; TSB
03542  		.BYTE $84	; TRB
03543  		.BYTE $68	; BIT
03544  		.BYTE $34	; STZ
03545  		.BYTE $32	; STY
03546  		.BYTE $32	; LDY
03547  		.BYTE $32	; CPY
03548  		.BYTE $30	; CPX
03549  		.BYTE $82	; ORA
03550  		.BYTE $88	; AND
03551  		.BYTE $E4	; EOR
03552  		.BYTE $06	; ADC
03553  		.BYTE $02	; STA
03554  		.BYTE $02	; LDA
03555  		.BYTE $60	; CMP
03556  		.BYTE $86	; SBC
03557  		.BYTE $D8	; ASL
03558  		.BYTE $D8	; ROL
03559  		.BYTE $E4	; LSR
03560  		.BYTE $E4	; ROR
03561  		.BYTE $30	; STX
03562  		.BYTE $30	; LDX
03563  		.BYTE $46	; DEC
03564  		.BYTE $86	; INC
03565  		.BYTE $60	; JMP
03566  		.BYTE $18	; BPL
03567  		.BYTE $52	; BMI
03568  		.BYTE $86	; BVC
03569  		.BYTE $A6	; BVS
03570  		.BYTE $C6	; BCC
03571  		.BYTE $E6	; BCS
03572  		.BYTE $8A	; BNE
03573  		.BYTE $62	; BEQ
03574  		.BYTE $82	; BRA
03575  	
03576  MIN			; Minimum legal value for MNE for each mode.
03577  	.BYTE $00, $30, $25, $39
03578  	.BYTE $20, $28, $34
03579  	.BYTE $28, $28, $28
03580  	.BYTE $20, $28, $28
03581  	.BYTE $38, $38
03582  MAX			; Maximum +1 legal value of MNE for each mode. 
03583  	.BYTE $1F+1, $33+1, $2F+1, $41+1
03584  	.BYTE $37+1, $33+1, $35+1
03585  	.BYTE $2F+1, $2F+1, $2F+1
03586  	.BYTE $38+1, $33+1, $2F+1
03587  	.BYTE $38+1, $38+1
03588  BASE			; Base value for each opcode
03589  	.BYTE $08, $18, $28, $38, $48, $58, $68, $78
03590  	.BYTE $88, $98, $A8, $B8, $C8, $D8, $E8, $F8
03591  	.BYTE $00, $1A, $14, $3A, $40, $5A, $60, $7A
03592  	.BYTE $8A, $9A, $AA, $BA, $CA, $DA, $EA, $FA	
03593  	.BYTE $00, $10, $20, $60, $80, $A0, $C0, $E0
03594  	.BYTE $01, $21, $41, $61, $81, $A1, $C1, $E1
03595  	.BYTE $02, $22, $42, $62, $82, $A2, $C2, $E2
03596  	.BYTE $40, $10, $30, $50, $70, $90, $B0, $D0
03597  	.BYTE $F0, $80
03598  	
03599  OFFSET			; Default offset values for each mode, 
03600  			; added to BASE to get the opcode
03601  	.BYTE $00, $08, $00, $00, $04, $14, $14
03602  	.BYTE $11, $00, $10, $0C, $1C, $18, $2C
03603  	.BYTE $3C
03604  	
03605  ;------------------------------------------------------------------------
03606  ; offset adjustments for the mnemonic exceptions
03607  ;------------------------------------------------------------------------
03608    0004              ADJABY  =$04
03609    0008              ADJIMM  =$08
03610    0068              ADJBIT	=$68
03611    00D0              ADJSTZ	=$D0
03612  
03613  ;------------------------------------------------------------------------	
03614  ; disassembler data
03615  ; XXXXXXZ0 instrs
03616  ; * Z=0, right half-byte
03617  ; * Z=1, left half-byte
03618  ;------------------------------------------------------------------------
03619  MODE		.BYTE $0F, $22, $FF, $33, $CB
03620  		.BYTE $62, $FF, $73, $03, $22
03621  		.BYTE $FF, $33, $CB, $66, $FF
03622  		.BYTE $77, $0F, $20, $FF, $33
03623  		.BYTE $CB, $60, $FF, $70, $0F
03624  		.BYTE $22, $FF, $39, $CB, $66
03625  		.BYTE $FF, $7D, $0B, $22, $FF
03626  		.BYTE $33, $CB, $A6, $FF, $73
03627  		.BYTE $11, $22, $FF, $33, $CB
03628  		.BYTE $A6, $FF, $87, $01, $22
03629  		.BYTE $FF, $33, $CB, $60, $FF
03630  		.BYTE $70, $01, $22, $FF, $33
03631  		.BYTE $CB, $60, $FF, $70
03632  ; YYXXXZ01 instrs
03633  		.BYTE $24, $31, $65, $78
03634  	
03635  MODE2		.BYTE $00		;ERR
03636  		.BYTE $21		;IMM		
03637  		.BYTE $81		;Z-PAG
03638  		.BYTE $82		;ABS
03639  		.BYTE $59		;(Z-PAG,X)
03640  		.BYTE $4D		;(Z-PAG),Y
03641  		.BYTE $91		;Z-PAG,X
03642  		.BYTE $92		;ABS,X
03643  		.BYTE $86		;ABS,Y
03644  		.BYTE $4A		;(ABS)
03645  		.BYTE $85		;Z-PAG,Y
03646  		.BYTE $9D		;REL
03647  		.BYTE $49		;(Z-PAG)
03648  		.BYTE $5A		;(ABS,X)
03649  	
03650  ;------------------------------------------------------------------------	
03651  CHAR2		.BYTE 'Y', $00, 'X', '$', '$', $00
03652  CHAR1		.BYTE ',', ')', ',', '#', '(', '$'
03653  	
03654  ; Special case mnemonics	
03655    0008              SPCNT	= $08		; duplicate some checks so I can use the same loop above
03656  
03657  ; Opcodes
03658  SPINC1		.BYTE $12, $22, $23, $24, $25, $35, $36, $37
03659  
03660  ; 1st address mode to check
03661  SPINC2		.BYTE $0A, $0B, $0B, $05, $0B, $0C, $0B, $0B
03662  
03663  ; 2nd address mode to check
03664  SPINC3		.BYTE $0A, $05, $05, $05, $05, $0C, $05, $05
03665  
03666  
03667  
03668  
03669  ;------------------------------------------------------------------------   
03670  ;Find addressing MODE
03671  ;SRCE = points top begining of NME in buffer
03672  ;CURMNE = location of found NME
03673  
03674  ADDMOD							;Check the arguments and work out the
03675  							;addressing mode
03676  							;return mode in X
03677  							;default error value for mode
03678  							;save it	
03679  							;Start checking the format...	
03680  		
03681  00F473  A4 C3         			LDY 	CURMNE			;Holds the current mne index
03682  00F475  20 A6 E5      			JSR	NNONSPC			;get next no space 				
03683  00F478  86 D9         			STX     SAVE_Y          	;Save current location in IN							
03684  00F47A  D0 13         			BNE 	.NOTSP			;Not could be 
03685  		
03686  00F47C  C0 12         .EOL			CPY 	#$12			;check exception first - JSR
03687  00F47E  F0 09         			BEQ	.RET
03688  00F480  A0 00         			LDY 	#IMP			;implied mode - space
03689  00F482  20 FD F4      			JSR 	CHKMOD			;check command is ok with this mode
03690  00F485  C0 FF         			CPY 	#FAIL			;not ok		
03691  00F487  F0 01         			BEQ 	.NOTIMP			;may still be accumulator mode though
03692  00F489  60            .RET			RTS
03693  00F48A  A0 01         .NOTIMP 		LDY 	#ACC			;accumulator mode - space
03694  00F48C  4C FD F4      			JMP 	CHKMOD			;check command is ok with this mode
03695  		
03696  00F48F  C9 23         .NOTSP			CMP 	#IMV			;immediate mode - '#'
03697  00F491  F0 0B         			BEQ 	.DOIMM				
03698  00F493  A0 03         			LDY 	#REL
03699  00F495  20 FD F4      			JSR 	CHKMOD			;check if command is a branch
03700  00F498  C0 FF         			CPY 	#FAIL
03701  00F49A  F0 21         			BEQ 	.NOTREL					
03702  00F49C  80 73         			BRA 	DOREL			;Do relative Addressing
03703  	
03704  00F49E  98            .DOIMM			TYA
03705  00F49F  A0 02         			LDY 	#IMM
03706  00F4A1  C9 2C         			CMP 	#$2C			;check exception first - STA
03707  00F4A3  F0 67         			BEQ 	BAD			
03708  00F4A5  C9 35         			CMP 	#$35			;check inclusion - LDX
03709  00F4A7  F0 0B         			BEQ 	.IMMOK
03710  00F4A9  C9 22         			CMP 	#$22			;check inclusion - BIT
03711  00F4AB  F0 07         			BEQ 	.IMMOK
03712  					
03713  00F4AD  20 FD F4      			JSR 	CHKMOD			;check command is ok with this mode
03714  00F4B0  C0 FF         			CPY 	#FAIL
03715  00F4B2  F0 D5         			BEQ 	.RET
03716  		
03717  00F4B4  84 C4         .IMMOK			STY	CURADM			;
03718  00F4B6  A6 D9         			LDX	SAVE_Y
03719  00F4B8  E8            			INX				;Get next Charater 
03720  00F4B9  20 E3 E6      			JSR	GET_EXPRES
03721  00F4BC  60            			RTS
03722  		
03723  .NOTREL 		;LDX	SAVE_Y			;save two bytes :-) 
03724  00F4BD  B5 19         			LDA	IN,X			;check the more complicated modes
03725  00F4BF  C9 28         			CMP 	#OPEN			;indirection?
03726  00F4C1  D0 01         			BNE 	.CONT			;no
03727  00F4C3  E8            			INX				;skip the '('
03728  00F4C4  A6 D9         .CONT			LDX	SAVE_Y			;restore the index
03729  00F4C6  20 34 F5      			JSR 	FMT2AM			;calculate the addressing mode from the format
03730  00F4C9  E0 FF         			CPX 	#FAIL
03731  00F4CB  F0 BC         			BEQ 	.RET
03732  00F4CD  84 C4         			STY 	CURADM
03733  ;			JMP CHKEXS
03734  ; 			falls through
03735  
03736  ;------------------------------------------------------------------------
03737  
03738  CHKEXS							;Current addressing mode is in X
03739  00F4CF  C0 06         			CPY 	#ZPY			;for MNE indices 28 to 2F, ZPY is illegal
03740  00F4D1  D0 0E         			BNE 	.CONT			;but ABY is ok, so promote byte argument to word
03741  00F4D3  A4 C3         			LDY 	CURMNE
03742  00F4D5  C0 28         			CPY 	#$28
03743  00F4D7  90 08         			BCC 	.CONT
03744  00F4D9  C0 30         			CPY 	#$2F+1
03745  00F4DB  B0 04         			BCS 	.CONT	
03746  00F4DD  A0 0C         			LDY 	#ABY			;updated addressing mode
03747  00F4DF  D0 28         			BNE 	OK
03748  00F4E1  A2 08         .CONT			LDX 	#SPCNT			;check special includes
03749  00F4E3  BD 5A F4      .LOOP			LDA 	SPINC1-1,X		;load mnemonic code
03750  00F4E6  C5 C3         			CMP 	CURMNE
03751  00F4E8  D0 0E         			BNE 	.NEXT
03752  00F4EA  BC 62 F4      			LDY 	SPINC2-1,X		;load addressing mode
03753  00F4ED  C4 C4         			CPY 	CURADM
03754  00F4EF  F0 18         			BEQ 	OK			;match - so ok
03755  00F4F1  BC 6A F4      			LDY 	SPINC3-1,X		;load addressing mode
03756  00F4F4  C4 C4         			CPY 	CURADM
03757  00F4F6  F0 11         			BEQ 	OK			;match - so ok
03758  00F4F8  CA            .NEXT			DEX
03759  00F4F9  D0 E8         			BNE 	.LOOP
03760  00F4FB  A4 C4         			LDY 	CURADM
03761  ;	BNE CHKMOD	; wasn't in the exceptions table - check normally
03762  ; falls through
03763  
03764  
03765  ;------------------------------------------------------------------------
03766  ; CHeck Adressing Mode
03767  
03768  00F4FD  A5 C3         CHKMOD			LDA 	CURMNE			;always > 0
03769  00F4FF  D9 8E F3      			CMP 	MIN,y			;mode index in X
03770  00F502  90 08         			BCC 	BAD			;mnemonic < MIN
03771  00F504  D9 9D F3      			CMP 	MAX,y			;MAX,X holds actually MAX + 1
03772  00F507  B0 03         			BCS 	BAD			;mnemonic > MAX
03773  00F509  84 C4         OK			STY 	CURADM			;save mode		
03774  00F50B  60            			RTS
03775  				
03776  ;------------------------------------------------------------------------
03777  
03778  00F50C  A0 FF         BAD			LDY 	#FAIL			;Illegal addressing mode error
03779  00F50E  84 C6         			STY	ERROR	
03780  00F510  60            			RTS
03781  
03782  ;------------------------------------------------------------------------		
03783  ; Calculate relative addressing mode
03784  ;------------------------------------------------------------------------					----BUG
03785  00F511  A6 D9         DOREL			LDX	SAVE_Y 			; restore index			
03786  00F513  20 A6 E5      			JSR     NNONSPC         	;Find next non space
03787  00F516  20 E3 E6                      	JSR     GET_EXPRES      	;Evaluate expression                
03788  00F519  A5 BF                         	LDA     UNDEF           	;Undefined label used?
03789  00F51B  D0 16                         	BNE     HEXVAL2OBJ      	;Yes! Can't verify range		
03790  00F51D  18                            	CLC                    		;Calculate displacement (+1!)
03791  00F51E  A5 CF                         	LDA     HEXVAL
03792  00F520  E5 B6                         	SBC     PC
03793  00F522  85 CF                         	STA     HEXVAL
03794  00F524  10 02                         	BPL     .NOBOR          	;No borrow needed                	
03795  00F526  E6 D0                         	INC     HEXVAL+1
03796  00F528  C6 CF         .NOBOR          	DEC	HEXVAL			;adjust
03797  00F52A  A5 D0         			LDA     HEXVAL+1        	;See if high byte of displacement
03798  00F52C  E5 B7                         	SBC     PC+1             	;is 0                	
03799  00F52E  F0 03                         	BEQ     HEXVAL2OBJ      	;OK!
03800  00F530  20 38 F2      .RANGE          	JSR     RANGE_ERROR     	;Range error!
03801  00F533  60            HEXVAL2OBJ      	RTS
03802  		;LDA     HEXVAL          	;Save displacement
03803                  ;JMP     SAVE_OBJ
03804  		
03805          	
03806  	        	
03807          	
03808          	
03809  ;------------------------------------------------------------------------
03810  
03811  FMT2AM			; calculate the addressing given
03812  			; the format of the arguments; 
03813  			; return format in X, and
03814  			; location to CHKEXT from in A
03815  			; $FF		invalid
03816  			; #ZPG		$nn
03817  			; #ZPX		$nn,X
03818  			; #ZPY		$nn,Y
03819  			; #ABS		$nnnn
03820  			; #ABX		$nnnn,X
03821  			; #ABY		$nnnn,Y
03822  			; #IND		($nnnn)
03823  			; #IDX		($nn,X)
03824  			; #IDY		($nn),Y
03825  			; #INZ		($nn)
03826  			; #IAX		($nnnn,X)
03827  ;		
03828  ;	Addressing modes are organised as follows:
03829  ;
03830  ;	IMP (0)	ZPG (4) INZ (7) ABS (A) IND (D)
03831  ;	ACC (1) ZPX (5) INX (8) ABX (B) IAX (E)
03832  ;	IMM (2) ZPY (6) INY (9) ABY (C) ---
03833  ;	REL (3) ---	 ---	---	---
03834  ;
03835  ;	so algorithm below starts with 4, adds 3 if indirect
03836  ;	and adds 6 if absolute (i.e. 2 byte address), then adds 1 or 2
03837  ;	if ,X or ,Y format
03838  ;
03839  			;LDX 	#$00			;save two btyes :-)
03840  00F534  A9 04         			LDA 	#$04			; start with mode index of 4
03841  00F536  B4 19         			LDY 	IN,X
03842  00F538  C0 28         			CPY 	#OPEN			;Compar '('
03843  00F53A  D0 04         			BNE 	.SKIP
03844  00F53C  18            			CLC				;add 3 for indirect modes
03845  00F53D  69 03         			ADC 	#$03
03846  00F53F  E8            			INX
03847  
03848  00F540  48            .SKIP			PHA
03849  00F541  20 E3 E6      			JSR	GET_EXPRES		;Get all the bytes			
03850  00F544  CA            			DEX
03851  00F545  38            			SEC				;count bytes (1 or 2 only)
03852  00F546  8A            			TXA				;Contains last count
03853  00F547  E5 D9         			SBC	SAVE_Y			;subtract the begining of addressing
03854  00F549  4A            			LSR				;divied by 2			
03855  00F54A  A8            			TAY				;byte count in Y 
03856  00F54B  A5 C3         			LDA 	CURMNE
03857  00F54D  C9 12         			CMP 	#$12			;is it JSR?
03858  00F54F  F0 04         			BEQ 	.JSR
03859  00F551  C9 38         			CMP 	#$38			;is it JMP?
03860  00F553  D0 01         			BNE 	.NOJMP
03861  		
03862  .JSR			;LDY 	#$2			;force 2 bytes for these two situations
03863  00F555  C8            			INY				;following code treats Y = 3 the same as Y = 2
03864  
03865  00F556  68            .NOJMP			PLA				;mode base back in A
03866  00F557  E8            			INX				;check for NBYTS failure
03867  00F558  F0 55         			BEQ 	FERR
03868  00F55A  88            			DEY
03869  00F55B  F0 03         			BEQ 	.1BYT
03870  00F55D  18            .2BYT			CLC				;Two bytes eg: stx $xxxx
03871  00F55E  69 06         			ADC 	#$06			;add 6 to base index for 2 byte modes
03872  00F560  A8            .1BYT			TAY				;mode index now in Y
03873  00F561  20 A6 E5      .CHECK			JSR	NNONSPC			;next Char in the buffer
03874  00F564  F0 08         			BEQ 	.DONE			;Check for CR
03875  00F566  C9 3B         			CMP	#';'			;a comment follows 
03876  00F568  F0 47         			BEQ	FRET
03877  00F56A  C9 20         			CMP 	#SP
03878  00F56C  D0 0D         			BNE 	.CONT
03879  00F56E  A5 D2         .DONE			LDA 	CHAR			;first Bracket
03880  00F570  C9 28         			CMP 	#OPEN			;brackets must match
03881  00F572  F0 3B         			BEQ 	FERR
03882  00F574  C0 0F         .RET			CPY 	#$0F			;compare the amount of bytes
03883  00F576  10 37         			BPL 	FERR			;no indirect absolute Y mode
03884  00F578  98            			TYA
03885  00F579  AA            			TAX
03886  00F57A  60            			RTS
03887  00F57B  C9 29         .CONT			CMP 	#CLOSE
03888  00F57D  D0 0B         			BNE 	.MORE
03889  00F57F  A9 20         			LDA 	#SP
03890  00F581  85 D2         			STA 	CHAR			;erase brackets now they have found them
03891  00F583  E8            			INX				;next char in the keyboardf buffer
03892  00F584  B5 19         			LDA 	IN,X
03893  00F586  C9 2C         			CMP 	#COMMA		
03894  00F588  D0 D7         			BNE 	.CHECK
03895  00F58A  20 A6 E5      .MORE			JSR	NNONSPC			;Next Character (skipping spaces)
03896  00F58D  C9 2C         			CMP 	#COMMA
03897  00F58F  D0 1E         			BNE 	FERR
03898  00F591  E8            			INX
03899  00F592  B5 19         			LDA 	IN,X			;Next Character
03900  00F594  C9 58         			CMP 	#'X'
03901  00F596  F0 0D         			BEQ 	.ISX
03902  00F598  C9 59         .ISY			CMP 	#'Y'
03903  00F59A  D0 13         			BNE 	FERR
03904  00F59C  A5 D2         			LDA 	CHAR
03905  00F59E  C9 28         			CMP 	#OPEN
03906  00F5A0  F0 0D         			BEQ 	FERR
03907  00F5A2  95 17         			STA 	IN-2,X			;to avoid ,X check below
03908  00F5A4  C8            			INY
03909  00F5A5  C8            .ISX			INY
03910  00F5A6  B5 17         			LDA 	IN-2,X
03911  00F5A8  C9 29         			CMP 	#CLOSE			;No such thing as (...),X mode
03912  00F5AA  F0 03         			BEQ 	FERR
03913  00F5AC  E8            			INX
03914  00F5AD  80 B2         			BRA 	.CHECK			;always
03915  00F5AF  A2 FF         FERR			LDX 	#FAIL			;error message generated upstream
03916  00F5B1  60            FRET			RTS
03917  
03918          	          
03919  ;------------------------------------------------------------------------------------------		
03920  ; Get the MNE index using the following rules:
03921  ; 	- lookup awkward cases in a lookup table (DISTBL)
03922  ;	- consider opcodes by category:
03923  ;		1: nnnn1000 -> nnnn
03924  ;		2: nnn10000 -> nnn + BPL
03925  ;		3: nnnn1010 or 0nn00000 -> BRK + nnnn(0nn0)
03926  ;		4: change nnnX0010 to nnnX0001
03927  ;		5: nnnXXXab -> 001abnnn if >= 23
03928  ;		6: 001abnnn + 1 otherwise
03929  ;------------------------------------------------------------------------------------------		
03930  	
03931  GETMNE							;get mnemonic index for opcode in A
03932  							;on completion, A holds the index 
03933  							;into the mnemonic table
03934  00F5B2  85 E2         			STA 	TEMP1			;will need it later
03935  00F5B4  A2 1A         			LDX 	#TBLSZ			;check lookup table first
03936  00F5B6  BD EE F2      .LOOP			LDA 	DISTBL-2,X
03937  00F5B9  C5 E2         			CMP 	TEMP1
03938  00F5BB  D0 04         			BNE 	.SKIP
03939  00F5BD  BD EF F2      			LDA 	DISTBL-1,X		;got it
03940  00F5C0  60            			RTS
03941  00F5C1  CA            .SKIP			DEX
03942  00F5C2  CA            			DEX
03943  00F5C3  D0 F1         			BNE 	.LOOP
03944  00F5C5  A5 E2         			LDA 	TEMP1	
03945  00F5C7  4A            			LSR
03946  00F5C8  4A            			LSR
03947  00F5C9  4A            			LSR
03948  00F5CA  4A            			LSR
03949  00F5CB  85 E3         				STA 	TEMP2		;save the high nibble
03950  00F5CD  A5 E2         				LDA 	TEMP1
03951  00F5CF  29 0F         			AND 	#$0F
03952  00F5D1  C9 08         			CMP 	#$08
03953  00F5D3  D0 03         			BNE 	.NOTC1
03954  00F5D5  A5 E3         			LDA 	TEMP2			;high nibble is our index
03955  00F5D7  60            			RTS	
03956  00F5D8  A5 E2         .NOTC1			LDA 	TEMP1
03957  00F5DA  29 1F         			AND 	#$1F
03958  00F5DC  C9 10         			CMP 	#$10
03959  00F5DE  D0 06         			BNE 	.NOTC2
03960  00F5E0  A5 E3         			LDA 	TEMP2
03961  00F5E2  4A            			LSR
03962  00F5E3  69 38         			ADC 	#$39-1			;since carry is set
03963  00F5E5  60            			RTS
03964  00F5E6  A5 E2         .NOTC2			LDA 	TEMP1
03965  00F5E8  29 9F         			AND 	#$9F
03966  00F5EA  F0 06         			BEQ 	.DOC3
03967  00F5EC  29 0F         			AND 	#$0F
03968  00F5EE  C9 0A         			CMP 	#$0A
03969  00F5F0  D0 06         			BNE 	.NOTC3
03970  00F5F2  A5 E3         .DOC3			LDA 	TEMP2
03971  00F5F4  18            			CLC
03972  00F5F5  69 10         			ADC 	#$10
03973  00F5F7  60            			RTS
03974  00F5F8  A6 E2         .NOTC3			LDX 	TEMP1			;does this code end in 10010?
03975  00F5FA  8A            			TXA
03976  00F5FB  29 1F         			AND 	#$1F
03977  00F5FD  C9 12         			CMP 	#$12
03978  00F5FF  D0 01         			BNE 	.1
03979  00F601  CA            			DEX
03980  00F602  8A            .1			TXA				;? ABCD EFGH - thanks bogax, www.6502.org/forum
03981  00F603  0A            			ASL				;A BCDE FGH0
03982  00F604  69 80         			ADC 	#$80			;B ?CDE FGHA
03983  00F606  2A            			ROL				;? CDEF GHAB
03984  00F607  0A            			ASL				;C DEFG HAB0
03985  00F608  29 1F         			AND 	#$1F			;C 000G HAB0
03986  00F60A  69 20         			ADC 	#$20			;0 001G HABC
03987  00F60C  C9 23         			CMP 	#$23
03988  00F60E  30 01         			BMI 	.NOTC5
03989  00F610  60            			RTS
03990  00F611  AA            .NOTC5			TAX
03991  00F612  E8            			INX
03992  00F613  8A            			TXA
03993  00F614  60            			RTS        	       	
03994  
03995  
03996  	
03997  ;------------------------------------------------------------------------
03998  ;------------------------------------------------------------------------
03999  ;GENRAL LIBRARY ROUTINES BELOW
04000  
04001  
04002  	.include	"General Lib.65s"				
04003  ; LIBRARY FILE
04004  ; version 2.09
04005  ; two pass assembler, dissembler and tracer- inspiration with permission from A1 by San Bergmans
04006  ; REGB bits 0-3 are connected to LED's
04007  ; tested in Michael Kowalski 6502 Simulator - using 65C02 Code 
04008  ; "Programmed" by Joe DiMeglio
04009  		
04010       		
04011  ;--------------------------------------------------------------------
04012  ;prints a string ending with EOS - checkign for packed strings
04013  ;--------------------------------------------------------------------        		
04014          		
04015  00F615  08            STRING  		PHP				;print stringz to screen
04016  00F616  48            	        	PHA	        	
04017  00F617  DA                    		PHX        		
04018  00F618  5A                    		PHY        		
04019  00F619  A5 DC                 		LDA     SRCE        		;Save SRCE 	
04020  00F61B  48                    		PHA        		
04021  00F61C  A5 DD                 		LDA     SRCE+1        		
04022  00F61E  48                    		PHA        		
04023  00F61F  BA                    		TSX        		
04024  00F620  BD 07 01              		LDA     $0107,x        		;get return address-1	
04025  00F623  85 DC                 		STA     SRCE        		
04026  00F625  BD 08 01              		LDA     $0108,x
04027  00F628  85 DD                 		STA     SRCE+1        		        		
04028  00F62A  E6 DC         .NEXTCHAR 		INC	SRCE
04029  00F62C  D0 02                 		BNE     .SKIPBUMP		;edge of page 
04030  00F62E  E6 DD                 		INC     SRCE+1	
04031  00F630  A0 01         .SKIPBUMP		LDY	#$01			;trick to save some bytes
04032  00F632  B2 DC         			LDA     (SRCE)   		
04033  00F634  F0 0D         			BEQ	.ADJUST_RETURN		;EOS Marker
04034  00F636  10 03         			BPL	.NOTPACK			;is it packed?			
04035  00F638  20 F8 ED      			JSR	UNPACK_DECODE		;return character AC and count YR			
04036  00F63B  20 A9 F6      .NOTPACK		JSR     WRCHAR        		;write character
04037  00F63E  88            			DEY
04038  00F63F  D0 FA         			BNE	.NOTPACK
04039  00F641  80 E7                 		BRA     .NEXTCHAR      		        		
04040  00F643  A5 DC         .ADJUST_RETURN 		LDA	SRCE
04041  00F645  9D 07 01              		STA     $0107,x        		
04042  00F648  A5 DD                 		LDA     SRCE+1        		
04043  00F64A  9D 08 01              		STA     $0108,x        		
04044  00F64D  68                    		PLA        			;Restore SRC
04045  00F64E  85 DD                 		STA     SRCE+1       	 		
04046  00F650  68                    		PLA        		
04047  00F651  85 DC                 		STA     SRCE
04048  00F653  7A                    		PLY        		
04049  00F654  FA                    		PLX        		
04050  00F655  68                    		PLA        	
04051  00F656  28                    		PLP        		
04052  00F657  60                    		RTS          		
04053          		  
04054  ;------------------------------------------------------------
04055  ; ANSI GOTO x & y 
04056  ;------------------------------------------------------------
04057  GOTOXY 			 	
04058  		.IF MYWYM
04059  00F658  8E 05 88              		STX	io_posx 		;use simlulator
04060  00F65B  8C 06 88      			STY	io_posy			
04061  00F65E  60            			RTS		
04062  		.ENDIF			
04063   
04064   ;------------------------------------------------------------------------
04065  ; ANSI - CSI n x See https://en.wikipedia.org/wiki/ANSI_escape_code
04066  ;  low level
04067  ;------------------------------------------------------------------------
04068  WRCSI
04069  00F65F  48             			PHA                		;save value
04070  00F660  A9 1B                 		LDA     #ESC        		
04071  00F662  20 A9 F6              		JSR     WRCHAR        		
04072  00F665  A9 5B                 		LDA     #'['        		
04073  00F667  20 A9 F6      	        	JSR     WRCHAR	        	
04074  00F66A  8A                    		TXA        		
04075  00F66B  20 A9 F6              		JSR     WRCHAR			;write in decimal 
04076  00F66E  68                    		PLA        		
04077  00F66F  20 A9 F6              		JSR     WRCHAR        		;write ANSI Mode        			        		
04078  00F672  60                    		RTS    
04079          			
04080  ;------------------------------------------------------------------------
04081  ; ANSI - Clear Screen; ;.BYTE 	ESC,"[2J",EOS		        		
04082  ;  low level
04083  ;------------------------------------------------------------------------
04084  CLS     		
04085  		.IF MYWYM
04086  00F673  8D 00 88      			STA	io_cls			;use simlulator	
04087  00F676  60            			RTS			
04088          	.ENDIF
04089          	
04090  ;------------------------------------------------------------------------
04091  ; ANSI -  Bring Cursor Home 
04092  ;------------------------------------------------------------------------
04093  00F677  20 15 F6      HOME    		JSR     STRING        		
04094          		.ASCII	ESC
04095          		.ASCIS	"[1;1H"
04096  00F680  60                    		RTS       	        	
04097          		
04098  ;------------------------------------------------------------------------
04099  ; ANSI -  Save Cursor Position
04100  ;------------------------------------------------------------------------
04101  00F681  20 15 F6      SAVECUR    		JSR     STRING 
04102  			.ASCII	ESC
04103          		.ASCIS	"[s"          		        	        		
04104  00F687  60                    		RTS       	        	
04105  
04106  ;------------------------------------------------------------------------
04107  ; ANSI -  Restore Cursor Position 
04108  ;------------------------------------------------------------------------
04109  00F688  20 15 F6      RESTCUR    		JSR     STRING 			
04110          		.ASCIS	ESC,"[u"          		        	        		
04111  00F68E  60                    		RTS      	        	
04112          	        	        	
04113  ;------------------------------------------------------------------------
04114  ; Print a dot
04115  ;------------------------------------------------------------------------
04116  00F68F  A9 2E         WRDOT           	LDA     #'.'            	;Print a dot
04117  00F691  80 16                         	BRA     WRCHAR
04118  
04119  ;------------------------------------------------------------------------
04120  ; Check Tabs
04121  ;------------------------------------------------------------------------
04122  TABS3
04123     		.IF MYWYM
04124  00F693  48            			PHA
04125  00F694  AD 05 88      			LDA 	io_posx
04126  00F697  A9 14         			LDA 	#20
04127  			;CLC
04128  			;ADC	#06
04129  00F699  8D 05 88      			STA 	io_posx
04130  00F69C  68            			PLA
04131  		.ENDIF	
04132  00F69D  60            			RTS	
04133  		                
04134  ;------------------------------------------------------------------------
04135  ; Print a space
04136  ;------------------------------------------------------------------------
04137  00F69E  A9 20         WRSPACE         	LDA     #SP            		;Print a space
04138  00F6A0  80 07         			BRA     WRCHAR		
04139                  
04140  ;------------------------------------------------------------------------
04141  ; Print a CR
04142  ;------------------------------------------------------------------------
04143  
04144  00F6A2  A9 0D         WRCRLF          	LDA     #CR             	;Print a CR & LF		
04145  00F6A4  20 A9 F6      			JSR	WRCHAR
04146  00F6A7  A9 0A         PRLF			LDA	#LF			;fall through to WRCHAR
04147  
04148  ;--------------------------------------------------------------
04149  ;WRCHAR Out charater to the screen
04150  ;  Low level
04151  ;--------------------------------------------------------------
04152  WRCHAR  	
04153  		.IF LCD_ROUTINES
04154  
04155  		.IF MYWYM
04156  00F6A9  8D 01 88      			STA	io_putc			;Else use simulator
04157  00F6AC  60            			RTS
04158  		.ENDIF	
04159  						
04160  ;--------------------------------------------------------------
04161  ;REPWRCHAR Out charater to the screen
04162  ; A= Char  y= times
04163  ;--------------------------------------------------------------
04164  00F6AD  20 A2 F6      DRAWLINE		JSR	WRCRLF
04165  00F6B0  A9 2D         			LDA	#DASH
04166  00F6B2  A0 32         			LDY	#50
04167  00F6B4  20 A9 F6      REPWRCHAR 		JSR	WRCHAR					
04168  00F6B7  88            			DEY
04169  00F6B8  10 FA         			BPL	REPWRCHAR 						
04170  00F6BA  80 E6         			BRA	WRCRLF
04171  
04172  ;--------------------------------------------------------------
04173  ;convert binary into a ASCII characters 
04174  ;write to screen eg xx
04175  
04176  00F6BC  48            WR2HEX  		PHA        	
04177  00F6BD  4A                    		LSR				;write 2 hex digits        	
04178  00F6BE  4A                    		LSR        	
04179  00F6BF  4A                    		LSR        	
04180  00F6C0  4A                    		LSR        	
04181  00F6C1  20 C5 F6              		JSR     WR1HEX        	
04182  00F6C4  68                    		PLA        	
04183  00F6C5  D8            WR1HEX        		CLD        			;write 1 character HEX eg x 
04184  00F6C6  29 0F                 		AND     #$0f        	
04185  00F6C8  C9 0A                 		CMP     #$0a        	
04186  00F6CA  90 02                 		BCC     .z09        	        	
04187  00F6CC  69 06                 		ADC     #$06			;carry is set        	
04188  00F6CE  69 30         .z09     		ADC     #$30
04189  00F6D0  80 D7                 		BRA     WRCHAR     
04190          	
04191  ;------------------------------------------------------------------------
04192  ; Print word in hex
04193  ; A holds MSB, Y holds LSB, eg $xxxx
04194  ;------------------------------------------------------------------------
04195  
04196  00F6D2  48            WRWORD         		PHA                     	;Save MSB
04197  00F6D3  A9 24                         	LDA     #'$'            	;Print dollar symbol
04198  00F6D5  20 A9 F6                      	JSR     WRCHAR
04199  00F6D8  68                            	PLA
04200  00F6D9  20 BC F6      WRWORDAY       		JSR     WR2HEX          	;Print MSB
04201  00F6DC  98                            	TYA
04202  00F6DD  80 DD                         	BRA     WR2HEX          	;Print LSB
04203  
04204  ;------------------------------------------------------------------------
04205  ; SCAN_ESC if key is pressed
04206  ;  Low level
04207  ;------------------------------------------------------------------------
04208  
04209  SCAN_ESC    
04210  		.IF MYWYM		
04211  00F6DF  AD 04 88      			LDA     KBDCR           	;Was a key pressed?
04212  00F6E2  C9 1B         			CMP     #ESC   			;Make Z=1 if ESC
04213  00F6E4  60            			RTS
04214  		.ENDIF
04215  
04216  
04217  ;------------------------------------------------------------------------
04218  ; Wait for keypressed
04219  ;  Low level
04220  ;------------------------------------------------------------------------
04221  
04222  RDCHAR
04223    		.IF MYWYM 
04224  00F6E5  AD 04 88      			LDA	KBDCR			;Else use simulator 		
04225  00F6E8  F0 FB         			BEQ 	RDCHAR 		
04226  00F6EA  60            			RTS	
04227  		.ENDIF
04228  	
04229  
04230  ;--------------------------------------------------------------------
04231  00F6EB  20 E5 F6      RD1HEX  		JSR     RDCHAR
04232  00F6EE  80 0F                 		BRA     HEX2BIN        	
04233  
04234  ;--------------------------------------------------------------------
04235  00F6F0  20 EB F6      RD2HEX  		JSR     RD1HEX        	
04236  00F6F3  0A                    		ASL        	
04237  00F6F4  0A                    		ASL        	
04238  00F6F5  0A                    		ASL        	
04239  00F6F6  0A                    		ASL        	        	
04240  00F6F7  85 E2                 		STA     TEMP1            	
04241  00F6F9  20 EB F6              		JSR     RD1HEX        	        	
04242  00F6FC  05 E2                 		ORA     TEMP1       	        	        	
04243  00F6FE  60                    		RTS      	
04244  
04245  
04246  ;--------------------------------------------------------------
04247  ;AC in HEX out BIN
04248  
04249  00F6FF  49 30         HEX2BIN			EOR     #'0'            	;Ignore ASCII part for decimals				
04250  00F701  C9 0A                         	CMP     #9+1	
04251  00F703  90 08                         	BCC     .okhex          	;It was a decimal digit!
04252  00F705  69 88                         	ADC     #$88            	;Map letters A - F to $FA-FF
04253  00F707  C9 FA                         	CMP     #$fa
04254  00F709  90 03                         	BCC     .invalid        	;No hex digit anymore!
04255  00F70B  29 0F                         	AND	#$0F		  	
04256  00F70D  60            .okhex   		RTS
04257  
04258  00F70E  A9 FF         .invalid 		LDA 	#FAIL
04259  00F710  60            			RTS
04260  			;SEC
04261  			;JSR     STRING
04262          		;.ASCIS   CR,LF,BELL," :HEX 2 BIN CONVERSION",CR,LF        	
04263          		;BRK
04264  
04265  ;--------------------------------------------------------------
04266  ;Restore saved registers
04267  ;--------------------------------------------------------------
04268  00F711  A5 A8         RESTORE 		LDA SAVP     		 	;Restore 6502 Register Contents 
04269  00F713  48                    		PHA             	 	;Used by tracing software
04270  00F714  A5 AC                 		LDA SAVA	
04271  00F716  A6 AB         			LDX SAVX
04272  00F718  A4 AA                 		LDY SAVY
04273  00F71A  28                    		PLP
04274  00F71B  60                    		RTS
04275  
04276  ;------------------------------------------------------------------------
04277  ; Save HW registers
04278  ;------------------------------------------------------------------------    	
04279          	
04280  00F71C  85 AC         SAVE    		STA SAVA        		;Save 6502 HW registers
04281  00F71E  86 AB         			STX SAVX
04282  00F720  84 AA                 		STY SAVY
04283  00F722  08                    		PHP
04284  00F723  68                    		PLA
04285  00F724  85 A8                 		STA SAVP			;svae the flags
04286  00F726  BA                    		TSX
04287  00F727  86 A9                 		STX SAVS			;stack pointer        		
04288  00F729  60                    		RTS	
04289          	
04290  ;--------------------------------------------------------------
04291  ;Convert buffer to uppercase         	
04292  00F72A  B5 19         UPPERCASE 		LDA 	IN,x
04293  00F72C  C9 7B                 		CMP     #'z'+1        		
04294  00F72E  B0 08         	        	BCS     .NEXTDIGIT        	
04295  00F730  C9 61                 		CMP     #'a'	        	
04296  00F732  90 04                 		BCC     .NEXTDIGIT        	
04297  00F734  E9 20                 		SBC     #SP        	
04298  00F736  95 19                 		STA     IN,x        		
04299  00F738  CA            .NEXTDIGIT 		DEX
04300  00F739  10 EF         			BPL     UPPERCASE		;end of string        	
04301  00F73B  60                    		RTS       	
04302   
04303   
04304    
04305   
04306   		.IF LCD_ROUTINES
04307  		.ENDIF       				;End of LCD Routines
04308  
04309   
04310  ;------------------------------------------------------------------------------------------        	
04311  ;Interrupts Handling       	
04312  ;------------------------------------------------------------------------------------------
04313  00F73C  6C FB 00      NMI_VECTOR     		JMP     (USMNI)        		;NMI hardware interrupt handler        			      		
04314          		    				;loop through RAM        		
04315  
04316  ;------------------------------------------------------------------------------------------
04317  NMI_RETURN 		 				;Routines http://6502.org/tutorials/interrupts.html	
04318          			
04319  IRQ_RETURN    		;JSR	SAVE  	         
04320           		;LDA  	ASTAT 			;Read 6551 ACIA status register
04321           		;AND 	#$88   			;Isolate bits 7: Interrupt has occured and 3: receive data register full 
04322           		;EOR  	#$88   			;Invert state of both bits 		
04323           		;BNE  	.BRKINSTR 		;IF bit 7 OR bit 3 = 1: no valid data in receive data register          		       
04324                  	;LDX  	INCNT  			; ELSE, Store keystroke in keystroke buffer address
04325           		;STA  	IN,X 			;  indexed by INCNT: keystroke buffer input counter
04326           		;INC  	INCNT  			;Increment keystroke buffer input counter
04327  .BRKINSTR		;JSR	RESTORE         
04328  00F73F  40            			RTI				;IRQ return address - used to store in RAM 
04329  
04330  ;------------------------------------------------------------------------------------------
04331  ;IRQ Routine
04332  ;------------------------------------------------------------------------------------------
04333  00F740  48            IRQ_VECTOR     		PHA                		;IRQ hardware interrupt
04334  00F741  DA                    		PHX
04335  00F742  BA                    		TSX
04336  00F743  BD 03 01              		LDA     $0103,x			;check if caused by a 
04337  00F746  FA                    		PLX				;done with X so restore it
04338  00F747  89 10                 		BIT     #$10			;BRK instruction        	
04339  00F749  D0 04                 		BNE     GOBRK			;yes        	
04340  00F74B  68                    		PLA				;no must have been an IRQ        	
04341  00F74C  6C F7 00              		JMP     (USIRQ)        	
04342  00F74F  68            GOBRK   		PLA		
04343  00F750  6C F9 00              		JMP     (USBRK)
04344  
04345  ;------------------------------------------------------------------------------------------
04346  ; IRQ Routine return
04347  ;------------------------------------------------------------------------------------------
04348  00F753  28            BRK_RETURN     		PLP
04349  00F754  20 1C F7              		JSR 	SAVE       		;Save the Registers
04350  00F757  68                    		PLA              		; save the Program counter
04351  00F758  85 DC                 		STA 	SRCE
04352  00F75A  68                    		PLA
04353  00F75B  85 DD                 		STA 	SRCE+1
04354  00F75D  BA            			TSX			
04355  00F75E  86 A9                 		STX 	SAVS			;save registers
04356  00F760  20 FF F7      XBRK			JSR 	TRACE_DIS		;show registers		
04357  00F763  58            			CLI
04358  00F764  4C 03 E0      			JMP    	WARM 
04359  
04360  ;------------------------------------------------------------------------
04361  ; Tracing
04362  ;------------------------------------------------------------------------	
04363  
04364  00F767  68            CMD_TRACE		PLA				;Pull caller address off stack
04365  00F768  68            			PLA				
04366  00F769  20 E3 E6      			JSR 	GET_EXPRES 
04367  00F76C  D0 07         			BNE	.CONT
04368  00F76E  84 DC         		        STY     SRCE			; else continue 
04369  00F770  85 DD                         	STA     SRCE+1  
04370  00F772  20 73 F6                      	JSR	CLS			;Clear the screen                	
04371  00F775  20 FF F7      .CONT			JSR 	TRACE_DIS						
04372  00F778  A2 08         			LDX 	#$08
04373  00F77A  BD F6 F7      XQINIT  		LDA 	INITBL-1,X 		;Init XEQ AREA with dummy code into Excute area
04374  00F77D  95 99                 		STA 	XQT,X			
04375  00F77F  CA                    		DEX
04376  00F780  D0 F8                 		BNE 	XQINIT
04377          		
04378  00F782  A1 DC                 		LDA 	(SRCE,X)    		;Get the user code OP- Current source line address
04379  00F784  F0 DA                 		BEQ 	XBRK		       	;Special If BRK       	
04380  00F786  A4 DA                 		LDY 	LENG     		;Length from Dissassembler 
04381  00F788  C9 80                 		CMP	#$80			;BRA instructions	
04382  00F78A  D0 02                 		BNE	.BRNCH 			
04383  00F78C  A9 F0                 		LDA	#$F0			;Fudge BRA into a BEQ
04384  00F78E  C9 20         .BRNCH        		CMP 	#$20
04385  00F790  F0 38                 		BEQ 	XJSR       		;Handle JSR, RTS, JMP,
04386  00F792  C9 60                 		CMP 	#$60    	   	;RTS
04387  00F794  F0 26                 		BEQ 	XRTS
04388  00F796  C9 4C                 		CMP 	#$4C			;JMP
04389  00F798  F0 38                 		BEQ 	XJMP
04390  00F79A  C9 6C                 		CMP 	#$6C			;JMP ()
04391  00F79C  F0 35                 		BEQ 	XJMPAT
04392  00F79E  C9 40                 		CMP 	#$40			;RTI - this is special
04393  00F7A0  F0 16                 		BEQ 	XRTI
04394  00F7A2  29 1F                 		AND 	#$1F
04395  00F7A4  49 14                 		EOR 	#$14
04396  00F7A6  C9 04                 		CMP 	#$04       		;Copy use code into the XEQ area
04397  00F7A8  F0 02                 		BEQ 	.XQ2       		;  with trialing NOP command
04398  00F7AA  B1 DC         .XQ1    		LDA 	(SRCE),Y    		;Changce relative branch
04399  00F7AC  99 99 00      .XQ2    		STA 	XQT,Y      		;  Disp to 4
04400  00F7AF  88                    		DEY            			;  JMP to branch or
04401  00F7B0  10 F8                 		BPL 	.XQ1      	 	;  NBRANCK (not branch) from XEQ.
04402  00F7B2  20 11 F7              		JSR 	RESTORE    		;Restore user registers 
04403  00F7B5  4C 99 00              		JMP	 XQT        		;XEQ excute user code in RAM
04404  00F7B8  18            XRTI    		CLC
04405  00F7B9  68                    		PLA     	        	;Simulate RTI by expect flags register
04406  00F7BA  85 A8                 		STA 	SAVP     		; status from stack, then return
04407  00F7BC  68            XRTS    		PLA              		;RTS simulate
04408  00F7BD  85 DC                	 		STA 	SRCE        		;  Extract PC from stack 
04409  00F7BF  68                    		PLA             		;  and update PC 
04410  00F7C0  85 DD         PCINC2  		STA 	SRCE+1
04411  00F7C2  20 FA E2      PCINC3  		JSR 	PCADJ2			;Update by the length of the instruction
04412  00F7C5  84 DD                 		STY 	SRCE+1
04413  00F7C7  18                    		CLC
04414  00F7C8  80 11                 		BRA 	NEWPCL			;Always taken
04415          	
04416  00F7CA  18            XJSR    		CLC				;Handle JSR instructions
04417  00F7CB  20 FA E2              		JSR 	PCADJ2     		;Update the PC
04418  00F7CE  5A                    		PHY				;and push it onto the stak
04419  00F7CF  48                    		PHA
04420  00F7D0  A0 02                 		LDY 	#$02
04421  00F7D2  18            XJMP    		CLC
04422  00F7D3  B1 DC         XJMPAT  		LDA 	(SRCE),Y
04423  00F7D5  AA                    		TAX              		;LOAD PC FOR JMP,
04424  00F7D6  88                    		DEY              		;  (JMP) SIMULATE.
04425  00F7D7  B1 DC                 		LDA 	(SRCE),Y
04426  00F7D9  86 DD                 		STX 	SRCE+1
04427  00F7DB  85 DC         NEWPCL  		STA 	SRCE
04428  00F7DD  B0 F3                 		BCS 	XJMP
04429  RTS_TRACE     		;STZ	ERROR			;no error - save a bytes
04430  00F7DF  4C 09 E0      			JMP	GETLINE 		;stack may carry JSR/RTS address's
04431          		
04432  ;------------------------------------------------------------------------
04433  ; TRACE - Branch taken calculation
04434  ;------------------------------------------------------------------------
04435  00F7E2  38            BRANCH  		SEC     	         	;branch Taken
04436  00F7E3  A0 01                 		LDY 	#$01       		;  Then add len + 2
04437  00F7E5  B1 DC                 		LDA	(SRCE),Y
04438  00F7E7  20 FC E2              		JSR 	PCADJ3        		;calculate address
04439  00F7EA  1A                    		INA				;Inc A
04440  00F7EB  85 DC                 		STA 	SRCE
04441  00F7ED  84 DD                 		STY	SRCE+1		
04442  00F7EF  80 EE                 		BRA 	RTS_TRACE		;save a byte
04443  
04444  ;------------------------------------------------------------------------
04445  ; TRACE - Normal return from Trace command
04446  ;------------------------------------------------------------------------
04447         		
04448  00F7F1  20 1C F7      NBRNCH  		JSR 	SAVE       		;Normal Return after
04449  00F7F4  38                    		SEC              		;  XEQ used for
04450  00F7F5  80 CB                 		BRA 	PCINC3     		;Goto PC update
04451  
04452  ;------------------------------------------------------------------------
04453  ; TRACE - Initial Build for Tracing
04454  ;------------------------------------------------------------------------
04455  00F7F7  EA            INITBL  		NOP				;Dummy fill for Tracing
04456  00F7F8  EA                    		NOP              		;XEQ area
04457  00F7F9  4C F1 F7              		JMP NBRNCH     			;Normal return
04458  00F7FC  4C E2 F7              		JMP BRANCH
04459          		       	
04460  
04461  ;------------------------------------------------------------------------------------------
04462  ; TRACE - show registers and dissamble OPCODE and display
04463  ;------------------------------------------------------------------------------------------
04464  00F7FF  20 0B F8      TRACE_DIS		JSR 	CMD_SHOWREG		;show registers	
04465  00F802  20 C3 E3      			JSR	DISPLAY_ADDR        	;display SOURCE address (could remove A&Y)              		               		               		
04466  00F805  B2 DC         			LDA	(SRCE)			;Get OpCode
04467  00F807  20 6F E2      			JSR 	INSTDSP					
04468  00F80A  60                    		RTS
04469  
04470  ;------------------------------------------------------------------------------------------  
04471  ; Show the registers
04472  ;------------------------------------------------------------------------------------------  
04473  00F80B  D8            CMD_SHOWREG		CLD				;debugging
04474  		.IF	MYWYM
04475  00F80C  AC 06 88      			LDY	io_posy			;GETY position
04476  			;INY	
04477  00F80F  C0 05         			CPY	#05
04478  00F811  10 02         			BPL	.reset
04479  00F813  A0 05         			LDY	#05				
04480  00F815  5A            .reset			PHY			
04481  		.ENDIF		
04482  00F816  A2 00         			LDX	#00			;top left
04483  00F818  A0 00         			LDY	#00
04484  00F81A  20 58 F6      			JSR	GOTOXY	
04485  00F81D  20 15 F6      			JSR	STRING
04486  			
04487  			;packed 
04488  			
04489  			.DB	$a1,$a5,$a1,$a5,$a1,$a5,$a1,$a5,$a1,$a5,$b4,CR,LF,$7c,$a1,$a3			
04490  			.DB	$a1,$7c,$a1,$a2,$a2,$7c,$a2,$a1,$a2,$7c,$a5,$7c,$a3,$a2,$7c,$a2
04491  			.db	$41,$43,$3d,EOS
04492  			
04493  			
04494  00F844  A5 AC         			LDA	SAVA 
04495  00F846  20 BC F6              		JSR     WR2HEX     		;Accumulator        		
04496  00F849  20 9E F6              		JSR     WRSPACE        		
04497          		
04498  00F84C  20 15 F6              		JSR	STRING
04499          	.ASCII 	"  SP=",EOS
04500  00F855  A5 A9                 		LDA	SAVS
04501  00F857  20 BC F6              		JSR     WR2HEX     		;Stack Pointer
04502  00F85A  20 9E F6              		JSR     WRSPACE
04503  		
04504  			        		
04505  00F85D  20 15 F6              		JSR	STRING
04506  		.ASCII CR,LF
04507  		.ASCII "  | | |    -|     |   --|   __|  XR=",EOS
04508  		
04509  		        		
04510  00F887  A5 AB                 		LDA	SAVX 
04511  00F889  20 BC F6              		JSR     WR2HEX     		;X Reg        		
04512  00F88C  20 9E F6              		JSR     WRSPACE        		
04513          		
04514  00F88F  20 15 F6              		JSR     STRING	        
04515  	        .ASCII "  NV*B.DIZC",CR,LF
04516  	        .ASCII "  |_| |__|__|__|__|_____|_____|  YR=",EOS
04517  	        	
04518  00F8C4  A5 AA                 		LDA	SAVY 
04519  00F8C6  20 BC F6              		JSR     WR2HEX     		;Y Reg
04520  00F8C9  20 9E F6              		JSR     WRSPACE        		
04521          	
04522  00F8CC  20 9E F6              		JSR	WRSPACE
04523  00F8CF  20 9E F6              		JSR	WRSPACE
04524          		
04525  00F8D2  A5 A8                 		LDA	SAVP
04526  00F8D4  20 C8 EB              		JSR	WRBIN			;Flags       	        	
04527  00F8D7  20 AD F6              		JSR	DRAWLINE
04528          		
04529          	.IF 	MYWYM		 
04530  00F8DA  7A                    		PLY				;restore Y
04531  00F8DB  8C 06 88              		STY	io_posy
04532          	.ENDIF	
04533  00F8DE  60                    		RTS        			;Start of code	
04534          	
04535  ;------------------------------------------------------------------------------------------
04536  00F8DF  78            RESET_VECTOR   		SEI				;Hardware reset routine
04537  00F8E0  A5 FD         			LDA	USRRST			;Check what vector to use
04538  00F8E2  49 A5         			EOR	#$A5
04539  00F8E4  C5 FF         			CMP	USRRST+2
04540  00F8E6  D0 03         			BNE	COLD_BOOT 
04541  00F8E8  6C FD 00      			JMP     (USRRST)		;User Rest Vector
04542  		
04543  				
04544  00F8EB  A9 F7         COLD_BOOT		LDA	#<RESET_RETURN		;User user vector
04545  00F8ED  85 FD         			STA	USRRST
04546  00F8EF  49 A5         			EOR	#$A5
04547  00F8F1  85 FF         			STA	USRRST+2
04548  00F8F3  A9 F8         			LDA	#>RESET_RETURN	
04549  00F8F5  85 FE         			STA	USRRST+1
04550  			
04551  
04552  RESET_RETURN 		
04553  		.IF	MYWYM	
04554  	
04555  00F8F7  A2 FF         			LDX	#$ff       		;normal boot up procedure
04556  00F8F9  9A                    		TXS
04557  
04558  ;			SED
04559  ;			SEC
04560  ;			LDA 	#$20
04561  ;			SBC 	#$0F
04562  ;			CMP	#$0B
04563  ;			BNE	DET6502
04564  ;			JSR	STRING
04565  ;		.ASCIS	"detected a 65C02 CPU"
04566  ;DET6502			NOP		
04567  
04568  00F8FA  D8                    		CLD
04569          		
04570          	.IF	MYWYM
04571               
04572  00F8FB  A2 0E                         	LDX	#INITDATA_END-INITDATA	;FAST Initialise ZP	
04573  00F8FD  BD 09 F9      .INITZP         	LDA	INITDATA,X
04574  00F900  95 ED         			STA	USR_OBJHI,X	
04575  00F902  CA            			DEX
04576  00F903  10 F8                         	BPL	.INITZP	               			
04577  00F905  58            			CLI				;restore Interrupts
04578  00F906  4C 00 E0              		JMP	COLD       	
04579  
04580  INITDATA		.WORD	$9000			;USR_OBJHI User's safe object end		
04581  			.BYTE	$00 			;Lomem address   | Don't
04582  			.BYTE	DEF_LOMEM		;LOMEM defined page
04583  			.BYTE	$00			;Himem address |  change order			
04584  			.BYTE	DEF_LOMEM		;HIMEM defined page
04585  			.WORD	XEC_RTS			;XEC_LAST Last Xec address				
04586  			.WORD	USERKEYDEF_RETURN	;USERKEYDEF User defined @keys 
04587  			.WORD	IRQ_RETURN		;User IRQ vector
04588  			.WORD	BRK_RETURN		;User BRK vector	
04589  INITDATA_END		.WORD	NMI_RETURN		;User NMI vector	
04590  			;.WORD	RESET_RETURN		;User RESET vector
04591  				
04592  
04593  ;------------------------------------------------------------------------------------------
04594  ;Display help screen
04595  ;------------------------------------------------------------------------------------------
04596  00F919  20 15 F6      CMD_HLP 		JSR     STRING            	
04597  	
04598  		;Code packed saving 30% of bytes 324 bytes reduced
04599  		
04600  			.DB	$0d,$e2,$a7,$e2,$a7,$e2,$a5,$e4,$a6,$e2,$a2,$e1,$0d,$0a,$e1,$7c
04601  			.DB	$e3,$7c,$e3,$7c,$7c,$e4,$a3,$7c,$7c,$e5,$7c,$e2,$7c,$e3,$a2,$e1
04602  			.DB	$5c,$7c,$e2,$7c,$0d,$0a,$e1,$7c,$e7,$7c,$7c,$e4,$a3,$7c,$7c,$e5
04603  			.DB	$7c,$a1,$e1,$7c,$e4,$a2,$2f,$7c,$a2,$7c,$eb,$40,$e2,$55,$73,$65
04604  			.DB	$72,$e1,$64,$65,$66,$69,$6e,$65,$64,$e1,$63,$6f,$6d,$6d,$61,$6e
04605  			.DB	$64,$0d,$0a,$e1,$7c,$a3,$7c,$a3,$7c,$7c,$a7,$7c,$7c,$a7,$7c,$7c
04606  			.DB	$a3,$7c,$e3,$7c,$a2,$7c,$eb,$41,$e2,$41,$75,$74,$6f,$e1,$6c,$69
04607  			.DB	$6e,$65,$e1,$6e,$75,$6d,$62,$65,$72,$69,$6e,$67,$0d,$0a,$ff,$f4,$42
04608  			.DB	$e2,$42,$72,$65,$61,$6b,$e1,$63,$6f,$6d,$6d,$61,$6e,$64,$0d,$0a
04609  			.DB	$e3,$45,$58,$50,$41,$4e,$53,$49,$4f,$4e,$e1,$50,$4f,$52,$54,$e1
04610  			.DB	$4c,$4f,$57,$e5,$45,$58,$50,$41,$4e,$53,$49,$4f,$4e,$e1,$50,$4f
04611  			.DB	$52,$54,$e1,$54,$4f,$50,$e7,$43,$e2,$43,$6f,$70,$79,$e1,$63,$6f
04612  			.DB	$6d,$6d,$61,$6e,$64,$0d,$0a,$e2,$2b,$b3,$2b,$e2,$2b,$b3,$2b,$e5
04613  			.DB	$44,$e2,$44,$69,$73,$73,$61,$73,$73,$65,$6d,$62,$6c,$65,$72,$0d
04614  			.DB	$0a,$e2,$7c,$5b,$5d,$47,$4e,$44,$e9,$2b,$35,$56,$5b,$5d,$7c,$e2
04615  			.DB	$7c,$5b,$5d,$50,$41,$30,$e9,$49,$52,$51,$5b,$5d,$7c,$e5,$49,$e2
04616  			.DB	$41,$53,$43,$49,$49,$e1,$44,$75,$6d,$70,$0d,$0a,$e2,$7c,$5b,$5d
04617  			.DB	$41,$31,$32,$e9,$2b,$35,$56,$5b,$5d,$7c,$e2,$7c,$5b,$5d,$50,$41
04618  			.DB	$31,$e9,$4e,$4d,$49,$5b,$5d,$7c,$e5,$4c,$e2,$4c,$69,$73,$74,$e1
04619  			.DB	$63,$6f,$6d,$6d,$61,$6e,$64,$0d,$0a,$e2,$7c,$5b,$5d,$41,$37,$eb
04620  			.DB	$4e,$43,$5b,$5d,$7c,$e2,$7c,$5b,$5d,$50,$41,$32,$e9,$52,$2f,$57
04621  			.DB	$5b,$5d,$7c,$e5,$4d,$e2,$4d,$65,$6d,$6f,$72,$79,$e1,$63,$6f,$6d
04622  			.DB	$6d,$61,$6e,$64,$0d,$0a,$e2,$7c,$5b,$5d,$41,$36,$eb,$41,$38,$5b
04623  			.DB	$5d,$7c,$e2,$7c,$5b,$5d,$50,$41,$33,$ea,$30,$32,$5b,$5d,$7c,$e5
04624  			.DB	$4e,$e2,$4e,$65,$77,$e1,$63,$6f,$6d,$6d,$61,$6e,$64,$0d,$0a,$e2
04625  			.DB	$7c,$5b,$5d,$41,$35,$eb,$41,$39,$5b,$5d,$7c,$e2,$7c,$5b,$5d,$50
04626  			.DB	$41,$34,$e9,$43,$41,$31,$5b,$5d,$7c,$e5,$4f,$e2,$4f,$6c,$64,$e1
04627  			.DB	$63,$6f,$6d,$6d,$61,$6e,$64,$0d,$0a,$e2,$7c,$5b,$5d,$41,$34,$ea
04628  			.DB	$41,$31,$31,$5b,$5d,$7c,$e2,$7c,$5b,$5d,$50,$41,$35,$e9,$50,$42
04629  			.DB	$35,$5b,$5d,$7c,$e5,$52,$e2,$52,$65,$6e,$75,$6d,$62,$65,$72,$e1
04630  			.DB	$63,$6f,$6d,$6d,$61,$6e,$64,$0d,$0a,$e2,$7c,$5b,$5d,$41,$33,$ea
04631  			.DB	$47,$4e,$44,$5b,$5d,$7c,$e2,$7c,$5b,$5d,$50,$41,$36,$e9,$50,$42
04632  			.DB	$36,$5b,$5d,$7c,$e5,$53,$e2,$53,$74,$61,$72,$74,$e1,$61,$73,$73
04633  			.DB	$65,$6d,$62,$6c,$69,$6e,$67,$0d,$0a,$e2,$7c,$5b,$5d,$41,$32,$ea
04634  			.DB	$41,$31,$30,$5b,$5d,$7c,$e2,$7c,$5b,$5d,$50,$41,$37,$e9,$50,$42
04635  			.DB	$37,$5b,$5d,$7c,$e5,$54,$e2,$54,$72,$61,$63,$65,$e1,$63,$6f,$64
04636  			.DB	$65,$0d,$0a,$e2,$7c,$5b,$5d,$41,$31,$eb,$43,$53,$5b,$5d,$7c,$e2
04637  			.DB	$2b,$b3,$2b,$e5,$56,$e2,$56,$61,$6c,$75,$65,$e1,$63,$6f,$6d,$6d
04638  			.DB	$61,$6e,$64,$0d,$0a,$e2,$7c,$5b,$5d,$41,$30,$eb,$44,$37,$5b,$5d
04639  			.DB	$7c,$fc,$47,$e2,$47,$6f,$e1,$63,$6f,$6d,$6d,$61,$6e,$64,$0d,$0a
04640  			.DB	$e2,$7c,$5b,$5d,$44,$30,$eb,$44,$36,$5b,$5d,$7c,$e3,$48,$41,$52
04641  			.DB	$44,$57,$41,$52,$45,$e1,$4d,$41,$50,$50,$49,$4e,$47,$e9,$59,$e2
04642  			.DB	$4d,$65,$6d,$6f,$72,$79,$e1,$63,$6f,$6e,$66,$69,$67,$75,$72,$61
04643  			.DB	$69,$6f,$6e,$0d,$0a,$e2,$7c,$5b,$5d,$44,$31,$eb,$44,$35,$5b,$5d
04644  			.DB	$7c,$fc,$45,$e2,$45,$72,$61,$73,$65,$e1,$6c,$69,$6e,$65,$0d,$0a
04645  			.DB	$e2,$7c,$5b,$5d,$44,$32,$eb,$44,$34,$5b,$5d,$7c,$e4,$43,$53,$e3
04646  			.DB	$24,$32,$30,$30,$30,$ee,$5a,$e2,$43,$6c,$65,$61,$72,$e1,$53,$63
04647  			.DB	$72,$65,$65,$6e,$0d,$0a,$e2,$7c,$5b,$5d,$47,$4e,$44,$ea,$44,$33
04648  			.DB	$5b,$5d,$7c,$e4,$56,$49,$41,$e2,$24,$34,$30,$30,$30,$ee,$57,$e2
04649  			.DB	$44,$69,$73,$70,$6c,$61,$79,$e1,$52,$65,$67,$69,$73,$74,$65,$72
04650  			.DB	$0d,$0a,$e2,$2b,$b3,$2b,$e4,$41,$43,$49,$41,$e1,$24,$36,$30,$30
04651  			.DB	$30,$0d,$0a,EOS
04652  		
04653  		
04654  00FC51  60            USERKEYDEF_RETURN	RTS
04655  
04656  ;------------------------------------------------------------------------------------------
04657  ; Routines library for dissembler ROMs
04658  ;
04659  		
04660  ;RNT_RDCHAR	.BYTE	$71,00,06
04661  ;		.ASCII	"RDCHAR", $8D
04662  ;RNT_WDCHAR	.ASCIS	"WRCHAR"
04663  		
04664  		
04665  ;SYM_TABLE_ROM	.ASCIS	"R"
04666  ;		.BYTE	<RDCHAR
04667  ;		.BYTE	>RDCHAR
04668  ;		.BYTE	<RNT_RDCHAR 			
04669  ;		.BYTE	>RNT_RDCHAR
04670  ;		.BYTE	$FF
04671  ;		.BYTE	EOS
04672  
04673  
04674  		
04675  ;------------------------------------------------------------------------------------------
04676  ;interrupt vectors        
04677  ;------------------------------------------------------------------------------------------
04678  00FFFA                			*=	 $fffa 			
04679          		.WORD   NMI_VECTOR		; NMI_VECTOR
04680          		.WORD   RESET_VECTOR		; REST VECTOR
04681          		.WORD   IRQ_VECTOR		; IRQ_VECTOR        	
04682  
