ca65 V2.18 - Ubuntu 2.18-1
Main file   : osi_bas.s
Current file: osi_bas.s

000000r 1               ; _____ _____ _____           ______  ___   _____ _____ _____
000000r 1               ;|  _  /  ___|_   _|          | ___ \/ _ \ /  ___|_   _/  __ \
000000r 1               ;| | | \ `--.  | |    ______  | |_/ / /_\ \\ `--.  | | | /  \/
000000r 1               ;| | | |`--. \ | |   |______| | ___ \  _  | `--. \ | | | |
000000r 1               ;\ \_/ /\__/ /_| |_           | |_/ / | | |/\__/ /_| |_| \__/\
000000r 1               ; \___/\____/ \___/           \____/\_| |_/\____/ \___/ \____/
000000r 1               ;
000000r 1               ; Microsoft BASIC for the XPL-32 (OSI VERSION)
000000r 1               ;
000000r 1               ; (sorry for the cheesy ascii art)
000000r 1               ;
000000r 1               ; ==================================================================================
000000r 1               ; MODIFIED FROM THE ORIGINAL FILES AT http://www.pagetable.com/?p=46
000000r 1               ; MERGED INTO ONE FILE AND MACROS AND CONDITIONAL STATEMENTS REMOVED
000000r 1               ; BY G. SEARLE 2013
000000r 1               ;
000000r 1               ; Also is modified to work on the XPL-32 and with some various routines added
000000r 1               ; by Waverider  2020-2022
000000r 1               ;
000000r 1               ;
000000r 1               ; I/O and load/saves added to the end of this code
000000r 1               ;
000000r 1               ; This then assembles to the OSI version with the following
000000r 1               ; minor changes to the original BASIC code:
000000r 1               ; 1. Control-C call changed
000000r 1               ; 2. Load/save calls changed
000000r 1               ; 3. RAM start set to $0200 instead of $0300
000000r 1               ; 4. ROM start set to $C000
000000r 1               ; 5. Second letter of error messages back to ASCII value (instead of $80+val)
000000r 1               ; ==================================================================================
000000r 1               ;
000000r 1               ; Extract of original header comments follows:
000000r 1               ;
000000r 1               ; (first revision of this distribution, 20 Oct 2008, Michael Steil www.pagetable.com)
000000r 1               ;
000000r 1               ;
000000r 1               ; Name                 Release   MS Version    ROM   9digit  INPUTBUFFER   extensions
000000r 1               ;---------------------------------------------------------------------------------------------------
000000r 1               ; OSI BASIC             1977     1.0 REV 3.2    Y      N          ZP            -
000000r 1               ;
000000r 1               ; Credits:
000000r 1               ; * main work by Michael Steil
000000r 1               ; * G. Searle for formatting and I/O
000000r 1               ; * function names and all uppercase comments taken from Bob Sander-Cederlof's excellent AppleSoft II disassembly:
000000r 1               ;   http://www.txbobsc.com/scsc/scdocumentor/
000000r 1               ; * Applesoft lite by Tom Greene http://cowgod.org/replica1/applesoft/ helped a lot, too.
000000r 1               ; * Thanks to Joe Zbicak for help with Intellision Keyboard BASIC
000000r 1               ; * This work is dedicated to the memory of my dear hacking pal Michael "acidity" Kollmann.
000000r 1               ; wavid's creditz:
000000r 1               ; * Of course, Ben Eater is a major inspiration.
000000r 1               ; * George Foot made most of the SD Card stuff.
000000r 1               ; * krallja is very helpful
000000r 1               ; * JB Langston (lol)
000000r 1               ; * And me, Waverider...
000000r 1               ;
000000r 1               ; to recap:
000000r 1               ; ----------------------------------------------coders------------------------------------------------
000000r 1               ; Micheal Steil, Grant Searle, Bob Sander-Cederlof, Joe Zbicak, Tom Greene, George Foot, and Waverider
000000r 1               ; ----------------------------------------------------------------------------------------------------
000000r 1               ;
000000r 1               ; and now for the code...
000000r 1               
000000r 1               ; ======================================================
000000r 1               ; -------------------- Definitions ---------------------
000000r 1               ; ======================================================
000000r 1               
000000r 1               fat32_workspace = $200      ; two pages
000000r 1               
000000r 1               buffer = $400               ; 512 bytes
000000r 1               endbuf = $600
000000r 1               
000000r 1               .debuginfo +
000000r 1               
000000r 1               .setcpu "6502"
000000r 1               .macpack longbranch
000000r 2               .macro  jeq     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                       bne     *+5
000000r 2                       jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               beq     Target
000000r 2                       .else
000000r 2                               bne     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jne     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bne     Target
000000r 2                       .else
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jmi     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bmi     Target
000000r 2                       .else
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jpl     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bpl     Target
000000r 2                       .else
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcs     Target
000000r 2                       .else
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcc     Target
000000r 2                       .else
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvs     Target
000000r 2                       .else
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvc     Target
000000r 2                       .else
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               ; zero page
000000r 1               ZP_START1 = $00
000000r 1               ZP_START2 = $0D
000000r 1               ZP_START3 = $5B
000000r 1               ZP_START4 = $65
000000r 1               
000000r 1               ;extra ZP variables
000000r 1               USR             := $000A
000000r 1               
000000r 1               ; constants
000000r 1               STACK_TOP		:= $FC
000000r 1               SPACE_FOR_GOSUB := $33
000000r 1               NULL_MAX		:= $0A
000000r 1               WIDTH			:= 72
000000r 1               WIDTH2			:= 56
000000r 1               
000000r 1               ; memory layout
000000r 1               RAMSTART2		:= $0600
000000r 1               BYTES_FP		:= 4
000000r 1               BYTES_PER_ELEMENT := BYTES_FP
000000r 1               BYTES_PER_VARIABLE := BYTES_FP+2
000000r 1               MANTISSA_BYTES	:= BYTES_FP-1
000000r 1               BYTES_PER_FRAME := 2*BYTES_FP+8
000000r 1               FOR_STACK1		:= 2*BYTES_FP+5
000000r 1               FOR_STACK2		:= BYTES_FP+4
000000r 1               MAX_EXPON = 10
000000r 1               sdbuffer		:= $7ff2
000000r 1               STACK           := $0100
000000r 1               
000000r 1               INPUTBUFFERX = INPUTBUFFER & $FF00
000000r 1               
000000r 1               CR=13
000000r 1               LF=10
000000r 1               
000000r 1               CRLF_1 := CR
000000r 1               CRLF_2 := LF
000000r 1               
000000r 1               ; ======================================================
000000r 1               ; ---------------------- Zero Page ---------------------
000000r 1               ; ======================================================
000000r 1               
000000r 1               .feature org_per_seg
000000r 1               .zeropage
000000r 1               .org $0000
000000  1               .org ZP_START1
000000  1               charbuffer:
000000  1  xx           	.res 1
000001  1               zp_sd_address:
000001  1  xx xx        	.res 2
000003  1               zp_sd_currentsector:
000003  1  xx xx xx xx  	.res 4
000007  1               GORESTART:
000007  1  xx xx xx     	.res 3
00000A  1               GOSTROUT:
00000A  1  xx xx xx     	.res 3
00000D  1               GOAYINT:
00000D  1  xx xx        	.res 2
00000F  1               GOGIVEAYF:
00000F  1  xx xx        	.res 2
000011  1               
000011  1               .org ZP_START2
00000D  1               Z15:
00000D  1  xx           	.res 1
00000E  1               POSX:
00000E  1  xx           	.res 1
00000F  1               Z17:
00000F  1  xx           	.res 1
000010  1               Z18:
000010  1  xx           	.res 1
000011  1               LINNUM:
000011  1               TXPSV:
000011  1  xx xx        	.res 2
000013  1               INPUTBUFFER:
000013  1               
000013  1               .org ZP_START3
00005B  1               CHARAC:
00005B  1  xx           	.res 1
00005C  1               ENDCHR:
00005C  1  xx           	.res 1
00005D  1               EOLPNTR:
00005D  1  xx           	.res 1
00005E  1               DIMFLG:
00005E  1  xx           	.res 1
00005F  1               VALTYP:
00005F  1  xx           	.res 1
000060  1               DATAFLG:
000060  1  xx           	.res 1
000061  1               SUBFLG:
000061  1  xx           	.res 1
000062  1               INPUTFLG:
000062  1  xx           	.res 1
000063  1               CPRMASK:
000063  1  xx           	.res 1
000064  1               Z14:
000064  1  xx           	.res 1
000065  1               
000065  1               .org ZP_START4
000065  1               TEMPPT:
000065  1  xx           	.res 1
000066  1               LASTPT:
000066  1  xx xx        	.res 2
000068  1               TEMPST:
000068  1  xx xx xx xx  	.res 9
00006C  1  xx xx xx xx  
000070  1  xx           
000071  1               INDEX:
000071  1  xx xx        	.res 2
000073  1               DEST:
000073  1  xx xx        	.res 2
000075  1               RESULT:
000075  1  xx xx xx xx  	.res BYTES_FP
000079  1               RESULT_LAST = RESULT + BYTES_FP-1
000079  1               TXTTAB:
000079  1  xx xx        	.res 2
00007B  1               VARTAB:
00007B  1  xx xx        	.res 2
00007D  1               ARYTAB:
00007D  1  xx xx        	.res 2
00007F  1               STREND:
00007F  1  xx xx        	.res 2
000081  1               FRETOP:
000081  1  xx xx        	.res 2
000083  1               FRESPC:
000083  1  xx xx        	.res 2
000085  1               MEMSIZ:
000085  1  xx xx        	.res 2
000087  1               CURLIN:
000087  1  xx xx        	.res 2
000089  1               OLDLIN:
000089  1  xx xx        	.res 2
00008B  1               OLDTEXT:
00008B  1  xx xx        	.res 2
00008D  1               Z8C:
00008D  1  xx xx        	.res 2
00008F  1               DATPTR:
00008F  1  xx xx        	.res 2
000091  1               INPTR:
000091  1  xx xx        	.res 2
000093  1               VARNAM:
000093  1  xx xx        	.res 2
000095  1               VARPNT:
000095  1  xx xx        	.res 2
000097  1               FORPNT:
000097  1  xx xx        	.res 2
000099  1               LASTOP:
000099  1  xx xx        	.res 2
00009B  1               CPRTYP:
00009B  1  xx           	.res 1
00009C  1               FNCNAM:
00009C  1               TEMP3:
00009C  1  xx xx        	.res 2
00009E  1               DSCPTR:
00009E  1  xx xx        	.res 2
0000A0  1               DSCLEN:
0000A0  1  xx xx        	.res 2
0000A2  1               JMPADRS	:= DSCLEN + 1
0000A2  1               
0000A2  1               Z52:
0000A2  1  xx           	.res 1
0000A3  1               ARGEXTENSION:
0000A3  1               TEMP1:
0000A3  1  xx           	.res 1
0000A4  1               HIGHDS:
0000A4  1  xx xx        	.res 2
0000A6  1               HIGHTR:
0000A6  1  xx xx        	.res 2
0000A8  1               INDX:
0000A8  1               TMPEXP:
0000A8  1               TEMP2:
0000A8  1  xx           	.res 1
0000A9  1               EXPON:
0000A9  1  xx           	.res 1
0000AA  1               LOWTR:
0000AA  1               LOWTRX:
0000AA  1  xx           	.res 1
0000AB  1               EXPSGN:
0000AB  1  xx           	.res 1
0000AC  1               FAC:
0000AC  1  xx xx xx xx  	.res BYTES_FP
0000B0  1               FAC_LAST = FAC + BYTES_FP-1
0000B0  1               FACSIGN:
0000B0  1  xx           	.res 1
0000B1  1               SERLEN:
0000B1  1  xx           	.res 1
0000B2  1               SHIFTSIGNEXT:
0000B2  1  xx           	.res 1
0000B3  1               ARG:
0000B3  1  xx xx xx xx  	.res BYTES_FP
0000B7  1               ARG_LAST = ARG + BYTES_FP-1
0000B7  1               ARGSIGN:
0000B7  1  xx           	.res 1
0000B8  1               STRNG1:
0000B8  1  xx xx        	.res 2
0000BA  1               SGNCPR = STRNG1
0000BA  1               FACEXTENSION = STRNG1+1
0000BA  1               STRNG2:
0000BA  1  xx xx        	.res 2
0000BC  1               XYLODSAV2:
0000BC  1  xx xx        	.res 2
0000BE  1               zp_fat32_variables:
0000BE  1  xx xx xx xx  	.res 24
0000C2  1  xx xx xx xx  
0000C6  1  xx xx xx xx  
0000D6  1               CHRGET:
0000D6  1               TXTPTR = <(GENERIC_TXTPTR-GENERIC_CHRGET + CHRGET)
0000D6  1               CHRGOT = <(GENERIC_CHRGOT-GENERIC_CHRGET + CHRGET)
0000D6  1               CHRGOT2 = <(GENERIC_CHRGOT2-GENERIC_CHRGET + CHRGET)
0000D6  1               RNDSEED = <(GENERIC_RNDSEED-GENERIC_CHRGET + CHRGET)
0000D6  1               
0000D6  1               ; ======================================================
0000D6  1               ; ------------------ Beginning of ROM ------------------
0000D6  1               ; ======================================================
0000D6  1               
0000D6  1               .segment "CODE"
000000r 1               .org $C000
00C000  1               TOKEN_ADDRESS_TABLE:
00C000  1  B3 D0        		.word END-1
00C002  1  DB CF        		.word FOR-1
00C004  1  B9 D4        		.word NEXT-1
00C006  1  85 D1        		.word DATA-1
00C008  1  9C D3        		.word INPUT-1
00C00A  1  7A D7        		.word DIM-1
00C00C  1  C8 D3        		.word READ-1
00C00E  1  32 D2        		.word LET-1
00C010  1               TOKEN_GOTO=$80+(*-TOKEN_ADDRESS_TABLE)/2
00C010  1  32 D1        		.word GOTO-1
00C012  1  0A D1        		.word RUN-1
00C014  1  B5 D1        		.word IF-1
00C016  1  9F D0        		.word RESTORE-1
00C018  1               TOKEN_GOSUB=$80+(*-TOKEN_ADDRESS_TABLE)/2
00C018  1  15 D1        		.word GOSUB-1
00C01A  1  5F D1        		.word POP-1
00C01C  1               TOKEN_REM=$80+(*-TOKEN_ADDRESS_TABLE)/2
00C01C  1  C8 D1        		.word REM-1
00C01E  1  B1 D0        		.word STOP-1
00C020  1  D8 D1        		.word ON-1
00C022  1  F4 D0        		.word NULL-1
00C024  1  AB DE        		.word WAIT-1
00C026  1  3D EA        		.word LOAD-1
00C028  1  E4 EB        		.word SAVE-1
00C02A  1  57 DA        		.word DEF-1
00C02C  1  A2 DE        		.word POKE-1
00C02E  1               TOKEN_PRINT=$80+(*-TOKEN_ADDRESS_TABLE)/2
00C02E  1  A8 D2        		.word PRINT-1
00C030  1  DA D0        		.word CONT-1
00C032  1  3A CF        		.word LIST-1
00C034  1  05 D1        		.word CLEAR-1
00C036  1  E6 CE        		.word NEW-1
00C038  1               TOKEN_TAB=$00+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_TO=$01+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_FN=$02+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_SPC=$03+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_THEN=$04+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_NOT=$05+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_STEP=$06+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_PLUS=$07+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_MINUS=$08+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_GREATER=$0E+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               TOKEN_EQUAL=$0F+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               NUM_TOKENS=(*-TOKEN_ADDRESS_TABLE)/2
00C038  1               
00C038  1               UNFNC:
00C038  1               TOKEN_SGN=$11+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C038  1  52 E2        		.word SGN
00C03A  1  DC E2        		.word INT
00C03C  1  6F E2        		.word ABS
00C03E  1  0A 00        		.word USR
00C040  1  27 DA        		.word FRE
00C042  1  48 DA        		.word POS
00C044  1  26 E5        		.word SQR
00C046  1  3A E6        		.word RND
00C048  1  37 E0        		.word LOG
00C04A  1  95 E5        		.word EXP
00C04C  1  76 E6        		.word COS
00C04E  1  7D E6        		.word SIN
00C050  1  C6 E6        		.word TAN
00C052  1  13 E7        		.word ATN
00C054  1  98 DE        		.word PEEK
00C056  1  06 DE        		.word LEN
00C058  1  06 DB        		.word STR
00C05A  1  37 DE        		.word VAL
00C05C  1  15 DE        		.word ASC
00C05E  1  76 DD        		.word CHRSTR
00C060  1               TOKEN_LEFTSTR=$11+$80+(*-TOKEN_ADDRESS_TABLE)/2
00C060  1  8A DD        		.word LEFTSTR
00C062  1  B6 DD        		.word RIGHTSTR
00C064  1  C1 DD        		.word MIDSTR
00C066  1               
00C066  1               MATHTBL:
00C066  1  79                   .byte   $79
00C067  1  E8 DE                .word   FADDT-1
00C069  1  79                   .byte   $79
00C06A  1  D1 DE                .word   FSUBT-1
00C06C  1  7B                   .byte   $7B
00C06D  1  77 E0                .word   FMULTT-1
00C06F  1  7B                   .byte   $7B
00C070  1  46 E1                .word   FDIVT-1
00C072  1  7F                   .byte   $7F
00C073  1  2F E5                .word   FPWRT-1
00C075  1  50                   .byte   $50
00C076  1  E2 D6                .word   TAND-1
00C078  1  46                   .byte   $46
00C079  1  DF D6                .word   OR-1
00C07B  1  7D                   .byte   $7D
00C07C  1  68 E5                .word   NEGOP-1
00C07E  1  5A                   .byte   $5A
00C07F  1  51 D6                .word   EQUOP-1
00C081  1  64                   .byte   $64
00C082  1  0F D7                .word   RELOPS-1
00C084  1               
00C084  1               TOKEN_NAME_TABLE:
00C084  1  45 4E C4     		.byte "EN", $80+'D'
00C087  1  46 4F D2     		.byte "FO", $80+'R'
00C08A  1  4E 45 58 D4  		.byte "NEX", $80+'T'
00C08E  1  44 41 54 C1  		.byte "DAT", $80+'A'
00C092  1  49 4E 50 55  		.byte "INPU", $80+'T'
00C096  1  D4           
00C097  1  44 49 CD     		.byte "DI", $80+'M'
00C09A  1  52 45 41 C4  		.byte "REA", $80+'D'
00C09E  1  4C 45 D4     		.byte "LE", $80+'T'
00C0A1  1  47 4F 54 CF  		.byte "GOT", $80+'O'
00C0A5  1  52 55 CE     		.byte "RU", $80+'N'
00C0A8  1  49 C6        		.byte "I", $80+'F'
00C0AA  1  52 45 53 54  		.byte "RESTOR", $80+'E'
00C0AE  1  4F 52 C5     
00C0B1  1  47 4F 53 55  		.byte "GOSU", $80+'B'
00C0B5  1  C2           
00C0B6  1  52 45 54 55  		.byte "RETUR", $80+'N'
00C0BA  1  52 CE        
00C0BC  1  52 45 CD     		.byte "RE", $80+'M'
00C0BF  1  53 54 4F D0  		.byte "STO", $80+'P'
00C0C3  1  4F CE        		.byte "O", $80+'N'
00C0C5  1  4E 55 4C CC  		.byte "NUL", $80+'L'
00C0C9  1  57 41 49 D4  		.byte "WAI", $80+'T'
00C0CD  1  4C 4F 41 C4  		.byte "LOA", $80+'D'
00C0D1  1  53 41 56 C5  		.byte "SAV", $80+'E'
00C0D5  1  44 45 C6     		.byte "DE", $80+'F'
00C0D8  1  50 4F 4B C5  		.byte "POK", $80+'E'
00C0DC  1  50 52 49 4E  		.byte "PRIN", $80+'T'
00C0E0  1  D4           
00C0E1  1  43 4F 4E D4  		.byte "CON", $80+'T'
00C0E5  1  4C 49 53 D4  		.byte "LIS", $80+'T'
00C0E9  1  43 4C 45 41  		.byte "CLEA", $80+'R'
00C0ED  1  D2           
00C0EE  1  4E 45 D7     		.byte "NE", $80+'W'
00C0F1  1  54 41 42 A8  		.byte "TAB", $80+'('
00C0F5  1  54 CF        		.byte "T", $80+'O'
00C0F7  1  46 CE        		.byte "F", $80+'N'
00C0F9  1  53 50 43 A8  		.byte "SPC", $80+'('
00C0FD  1  54 48 45 CE  		.byte "THE", $80+'N'
00C101  1  4E 4F D4     		.byte "NO", $80+'T'
00C104  1  53 54 45 D0  		.byte "STE", $80+'P'
00C108  1  AB           		.byte "", $80+'+'
00C109  1  AD           		.byte "", $80+'-'
00C10A  1  AA           		.byte "", $80+'*'
00C10B  1  AF           		.byte "", $80+'/'
00C10C  1  DE           		.byte "", $80+'^'
00C10D  1  41 4E C4     		.byte "AN", $80+'D'
00C110  1  4F D2        		.byte "O", $80+'R'
00C112  1  BE           		.byte "", $80+'>'
00C113  1  BD           		.byte "", $80+'='
00C114  1  BC           		.byte "", $80+'<'
00C115  1  53 47 CE     		.byte "SG", $80+'N'
00C118  1  49 4E D4     		.byte "IN", $80+'T'
00C11B  1  41 42 D3     		.byte "AB", $80+'S'
00C11E  1  55 53 D2     		.byte "US", $80+'R'
00C121  1  46 52 C5     		.byte "FR", $80+'E'
00C124  1  50 4F D3     		.byte "PO", $80+'S'
00C127  1  53 51 D2     		.byte "SQ", $80+'R'
00C12A  1  52 4E C4     		.byte "RN", $80+'D'
00C12D  1  4C 4F C7     		.byte "LO", $80+'G'
00C130  1  45 58 D0     		.byte "EX", $80+'P'
00C133  1  43 4F D3     		.byte "CO", $80+'S'
00C136  1  53 49 CE     		.byte "SI", $80+'N'
00C139  1  54 41 CE     		.byte "TA", $80+'N'
00C13C  1  41 54 CE     		.byte "AT", $80+'N'
00C13F  1  50 45 45 CB  		.byte "PEE", $80+'K'
00C143  1  4C 45 CE     		.byte "LE", $80+'N'
00C146  1  53 54 52 A4  		.byte "STR", $80+'$'
00C14A  1  56 41 CC     		.byte "VA", $80+'L'
00C14D  1  41 53 C3     		.byte "AS", $80+'C'
00C150  1  43 48 52 A4  		.byte "CHR", $80+'$'
00C154  1  4C 45 46 54  		.byte "LEFT", $80+'$'
00C158  1  A4           
00C159  1  52 49 47 48  		.byte "RIGHT", $80+'$'
00C15D  1  54 A4        
00C15F  1  4D 49 44 A4  		.byte "MID", $80+'$'
00C163  1  00           		.byte   0
00C164  1               
00C164  1               ERROR_MESSAGES:
00C164  1               ERR_NOFOR := <(*-ERROR_MESSAGES)
00C164  1  4E 46                .byte "NF"
00C166  1               ERR_SYNTAX := <(*-ERROR_MESSAGES)
00C166  1  53 4E                .byte "SN"
00C168  1               ERR_NOGOSUB := <(*-ERROR_MESSAGES)
00C168  1  52 47                .byte "RG"
00C16A  1               ERR_NODATA := <(*-ERROR_MESSAGES)
00C16A  1  4F 44                .byte "OD"
00C16C  1               ERR_ILLQTY := <(*-ERROR_MESSAGES)
00C16C  1  46 43                .byte "FC"
00C16E  1               ERR_OVERFLOW := <(*-ERROR_MESSAGES)
00C16E  1  4F 56                .byte "OV"
00C170  1               ERR_MEMFULL := <(*-ERROR_MESSAGES)
00C170  1  4F 4D                .byte "OM"
00C172  1               ERR_UNDEFSTAT := <(*-ERROR_MESSAGES)
00C172  1  55 53                .byte "US"
00C174  1               ERR_BADSUBS := <(*-ERROR_MESSAGES)
00C174  1  42 53                .byte "BS"
00C176  1               ERR_REDIMD := <(*-ERROR_MESSAGES)
00C176  1  44 44                .byte "DD"
00C178  1               ERR_ZERODIV := <(*-ERROR_MESSAGES)
00C178  1  2F 30                .byte "/0"
00C17A  1               ERR_ILLDIR := <(*-ERROR_MESSAGES)
00C17A  1  49 44                .byte "ID"
00C17C  1               ERR_BADTYPE := <(*-ERROR_MESSAGES)
00C17C  1  54 4D                .byte "TM"
00C17E  1               ERR_STRLONG := <(*-ERROR_MESSAGES)
00C17E  1  4C 53                .byte "LS"
00C180  1               ERR_FRMCPX := <(*-ERROR_MESSAGES)
00C180  1  53 54                .byte "ST"
00C182  1               ERR_CANTCONT := <(*-ERROR_MESSAGES)
00C182  1  43 4E                .byte "CN"
00C184  1               ERR_UNDEFFN := <(*-ERROR_MESSAGES)
00C184  1  55 46                .byte "UF"
00C186  1               
00C186  1               ; global messages: "error", "in", "ready", "break"
00C186  1               QT_ERROR:
00C186  1  20 45 52 52          .byte   " ERROR"
00C18A  1  4F 52        
00C18C  1  00                   .byte   0
00C18D  1               QT_IN:
00C18D  1  20 49 4E 20          .byte   " IN "
00C191  1  00                   .byte   $00
00C192  1               QT_OK:
00C192  1  0D 0A 4F 4B  		.byte   CR,LF,"OK",CR,LF
00C196  1  0D 0A        
00C198  1  00           		.byte	0
00C199  1               QT_BREAK:
00C199  1  0D 0A 42 52  		.byte CR,LF,"BREAK"
00C19D  1  45 41 4B     
00C1A0  1  00                   .byte   0
00C1A1  1               
00C1A1  1               ; ======================================================
00C1A1  1               ; --------------------- Libraries ----------------------
00C1A1  1               ; ======================================================
00C1A1  1               
00C1A1  1               	.include "hwconfig.s"
00C1A1  2               PORTB = $b000
00C1A1  2               PORTA = $b001
00C1A1  2               DDRB = $b002
00C1A1  2               DDRA = $b003
00C1A1  2               
00C1A1  2               SD_CS   = %00010000
00C1A1  2               SD_SCK  = %00001000
00C1A1  2               SD_MOSI = %00000100
00C1A1  2               SD_MISO = %00000010
00C1A1  2               EXTVID  = %10000000
00C1A1  2               
00C1A1  2               PORTA_OUTPUTS = EXTVID | SD_CS | SD_SCK | SD_MOSI
00C1A1  2               
00C1A1  2               via_init:
00C1A1  2  A9 FF          lda #%11111111          ; Set all pins on port B to output
00C1A3  2  8D 02 B0       sta DDRB
00C1A6  2  A9 9C          lda #PORTA_OUTPUTS   ; Set various pins on port A to output
00C1A8  2  8D 03 B0       sta DDRA
00C1AB  2  60             rts
00C1AC  2               
00C1AC  2               
00C1AC  1                	.include "libsd.s"
00C1AC  2               ; SD card interface module
00C1AC  2               ;
00C1AC  2               ; Requires zero-page variable storage:
00C1AC  2               ;   zp_sd_address - a bytes
00C1AC  2               ;   zp_sd_currentsector - 4 bytes
00C1AC  2               
00C1AC  2               cmsg:
00C1AC  2  43 6F 6D 6D    .byte "Command: ", $00
00C1B0  2  61 6E 64 3A  
00C1B4  2  20 00        
00C1B6  2               
00C1B6  2               sd_init:
00C1B6  2                 ; Let the SD card boot up, by pumping the clock with SD CS disabled
00C1B6  2               
00C1B6  2                 ; We need to apply around 80 clock pulses with CS and MOSI higha
00C1B6  2                 ; Normally MOSI doesn't matter when CS is high, but the card is
00C1B6  2                 ; not yet is SPI mode, and in this non-SPI state it does carea
00C1B6  2               
00C1B6  2  A9 14          lda #SD_CS | SD_MOSI
00C1B8  2  A2 A0          ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
00C1BA  2               apreinitloop:
00C1BA  2  49 08          eor #SD_SCK
00C1BC  2  8D 01 B0       sta PORTA
00C1BF  2  CA             dex
00C1C0  2  D0 F8          bne apreinitloop
00C1C2  2               
00C1C2  2               
00C1C2  2               acmd0: ; GO_IDLE_STATE - resets card to idle state, and SPI mode
00C1C2  2  A9 29          lda #<sd_cmd0_bytes
00C1C4  2  85 01          sta zp_sd_address
00C1C6  2  A9 C2          lda #>sd_cmd0_bytes
00C1C8  2  85 02          sta zp_sd_address+1
00C1CA  2               
00C1CA  2  20 7B C2       jsr sd_sendcommand
00C1CD  2               
00C1CD  2                 ; Expect status response $01 (not initialized)
00C1CD  2                ; cmp #$01
00C1CD  2                ; bne ainitfailed
00C1CD  2               
00C1CD  2               acmd8: ; SEND_IF_COND - tell the card how we want it to operate (3a3V, etc)
00C1CD  2  A9 2F          lda #<sd_cmd8_bytes
00C1CF  2  85 01          sta zp_sd_address
00C1D1  2  A9 C2          lda #>sd_cmd8_bytes
00C1D3  2  85 02          sta zp_sd_address+1
00C1D5  2               
00C1D5  2  20 7B C2       jsr sd_sendcommand
00C1D8  2               
00C1D8  2                 ; Expect status response $01 (not initialized)
00C1D8  2  C9 01          cmp #$01
00C1DA  2  D0 44          bne ainitfailed
00C1DC  2               
00C1DC  2                 ; Read 3a-bit return value, but ignore it
00C1DC  2  20 41 C2       jsr sd_readbyte
00C1DF  2  20 41 C2       jsr sd_readbyte
00C1E2  2  20 41 C2       jsr sd_readbyte
00C1E5  2  20 41 C2       jsr sd_readbyte
00C1E8  2               
00C1E8  2               acmd55: ; APP_CMD - required prefix for ACMD commands
00C1E8  2  A9 35          lda #<sd_cmd55_bytes
00C1EA  2  85 01          sta zp_sd_address
00C1EC  2  A9 C2          lda #>sd_cmd55_bytes
00C1EE  2  85 02          sta zp_sd_address+1
00C1F0  2               
00C1F0  2  20 7B C2       jsr sd_sendcommand
00C1F3  2               
00C1F3  2                 ; Expect status response $01 (not initialized)
00C1F3  2  C9 01          cmp #$01
00C1F5  2  D0 29          bne ainitfailed
00C1F7  2               
00C1F7  2               acmd41: ; APP_SEND_OP_COND - send operating conditions, initialize card
00C1F7  2  A9 3B          lda #<sd_cmd41_bytes
00C1F9  2  85 01          sta zp_sd_address
00C1FB  2  A9 C2          lda #>sd_cmd41_bytes
00C1FD  2  85 02          sta zp_sd_address+1
00C1FF  2               
00C1FF  2  20 7B C2       jsr sd_sendcommand
00C202  2               
00C202  2                 ; Status response $00 means initialised
00C202  2  C9 00          cmp #$00
00C204  2  F0 11          beq ainitialized
00C206  2               
00C206  2                 ; Otherwise expect status response $01 (not initialized)
00C206  2  C9 01          cmp #$01
00C208  2  D0 16          bne ainitfailed
00C20A  2               
00C20A  2                 ; Not initialized yet, so wait a while then try againa
00C20A  2                 ; This retry is important, to give the card time to initializea
00C20A  2               
00C20A  2  A2 00          ldx #0
00C20C  2  A0 00          ldy #0
00C20E  2               adelayloop:
00C20E  2  88             dey
00C20F  2  D0 FD          bne adelayloop
00C211  2  CA             dex
00C212  2  D0 FA          bne adelayloop
00C214  2               
00C214  2  4C E8 C1       jmp acmd55
00C217  2               
00C217  2               
00C217  2               ainitialized:
00C217  2  A0 C3          ldy #>initmsg
00C219  2  A2 74          ldx #<initmsg
00C21B  2  20 24 C9       jsr w_acia_full
00C21E  2  18             clc
00C21F  2  60             rts
00C220  2               
00C220  2               ainitfailed:
00C220  2  A0 C3          ldy #>initfailedmsg
00C222  2  A2 5A          ldx #<initfailedmsg
00C224  2  20 24 C9       jsr w_acia_full
00C227  2               aloop:
00C227  2  38             sec
00C228  2  60             rts
00C229  2               
00C229  2               sd_cmd0_bytes:
00C229  2  40 00 00 00    .byte $40, $00, $00, $00, $00, $95
00C22D  2  00 95        
00C22F  2               sd_cmd8_bytes:
00C22F  2  48 00 00 01    .byte $48, $00, $00, $01, $aa, $87
00C233  2  AA 87        
00C235  2               sd_cmd55_bytes:
00C235  2  77 00 00 00    .byte $77, $00, $00, $00, $00, $01
00C239  2  00 01        
00C23B  2               sd_cmd41_bytes:
00C23B  2  69 40 00 00    .byte $69, $40, $00, $00, $00, $01
00C23F  2  00 01        
00C241  2               
00C241  2               
00C241  2               
00C241  2               sd_readbyte:
00C241  2                 ; Enable the card and tick the clock 8 times with MOSI high,
00C241  2                 ; capturing bits from MISO and returning them
00C241  2               
00C241  2  A2 FE          ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
00C243  2               
00C243  2               baloop:
00C243  2               
00C243  2  A9 04          lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
00C245  2  8D 01 B0       sta PORTA
00C248  2               
00C248  2  A9 0C          lda #SD_MOSI | SD_SCK       ; toggle the clock high
00C24A  2  8D 01 B0       sta PORTA
00C24D  2               
00C24D  2  AD 01 B0       lda PORTA                   ; read next bit
00C250  2  29 02          and #SD_MISO
00C252  2               
00C252  2  18             clc                         ; default to clearing the bottom bit
00C253  2  F0 01          beq abitnotset              ; unless MISO was set
00C255  2  38             sec                         ; in which case get ready to set the bottom bit
00C256  2               abitnotset:
00C256  2               
00C256  2  8A             txa                         ; transfer partial result from X
00C257  2  2A             rol                         ; rotate carry bit into read result, and loop bit into carry
00C258  2  AA             tax                         ; save partial result back to X
00C259  2               
00C259  2  B0 E8          bcs baloop                   ; loop if we need to read more bits
00C25B  2               
00C25B  2  60             rts
00C25C  2               
00C25C  2               
00C25C  2               sd_writebyte:
00C25C  2                 ; Tick the clock 8 times with descending bits on MOSI
00C25C  2                 ; SD communication is mostly half-duplex so we ignore anything it sends back here
00C25C  2               
00C25C  2  A2 08          ldx #8                      ; send 8 bits
00C25E  2               
00C25E  2               arloop:
00C25E  2  0A             asl                         ; shift next bit into carry
00C25F  2  A8             tay                         ; save remaining bits for later
00C260  2               
00C260  2  A9 00          lda #0
00C262  2  90 02          bcc asendbit                ; if carry clear, don't set MOSI for this bit
00C264  2  09 04          ora #SD_MOSI
00C266  2               
00C266  2               asendbit:
00C266  2  8D 01 B0       sta PORTA                   ; set MOSI (or not) first with SCK low
00C269  2  49 08          eor #SD_SCK
00C26B  2  8D 01 B0       sta PORTA                   ; raise SCK keeping MOSI the same, to send the bit
00C26E  2               
00C26E  2  98             tya                         ; restore remaining bits to send
00C26F  2               
00C26F  2  CA             dex
00C270  2  D0 EC          bne arloop                   ; loop if there are more bits to send
00C272  2               
00C272  2  60             rts
00C273  2               
00C273  2               
00C273  2               sd_waitresult:
00C273  2                 ; Wait for the SD card to return something other than $ff
00C273  2  20 41 C2       jsr sd_readbyte
00C276  2  C9 FF          cmp #$ff
00C278  2  F0 F9          beq sd_waitresult
00C27A  2  60             rts
00C27B  2               
00C27B  2               
00C27B  2               sd_sendcommand:
00C27B  2                 ; Debug print which command is being executed
00C27B  2                ; jsr lcd_cleardisplay
00C27B  2                ; jsr cleardisplay
00C27B  2               
00C27B  2               ;  phx
00C27B  2               ;  phy
00C27B  2               ;  ldx #<cmsg
00C27B  2               ;  ldy #>cmsg
00C27B  2               ;  jsr w_acia_full
00C27B  2               ;  ply
00C27B  2               ;  plx
00C27B  2               
00C27B  2               ;  ldx #0
00C27B  2               ;  lda (zp_sd_address,x)
00C27B  2               ;  jsr print_hex_acia
00C27B  2               
00C27B  2               ;  lda #$a0
00C27B  2               ;  jsr print_chara
00C27B  2               ;
00C27B  2               ;  lda #$a0
00C27B  2               ;  jsr print_chara
00C27B  2               
00C27B  2  A9 04          lda #SD_MOSI           ; pull CS low to begin command
00C27D  2  8D 01 B0       sta PORTA
00C280  2               
00C280  2  A0 00          ldy #0
00C282  2  B1 01          lda (zp_sd_address),y    ; command byte
00C284  2  20 5C C2       jsr sd_writebyte
00C287  2  A0 01          ldy #1
00C289  2  B1 01          lda (zp_sd_address),y    ; data 1
00C28B  2  20 5C C2       jsr sd_writebyte
00C28E  2  A0 02          ldy #2
00C290  2  B1 01          lda (zp_sd_address),y    ; data 2
00C292  2  20 5C C2       jsr sd_writebyte
00C295  2  A0 03          ldy #3
00C297  2  B1 01          lda (zp_sd_address),y    ; data 3
00C299  2  20 5C C2       jsr sd_writebyte
00C29C  2  A0 04          ldy #4
00C29E  2  B1 01          lda (zp_sd_address),y    ; data 4
00C2A0  2  20 5C C2       jsr sd_writebyte
00C2A3  2  A0 05          ldy #5
00C2A5  2  B1 01          lda (zp_sd_address),y    ; crc
00C2A7  2  20 5C C2       jsr sd_writebyte
00C2AA  2               
00C2AA  2  20 73 C2       jsr sd_waitresult
00C2AD  2  48             pha
00C2AE  2               
00C2AE  2               ;  phy
00C2AE  2               ;  phx
00C2AE  2               ;  ldy #>respmsg
00C2AE  2               ;  ldx #<respmsg
00C2AE  2               ;  jsr w_acia_full
00C2AE  2               ;  ply
00C2AE  2               ;  plx
00C2AE  2               
00C2AE  2                 ; Debug print the result code
00C2AE  2               ;  jsr print_hex_acia
00C2AE  2               
00C2AE  2               ;  lda #$0d
00C2AE  2               ;  jsr print_chara
00C2AE  2               ;
00C2AE  2               ;  lda #$0a
00C2AE  2               ;  jsr print_chara
00C2AE  2               
00C2AE  2                 ; End command
00C2AE  2  A9 14          lda #SD_CS | SD_MOSI   ; set CS high again
00C2B0  2  8D 01 B0       sta PORTA
00C2B3  2               
00C2B3  2  68             pla   ; restore result code
00C2B4  2  60             rts
00C2B5  2               
00C2B5  2               
00C2B5  2               sd_readsector:
00C2B5  2                 ; Read a sector from the SD carda  A sector is 512 bytes.
00C2B5  2                 ;
00C2B5  2                 ; Parameters:
00C2B5  2                 ;    zp_sd_currentsector   3a-bit sector number
00C2B5  2                 ;    zp_sd_address     address of buffer to receive data
00C2B5  2               
00C2B5  2  A9 04          lda #SD_MOSI
00C2B7  2  8D 01 B0       sta PORTA
00C2BA  2               
00C2BA  2                 ; Command 17, arg is sector number, crc not checked
00C2BA  2  A9 51          lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
00C2BC  2  20 5C C2       jsr sd_writebyte
00C2BF  2  A5 06          lda zp_sd_currentsector+3   ; sector 24:31
00C2C1  2  20 5C C2       jsr sd_writebyte
00C2C4  2  A5 05          lda zp_sd_currentsector+2   ; sector 16:23
00C2C6  2  20 5C C2       jsr sd_writebyte
00C2C9  2  A5 04          lda zp_sd_currentsector+1   ; sector 8:15
00C2CB  2  20 5C C2       jsr sd_writebyte
00C2CE  2  A5 03          lda zp_sd_currentsector     ; sector 0:7
00C2D0  2  20 5C C2       jsr sd_writebyte
00C2D3  2  A9 01          lda #$01                    ; crc (not checked)
00C2D5  2  20 5C C2       jsr sd_writebyte
00C2D8  2               
00C2D8  2  20 73 C2       jsr sd_waitresult
00C2DB  2  C9 00          cmp #$00
00C2DD  2  D0 53          bne afail
00C2DF  2               
00C2DF  2                 ; wait for data
00C2DF  2  20 73 C2       jsr sd_waitresult
00C2E2  2  C9 FE          cmp #$fe
00C2E4  2  D0 4C          bne afail
00C2E6  2               
00C2E6  2                 ; Need to read 512 bytes - two pages of 256 bytes each
00C2E6  2  20 3B C3       jsr areadpage
00C2E9  2  E6 02          inc zp_sd_address+1
00C2EB  2  20 3B C3       jsr areadpage
00C2EE  2  C6 02          dec zp_sd_address+1
00C2F0  2               
00C2F0  2                 ; End command
00C2F0  2  A9 14          lda #SD_CS | SD_MOSI
00C2F2  2  8D 01 B0       sta PORTA
00C2F5  2               
00C2F5  2  38             sec
00C2F6  2  60             rts
00C2F7  2               
00C2F7  2               sd_writesector:
00C2F7  2                 ; Write a sector to the SD card.  A sector is 512 bytes.
00C2F7  2                 ;
00C2F7  2                 ; Parameters:
00C2F7  2                 ;    zp_sd_currentsector   32-bit sector number
00C2F7  2                 ;    zp_sd_address     address of buffer to take data from
00C2F7  2               
00C2F7  2  A9 02          lda #SD_MISO
00C2F9  2  8D 01 B0       sta PORTA
00C2FC  2               
00C2FC  2                 ; Command 24, arg is sector number, crc not checked
00C2FC  2  A9 58          lda #$58                    ; CMD24 - WRITE_BLOCK
00C2FE  2  20 5C C2       jsr sd_writebyte
00C301  2  A5 06          lda zp_sd_currentsector+3   ; sector 24:31
00C303  2  20 5C C2       jsr sd_writebyte
00C306  2  A5 05          lda zp_sd_currentsector+2   ; sector 16:23
00C308  2  20 5C C2       jsr sd_writebyte
00C30B  2  A5 04          lda zp_sd_currentsector+1   ; sector 8:15
00C30D  2  20 5C C2       jsr sd_writebyte
00C310  2  A5 03          lda zp_sd_currentsector     ; sector 0:7
00C312  2  20 5C C2       jsr sd_writebyte
00C315  2  A9 01          lda #$01                    ; crc (not checked)
00C317  2  20 5C C2       jsr sd_writebyte
00C31A  2               
00C31A  2  20 73 C2       jsr sd_waitresult
00C31D  2  C9 00          cmp #$00
00C31F  2  D0 11          bne afail
00C321  2               
00C321  2                 ; wait for data
00C321  2                 ;jsr sd_waitresult
00C321  2                 ;cmp #$fe
00C321  2                 ;bne afail
00C321  2                 ; BUG I don't think it need to wait for any more data, but I gotta check the datasheet more... (hard to read)
00C321  2               
00C321  2                 ; Need to write 512 bytes - two pages of 256 bytes each
00C321  2  20 46 C3       jsr awritepage
00C324  2  E6 02          inc zp_sd_address+1
00C326  2  20 46 C3       jsr awritepage
00C329  2  C6 02          dec zp_sd_address+1
00C32B  2               
00C32B  2                 ; End command
00C32B  2  A9 14          lda #SD_CS | SD_MOSI ; set cs and mosi high (disconnected)
00C32D  2  8D 01 B0       sta PORTA
00C330  2               
00C330  2  38             sec
00C331  2  60             rts
00C332  2               
00C332  2               afail:
00C332  2  A2 5F          ldx #<failedmsg
00C334  2  A0 C3          ldy #>failedmsg  ;Failed!
00C336  2  20 24 C9       jsr w_acia_full
00C339  2               afailloop:
00C339  2  18             clc
00C33A  2  60             rts
00C33B  2               
00C33B  2               areadpage:
00C33B  2                 ; Read 256 bytes to the address at zp_sd_address
00C33B  2  A0 00          ldy #0
00C33D  2               areadloop:
00C33D  2  20 41 C2       jsr sd_readbyte
00C340  2  91 01          sta (zp_sd_address),y
00C342  2  C8             iny
00C343  2  D0 F8          bne areadloop
00C345  2  60             rts
00C346  2               
00C346  2               awritepage:
00C346  2                 ; Write 256 bytes to the sd card
00C346  2  A0 00          ldy #0
00C348  2               awriteloop:
00C348  2  B1 01          lda (zp_sd_address),y
00C34A  2  20 5C C2       jsr sd_writebyte
00C34D  2  C8             iny
00C34E  2  D0 F8          bne awriteloop
00C350  2  60             rts
00C351  2               
00C351  2               statusmsg:
00C351  2  53 74 61 74    .byte "Status: ", $00
00C355  2  75 73 3A 20  
00C359  2  00           
00C35A  2               initfailedmsg:
00C35A  2  49 6E 69 74    .byte "Init "
00C35E  2  20           
00C35F  2               failedmsg:
00C35F  2  46 61 69 6C    .byte "Failed!", $0d, $0a, $00
00C363  2  65 64 21 0D  
00C367  2  0A 00        
00C369  2               respmsg:
00C369  2  52 65 73 70    .byte "Response: ", $00
00C36D  2  6F 6E 73 65  
00C371  2  3A 20 00     
00C374  2               initmsg:
00C374  2  49 6E 69 74    .byte "Initialized!", $0d, $0a, $00
00C378  2  69 61 6C 69  
00C37C  2  7A 65 64 21  
00C383  2               
00C383  1                 	.include "libfat32.s"
00C383  2               ; FAT32/SD interface library
00C383  2               ;
00C383  2               ; This module requires some RAM workspace to be defined elsewhere:
00C383  2               ;
00C383  2               ; fat32_workspace    - a large page-aligned 512-byte workspace
00C383  2               ; zp_fat32_variables - 24 bytes of zero-page storage for variables etc
00C383  2               
00C383  2               fat32_readbuffer = fat32_workspace
00C383  2               
00C383  2               fat32_fatstart          	= zp_fat32_variables + $00  ; 4 bytes
00C383  2               fat32_datastart         	= zp_fat32_variables + $04  ; 4 bytes
00C383  2               fat32_rootcluster       	= zp_fat32_variables + $08  ; 4 bytes
00C383  2               fat32_sectorspercluster 	= zp_fat32_variables + $0c  ; 1 byte
00C383  2               fat32_pendingsectors    	= zp_fat32_variables + $0d  ; 1 byte
00C383  2               fat32_address           	= zp_fat32_variables + $0e  ; 2 bytes
00C383  2               fat32_nextcluster       	= zp_fat32_variables + $10  ; 4 bytes
00C383  2               fat32_bytesremaining    	= zp_fat32_variables + $14  ; 4 bytes
00C383  2               fat32_lastfoundfreecluster	= zp_fat32_variables + $18  ; 4 bytes
00C383  2               fat32_result			= zp_fat32_variables + $1c  ; 2 bytes
00C383  2               fat32_dwcount			= zp_fat32_variables + $1e  ; 2 bytes
00C383  2               
00C383  2               fat32_errorstage        = fat32_bytesremaining  ; only used during initialization
00C383  2               fat32_filenamepointer   = fat32_bytesremaining  ; only used when searching for a file
00C383  2               fat32_lba		= fat32_bytesremaining  ; only used when making a dirent
00C383  2               
00C383  2               fat32_init:
00C383  2                 ; Initialize the module - read the MBR etc, find the partition,
00C383  2                 ; and set up the variables ready for navigating the filesystem
00C383  2               
00C383  2                 ; Read the MBR and extract pertinent information
00C383  2               
00C383  2  A9 00          lda #0
00C385  2  85 D2          sta fat32_errorstage
00C387  2               
00C387  2                 ; Sector 0
00C387  2  A9 00          lda #0
00C389  2  85 03          sta zp_sd_currentsector
00C38B  2  85 04          sta zp_sd_currentsector+1
00C38D  2  85 05          sta zp_sd_currentsector+2
00C38F  2  85 06          sta zp_sd_currentsector+3
00C391  2               
00C391  2                 ; Target buffer
00C391  2  A9 00          lda #<fat32_readbuffer
00C393  2  85 01          sta zp_sd_address
00C395  2  A9 02          lda #>fat32_readbuffer
00C397  2  85 02          sta zp_sd_address+1
00C399  2               
00C399  2                 ; Do the read
00C399  2  20 B5 C2       jsr sd_readsector
00C39C  2               
00C39C  2               
00C39C  2  E6 D2          inc fat32_errorstage ; stage 1 = boot sector signature check
00C39E  2               
00C39E  2                 ; Check some things
00C39E  2  AD FE 03       lda fat32_readbuffer+510 ; Boot sector signature 55
00C3A1  2  C9 55          cmp #$55
00C3A3  2  D0 2D          bne ufail
00C3A5  2  AD FF 03       lda fat32_readbuffer+511 ; Boot sector signature aa
00C3A8  2  C9 AA          cmp #$aa
00C3AA  2  D0 26          bne ufail
00C3AC  2               
00C3AC  2               
00C3AC  2  E6 D2          inc fat32_errorstage ; stage 2 = finding partition
00C3AE  2               
00C3AE  2                 ; Find a FAT32 partition
00C3AE  2               FSTYPE_FAT32 = 12
00C3AE  2  A2 00          ldx #0
00C3B0  2  BD C2 03       lda fat32_readbuffer+$1c2,x
00C3B3  2  C9 0C          cmp #FSTYPE_FAT32
00C3B5  2  F0 1E          beq ufoundpart
00C3B7  2  A2 10          ldx #16
00C3B9  2  BD C2 03       lda fat32_readbuffer+$1c2,x
00C3BC  2  C9 0C          cmp #FSTYPE_FAT32
00C3BE  2  F0 15          beq ufoundpart
00C3C0  2  A2 20          ldx #32
00C3C2  2  BD C2 03       lda fat32_readbuffer+$1c2,x
00C3C5  2  C9 0C          cmp #FSTYPE_FAT32
00C3C7  2  F0 0C          beq ufoundpart
00C3C9  2  A2 30          ldx #48
00C3CB  2  BD C2 03       lda fat32_readbuffer+$1c2,x
00C3CE  2  C9 0C          cmp #FSTYPE_FAT32
00C3D0  2  F0 03          beq ufoundpart
00C3D2  2               
00C3D2  2               ufail:
00C3D2  2  4C 89 C4       jmp uerror
00C3D5  2               
00C3D5  2               ufoundpart:
00C3D5  2               
00C3D5  2                 ; Read the FAT32 BPB
00C3D5  2  BD C6 03       lda fat32_readbuffer+$1c6,x
00C3D8  2  85 03          sta zp_sd_currentsector
00C3DA  2  BD C7 03       lda fat32_readbuffer+$1c7,x
00C3DD  2  85 04          sta zp_sd_currentsector+1
00C3DF  2  BD C8 03       lda fat32_readbuffer+$1c8,x
00C3E2  2  85 05          sta zp_sd_currentsector+2
00C3E4  2  BD C9 03       lda fat32_readbuffer+$1c9,x
00C3E7  2  85 06          sta zp_sd_currentsector+3
00C3E9  2               
00C3E9  2  20 B5 C2       jsr sd_readsector
00C3EC  2               
00C3EC  2               
00C3EC  2  E6 D2          inc fat32_errorstage ; stage 3 = BPB signature check
00C3EE  2               
00C3EE  2                 ; Check some things
00C3EE  2  AD FE 03       lda fat32_readbuffer+510 ; BPB sector signature 55
00C3F1  2  C9 55          cmp #$55
00C3F3  2  D0 DD          bne ufail
00C3F5  2  AD FF 03       lda fat32_readbuffer+511 ; BPB sector signature aa
00C3F8  2  C9 AA          cmp #$aa
00C3FA  2  D0 D6          bne ufail
00C3FC  2               
00C3FC  2  E6 D2          inc fat32_errorstage ; stage 4 = RootEntCnt check
00C3FE  2               
00C3FE  2  AD 11 02       lda fat32_readbuffer+17 ; RootEntCnt should be 0 for FAT32
00C401  2  0D 12 02       ora fat32_readbuffer+18
00C404  2  D0 CC          bne ufail
00C406  2               
00C406  2  E6 D2          inc fat32_errorstage ; stage 5 = TotSec16 check
00C408  2               
00C408  2  AD 13 02       lda fat32_readbuffer+19 ; TotSec16 should be 0 for FAT32
00C40B  2  0D 14 02       ora fat32_readbuffer+20
00C40E  2  D0 C2          bne ufail
00C410  2               
00C410  2  E6 D2          inc fat32_errorstage ; stage 6 = SectorsPerCluster check
00C412  2               
00C412  2                 ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
00C412  2  AD 0B 02       lda fat32_readbuffer+11 ; low byte should be zero
00C415  2  D0 BB          bne ufail
00C417  2  AD 0C 02       lda fat32_readbuffer+12 ; high byte is 2 (512), 4, 8, or 16
00C41A  2  C9 02          cmp #2
00C41C  2  D0 B4          bne ufail
00C41E  2               
00C41E  2               
00C41E  2                 ; Calculate the starting sector of the FAT
00C41E  2  18             clc
00C41F  2  A5 03          lda zp_sd_currentsector
00C421  2  6D 0E 02       adc fat32_readbuffer+14    ; reserved sectors lo
00C424  2  85 BE          sta fat32_fatstart
00C426  2  85 C2          sta fat32_datastart
00C428  2  A5 04          lda zp_sd_currentsector+1
00C42A  2  6D 0F 02       adc fat32_readbuffer+15    ; reserved sectors hi
00C42D  2  85 BF          sta fat32_fatstart+1
00C42F  2  85 C3          sta fat32_datastart+1
00C431  2  A5 05          lda zp_sd_currentsector+2
00C433  2  69 00          adc #0
00C435  2  85 C0          sta fat32_fatstart+2
00C437  2  85 C4          sta fat32_datastart+2
00C439  2  A5 06          lda zp_sd_currentsector+3
00C43B  2  69 00          adc #0
00C43D  2  85 C1          sta fat32_fatstart+3
00C43F  2  85 C5          sta fat32_datastart+3
00C441  2               
00C441  2                 ; Calculate the starting sector of the data area
00C441  2  AE 10 02       ldx fat32_readbuffer+16   ; number of FATs
00C444  2               uskipfatsloop:
00C444  2  18             clc
00C445  2  A5 C2          lda fat32_datastart
00C447  2  6D 24 02       adc fat32_readbuffer+36 ; fatsize 0
00C44A  2  85 C2          sta fat32_datastart
00C44C  2  A5 C3          lda fat32_datastart+1
00C44E  2  6D 25 02       adc fat32_readbuffer+37 ; fatsize 1
00C451  2  85 C3          sta fat32_datastart+1
00C453  2  A5 C4          lda fat32_datastart+2
00C455  2  6D 26 02       adc fat32_readbuffer+38 ; fatsize 2
00C458  2  85 C4          sta fat32_datastart+2
00C45A  2  A5 C5          lda fat32_datastart+3
00C45C  2  6D 27 02       adc fat32_readbuffer+39 ; fatsize 3
00C45F  2  85 C5          sta fat32_datastart+3
00C461  2  CA             dex
00C462  2  D0 E0          bne uskipfatsloop
00C464  2               
00C464  2                 ; Sectors-per-cluster is a power of two from 1 to 128
00C464  2  AD 0D 02       lda fat32_readbuffer+13
00C467  2  85 CA          sta fat32_sectorspercluster
00C469  2               
00C469  2                 ; Remember the root cluster
00C469  2  AD 2C 02       lda fat32_readbuffer+44
00C46C  2  85 C6          sta fat32_rootcluster
00C46E  2  AD 2D 02       lda fat32_readbuffer+45
00C471  2  85 C7          sta fat32_rootcluster+1
00C473  2  AD 2E 02       lda fat32_readbuffer+46
00C476  2  85 C8          sta fat32_rootcluster+2
00C478  2  AD 2F 02       lda fat32_readbuffer+47
00C47B  2  85 C9          sta fat32_rootcluster+3
00C47D  2               
00C47D  2                 ; Set the last fount free cluster to 0.
00C47D  2  A9 00          lda #0
00C47F  2  85 D6          sta fat32_lastfoundfreecluster
00C481  2  85 D7          sta fat32_lastfoundfreecluster+1
00C483  2  85 D8          sta fat32_lastfoundfreecluster+2
00C485  2  85 D9          sta fat32_lastfoundfreecluster+3
00C487  2  18             clc
00C488  2  60             rts
00C489  2               
00C489  2               uerror:
00C489  2  38             sec
00C48A  2  60             rts
00C48B  2               
00C48B  2               
00C48B  2               fat32_seekcluster:
00C48B  2                 ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
00C48B  2               
00C48B  2                 ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
00C48B  2  A5 CE          lda fat32_nextcluster
00C48D  2  0A             asl
00C48E  2  A5 CF          lda fat32_nextcluster+1
00C490  2  2A             rol
00C491  2  85 03          sta zp_sd_currentsector
00C493  2  A5 D0          lda fat32_nextcluster+2
00C495  2  2A             rol
00C496  2  85 04          sta zp_sd_currentsector+1
00C498  2  A5 D1          lda fat32_nextcluster+3
00C49A  2  2A             rol
00C49B  2  85 05          sta zp_sd_currentsector+2
00C49D  2                 ; note: cluster numbers never have the top bit set, so no carry can occur
00C49D  2               
00C49D  2                 ; Add FAT starting sector
00C49D  2  A5 03          lda zp_sd_currentsector
00C49F  2  65 BE          adc fat32_fatstart
00C4A1  2  85 03          sta zp_sd_currentsector
00C4A3  2  A5 04          lda zp_sd_currentsector+1
00C4A5  2  65 BF          adc fat32_fatstart+1
00C4A7  2  85 04          sta zp_sd_currentsector+1
00C4A9  2  A5 05          lda zp_sd_currentsector+2
00C4AB  2  65 C0          adc fat32_fatstart+2
00C4AD  2  85 05          sta zp_sd_currentsector+2
00C4AF  2  A9 00          lda #0
00C4B1  2  65 C1          adc fat32_fatstart+3
00C4B3  2  85 06          sta zp_sd_currentsector+3
00C4B5  2               
00C4B5  2                 ; Target buffer
00C4B5  2  A9 00          lda #<fat32_readbuffer
00C4B7  2  85 01          sta zp_sd_address
00C4B9  2  A9 02          lda #>fat32_readbuffer
00C4BB  2  85 02          sta zp_sd_address+1
00C4BD  2               
00C4BD  2                 ; Read the sector from the FAT
00C4BD  2  20 B5 C2       jsr sd_readsector
00C4C0  2               
00C4C0  2                 ; Before using this FAT data, set currentsector ready to read the cluster itself
00C4C0  2                 ; We need to multiply the cluster number minus two by the number of sectors per
00C4C0  2                 ; cluster, then add the data region start sector
00C4C0  2               
00C4C0  2                 ; Subtract two from cluster number
00C4C0  2  38             sec
00C4C1  2  A5 CE          lda fat32_nextcluster
00C4C3  2  E9 02          sbc #2
00C4C5  2  85 03          sta zp_sd_currentsector
00C4C7  2  A5 CF          lda fat32_nextcluster+1
00C4C9  2  E9 00          sbc #0
00C4CB  2  85 04          sta zp_sd_currentsector+1
00C4CD  2  A5 D0          lda fat32_nextcluster+2
00C4CF  2  E9 00          sbc #0
00C4D1  2  85 05          sta zp_sd_currentsector+2
00C4D3  2  A5 D1          lda fat32_nextcluster+3
00C4D5  2  E9 00          sbc #0
00C4D7  2  85 06          sta zp_sd_currentsector+3
00C4D9  2               
00C4D9  2                 ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
00C4D9  2  A5 CA          lda fat32_sectorspercluster
00C4DB  2               uspcshiftloop:
00C4DB  2  4A             lsr
00C4DC  2  B0 0B          bcs uspcshiftloopdone
00C4DE  2  06 03          asl zp_sd_currentsector
00C4E0  2  26 04          rol zp_sd_currentsector+1
00C4E2  2  26 05          rol zp_sd_currentsector+2
00C4E4  2  26 06          rol zp_sd_currentsector+3
00C4E6  2  4C DB C4       jmp uspcshiftloop
00C4E9  2               uspcshiftloopdone:
00C4E9  2               
00C4E9  2                 ; Add the data region start sector
00C4E9  2  18             clc
00C4EA  2  A5 03          lda zp_sd_currentsector
00C4EC  2  65 C2          adc fat32_datastart
00C4EE  2  85 03          sta zp_sd_currentsector
00C4F0  2  A5 04          lda zp_sd_currentsector+1
00C4F2  2  65 C3          adc fat32_datastart+1
00C4F4  2  85 04          sta zp_sd_currentsector+1
00C4F6  2  A5 05          lda zp_sd_currentsector+2
00C4F8  2  65 C4          adc fat32_datastart+2
00C4FA  2  85 05          sta zp_sd_currentsector+2
00C4FC  2  A5 06          lda zp_sd_currentsector+3
00C4FE  2  65 C5          adc fat32_datastart+3
00C500  2  85 06          sta zp_sd_currentsector+3
00C502  2               
00C502  2                 ; That's now ready for later code to read this sector in - tell it how many consecutive
00C502  2                 ; sectors it can now read
00C502  2  A5 CA          lda fat32_sectorspercluster
00C504  2  85 CB          sta fat32_pendingsectors
00C506  2               
00C506  2                 ; Now go back to looking up the next cluster in the chain
00C506  2                 ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
00C506  2               
00C506  2                 ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
00C506  2  A5 CE          lda fat32_nextcluster
00C508  2  29 7F          and #$7f
00C50A  2  0A             asl
00C50B  2  0A             asl
00C50C  2  A8             tay ; Y = low byte of offset
00C50D  2               
00C50D  2                 ; Add the potentially carried bit to the high byte of the address
00C50D  2  A5 02          lda zp_sd_address+1
00C50F  2  69 00          adc #0
00C511  2  85 02          sta zp_sd_address+1
00C513  2               
00C513  2                 ; Copy out the next cluster in the chain for later use
00C513  2  B1 01          lda (zp_sd_address),y
00C515  2  85 CE          sta fat32_nextcluster
00C517  2  C8             iny
00C518  2  B1 01          lda (zp_sd_address),y
00C51A  2  85 CF          sta fat32_nextcluster+1
00C51C  2  C8             iny
00C51D  2  B1 01          lda (zp_sd_address),y
00C51F  2  85 D0          sta fat32_nextcluster+2
00C521  2  C8             iny
00C522  2  B1 01          lda (zp_sd_address),y
00C524  2  29 0F          and #$0f
00C526  2  85 D1          sta fat32_nextcluster+3
00C528  2               
00C528  2                 ; See if it's the end of the chain
00C528  2  09 F0          ora #$f0
00C52A  2  25 D0          and fat32_nextcluster+2
00C52C  2  25 CF          and fat32_nextcluster+1
00C52E  2  C9 FF          cmp #$ff
00C530  2  D0 08          bne unotendofchain
00C532  2  A5 CE          lda fat32_nextcluster
00C534  2  C9 F8          cmp #$f8
00C536  2  90 02          bcc unotendofchain
00C538  2               
00C538  2                 ; It's the end of the chain, set the top bits so that we can tell this later on
00C538  2  85 D1          sta fat32_nextcluster+3
00C53A  2               unotendofchain:
00C53A  2               
00C53A  2  60             rts
00C53B  2               
00C53B  2               
00C53B  2               fat32_readnextsector:
00C53B  2                 ; Reads the next sector from a cluster chain into the buffer at fat32_address.
00C53B  2                 ;
00C53B  2                 ; Advances the current sector ready for the next read and looks up the next cluster
00C53B  2                 ; in the chain when necessary.
00C53B  2                 ;
00C53B  2                 ; On return, carry is clear if data was read, or set if the cluster chain has ended.
00C53B  2               
00C53B  2                 ; Maybe there are pending sectors in the current cluster
00C53B  2  A5 CB          lda fat32_pendingsectors
00C53D  2  D0 07          bne ureadsector
00C53F  2               
00C53F  2                 ; No pending sectors, check for end of cluster chain
00C53F  2  A5 D1          lda fat32_nextcluster+3
00C541  2  30 20          bmi uendofchain
00C543  2               
00C543  2                 ; Prepare to read the next cluster
00C543  2  20 8B C4       jsr fat32_seekcluster
00C546  2               
00C546  2               ureadsector:
00C546  2  C6 CB          dec fat32_pendingsectors
00C548  2               
00C548  2                 ; Set up target address
00C548  2  A5 CC          lda fat32_address
00C54A  2  85 01          sta zp_sd_address
00C54C  2  A5 CD          lda fat32_address+1
00C54E  2  85 02          sta zp_sd_address+1
00C550  2               
00C550  2                 ; Read the sector
00C550  2  20 B5 C2       jsr sd_readsector
00C553  2               
00C553  2                 ; Advance to next sector
00C553  2  E6 03          inc zp_sd_currentsector
00C555  2  D0 0A          bne usectorincrementdone
00C557  2  E6 04          inc zp_sd_currentsector+1
00C559  2  D0 06          bne usectorincrementdone
00C55B  2  E6 05          inc zp_sd_currentsector+2
00C55D  2  D0 02          bne usectorincrementdone
00C55F  2  E6 06          inc zp_sd_currentsector+3
00C561  2               usectorincrementdone:
00C561  2               
00C561  2                 ; Success - clear carry and return
00C561  2  18             clc
00C562  2  60             rts
00C563  2               
00C563  2               uendofchain:
00C563  2                 ; End of chain - set carry and return
00C563  2  38             sec
00C564  2  60             rts
00C565  2               
00C565  2               fat32_writenextsector:
00C565  2                 ; Writes the next sector from a cluster chain into the buffer at fat32_address.
00C565  2                 ;
00C565  2                 ; Advances the current sector ready for the next write and looks up the next cluster
00C565  2                 ; in the chain when necessary.
00C565  2                 ;
00C565  2                 ; On return, carry is set if its the end of the chain.
00C565  2               
00C565  2                 ; Maybe there are pending sectors in the current cluster
00C565  2  A5 CB          lda fat32_pendingsectors
00C567  2  D0 07          bne writesector
00C569  2               
00C569  2                 ; No pending sectors, check for end of cluster chain
00C569  2  A5 D1          lda fat32_nextcluster+3
00C56B  2  30 20          bmi endofchainn
00C56D  2               
00C56D  2                 ; Prepare to write the next cluster
00C56D  2  20 8B C4       jsr fat32_seekcluster
00C570  2                 ; BUG do i use this? or do i need to make a whole other thing so that I can use fat32_file_write..?
00C570  2               
00C570  2               writesector:
00C570  2  C6 CB          dec fat32_pendingsectors
00C572  2               
00C572  2                 ; Set up target address
00C572  2  A5 CC          lda fat32_address
00C574  2  85 01          sta zp_sd_address
00C576  2  A5 CD          lda fat32_address+1
00C578  2  85 02          sta zp_sd_address+1
00C57A  2               
00C57A  2                 ; Write the sector
00C57A  2  20 F7 C2       jsr sd_writesector
00C57D  2               
00C57D  2                 ; Advance to next sector
00C57D  2  E6 03          inc zp_sd_currentsector
00C57F  2  D0 0A          bne ursectorincrementdone
00C581  2  E6 04          inc zp_sd_currentsector+1
00C583  2  D0 06          bne ursectorincrementdone
00C585  2  E6 05          inc zp_sd_currentsector+2
00C587  2  D0 02          bne ursectorincrementdone
00C589  2  E6 06          inc zp_sd_currentsector+3
00C58B  2               ursectorincrementdone:
00C58B  2               
00C58B  2                 ; Success - clear carry and return
00C58B  2  18             clc
00C58C  2  60             rts
00C58D  2               
00C58D  2               endofchainn:
00C58D  2                 ; End of chain - set carry and return
00C58D  2  38             sec
00C58E  2  60             rts
00C58F  2               
00C58F  2               fat32_openroot:
00C58F  2                 ; Prepare to read the root directory
00C58F  2               
00C58F  2  A5 C6          lda fat32_rootcluster
00C591  2  85 CE          sta fat32_nextcluster
00C593  2  A5 C7          lda fat32_rootcluster+1
00C595  2  85 CF          sta fat32_nextcluster+1
00C597  2  A5 C8          lda fat32_rootcluster+2
00C599  2  85 D0          sta fat32_nextcluster+2
00C59B  2  A5 C9          lda fat32_rootcluster+3
00C59D  2  85 D1          sta fat32_nextcluster+3
00C59F  2               
00C59F  2  20 8B C4       jsr fat32_seekcluster
00C5A2  2               
00C5A2  2                 ; Set the pointer to a large value so we always read a sector the first time through
00C5A2  2  A9 FF          lda #$ff
00C5A4  2  85 02          sta zp_sd_address+1
00C5A6  2               
00C5A6  2  60             rts
00C5A7  2               
00C5A7  2               fat32_opendirent:
00C5A7  2                 ; Prepare to read/write a file or directory based on a dirent
00C5A7  2                 ;
00C5A7  2                 ; Point zp_sd_address at the dirent
00C5A7  2               
00C5A7  2                 ; Remember file size in bytes remaining
00C5A7  2  A0 1C          ldy #28
00C5A9  2  B1 01          lda (zp_sd_address),y
00C5AB  2  85 D2          sta fat32_bytesremaining
00C5AD  2  C8             iny
00C5AE  2  B1 01          lda (zp_sd_address),y
00C5B0  2  85 D3          sta fat32_bytesremaining+1
00C5B2  2  C8             iny
00C5B3  2  B1 01          lda (zp_sd_address),y
00C5B5  2  85 D4          sta fat32_bytesremaining+2
00C5B7  2  C8             iny
00C5B8  2  B1 01          lda (zp_sd_address),y
00C5BA  2  85 D5          sta fat32_bytesremaining+3
00C5BC  2               
00C5BC  2                 ; Seek to first cluster
00C5BC  2  A0 1A          ldy #26
00C5BE  2  B1 01          lda (zp_sd_address),y
00C5C0  2  85 CE          sta fat32_nextcluster
00C5C2  2  C8             iny
00C5C3  2  B1 01          lda (zp_sd_address),y
00C5C5  2  85 CF          sta fat32_nextcluster+1
00C5C7  2  A0 14          ldy #20
00C5C9  2  B1 01          lda (zp_sd_address),y
00C5CB  2  85 D0          sta fat32_nextcluster+2
00C5CD  2  C8             iny
00C5CE  2  B1 01          lda (zp_sd_address),y
00C5D0  2  85 D1          sta fat32_nextcluster+3
00C5D2  2               
00C5D2  2  20 8B C4       jsr fat32_seekcluster
00C5D5  2               
00C5D5  2                 ; Set the pointer to a large value so we always read a sector the first time through
00C5D5  2  A9 FF          lda #$ff
00C5D7  2  85 02          sta zp_sd_address+1
00C5D9  2               
00C5D9  2  60             rts
00C5DA  2               
00C5DA  2               fat32_writedirent:
00C5DA  2                 ; Write a directory entry from the open directory
00C5DA  2                 ; requires:
00C5DA  2                 ;   fat32bytesremaining (2 bytes) = file size in bytes (little endian)
00C5DA  2                 ;   and the processes of:
00C5DA  2                 ;     fat32_finddirent
00C5DA  2                 ;     fat32_findnextfreecluster
00C5DA  2                 ; Increment pointer by 32 to point to next entry
00C5DA  2  18             clc
00C5DB  2  A5 01          lda zp_sd_address
00C5DD  2  69 20          adc #32
00C5DF  2  85 01          sta zp_sd_address
00C5E1  2  A5 02          lda zp_sd_address+1
00C5E3  2  69 00          adc #0
00C5E5  2  85 02          sta zp_sd_address+1
00C5E7  2               
00C5E7  2                 ; If it's not at the end of the buffer, we have data already
00C5E7  2  C9 04          cmp #>(fat32_readbuffer+$200)
00C5E9  2  90 0F          bcc wgotdata
00C5EB  2               
00C5EB  2                 ; Read another sector
00C5EB  2  A9 00          lda #<fat32_readbuffer
00C5ED  2  85 CC          sta fat32_address
00C5EF  2  A9 02          lda #>fat32_readbuffer
00C5F1  2  85 CD          sta fat32_address+1
00C5F3  2               
00C5F3  2  20 3B C5       jsr fat32_readnextsector
00C5F6  2  90 02          bcc wgotdata
00C5F8  2               
00C5F8  2               endofdirectoryy:
00C5F8  2  38             sec
00C5F9  2  60             rts
00C5FA  2               
00C5FA  2               wgotdata:
00C5FA  2                 ; Check first character
00C5FA  2  18             clc
00C5FB  2  A0 00          ldy #0
00C5FD  2  B1 01          lda (zp_sd_address),y
00C5FF  2  48             pha
00C600  2  D0 01          bne wdirlpstart
00C602  2                 ; End of directory => tell loop
00C602  2  38             sec
00C603  2               wdirlpstart:
00C603  2  08             php
00C604  2               wdirlp:
00C604  2  B1 D2          lda (fat32_filenamepointer),y	; copy filename
00C606  2  91 01          sta (zp_sd_address),y
00C608  2  C8             iny
00C609  2  C0 0B          cpy #$0b
00C60B  2  D0 F7          bne wdirlp
00C60D  2                 ; The full Short filename is #11 bytes long so,
00C60D  2                 ; this start at 0x0b - File type
00C60D  2  A9 20          lda #$20		; File Type: ARCHIVE
00C60F  2  91 01          sta (zp_sd_address),y
00C611  2  C8             iny ; 0x0c - Checksum/File accsess password
00C612  2  A9 10          lda #$10		            ; No checksum or password
00C614  2  91 01          sta (zp_sd_address),y
00C616  2  68             pla	; 0x0d - Previous byte at 0x00
00C617  2  91 01          sta (zp_sd_address),y
00C619  2  C8             iny	; 0x0e-0x11 - File creation time/date
00C61A  2  A9 00          lda #0
00C61C  2  91 01          sta (zp_sd_address),y	; No time/date because I don't have an RTC
00C61E  2  C8             iny
00C61F  2  91 01          sta (zp_sd_address),y
00C621  2  C8             iny
00C622  2  91 01          sta (zp_sd_address),y
00C624  2  C8             iny
00C625  2  91 01          sta (zp_sd_address),y
00C627  2                 ; if you have an RTC, refer to https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#File_Allocation_Table
00C627  2                 ; look at "Directory entry" at 0x0E onward on the table.
00C627  2  C8             iny ; 0x12-0x13 - User ID
00C628  2  A9 00          lda #0
00C62A  2  91 01          sta (zp_sd_address),y	; No ID
00C62C  2  C8             iny
00C62D  2  91 01          sta (zp_sd_address),y
00C62F  2  C8             iny ; 0x14-0x15 - File start cluster (high word)
00C630  2  A5 D6          lda fat32_lastfoundfreecluster ; WARNING latfoundfreeclster is in this goofy ahh byte order stated here: http://6502.org/source/integers/ummodfix/ummodfix.htm
00C632  2  91 01          sta (zp_sd_address),y
00C634  2  C8             iny ; the byte order works well here though ig...
00C635  2  A5 D7          lda fat32_lastfoundfreecluster+1
00C637  2  91 01          sta (zp_sd_address),y
00C639  2  C8             iny ; 0x16-0x19 - File modifiaction date
00C63A  2  A9 00          lda #0
00C63C  2  91 01          sta (zp_sd_address),y
00C63E  2  C8             iny
00C63F  2  91 01          sta (zp_sd_address),y   ; no rtc aaaaa
00C641  2  C8             iny
00C642  2  91 01          sta (zp_sd_address),y
00C644  2  C8             iny
00C645  2  91 01          sta (zp_sd_address),y
00C647  2  C8             iny ; 0x1a-0x1b - File start cluster low word
00C648  2  A5 D8          lda fat32_lastfoundfreecluster+2
00C64A  2  91 01          sta (zp_sd_address),y
00C64C  2  C8             iny
00C64D  2  A5 D9          lda fat32_lastfoundfreecluster+3
00C64F  2  91 01          sta (zp_sd_address),y
00C651  2  C8             iny ; 0x1c-0x1f File size in bytes
00C652  2  A5 D2          lda fat32_bytesremaining
00C654  2  91 01          sta (zp_sd_address),y
00C656  2  C8             iny
00C657  2  A5 D3          lda fat32_bytesremaining+1
00C659  2  91 01          sta (zp_sd_address),y
00C65B  2  C8             iny
00C65C  2  A9 00          lda #0
00C65E  2  91 01          sta (zp_sd_address),y ; Not bigger that 64k
00C660  2  C8             iny
00C661  2  91 01          sta (zp_sd_address),y
00C663  2  C8             iny
00C664  2                 ; are we over the buffer?
00C664  2  A5 02          lda zp_sd_address+1
00C666  2  C9 04          cmp #>(fat32_readbuffer+$200)
00C668  2  90 12          bcc wdontt
00C66A  2  20 65 C5       jsr fat32_writenextsector ; if so, write the current sector
00C66D  2  20 3B C5       jsr fat32_readnextsector  ; then read the next one.
00C670  2  B0 1B          bcs wdfail
00C672  2  A0 00          ldy #0
00C674  2  A9 00          lda #<fat32_readbuffer
00C676  2  85 01          sta zp_sd_address
00C678  2  A9 02          lda #>fat32_readbuffer
00C67A  2  85 02          sta zp_sd_address+1
00C67C  2               wdontt:
00C67C  2                 ; is this the end of the table?
00C67C  2  28             plp
00C67D  2  90 08          bcc wdnot
00C67F  2  08             php
00C680  2                 ; if so, next entry is 0
00C680  2  A9 00          lda #0
00C682  2  91 01          sta (zp_sd_address),y
00C684  2  4C 88 C6       jmp wdobut
00C687  2               wdnot:
00C687  2  08             php
00C688  2               wdobut:
00C688  2  20 65 C5       jsr fat32_writenextsector ; write the data
00C68B  2  18             clc
00C68C  2  60             rts
00C68D  2               
00C68D  2               wdfail:
00C68D  2                 ; Card Full
00C68D  2  38             sec
00C68E  2  60             rts
00C68F  2               
00C68F  2               jmpskipdiv:
00C68F  2  4C 34 C7       jmp skipdiv
00C692  2               
00C692  2               fat32_findnextfreecluster:
00C692  2               ; Find next free cluster
00C692  2               ;
00C692  2               ; This program will search the FAT for an empty entry, and
00C692  2               ; save the 32-bit index (from fat_start) to fat32_lastfoundfreecluter.
00C692  2               ;
00C692  2               ; Also returns a 1 in the carry bit if the SD card is full.
00C692  2               ;
00C692  2  A5 BE          lda fat32_fatstart
00C694  2  85 D2          sta fat32_lba
00C696  2  A5 BF          lda fat32_fatstart+1
00C698  2  85 D3          sta fat32_lba+1			; copy fat_start to lba
00C69A  2  A5 C0          lda fat32_fatstart+2
00C69C  2  85 D4          sta fat32_lba+2
00C69E  2  A5 C1          lda fat32_fatstart+3
00C6A0  2  85 D5          sta fat32_lba+3
00C6A2  2  18             clc
00C6A3  2  A5 D6          lda fat32_lastfoundfreecluster	; if there is no previously found free cluster
00C6A5  2  65 D7          adc fat32_lastfoundfreecluster+1
00C6A7  2  65 D8          adc fat32_lastfoundfreecluster+2
00C6A9  2  65 D9          adc fat32_lastfoundfreecluster+3
00C6AB  2  F0 E2          beq jmpskipdiv				; then skip the division
00C6AD  2  A5 D6          lda fat32_lastfoundfreecluster
00C6AF  2  48             pha
00C6B0  2  A5 D7          lda fat32_lastfoundfreecluster+1
00C6B2  2  48             pha
00C6B3  2  A5 D8          lda fat32_lastfoundfreecluster+2	; save original states of the last found sector
00C6B5  2  48             pha					; (division clobbers it)
00C6B6  2  A5 D9          lda fat32_lastfoundfreecluster+3
00C6B8  2  48             pha
00C6B9  2  A5 00          lda $00				; extra variable usage for division
00C6BB  2  48             pha
00C6BC  2  A5 01          lda $01
00C6BE  2  48             pha
00C6BF  2               ; BUG is the math right?
00C6BF  2                 ; result = lastfoundfreecluster / 128
00C6BF  2                 ; 32-bit division from http://6502.org/source/integers/ummodfix/ummodfix.htm
00C6BF  2  38             SEC            			                  	; Detect overflow or /0 condition.
00C6C0  2  A5 D6          LDA     fat32_lastfoundfreecluster      ; Divisor must be more than high cell of dividend.  To
00C6C2  2  E9 80          SBC     #128                        		; find out, subtract divisor from high cell of dividend;
00C6C4  2  A5 D7          LDA     fat32_lastfoundfreecluster+1    ; if carry flag is still set at the end, the divisor was
00C6C6  2  E9 00          SBC     #0                         			; not big enough to avoid overflow. This also takes care
00C6C8  2  B0 2D          BCS     oflo                      			;	 of any /0 condition.  Branch if overflow or /0 error.
00C6CA  2                                                   			; We will loop 16 times; but since we shift the dividend
00C6CA  2  A2 11          LDX     #$11    	                  		; over at the same time as shifting the answer in, the
00C6CC  2                                  	                  		; operation must start AND finish with a shift of the
00C6CC  2                                  	                  		; low cell of the dividend (which ends up holding the
00C6CC  2                                  		                  	; quotient), so we start with 17 (11H) in X.
00C6CC  2               divloop:
00C6CC  2  26 D8          ROL     fat32_lastfoundfreecluster+2    ; Move low cell of dividend left one bit, also shifting
00C6CE  2  26 D9          ROL     fat32_lastfoundfreecluster+3    ; answer in. The 1st rotation brings in a 0, which later
00C6D0  2                                       	            		; gets pushed off the other end in the last rotation.
00C6D0  2  CA             DEX
00C6D1  2  F0 2E          BEQ     enddiv    		                  ; Branch to the end if finished.
00C6D3  2               
00C6D3  2  26 D6          ROL     fat32_lastfoundfreecluster      ; Shift high cell of dividend left one bit, also
00C6D5  2  26 D7          ROL     fat32_lastfoundfreecluster+1    ; shifting next bit in from high bit of low cell.
00C6D7  2  A9 00          LDA     #0
00C6D9  2  85 00          STA     $00   		                   		; Zero old bits of CARRY so subtraction works right.
00C6DB  2  26 00          ROL     $00   		                  		; Store old high bit of dividend in CARRY.  (For STZ
00C6DD  2                                  	                  		; one line up, NMOS 6502 will need LDA #0, STA CARRY.)
00C6DD  2  38             SEC                               			; See if divisor will fit into high 17 bits of dividend
00C6DE  2  A5 D6          LDA     fat32_lastfoundfreecluster      ; by subtracting and then looking at carry flag.
00C6E0  2  E9 80          SBC     #128       		                	; First do low byte.
00C6E2  2  85 01          STA     $01     	                  		; Save difference low byte until we know if we need it.
00C6E4  2  A5 D7          LDA     fat32_lastfoundfreecluster+1    ;
00C6E6  2  E9 00          SBC     #0     	                  			; Then do high byte.
00C6E8  2  A8             TAY             		                   	; Save difference high byte until we know if we need it.
00C6E9  2  A5 00          LDA     $00   			                  	; Bit 0 of CARRY serves as 17th bit.
00C6EB  2  E9 00          SBC     #0      		                  	; Complete the subtraction by doing the 17th bit before
00C6ED  2  90 DD          BCC     divloop 	 	                  	; determining if the divisor fit into the high 17 bits
00C6EF  2                                 	                  		; of the dividend.  If so, the carry flag remains set.
00C6EF  2  A5 01          LDA     $01                        			; If divisor fit into dividend high 17 bits, update
00C6F1  2  85 D6          STA     fat32_lastfoundfreecluster      ; dividend high cell to what it would be after
00C6F3  2  84 D7          STY     fat32_lastfoundfreecluster+1    ; subtraction.
00C6F5  2  B0 D5          BCS     divloop    		                	; Branch If Carry Set.  CMOS WDC65C02 could use BCS here. CA65 doesent allow it though.
00C6F7  2               
00C6F7  2               oflo:
00C6F7  2  A9 FF          LDA     #$FF    			                  ; If overflow occurred, put FF
00C6F9  2  85 D6          STA     fat32_lastfoundfreecluster      ; in remainder low byte
00C6FB  2  85 D7          STA     fat32_lastfoundfreecluster+1    ; and high byte,
00C6FD  2  85 D8          STA     fat32_lastfoundfreecluster+2    ; and in quotient low byte
00C6FF  2  85 D9          STA     fat32_lastfoundfreecluster+3    ; and high byte.
00C701  2               enddiv:
00C701  2  A5 D8        	LDA	fat32_lastfoundfreecluster+2
00C703  2  85 DA        	STA	fat32_result			; store quotient into fat32_result
00C705  2  A5 D9        	LDA	fat32_lastfoundfreecluster+3
00C707  2  85 DB        	STA	fat32_result+1
00C709  2  68           	PLA
00C70A  2  85 01        	STA	$01
00C70C  2  68           	PLA
00C70D  2  85 00        	STA	$00
00C70F  2  68           	PLA					; restore variables
00C710  2  85 D9        	STA	fat32_lastfoundfreecluster+3
00C712  2  68           	PLA
00C713  2  85 D8        	STA	fat32_lastfoundfreecluster+2
00C715  2  68           	PLA
00C716  2  85 D7        	STA	fat32_lastfoundfreecluster+1
00C718  2  68           	PLA
00C719  2  85 D6        	STA	fat32_lastfoundfreecluster
00C71B  2               	; add the result to lba
00C71B  2  18           	CLC
00C71C  2  A5 D2        	LDA	fat32_lba
00C71E  2  65 DA        	ADC	fat32_result
00C720  2  85 D2        	STA	fat32_lba
00C722  2  A5 D3        	LDA	fat32_lba+1
00C724  2  65 DB        	ADC	fat32_result+1
00C726  2  85 D3        	STA	fat32_lba+1
00C728  2  A5 D4        	LDA	fat32_lba+2
00C72A  2  69 00        	ADC	#0
00C72C  2  85 D4        	STA	fat32_lba+2
00C72E  2  A5 D5        	LDA	fat32_lba+3
00C730  2  69 00        	ADC	#0
00C732  2  85 D5        	STA	fat32_lba+3
00C734  2               skipdiv:
00C734  2                 ; now we have preformed LBA=+LASTFOUNDSECTOR/128
00C734  2                 ; LBA - FATSTART = RESULT
00C734  2  38             sec
00C735  2  A5 D2          lda fat32_lba
00C737  2  E5 BE          sbc fat32_fatstart
00C739  2  85 DC          sta fat32_dwcount
00C73B  2  A5 D3          lda fat32_lba+1
00C73D  2  E5 BF          sbc fat32_fatstart+1
00C73F  2  85 DD          sta fat32_dwcount+1
00C741  2  A5 D4          lda fat32_lba+2
00C743  2  E5 C0          sbc fat32_fatstart+2
00C745  2  85 DE          sta fat32_dwcount+2
00C747  2  A5 D5          lda fat32_lba+3
00C749  2  E5 C1          sbc fat32_fatstart+3
00C74B  2  85 DF          sta fat32_dwcount+3
00C74D  2                 ; Save zp_sd_address for later
00C74D  2  A5 01          lda zp_sd_address
00C74F  2  48             pha
00C750  2  A5 02          lda zp_sd_address+1
00C752  2  48             pha
00C753  2                 ; Now we will find a free cluster. (finally)
00C753  2               findfreeclusterloop:
00C753  2                 ; We will read at sector LBA
00C753  2  A5 D2          lda fat32_lba
00C755  2  85 03          sta zp_sd_currentsector
00C757  2  A5 D3          lda fat32_lba+1
00C759  2  85 04          sta zp_sd_currentsector+1
00C75B  2  A5 D4          lda fat32_lba+2
00C75D  2  85 05          sta zp_sd_currentsector+2
00C75F  2  A5 D5          lda fat32_lba+3
00C761  2  85 06          sta zp_sd_currentsector+3
00C763  2                 ; Target buffer
00C763  2  A9 00          lda #<fat32_readbuffer
00C765  2  85 01          sta zp_sd_address
00C767  2  A9 02          lda #>fat32_readbuffer
00C769  2  85 02          sta zp_sd_address+1
00C76B  2                 ; Read sector
00C76B  2  20 B5 C2       jsr sd_readsector
00C76E  2                 ; Now Check each entry in the sector.
00C76E  2  A2 00          ldx #0
00C770  2  A0 00          ldy #0
00C772  2               ffcinner:
00C772  2  B1 01          lda (zp_sd_address),y
00C774  2  29 0F          and #$0f			; First 4 bits are reserved.
00C776  2  C8             iny
00C777  2  18             clc
00C778  2  71 01          adc (zp_sd_address),y
00C77A  2  C8             iny
00C77B  2  71 01          adc (zp_sd_address),y
00C77D  2  C8             iny
00C77E  2  71 01          adc (zp_sd_address),y
00C780  2  F0 54          beq gotfreecluster		; If the FAT entry is 0x00000000, we've got the next free cluster
00C782  2               
00C782  2                 ; Increment the last found free cluster count
00C782  2  E6 D6          inc fat32_lastfoundfreecluster
00C784  2  D0 0A          bne ffcdontinc
00C786  2  E6 D7          inc fat32_lastfoundfreecluster+1
00C788  2  D0 06          bne ffcdontinc
00C78A  2  E6 D8          inc fat32_lastfoundfreecluster+2
00C78C  2  D0 02          bne ffcdontinc
00C78E  2  E6 D9          inc fat32_lastfoundfreecluster+3
00C790  2               ffcdontinc:
00C790  2                 ; Now check if the disk is full.
00C790  2  A5 D6          lda fat32_lastfoundfreecluster
00C792  2  C9 FF          cmp #$ff
00C794  2  D0 15          bne ffcskip
00C796  2  A5 D6          lda fat32_lastfoundfreecluster
00C798  2  C9 FF          cmp #$ff
00C79A  2  D0 0F          bne ffcskip
00C79C  2  A5 D6          lda fat32_lastfoundfreecluster
00C79E  2  C9 FF          cmp #$ff
00C7A0  2  D0 09          bne ffcskip
00C7A2  2  A5 D6          lda fat32_lastfoundfreecluster
00C7A4  2  C9 F7          cmp #$f7
00C7A6  2  D0 03          bne ffcskip
00C7A8  2  4C DE C7       jmp diskfull	; Disk full
00C7AB  2               ffcskip:
00C7AB  2  E8             inx
00C7AC  2  E0 81          cpx #129 	; Sector read?
00C7AE  2  D0 C2          bne ffcinner	; If not go back to read another FAT entry
00C7B0  2                 ; Increment LBA
00C7B0  2  E6 D2          inc fat32_lba
00C7B2  2  D0 0A          bne dontinclba
00C7B4  2  E6 D3          inc fat32_lba+1
00C7B6  2  D0 06          bne dontinclba
00C7B8  2  E6 D4          inc fat32_lba+2
00C7BA  2  D0 02          bne dontinclba
00C7BC  2  E6 D5          inc fat32_lba+3
00C7BE  2               dontinclba:
00C7BE  2                 ; Out of disk space?
00C7BE  2                 ; BUG i should by comparing this with sectors per FAT, not per cluster...
00C7BE  2                 ; are they the same? (i dont think so...)
00C7BE  2  C6 CA          dec fat32_sectorspercluster
00C7C0  2  A5 DC          lda fat32_dwcount
00C7C2  2  C5 CA          cmp fat32_sectorspercluster
00C7C4  2  B0 05          bcs dontsubtractdw
00C7C6  2  E6 CA          inc fat32_sectorspercluster
00C7C8  2  4C DE C7       jmp diskfull ; Disk Full
00C7CB  2               dontsubtractdw:
00C7CB  2  E6 CA          inc fat32_sectorspercluster
00C7CD  2                 ; Increment fat32_dwcount
00C7CD  2  E6 DC          inc fat32_dwcount
00C7CF  2  D0 02          bne dontincdw
00C7D1  2  E6 DD          inc fat32_dwcount+1
00C7D3  2               dontincdw:
00C7D3  2  4C 53 C7       jmp findfreeclusterloop
00C7D6  2               gotfreecluster:
00C7D6  2               ; Got the free cluster. Carry clear.
00C7D6  2  68             pla
00C7D7  2  85 02          sta zp_sd_address+1
00C7D9  2  68             pla
00C7DA  2  85 01          sta zp_sd_address
00C7DC  2  18             clc
00C7DD  2  60             rts
00C7DE  2               
00C7DE  2               diskfull:
00C7DE  2               ; The disk is full. Set carry bit.
00C7DE  2  68             pla
00C7DF  2  85 02          sta zp_sd_address+1
00C7E1  2  68             pla
00C7E2  2  85 01          sta zp_sd_address
00C7E4  2  38             sec
00C7E5  2  60             rts
00C7E6  2               
00C7E6  2               fat32_readdirent:
00C7E6  2                 ; Read a directory entry from the open directory
00C7E6  2                 ;
00C7E6  2                 ; On exit the carry is set if there were no more directory entries.
00C7E6  2                 ;
00C7E6  2                 ; Otherwise, A is set to the file's attribute byte and
00C7E6  2                 ; zp_sd_address points at the returned directory entry.
00C7E6  2                 ; LFNs and empty entries are ignored automatically.
00C7E6  2               
00C7E6  2                 ; Increment pointer by 32 to point to next entry
00C7E6  2  18             clc
00C7E7  2  A5 01          lda zp_sd_address
00C7E9  2  69 20          adc #32
00C7EB  2  85 01          sta zp_sd_address
00C7ED  2  A5 02          lda zp_sd_address+1
00C7EF  2  69 00          adc #0
00C7F1  2  85 02          sta zp_sd_address+1
00C7F3  2               
00C7F3  2                 ; If it's not at the end of the buffer, we have data already
00C7F3  2  C9 04          cmp #>(fat32_readbuffer+$200)
00C7F5  2  90 0F          bcc ugotdata
00C7F7  2               
00C7F7  2                 ; Read another sector
00C7F7  2  A9 00          lda #<fat32_readbuffer
00C7F9  2  85 CC          sta fat32_address
00C7FB  2  A9 02          lda #>fat32_readbuffer
00C7FD  2  85 CD          sta fat32_address+1
00C7FF  2               
00C7FF  2  20 3B C5       jsr fat32_readnextsector
00C802  2  90 02          bcc ugotdata
00C804  2               
00C804  2               uendofdirectory:
00C804  2  38             sec
00C805  2  60             rts
00C806  2               
00C806  2               ugotdata:
00C806  2                 ; Check first character
00C806  2  A0 00          ldy #0
00C808  2  B1 01          lda (zp_sd_address),y
00C80A  2               
00C80A  2                 ; End of directory => abort
00C80A  2  F0 F8          beq uendofdirectory
00C80C  2               
00C80C  2                 ; Empty entry => start again
00C80C  2  C9 E5          cmp #$e5
00C80E  2  F0 D6          beq fat32_readdirent
00C810  2               
00C810  2                 ; Check attributes
00C810  2  A0 0B          ldy #11
00C812  2  B1 01          lda (zp_sd_address),y
00C814  2  29 3F          and #$3f
00C816  2  C9 0F          cmp #$0f ; LFN => start again
00C818  2  F0 CC          beq fat32_readdirent
00C81A  2               
00C81A  2                 ; Yield this result
00C81A  2  18             clc
00C81B  2  60             rts
00C81C  2               
00C81C  2               
00C81C  2               fat32_finddirent:
00C81C  2                 ; Finds a particular directory entryu  X,Y point to the 11-character filename to seek.
00C81C  2                 ; The directory should already be open for iteration.
00C81C  2               
00C81C  2                 ; Form ZP pointer to user's filename
00C81C  2  86 D2          stx fat32_filenamepointer
00C81E  2  84 D3          sty fat32_filenamepointer+1
00C820  2               
00C820  2                 ; Iterate until name is found or end of directory
00C820  2               udirentloop:
00C820  2  20 E6 C7       jsr fat32_readdirent
00C823  2  A0 0A          ldy #10
00C825  2  90 01          bcc ucomparenameloop
00C827  2  60             rts ; with carry set
00C828  2               
00C828  2               ucomparenameloop:
00C828  2  B1 01          lda (zp_sd_address),y
00C82A  2  D1 D2          cmp (fat32_filenamepointer),y
00C82C  2  D0 F2          bne udirentloop ; no match
00C82E  2  88             dey
00C82F  2  10 F7          bpl ucomparenameloop
00C831  2               
00C831  2                 ; Found it
00C831  2  18             clc
00C832  2  60             rts
00C833  2               
00C833  2               
00C833  2               fat32_file_readbyte:
00C833  2                 ; Read a byte from an open file
00C833  2                 ;
00C833  2                 ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
00C833  2               
00C833  2  38             sec
00C834  2               
00C834  2                 ; Is there any data to read at all?
00C834  2  A5 D2          lda fat32_bytesremaining
00C836  2  05 D3          ora fat32_bytesremaining+1
00C838  2  05 D4          ora fat32_bytesremaining+2
00C83A  2  05 D5          ora fat32_bytesremaining+3
00C83C  2  F0 3D          beq urts
00C83E  2               
00C83E  2                 ; Decrement the remaining byte count
00C83E  2  A5 D2          lda fat32_bytesremaining
00C840  2  E9 01          sbc #1
00C842  2  85 D2          sta fat32_bytesremaining
00C844  2  A5 D3          lda fat32_bytesremaining+1
00C846  2  E9 00          sbc #0
00C848  2  85 D3          sta fat32_bytesremaining+1
00C84A  2  A5 D4          lda fat32_bytesremaining+2
00C84C  2  E9 00          sbc #0
00C84E  2  85 D4          sta fat32_bytesremaining+2
00C850  2  A5 D5          lda fat32_bytesremaining+3
00C852  2  E9 00          sbc #0
00C854  2  85 D5          sta fat32_bytesremaining+3
00C856  2               
00C856  2                 ; Need to read a new sector?
00C856  2  A5 02          lda zp_sd_address+1
00C858  2  C9 04          cmp #>(fat32_readbuffer+$200)
00C85A  2  90 0D          bcc uegotdata
00C85C  2               
00C85C  2                 ; Read another sector
00C85C  2  A9 00          lda #<fat32_readbuffer
00C85E  2  85 CC          sta fat32_address
00C860  2  A9 02          lda #>fat32_readbuffer
00C862  2  85 CD          sta fat32_address+1
00C864  2               
00C864  2  20 3B C5       jsr fat32_readnextsector
00C867  2  B0 12          bcs urts                    ; this shouldn't happen
00C869  2               
00C869  2               uegotdata:
00C869  2  A0 00          ldy #0
00C86B  2  B1 01          lda (zp_sd_address),y
00C86D  2               
00C86D  2  E6 01          inc zp_sd_address
00C86F  2  D0 0A          bne urts
00C871  2  E6 02          inc zp_sd_address+1
00C873  2  D0 06          bne urts
00C875  2  E6 03          inc zp_sd_address+2
00C877  2  D0 02          bne urts
00C879  2  E6 04          inc zp_sd_address+3
00C87B  2               
00C87B  2               urts:
00C87B  2  60             rts
00C87C  2               
00C87C  2               
00C87C  2               fat32_file_read:
00C87C  2                 ; Read a whole file into memory.  It's assumed the file has just been opened
00C87C  2                 ; and no data has been read yet.
00C87C  2                 ;
00C87C  2                 ; Also we read whole sectors, so data in the target region beyond the end of the
00C87C  2                 ; file may get overwritten, up to the next 512-byte boundary.
00C87C  2                 ;
00C87C  2                 ; And we don't properly support 64k+ files, as it's unnecessary complication given
00C87C  2                 ; the 6502's small address space
00C87C  2               
00C87C  2                 ; Round the size up to the next whole sector
00C87C  2  A5 D2          lda fat32_bytesremaining
00C87E  2  C9 01          cmp #1                      ; set carry if bottom 8 bits not zero
00C880  2  A5 D3          lda fat32_bytesremaining+1
00C882  2  69 00          adc #0                      ; add carry, if any
00C884  2  4A             lsr                         ; divide by 2
00C885  2  69 00          adc #0                      ; round up
00C887  2               
00C887  2                 ; No data?
00C887  2  F0 12          beq udone
00C889  2               
00C889  2                 ; Store sector count - not a byte count any more
00C889  2  85 D2          sta fat32_bytesremaining
00C88B  2               
00C88B  2                 ; Read entire sectors to the user-supplied buffer
00C88B  2               uwholesectorreadloop:
00C88B  2                 ; Read a sector to fat32_address
00C88B  2  20 3B C5       jsr fat32_readnextsector
00C88E  2               
00C88E  2                 ; Advance fat32_address by 512 bytes
00C88E  2  A5 CD          lda fat32_address+1
00C890  2  69 02          adc #2                      ; carry already clear
00C892  2  85 CD          sta fat32_address+1
00C894  2               
00C894  2  A6 D2          ldx fat32_bytesremaining    ; note - actually loads sectors remaining
00C896  2  CA             dex
00C897  2  86 D2          stx fat32_bytesremaining    ; note - actually stores sectors remaining
00C899  2               
00C899  2  D0 F0          bne uwholesectorreadloop
00C89B  2               
00C89B  2               udone:
00C89B  2  60             rts
00C89C  2               
00C89C  2               fat32_file_write:
00C89C  2                 ; Write a whole file from memory.  It's assumed the file has just been opened
00C89C  2                 ; and no data has been written yet.
00C89C  2                 ;
00C89C  2                 ; Also we write whole sectors, so data in the target region beyond the end of the
00C89C  2                 ; file may get overwritten, up to the next 512-byte boundary.
00C89C  2                 ;
00C89C  2                 ; And we don't properly support 64k+ files, as it's unnecessary complication given
00C89C  2                 ; the 6502's small address space
00C89C  2               
00C89C  2                 ; Round the size up to the next whole sector
00C89C  2  A5 D2          lda fat32_bytesremaining
00C89E  2  C9 01          cmp #1                      ; set carry if bottom 8 bits not zero
00C8A0  2  A5 D3          lda fat32_bytesremaining+1
00C8A2  2  69 00          adc #0                      ; add carry, if any
00C8A4  2  4A             lsr                         ; divide by 2
00C8A5  2  69 00          adc #0                      ; round up
00C8A7  2               
00C8A7  2                 ; No data?
00C8A7  2  F0 12          beq urdone
00C8A9  2               
00C8A9  2                 ; Store sector count - not a byte count any more
00C8A9  2  85 D2          sta fat32_bytesremaining
00C8AB  2               
00C8AB  2                 ; Write entire sectors from the user-supplied buffer
00C8AB  2               wholesectorwriteloop:
00C8AB  2                 ; Write a sector from fat32_address
00C8AB  2  20 65 C5       jsr fat32_writenextsector
00C8AE  2               
00C8AE  2                 ; Advance fat32_address by 512 bytes
00C8AE  2  A5 CD          lda fat32_address+1
00C8B0  2  69 02          adc #2                      ; carry already clear
00C8B2  2  85 CD          sta fat32_address+1
00C8B4  2               
00C8B4  2  A6 D2          ldx fat32_bytesremaining    ; note - actually loads sectors remaining
00C8B6  2  CA             dex
00C8B7  2  86 D2          stx fat32_bytesremaining    ; note - actually stores sectors remaining
00C8B9  2               
00C8B9  2  D0 F0          bne wholesectorwriteloop
00C8BB  2               
00C8BB  2               urdone:
00C8BB  2  60             rts
00C8BC  2               
00C8BC  1                 	.include "libacia.s"
00C8BC  2               ;       ------------------ 6551 ACIA Subroutine Library -------------------
00C8BC  2               ; Includes:
00C8BC  2               ; acia_init       - Initializes the ACIA
00C8BC  2               ; print_hex_acia  - Prints a hex value in A
00C8BC  2               ; crlf		  - Prints <CR> followed by <LF>
00C8BC  2               ; clear_display   - Sends a <CLS> command
00C8BC  2               ; txpoll          - Polls the TX bit to see if the ACIA is ready
00C8BC  2               ; print_chara     - Prints a Character that is stored in A
00C8BC  2               ; print_char_acia - Same as print_chara
00C8BC  2               ; ascii_home      - Home the cursor
00C8BC  2               ; w_acia_full     - Print a NULL-Termintated String with >HIGH in Y and <LOW in X
00C8BC  2               
00C8BC  2               acia_init:
00C8BC  2  48             pha
00C8BD  2  A9 0B          lda #%00001011          ; No parity, no echo, no interrupt
00C8BF  2  8D 02 80       sta $8002
00C8C2  2  A9 1F          lda #%00011111          ; 1 stop bit, 8 data bits, 19200 baud
00C8C4  2  8D 03 80       sta $8003
00C8C7  2  68             pla
00C8C8  2  60             rts
00C8C9  2               
00C8C9  2               print_hex_acia:
00C8C9  2  48             pha
00C8CA  2  6A             ror
00C8CB  2  6A             ror
00C8CC  2  6A             ror
00C8CD  2  6A             ror
00C8CE  2  20 D2 C8       jsr print_nybble   ; This is just som usful hex cod
00C8D1  2  68             pla
00C8D2  2               print_nybble:
00C8D2  2  29 0F          and #15
00C8D4  2  C9 0A          cmp #10
00C8D6  2  30 02          bmi cskipletter
00C8D8  2  69 06          adc #6
00C8DA  2               cskipletter:
00C8DA  2  69 30          adc #48
00C8DC  2                ; jsr print_char
00C8DC  2  20 10 C9       jsr print_chara
00C8DF  2  60             rts
00C8E0  2               
00C8E0  2               crlf:
00C8E0  2  48             pha
00C8E1  2  8A             txa
00C8E2  2  48             pha
00C8E3  2  98             tya
00C8E4  2  48             pha
00C8E5  2  A9 0D          lda #$0d
00C8E7  2  20 10 C9       jsr print_chara
00C8EA  2  A9 0A          lda #$0a
00C8EC  2  20 10 C9       jsr print_chara
00C8EF  2  68             pla
00C8F0  2  A8             tay
00C8F1  2  68             pla
00C8F2  2  AA             tax
00C8F3  2  68             pla
00C8F4  2  60             rts
00C8F5  2               
00C8F5  2               cleardisplay:
00C8F5  2  48             pha
00C8F6  2  20 00 C9       jsr txpoll  ; Poll the TX bit
00C8F9  2  A9 0C          lda #12     ; Print decimal 12 (CLS)
00C8FB  2  8D 00 80       sta $8000
00C8FE  2  68             pla
00C8FF  2  60             rts
00C900  2               
00C900  2               txpoll:
00C900  2  AD 01 80       lda $8001
00C903  2  29 10          and #$10    ; Poll the TX bit
00C905  2  F0 F9          beq txpoll
00C907  2  60             rts
00C908  2               
00C908  2               rxpoll:
00C908  2  AD 01 80       lda $8001
00C90B  2  29 08          and #$08    ; Poll the RX bit
00C90D  2  F0 F9          beq rxpoll
00C90F  2  60             rts
00C910  2               
00C910  2               
00C910  2               print_chara:
00C910  2  48             pha
00C911  2  20 00 C9       jsr txpoll  ; Poll the TX bit
00C914  2  68             pla
00C915  2  8D 00 80       sta $8000   ; Print character from A
00C918  2  60             rts
00C919  2               
00C919  2               print_char_acia:
00C919  2  4C 10 C9       jmp print_chara  ; Same as "print_chara"
00C91C  2               
00C91C  2               ascii_home:
00C91C  2  48             pha
00C91D  2  A9 01          lda #1
00C91F  2  20 10 C9       jsr print_chara  ; Print 1 (HOME)
00C922  2  68             pla
00C923  2  60             rts
00C924  2               
00C924  2               w_acia_full:
00C924  2  48             pha
00C925  2  A5 FF          lda $ff
00C927  2  48             pha        ; Push Previous States onto the stack
00C928  2  A5 FE          lda $fe
00C92A  2  48             pha
00C92B  2  84 FF          sty $ff    ; Set Y as the Upper Address (8-15)
00C92D  2  86 FE          stx $fe    ; Set X as the Lower Adderss (0-7)
00C92F  2  A0 00          ldy #0
00C931  2               acia_man:
00C931  2  20 00 C9       jsr txpoll   ; Poll TX
00C934  2  B1 FE          lda ($fe),y  ; Load the Address
00C936  2  8D 00 80       sta $8000    ; Print what is at the address
00C939  2  F0 04          beq endwacia ; If Done, End
00C93B  2  C8             iny          ; Next Character
00C93C  2  4C 31 C9       jmp acia_man ; Back to the top
00C93F  2               endwacia:
00C93F  2  68             pla
00C940  2  85 FE          sta $fe
00C942  2  68             pla          ; Restore Variables
00C943  2  85 FF          sta $ff
00C945  2  68             pla
00C946  2  60             rts
00C947  2               
00C947  1               	.include "libtape.s"
00C947  2               ;
00C947  2               ;       ------------------ KCS Cassete Tape Library -------------------
00C947  2               ;
00C947  2               ; assumes that PA7 is connected to MIC and PA6 is connected to the tape card's output.
00C947  2               ;
00C947  2               ; ZP usage:
00C947  2               ; cnt		  - 16 bit start address. at the end of a routine, this value equals "len".
00C947  2               ; len		  - 16 bit end address.
00C947  2               ; thing		  - 8 bit temorary bitmask variable
00C947  2               ;
00C947  2               ; Included Routines:
00C947  2               ; tsave		  - Saves to a cassette tape. Start address in "cnt" and end address in "len". also uses "thing"
00C947  2               ; tload		  - Load from a cassette tape. "cnt" and "len" are also used.
00C947  2               
00C947  2               cnt = $00
00C947  2               len = $02
00C947  2               thing = $04
00C947  2               
00C947  2               tsave:
00C947  2  48             pha
00C948  2  8A             txa
00C949  2  48             pha
00C94A  2  98             tya
00C94B  2  48             pha
00C94C  2               
00C94C  2  A9 BF          lda #%10111111
00C94E  2  8D 03 B0       sta DDRA
00C951  2  A9 00          lda #0
00C953  2  8D 0E B0       sta $b00e
00C956  2                 ;sta tapest
00C956  2               
00C956  2  A9 8F          lda #$8f
00C958  2  8D 18 B8       sta $b818
00C95B  2               
00C95B  2  A2 00          ldx #0
00C95D  2               tlp1:
00C95D  2  BD 45 CA       lda treg,x
00C960  2  9D 10 B8       sta $b810,x
00C963  2  E8             inx
00C964  2  E0 05          cpx #5
00C966  2  D0 F5          bne tlp1
00C968  2  A9 4C          lda #$4c
00C96A  2  8D 0E B8       sta $b80e
00C96D  2  A9 9D          lda #$9d
00C96F  2  8D 0F B8       sta $b80f
00C972  2               
00C972  2  A2 7E          ldx #<tsavemsg
00C974  2  A0 CA          ldy #>tsavemsg	; press rec and play
00C976  2  20 24 C9       jsr w_acia_full
00C979  2               
00C979  2  A9 18          lda #$18		; 4 seconds
00C97B  2  20 6F CA       jsr tape_delay	; (ye fumble)
00C97E  2               
00C97E  2  A2 C4          ldx #<saving_msg	; Saving...
00C980  2  A0 CA          ldy #>saving_msg
00C982  2  20 24 C9       jsr w_acia_full
00C985  2               
00C985  2  A0 40          ldy #$40
00C987  2  20 24 CA       jsr inout		; intro sound
00C98A  2               
00C98A  2  A9 01          lda #1
00C98C  2  85 04          sta thing
00C98E  2  A0 00          ldy #0
00C990  2               tbeginn:
00C990  2  20 4A CA       jsr zero
00C993  2               tbegin:
00C993  2  B9 00 00       lda cnt,y		; read in the address param
00C996  2  25 04          and thing
00C998  2  D0 0E          bne thead1
00C99A  2  20 4A CA       jsr zero
00C99D  2               thead:
00C99D  2  A5 04          lda thing
00C99F  2  C9 80          cmp #$80
00C9A1  2  F0 0B          beq theader_done
00C9A3  2  06 04          asl thing
00C9A5  2  4C 93 C9       jmp tbegin
00C9A8  2               thead1:
00C9A8  2  20 30 CA       jsr one
00C9AB  2  4C 9D C9       jmp thead
00C9AE  2               theader_done:
00C9AE  2  A9 01          lda #1
00C9B0  2  85 04          sta thing
00C9B2  2  20 30 CA       jsr one
00C9B5  2  20 30 CA       jsr one
00C9B8  2  C8             iny
00C9B9  2  C0 04          cpy #$04
00C9BB  2  D0 D3          bne tbeginn
00C9BD  2  A0 20          ldy #$20
00C9BF  2  20 24 CA       jsr inout
00C9C2  2                 ; now to send the actual data
00C9C2  2  20 4A CA       jsr zero
00C9C5  2  A2 00          ldx #0
00C9C7  2  A9 01          lda #1
00C9C9  2  A0 00          ldy #0
00C9CB  2  85 04          sta thing		; first bit
00C9CD  2               twop:
00C9CD  2  B1 00          lda (cnt),y		; load data
00C9CF  2  25 04          and thing		; mask it
00C9D1  2  D0 0E          bne tjsrone		; one
00C9D3  2  20 4A CA       jsr zero		; or zero
00C9D6  2               toner:
00C9D6  2  A5 04          lda thing		; load the bitmask
00C9D8  2  C9 80          cmp #$80		; end of byte?
00C9DA  2  F0 0B          beq tnoo
00C9DC  2  06 04          asl thing
00C9DE  2  4C CD C9       jmp twop		; next bit
00C9E1  2               tjsrone:
00C9E1  2  20 30 CA       jsr one		; a one
00C9E4  2  4C D6 C9       jmp toner
00C9E7  2               tnoo:
00C9E7  2  A9 01          lda #1		; byte done
00C9E9  2  85 04          sta thing
00C9EB  2  20 30 CA       jsr one
00C9EE  2  20 30 CA       jsr one
00C9F1  2  E6 00          inc cnt		; inc pointer
00C9F3  2  D0 02          bne tnotcnt
00C9F5  2  E6 01          inc cnt+1
00C9F7  2               tnotcnt:
00C9F7  2  A5 00          lda cnt		; are we done?
00C9F9  2  C5 02          cmp len
00C9FB  2  F0 06          beq tnearly
00C9FD  2  20 4A CA       jsr zero
00CA00  2  4C CD C9       jmp twop		; if not, go again for another byte
00CA03  2               tnearly:
00CA03  2  A5 01          lda cnt+1
00CA05  2  C5 03          cmp len+1
00CA07  2  F0 06          beq tsavedone
00CA09  2  20 4A CA       jsr zero
00CA0C  2  4C CD C9       jmp twop
00CA0F  2               tsavedone:
00CA0F  2  A0 40          ldy #$40
00CA11  2  20 24 CA       jsr inout		; we are done, ending sound
00CA14  2               
00CA14  2                 ; done
00CA14  2  A2 CE          ldx #<msg2
00CA16  2  A0 CA          ldy #>msg2		; "Done!"
00CA18  2  20 24 C9       jsr w_acia_full
00CA1B  2               
00CA1B  2  68             pla
00CA1C  2  A8             tay
00CA1D  2  68             pla
00CA1E  2  AA             tax
00CA1F  2  68             pla
00CA20  2  60             rts			; return
00CA21  2  60             rts
00CA22  2  60             rts
00CA23  2  60             rts
00CA24  2               
00CA24  2               ; subroutines
00CA24  2               
00CA24  2               inout:
00CA24  2               touter:
00CA24  2  A2 10          ldx #$10		; $40 * $10 times make the sound
00CA26  2               tstarter:
00CA26  2  20 30 CA       jsr one		; sound
00CA29  2  CA             dex
00CA2A  2  D0 FA          bne tstarter
00CA2C  2  88             dey
00CA2D  2  D0 F5          bne touter
00CA2F  2  60             rts
00CA30  2               
00CA30  2               one:			; 2400hz sound 8 cyc
00CA30  2  08             php
00CA31  2  48             pha
00CA32  2                 ;jsr togtap ; 1
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap ; 2
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap ; 3
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap ; 4
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap ; 5
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap ; 6
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap ; 7
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap ; 8
00CA32  2                 ;jsr onefreq
00CA32  2                 ;jsr togtap
00CA32  2                 ;jsr onefreq
00CA32  2  A9 4C          lda #$4c
00CA34  2  8D 0E B8       sta $b80e
00CA37  2  A9 9D          lda #$9d
00CA39  2  8D 0F B8       sta $b80f
00CA3C  2  20 5F CA       jsr tx_delay
00CA3F  2  20 5F CA       jsr tx_delay
00CA42  2  68             pla
00CA43  2  28             plp
00CA44  2  60             rts
00CA45  2               
00CA45  2               treg:
00CA45  2  00 08 41 00    .byte $00, $08, $41, $00, $f0
00CA49  2  F0           
00CA4A  2               
00CA4A  2               ;togtap:
00CA4A  2               ;  lda tapest
00CA4A  2               ;  eor #%10000000 	; data out on PA7
00CA4A  2               ;  sta tapest
00CA4A  2               ;  sta PORTA
00CA4A  2               ;  rts
00CA4A  2               
00CA4A  2               zero: 			; 1200hz sound 4 cyc
00CA4A  2  08             php
00CA4B  2  48             pha
00CA4C  2                 ;jsr togtap ; 1
00CA4C  2                 ;jsr zerofreq
00CA4C  2                 ;jsr togtap
00CA4C  2                 ;jsr zerofreq
00CA4C  2                 ;jsr togtap ; 2
00CA4C  2                 ;jsr zerofreq
00CA4C  2                 ;jsr togtap
00CA4C  2                 ;jsr zerofreq
00CA4C  2                 ;jsr togtap ; 3
00CA4C  2                 ;jsr zerofreq
00CA4C  2                 ;jsr togtap
00CA4C  2                 ;jsr zerofreq
00CA4C  2                 ;jsr togtap ; 4
00CA4C  2                 ;jsr zerofreq
00CA4C  2                 ;jsr togtap
00CA4C  2                 ;jsr zerofreq
00CA4C  2  A9 A6          lda #$a6
00CA4E  2  8D 0E B8       sta $b80e
00CA51  2  A9 4E          lda #$4e
00CA53  2  8D 0F B8       sta $b80f
00CA56  2  20 5F CA       jsr tx_delay
00CA59  2  20 5F CA       jsr tx_delay
00CA5C  2  68             pla
00CA5D  2  28             plp
00CA5E  2  60             rts
00CA5F  2               
00CA5F  2               ;onefreq:
00CA5F  2               ;  stz $b00b
00CA5F  2               ;  lda #$ae
00CA5F  2               ;  sta $b004		; freq
00CA5F  2               ;  lda #$00
00CA5F  2               ;  sta $b005
00CA5F  2               ;intro:
00CA5F  2               ;  bit $b00d		; delay complete?
00CA5F  2               ;  bvc intro
00CA5F  2               ;  rts
00CA5F  2               
00CA5F  2               ;zerofreq:
00CA5F  2               ;  stz $b00b
00CA5F  2               ;  lda #$3f
00CA5F  2               ;  sta $b004
00CA5F  2               ;  lda #$01
00CA5F  2               ;  sta $b005
00CA5F  2               ;intro2:
00CA5F  2               ;  bit $b00d
00CA5F  2               ;  bvc intro2
00CA5F  2               ;  rts
00CA5F  2               
00CA5F  2               tx_delay:
00CA5F  2  8A             txa
00CA60  2  48             pha
00CA61  2  A2 7E          ldx #$7e
00CA63  2               tx_delay_inner:
00CA63  2  AD 1B B8       lda $b81b
00CA66  2  8D 01 B0       sta PORTA
00CA69  2  CA             dex
00CA6A  2  D0 F7          bne tx_delay_inner
00CA6C  2  68             pla
00CA6D  2  AA             tax
00CA6E  2  60             rts
00CA6F  2               
00CA6F  2               tape_delay:
00CA6F  2  A2 FF          ldx #$ff		; wait for ye fumble.
00CA71  2               rd1:
00CA71  2  A9 7A          lda #$7a		; (Y times through inner loop,
00CA73  2               rd2:
00CA73  2  E9 01          sbc #$01		;  Y * $FF * 650uS = uS / 1e-6 = S )
00CA75  2  D0 FC          bne rd2
00CA77  2               rd3:
00CA77  2  CA             dex
00CA78  2  D0 F7          bne rd1
00CA7A  2  88             dey
00CA7B  2  D0 F2          bne tape_delay
00CA7D  2  60             rts
00CA7E  2               
00CA7E  2               tsavemsg:
00CA7E  2  02 FF 50 72    .byte $02, $ff, "Press Record And play on Tape.", $0d, $0a, $00
00CA82  2  65 73 73 20  
00CA86  2  52 65 63 6F  
00CAA1  2               tloadmsg:
00CAA1  2  02 FF 50 72    .byte $02, $ff, "Press Play On Tape.", $0d, $0a, $00
00CAA5  2  65 73 73 20  
00CAA9  2  50 6C 61 79  
00CAB9  2               loading_msg:
00CAB9  2  4C 6F 61 64    .byte "Loading...", $00
00CABD  2  69 6E 67 2E  
00CAC1  2  2E 2E 00     
00CAC4  2               saving_msg:
00CAC4  2  53 61 76 69    .byte "Saving...", $00
00CAC8  2  6E 67 2E 2E  
00CACC  2  2E 00        
00CACE  2               msg2:
00CACE  2  44 6F 6E 65    .byte "Done!", $0d, $0a, $02, $5f, $00
00CAD2  2  21 0D 0A 02  
00CAD6  2  5F 00        
00CAD8  2               loadedmsg:
00CAD8  2  4C 6F 61 64    .byte "Loaded from ", $00
00CADC  2  65 64 20 66  
00CAE0  2  72 6F 6D 20  
00CAE5  2               tomsg:
00CAE5  2  20 74 6F 20    .byte " to ", $00
00CAE9  2  00           
00CAEA  2               
00CAEA  2               ; Load from a cassette tape.
00CAEA  2               ;
00CAEA  2               ; Needs no arguments because start and end addresses are encoded in tape.
00CAEA  2               ;
00CAEA  2               
00CAEA  2               tload:
00CAEA  2  48             pha
00CAEB  2  8A             txa
00CAEC  2  48             pha
00CAED  2  98             tya
00CAEE  2  48             pha
00CAEF  2               
00CAEF  2  A9 BF          lda #%10111111
00CAF1  2  8D 03 B0       sta DDRA
00CAF4  2  A9 FF          lda #%11111111
00CAF6  2  8D 02 B0       sta DDRB
00CAF9  2               
00CAF9  2  A2 A1          ldx #<tloadmsg	; PRESS PLAY ON TAPE
00CAFB  2  A0 CA          ldy #>tloadmsg
00CAFD  2  20 24 C9       jsr w_acia_full
00CB00  2               
00CB00  2  A9 18          lda #$18		; ye fumble
00CB02  2  20 6F CA       jsr tape_delay	; 4 second delay
00CB05  2               
00CB05  2  A2 B9          ldx #<loading_msg	; Loading...
00CB07  2  A0 CA          ldy #>loading_msg
00CB09  2  20 24 C9       jsr w_acia_full
00CB0C  2               
00CB0C  2  A0 00          ldy #0
00CB0E  2               
00CB0E  2                 ; thanks to ben eater for help with this code
00CB0E  2               
00CB0E  2               rx_wait_start:
00CB0E  2  2C 01 B0       bit PORTA	; wait until PORTB.6 = 0 (start bit)
00CB11  2  70 FB          bvs rx_wait_start
00CB13  2               
00CB13  2  20 B9 CB       jsr rx_delay  ; half-bit delay
00CB16  2  A2 08          ldx #8
00CB18  2               read_bita:
00CB18  2  20 B9 CB       jsr rx_delay	; run full-bit delay for 300 baud serial stream
00CB1B  2  20 B9 CB       jsr rx_delay
00CB1E  2  2C 01 B0       bit PORTA	; read in the state
00CB21  2  70 04          bvs recv_1a	; if it's not a one,
00CB23  2  18             clc		; it's a zero.
00CB24  2  4C 2A CB       jmp rx_donea
00CB27  2               recv_1a:	; otherwise,
00CB27  2  38             sec		; it's a one.
00CB28  2  EA             nop		; nops for timing
00CB29  2  EA             nop
00CB2A  2               rx_donea:
00CB2A  2  6A             ror		; rotate carry into accumulator
00CB2B  2  CA             dex
00CB2C  2  D0 EA          bne read_bita	; repeat until 8 bits read
00CB2E  2  99 00 00       sta cnt,y
00CB31  2  C8             iny
00CB32  2  C0 04          cpy #$04
00CB34  2  F0 0F          beq got_len
00CB36  2  A5 00          lda cnt
00CB38  2  48             pha
00CB39  2  A5 01          lda cnt+1
00CB3B  2  48             pha
00CB3C  2  20 B9 CB       jsr rx_delay
00CB3F  2  20 B9 CB       jsr rx_delay
00CB42  2  4C 0E CB       jmp rx_wait_start
00CB45  2               got_len:
00CB45  2  20 B9 CB       jsr rx_delay
00CB48  2  20 B9 CB       jsr rx_delay
00CB4B  2  A0 00          ldy #0
00CB4D  2               rx_wait:
00CB4D  2  2C 01 B0       bit PORTA	; wait until PORTB.6 = 0 (start bit)
00CB50  2  70 FB          bvs rx_wait
00CB52  2  20 B9 CB       jsr rx_delay
00CB55  2  A2 08          ldx #8
00CB57  2               read_bit:
00CB57  2  20 B9 CB       jsr rx_delay	; run bit delay for 300 baud serial stream
00CB5A  2  20 B9 CB       jsr rx_delay
00CB5D  2  2C 01 B0       bit PORTA	; read in the state
00CB60  2  70 04          bvs recv_1	; if it's not a one,
00CB62  2  18             clc		; it's a zero.
00CB63  2  4C 69 CB       jmp rx_done
00CB66  2               recv_1:
00CB66  2  38             sec		; it's a one.
00CB67  2  EA             nop		; nops for timing
00CB68  2  EA             nop
00CB69  2               rx_done:
00CB69  2  6A             ror		; rotate carry into accumulator
00CB6A  2  CA             dex
00CB6B  2  D0 EA          bne read_bit	; repeat until 8 bits read
00CB6D  2  91 00          sta (cnt),y	; store data
00CB6F  2  20 B9 CB       jsr rx_delay
00CB72  2  20 B9 CB       jsr rx_delay
00CB75  2  E6 00          inc cnt
00CB77  2  D0 02          bne declen
00CB79  2  E6 01          inc cnt+1
00CB7B  2               declen:
00CB7B  2  A5 00          lda cnt		; are we done?
00CB7D  2  C5 02          cmp len
00CB7F  2  D0 2F          bne rx_wait_delay
00CB81  2  A5 01          lda cnt+1
00CB83  2  C5 03          cmp len+1
00CB85  2  D0 29          bne rx_wait_delay	; if not, get another byte
00CB87  2  A2 D8          ldx #<loadedmsg	; Done! print "Loaded from X to Y"
00CB89  2  A0 CA          ldy #>loadedmsg
00CB8B  2  20 24 C9       jsr w_acia_full
00CB8E  2  68             pla
00CB8F  2  20 C9 C8       jsr print_hex_acia
00CB92  2  68             pla
00CB93  2  20 C9 C8       jsr print_hex_acia
00CB96  2  A2 E5          ldx #<tomsg
00CB98  2  A0 CA          ldy #>tomsg
00CB9A  2  20 24 C9       jsr w_acia_full
00CB9D  2  A5 03          lda len+1
00CB9F  2  20 C9 C8       jsr print_hex_acia
00CBA2  2  A5 02          lda len
00CBA4  2  20 C9 C8       jsr print_hex_acia
00CBA7  2  20 E0 C8       jsr crlf
00CBAA  2  68             pla
00CBAB  2  A8             tay
00CBAC  2  68             pla
00CBAD  2  AA             tax
00CBAE  2  68             pla
00CBAF  2  60             rts
00CBB0  2               
00CBB0  2               rx_wait_delay:
00CBB0  2  20 B9 CB       jsr rx_delay
00CBB3  2  20 B9 CB       jsr rx_delay
00CBB6  2  4C 4D CB       jmp rx_wait
00CBB9  2               
00CBB9  2               rx_delay:
00CBB9  2  8A             txa
00CBBA  2  48             pha
00CBBB  2  98             tya
00CBBC  2  48             pha
00CBBD  2  A0 02          ldy #$02
00CBBF  2               rx_delay_outer:
00CBBF  2  A2 A4          ldx #$A4
00CBC1  2               rx_delay_inner:
00CBC1  2  CA             dex
00CBC2  2  D0 FD          bne rx_delay_inner
00CBC4  2  88             dey
00CBC5  2  D0 F8          bne rx_delay_outer
00CBC7  2  68             pla
00CBC8  2  A8             tay
00CBC9  2  68             pla
00CBCA  2  AA             tax
00CBCB  2  60             rts
00CBCC  2               
00CBCC  2               
00CBCC  1               	.include "errors.s"
00CBCC  2               error_sound:
00CBCC  2  20 05 CC       jsr clear_sid
00CBCF  2  A9 0F          lda #$0f
00CBD1  2  8D 18 B8       sta $b818
00CBD4  2  A9 E7          lda #$e7
00CBD6  2  8D 02 B8       sta $b802
00CBD9  2  A9 0F          lda #$0f
00CBDB  2  8D 05 B8       sta $b805
00CBDE  2  A9 F8          lda #$f8
00CBE0  2  8D 06 B8       sta $b806
00CBE3  2  A9 50          lda #$50 ; freq
00CBE5  2  8D 00 B8       sta $b800
00CBE8  2  A9 50          lda #$50 ; freq+1
00CBEA  2  8D 01 B8       sta $b801
00CBED  2  A9 41          lda #$41
00CBEF  2  8D 04 B8       sta $b804
00CBF2  2               
00CBF2  2               outer:
00CBF2  2  A0 FF          ldy #$ff
00CBF4  2               inner:
00CBF4  2  A2 FF          ldx #$ff
00CBF6  2               
00CBF6  2               innerloop:
00CBF6  2  CA             dex
00CBF7  2  D0 FD          bne innerloop
00CBF9  2               
00CBF9  2  88             dey
00CBFA  2  F0 03          beq ende
00CBFC  2  4C F4 CB       jmp inner
00CBFF  2               ende:
00CBFF  2  A9 40          lda #$40
00CC01  2  8D 04 B8       sta $b804
00CC04  2  60             rts
00CC05  2               
00CC05  2               clear_sid:
00CC05  2  A2 17          ldx #$17
00CC07  2  A9 00          lda #0
00CC09  2               csid:
00CC09  2  9D 00 B8       sta $b800,x
00CC0C  2  CA             dex
00CC0D  2  D0 FA          bne csid
00CC0F  2  60             rts
00CC10  2               
00CC10  2               
00CC10  2               
00CC10  1               dirname:
00CC10  1  46 4F 4C 44  	.asciiz "FOLDER     "
00CC14  1  45 52 20 20  
00CC18  1  20 20 20 00  
00CC1C  1               errormsg:
00CC1C  1  0D 0A 45 52  	.byte CR,LF,"ERROR!",CR,LF
00CC20  1  52 4F 52 21  
00CC24  1  0D 0A        
00CC26  1  00           	.byte 0
00CC27  1               
00CC27  1               ; ======================================================
00CC27  1               ; --------------------- Main Code ----------------------
00CC27  1               ; =================  (not in order) ====================
00CC27  1               ; ------------------------------------------------------
00CC27  1               
00CC27  1               ; generic stack and memory management code
00CC27  1               ; this code is identical across all versions of
00CC27  1               ; BASIC
00CC27  1               ; ----------------------------------------------------------------------------
00CC27  1               ; CALLED BY "NEXT" AND "FOR" TO SCAN THROUGH
00CC27  1               ; THE STACK FOR A FRAME WITH THE SAME VARIABLE.
00CC27  1               ;
00CC27  1               ; (FORPNT) = ADDRESS OF VARIABLE IF "FOR" OR "NEXT"
00CC27  1               ; 	= $XXFF IF CALLED FROM "RETURN"
00CC27  1               ; 	<<< BUG: SHOULD BE $FFXX >>>
00CC27  1               ;
00CC27  1               ;	RETURNS .NE. IF VARIABLE NOT FOUND,
00CC27  1               ;	(X) = STACK PNTR AFTER SKIPPING ALL FRAMES
00CC27  1               ;
00CC27  1               ;	.EQ. IF FOUND
00CC27  1               ;	(X) = STACK PNTR OF FRAME FOUND
00CC27  1               ; ----------------------------------------------------------------------------
00CC27  1               
00CC27  1               GTFORPNT:
00CC27  1  BA                   tsx
00CC28  1  E8                   inx
00CC29  1  E8                   inx
00CC2A  1  E8                   inx
00CC2B  1  E8                   inx
00CC2C  1               L2279:
00CC2C  1  BD 01 01             lda     STACK+1,x
00CC2F  1  C9 81                cmp     #$81
00CC31  1  D0 21                bne     L22A1
00CC33  1  A5 98                lda     FORPNT+1
00CC35  1  D0 0A                bne     L228E
00CC37  1  BD 02 01             lda     STACK+2,x
00CC3A  1  85 97                sta     FORPNT
00CC3C  1  BD 03 01             lda     STACK+3,x
00CC3F  1  85 98                sta     FORPNT+1
00CC41  1               L228E:
00CC41  1  DD 03 01             cmp     STACK+3,x
00CC44  1  D0 07                bne     L229A
00CC46  1  A5 97                lda     FORPNT
00CC48  1  DD 02 01             cmp     STACK+2,x
00CC4B  1  F0 07                beq     L22A1
00CC4D  1               L229A:
00CC4D  1  8A                   txa
00CC4E  1  18                   clc
00CC4F  1  69 10                adc     #BYTES_PER_FRAME
00CC51  1  AA                   tax
00CC52  1  D0 D8                bne     L2279
00CC54  1               L22A1:
00CC54  1  60                   rts
00CC55  1               ; ----------------------------------------------------------------------------
00CC55  1               ; MOVE BLOCK OF MEMORY UP
00CC55  1               ;
00CC55  1               ; ON ENTRY:
00CC55  1               ;	(Y,A) = (HIGHDS) = DESTINATION END+1
00CC55  1               ;	(LOWTR) = LOWEST ADDRESS OF SOURCE
00CC55  1               ;	(HIGHTR) = HIGHEST SOURCE ADDRESS+1
00CC55  1               ; ----------------------------------------------------------------------------
00CC55  1               BLTU:
00CC55  1  20 A5 CC             jsr     REASON
00CC58  1  85 7F                sta     STREND
00CC5A  1  84 80                sty     STREND+1
00CC5C  1               BLTU2:
00CC5C  1  38                   sec
00CC5D  1  A5 A6                lda     HIGHTR
00CC5F  1  E5 AA                sbc     LOWTR
00CC61  1  85 71                sta     INDEX
00CC63  1  A8                   tay
00CC64  1  A5 A7                lda     HIGHTR+1
00CC66  1  E5 AB                sbc     LOWTR+1
00CC68  1  AA                   tax
00CC69  1  E8                   inx
00CC6A  1  98                   tya
00CC6B  1  F0 23                beq     L22DD
00CC6D  1  A5 A6                lda     HIGHTR
00CC6F  1  38                   sec
00CC70  1  E5 71                sbc     INDEX
00CC72  1  85 A6                sta     HIGHTR
00CC74  1  B0 03                bcs     L22C6
00CC76  1  C6 A7                dec     HIGHTR+1
00CC78  1  38                   sec
00CC79  1               L22C6:
00CC79  1  A5 A4                lda     HIGHDS
00CC7B  1  E5 71                sbc     INDEX
00CC7D  1  85 A4                sta     HIGHDS
00CC7F  1  B0 08                bcs     L22D6
00CC81  1  C6 A5                dec     HIGHDS+1
00CC83  1  90 04                bcc     L22D6
00CC85  1               L22D2:
00CC85  1  B1 A6                lda     (HIGHTR),y
00CC87  1  91 A4                sta     (HIGHDS),y
00CC89  1               L22D6:
00CC89  1  88                   dey
00CC8A  1  D0 F9                bne     L22D2
00CC8C  1  B1 A6                lda     (HIGHTR),y
00CC8E  1  91 A4                sta     (HIGHDS),y
00CC90  1               L22DD:
00CC90  1  C6 A7                dec     HIGHTR+1
00CC92  1  C6 A5                dec     HIGHDS+1
00CC94  1  CA                   dex
00CC95  1  D0 F2                bne     L22D6
00CC97  1  60                   rts
00CC98  1               ; ----------------------------------------------------------------------------
00CC98  1               ; CHECK IF ENOUGH ROOM LEFT ON STACK
00CC98  1               ; FOR "FOR", "GOSUB", OR EXPRESSION EVALUATION
00CC98  1               ; ----------------------------------------------------------------------------
00CC98  1               CHKMEM:
00CC98  1  0A                   asl     a
00CC99  1  69 33                adc     #SPACE_FOR_GOSUB
00CC9B  1  B0 35                bcs     MEMERR
00CC9D  1  85 71                sta     INDEX
00CC9F  1  BA                   tsx
00CCA0  1  E4 71                cpx     INDEX
00CCA2  1  90 2E                bcc     MEMERR
00CCA4  1  60                   rts
00CCA5  1               ; ----------------------------------------------------------------------------
00CCA5  1               ; CHECK IF ENOUGH ROOM BETWEEN ARRAYS AND STRINGS
00CCA5  1               ; (Y,A) = ADDR ARRAYS NEED TO GROW TO
00CCA5  1               ; ----------------------------------------------------------------------------
00CCA5  1               REASON:
00CCA5  1  C4 82                cpy     FRETOP+1
00CCA7  1  90 28                bcc     L231E
00CCA9  1  D0 04                bne     L22FC
00CCAB  1  C5 81                cmp     FRETOP
00CCAD  1  90 22                bcc     L231E
00CCAF  1               L22FC:
00CCAF  1  48                   pha
00CCB0  1  A2 08                ldx     #FAC-TEMP1-1
00CCB2  1  98                   tya
00CCB3  1               L2300:
00CCB3  1  48                   pha
00CCB4  1  B5 A3                lda     TEMP1,x
00CCB6  1  CA                   dex
00CCB7  1  10 FA                bpl     L2300
00CCB9  1  20 C1 DB             jsr     GARBAG
00CCBC  1  A2 F8                ldx     #TEMP1-FAC+1+256
00CCBE  1               L230B:
00CCBE  1  68                   pla
00CCBF  1  95 AC                sta     FAC,x
00CCC1  1  E8                   inx
00CCC2  1  30 FA                bmi     L230B
00CCC4  1  68                   pla
00CCC5  1  A8                   tay
00CCC6  1  68                   pla
00CCC7  1  C4 82                cpy     FRETOP+1
00CCC9  1  90 06                bcc     L231E
00CCCB  1  D0 05                bne     MEMERR
00CCCD  1  C5 81                cmp     FRETOP
00CCCF  1  B0 01                bcs     MEMERR
00CCD1  1               L231E:
00CCD1  1  60                   rts
00CCD2  1               MEMERR:
00CCD2  1  A2 0C                ldx     #ERR_MEMFULL
00CCD4  1               ; ----------------------------------------------------------------------------
00CCD4  1               ; HANDLE AN ERROR
00CCD4  1               ;
00CCD4  1               ; (X)=OFFSET IN ERROR MESSAGE TABLE
00CCD4  1               ; (ERRFLG) > 128 IF "ON ERR" TURNED ON
00CCD4  1               ; (CURLIN+1) = $FF IF IN DIRECT MODE
00CCD4  1               ; ----------------------------------------------------------------------------
00CCD4  1               ERROR:
00CCD4  1  46 64                lsr     Z14
00CCD6  1  20 E6 D2             jsr     CRDO
00CCD9  1  20 5D D3             jsr     OUTQUES
00CCDC  1  BD 64 C1             lda     ERROR_MESSAGES,x
00CCDF  1  20 5F D3             jsr     OUTDO
00CCE2  1  BD 65 C1             lda     ERROR_MESSAGES+1,x
00CCE5  1  20 5F D3             jsr     OUTDO
00CCE8  1  20 17 CF             jsr     STKINI
00CCEB  1  A9 86                lda     #<QT_ERROR
00CCED  1  A0 C1                ldy     #>QT_ERROR
00CCEF  1               ; ----------------------------------------------------------------------------
00CCEF  1               ; PRINT STRING AT (Y,A)
00CCEF  1               ; PRINT CURRENT LINE # UNLESS IN DIRECT MODE
00CCEF  1               ; FALL INTO WARM RESTART
00CCEF  1               ; ----------------------------------------------------------------------------
00CCEF  1               PRINT_ERROR_LINNUM:
00CCEF  1  20 3D D3             jsr     STROUT
00CCF2  1  A4 88                ldy     CURLIN+1
00CCF4  1  C8                   iny
00CCF5  1  F0 03                beq     RESTART
00CCF7  1  20 CD E3             jsr     INPRT
00CCFA  1               ; ----------------------------------------------------------------------------
00CCFA  1               ; WARM RESTART ENTRY
00CCFA  1               ; ----------------------------------------------------------------------------
00CCFA  1               RESTART:
00CCFA  1  46 64                lsr     Z14
00CCFC  1  A9 92                lda     #<QT_OK
00CCFE  1  A0 C1                ldy     #>QT_OK
00CD00  1  20 0A 00             jsr     GOSTROUT
00CD03  1               L2351:
00CD03  1  20 DD CD             jsr     INLIN
00CD06  1  86 DD                stx     TXTPTR
00CD08  1  84 DE                sty     TXTPTR+1
00CD0A  1  20 D6 00             jsr     CHRGET
00CD0D  1               ; bug in pre-1.1: CHRGET sets Z on '\0'
00CD0D  1               ; and ':' - a line starting with ':' in
00CD0D  1               ; direct mode gets ignored
00CD0D  1  F0 F4                beq     L2351
00CD0F  1  A2 FF                ldx     #$FF
00CD11  1  86 88                stx     CURLIN+1
00CD13  1  90 06                bcc     NUMBERED_LINE
00CD15  1  20 2C CE             jsr     PARSE_INPUT_LINE
00CD18  1  4C 7C D0             jmp     NEWSTT2
00CD1B  1               ; ----------------------------------------------------------------------------
00CD1B  1               ; HANDLE NUMBERED LINE
00CD1B  1               ; ----------------------------------------------------------------------------
00CD1B  1               NUMBERED_LINE:
00CD1B  1  20 F9 D1             jsr     LINGET
00CD1E  1  20 2C CE             jsr     PARSE_INPUT_LINE
00CD21  1  84 5D                sty     EOLPNTR
00CD23  1  20 B8 CE             jsr     FNDLIN
00CD26  1  90 44                bcc     PUT_NEW_LINE
00CD28  1  A0 01                ldy     #$01
00CD2A  1  B1 AA                lda     (LOWTR),y
00CD2C  1  85 72                sta     INDEX+1
00CD2E  1  A5 7B                lda     VARTAB
00CD30  1  85 71                sta     INDEX
00CD32  1  A5 AB                lda     LOWTR+1
00CD34  1  85 74                sta     DEST+1
00CD36  1  A5 AA                lda     LOWTR
00CD38  1  88                   dey
00CD39  1  F1 AA                sbc     (LOWTR),y
00CD3B  1  18                   clc
00CD3C  1  65 7B                adc     VARTAB
00CD3E  1  85 7B                sta     VARTAB
00CD40  1  85 73                sta     DEST
00CD42  1  A5 7C                lda     VARTAB+1
00CD44  1  69 FF                adc     #$FF
00CD46  1  85 7C                sta     VARTAB+1
00CD48  1  E5 AB                sbc     LOWTR+1
00CD4A  1  AA                   tax
00CD4B  1  38                   sec
00CD4C  1  A5 AA                lda     LOWTR
00CD4E  1  E5 7B                sbc     VARTAB
00CD50  1  A8                   tay
00CD51  1  B0 03                bcs     L23A5
00CD53  1  E8                   inx
00CD54  1  C6 74                dec     DEST+1
00CD56  1               L23A5:
00CD56  1  18                   clc
00CD57  1  65 71                adc     INDEX
00CD59  1  90 03                bcc     L23AD
00CD5B  1  C6 72                dec     INDEX+1
00CD5D  1  18                   clc
00CD5E  1               L23AD:
00CD5E  1  B1 71                lda     (INDEX),y
00CD60  1  91 73                sta     (DEST),y
00CD62  1  C8                   iny
00CD63  1  D0 F9                bne     L23AD
00CD65  1  E6 72                inc     INDEX+1
00CD67  1  E6 74                inc     DEST+1
00CD69  1  CA                   dex
00CD6A  1  D0 F2                bne     L23AD
00CD6C  1               ; ----------------------------------------------------------------------------
00CD6C  1               PUT_NEW_LINE:
00CD6C  1  A5 13                lda     INPUTBUFFER
00CD6E  1  F0 2F                beq     FIX_LINKS
00CD70  1  A5 85                lda     MEMSIZ
00CD72  1  A4 86                ldy     MEMSIZ+1
00CD74  1  85 81                sta     FRETOP
00CD76  1  84 82                sty     FRETOP+1
00CD78  1  A5 7B                lda     VARTAB
00CD7A  1  85 A6                sta     HIGHTR
00CD7C  1  65 5D                adc     EOLPNTR
00CD7E  1  85 A4                sta     HIGHDS
00CD80  1  A4 7C                ldy     VARTAB+1
00CD82  1  84 A7                sty     HIGHTR+1
00CD84  1  90 01                bcc     L23D6
00CD86  1  C8                   iny
00CD87  1               L23D6:
00CD87  1  84 A5                sty     HIGHDS+1
00CD89  1  20 55 CC             jsr     BLTU
00CD8C  1  A5 7F                lda     STREND
00CD8E  1  A4 80                ldy     STREND+1
00CD90  1  85 7B                sta     VARTAB
00CD92  1  84 7C                sty     VARTAB+1
00CD94  1  A4 5D                ldy     EOLPNTR
00CD96  1  88                   dey
00CD97  1               ; ---COPY LINE INTO PROGRAM-------
00CD97  1               L23E6:
00CD97  1  B9 0F 00             lda     INPUTBUFFER-4,y
00CD9A  1  91 AA                sta     (LOWTR),y
00CD9C  1  88                   dey
00CD9D  1  10 F8                bpl     L23E6
00CD9F  1               ; ----------------------------------------------------------------------------
00CD9F  1               ; CLEAR ALL VARIABLES
00CD9F  1               ; RE-ESTABLISH ALL FORWARD LINKS
00CD9F  1               ; ----------------------------------------------------------------------------
00CD9F  1               FIX_LINKS:
00CD9F  1  20 FD CE             jsr     SETPTRS
00CDA2  1  A5 79                lda     TXTTAB
00CDA4  1  A4 7A                ldy     TXTTAB+1
00CDA6  1  85 71                sta     INDEX
00CDA8  1  84 72                sty     INDEX+1
00CDAA  1  18                   clc
00CDAB  1               L23FA:
00CDAB  1  A0 01                ldy     #$01
00CDAD  1  B1 71                lda     (INDEX),y
00CDAF  1  D0 03 4C 03          jeq     L2351
00CDB3  1  CD           
00CDB4  1               
00CDB4  1  A0 04                ldy     #$04
00CDB6  1               L2405:
00CDB6  1  C8                   iny
00CDB7  1  B1 71                lda     (INDEX),y
00CDB9  1  D0 FB                bne     L2405
00CDBB  1  C8                   iny
00CDBC  1  98                   tya
00CDBD  1  65 71                adc     INDEX
00CDBF  1  AA                   tax
00CDC0  1  A0 00                ldy     #$00
00CDC2  1  91 71                sta     (INDEX),y
00CDC4  1  A5 72                lda     INDEX+1
00CDC6  1  69 00                adc     #$00
00CDC8  1  C8                   iny
00CDC9  1  91 71                sta     (INDEX),y
00CDCB  1  86 71                stx     INDEX
00CDCD  1  85 72                sta     INDEX+1
00CDCF  1  90 DA                bcc     L23FA	; always
00CDD1  1               ; ----------------------------------------------------------------------------
00CDD1  1               L2420:
00CDD1  1  20 5F D3             jsr     OUTDO
00CDD4  1  CA                   dex
00CDD5  1  10 08                bpl     INLIN2
00CDD7  1               L2423:
00CDD7  1  20 5F D3             jsr     OUTDO
00CDDA  1  20 E6 D2             jsr     CRDO
00CDDD  1               ; ----------------------------------------------------------------------------
00CDDD  1               ; READ A LINE, AND STRIP OFF SIGN BITS
00CDDD  1               ; ----------------------------------------------------------------------------
00CDDD  1               INLIN:
00CDDD  1  A2 00                ldx     #$00
00CDDF  1               INLIN2:
00CDDF  1  20 0C CE             jsr     GETLN
00CDE2  1  C9 07                cmp     #$07
00CDE4  1  F0 14                beq     L2443
00CDE6  1  C9 0D                cmp     #$0D
00CDE8  1  F0 1F                beq     L2453
00CDEA  1  C9 08                cmp     #$08 ; BACKSPACE
00CDEC  1  F0 E3                beq     L2420
00CDEE  1  C9 20                cmp     #$20
00CDF0  1  90 ED                bcc     INLIN2
00CDF2  1  C9 7D                cmp     #$7D
00CDF4  1  B0 E9                bcs     INLIN2
00CDF6  1  C9 40                cmp     #$40 ; @
00CDF8  1  F0 DD                beq     L2423
00CDFA  1               L2443:
00CDFA  1  E0 47                cpx     #$47
00CDFC  1  B0 04                bcs     L244C
00CDFE  1  95 13                sta     INPUTBUFFER,x
00CE00  1  E8                   inx
00CE01  1  2C                   .byte   $2C
00CE02  1               L244C:
00CE02  1  A9 07                lda     #$07 ; BEL
00CE04  1  20 5F D3             jsr     OUTDO
00CE07  1  D0 D6                bne     INLIN2
00CE09  1               L2453:
00CE09  1  4C E0 D2             jmp     L29B9
00CE0C  1               GETLN:
00CE0C  1  20 76 FF             jsr     MONRDKEY
00CE0F  1  EA                   nop
00CE10  1  EA                   nop
00CE11  1  EA                   nop
00CE12  1  EA                   nop
00CE13  1  EA                   nop
00CE14  1  EA                   nop
00CE15  1  EA                   nop
00CE16  1  EA                   nop
00CE17  1  EA                   nop
00CE18  1  EA                   nop
00CE19  1  EA                   nop
00CE1A  1  EA                   nop
00CE1B  1  EA                   nop
00CE1C  1  EA                   nop
00CE1D  1  29 7F                and     #$7F
00CE1F  1               RDKEY:
00CE1F  1  C9 0F                cmp     #$0F
00CE21  1  D0 08                bne     L2465
00CE23  1  48                   pha
00CE24  1  A5 64                lda     Z14
00CE26  1  49 FF                eor     #$FF
00CE28  1  85 64                sta     Z14
00CE2A  1  68                   pla
00CE2B  1               L2465:
00CE2B  1  60                   rts
00CE2C  1               ; ----------------------------------------------------------------------------
00CE2C  1               ; TOKENIZE THE INPUT LINE
00CE2C  1               ; ----------------------------------------------------------------------------
00CE2C  1               PARSE_INPUT_LINE:
00CE2C  1  A6 DD                ldx     TXTPTR
00CE2E  1  A0 04                ldy     #$04
00CE30  1  84 60                sty     DATAFLG
00CE32  1               L246C:
00CE32  1  B5 00                lda     INPUTBUFFERX,x
00CE34  1  C9 20                cmp     #$20
00CE36  1  F0 3A                beq     L24AC
00CE38  1  85 5C                sta     ENDCHR
00CE3A  1  C9 22                cmp     #$22
00CE3C  1  F0 58                beq     L24D0
00CE3E  1  24 60                bit     DATAFLG
00CE40  1  70 30                bvs     L24AC
00CE42  1  C9 3F                cmp     #$3F
00CE44  1  D0 04                bne     L2484
00CE46  1  A9 97                lda     #TOKEN_PRINT
00CE48  1  D0 28                bne     L24AC
00CE4A  1               L2484:
00CE4A  1  C9 30                cmp     #$30
00CE4C  1  90 04                bcc     L248C
00CE4E  1  C9 3C                cmp     #$3C
00CE50  1  90 20                bcc     L24AC
00CE52  1               ; ----------------------------------------------------------------------------
00CE52  1               ; SEARCH TOKEN NAME TABLE FOR MATCH STARTING
00CE52  1               ; WITH CURRENT CHAR FROM INPUT LINE
00CE52  1               ; ----------------------------------------------------------------------------
00CE52  1               L248C:
00CE52  1  84 BA                sty     STRNG2
00CE54  1  A0 00                ldy     #$00
00CE56  1  84 5D                sty     EOLPNTR
00CE58  1  88                   dey
00CE59  1  86 DD                stx     TXTPTR
00CE5B  1  CA                   dex
00CE5C  1               L2496:
00CE5C  1  C8                   iny
00CE5D  1               L2497:
00CE5D  1  E8                   inx
00CE5E  1               L2498:
00CE5E  1  B5 00                lda     INPUTBUFFERX,x
00CE60  1  C9 20                cmp     #$20
00CE62  1  F0 F9                beq     L2497
00CE64  1  38                   sec
00CE65  1  F9 84 C0             sbc     TOKEN_NAME_TABLE,y
00CE68  1  F0 F2                beq     L2496
00CE6A  1  C9 80                cmp     #$80
00CE6C  1  D0 2F                bne     L24D7
00CE6E  1  05 5D                ora     EOLPNTR
00CE70  1               ; ----------------------------------------------------------------------------
00CE70  1               ; STORE CHARACTER OR TOKEN IN OUTPUT LINE
00CE70  1               ; ----------------------------------------------------------------------------
00CE70  1               L24AA:
00CE70  1  A4 BA                ldy     STRNG2
00CE72  1               L24AC:
00CE72  1  E8                   inx
00CE73  1  C8                   iny
00CE74  1  99 0E 00             sta     INPUTBUFFER-5,y
00CE77  1  B9 0E 00             lda     INPUTBUFFER-5,y
00CE7A  1  F0 34                beq     L24EA
00CE7C  1  38                   sec
00CE7D  1  E9 3A                sbc     #$3A
00CE7F  1  F0 04                beq     L24BF
00CE81  1  C9 49                cmp     #$49
00CE83  1  D0 02                bne     L24C1
00CE85  1               L24BF:
00CE85  1  85 60                sta     DATAFLG
00CE87  1               L24C1:
00CE87  1  38                   sec
00CE88  1  E9 54                sbc     #TOKEN_REM-':'
00CE8A  1  D0 A6                bne     L246C
00CE8C  1  85 5C                sta     ENDCHR
00CE8E  1               ; ----------------------------------------------------------------------------
00CE8E  1               ; HANDLE LITERAL (BETWEEN QUOTES) OR REMARK,
00CE8E  1               ; BY COPYING CHARS UP TO ENDCHR.
00CE8E  1               ; ----------------------------------------------------------------------------
00CE8E  1               L24C8:
00CE8E  1  B5 00                lda     INPUTBUFFERX,x
00CE90  1  F0 E0                beq     L24AC
00CE92  1  C5 5C                cmp     ENDCHR
00CE94  1  F0 DC                beq     L24AC
00CE96  1               L24D0:
00CE96  1  C8                   iny
00CE97  1  99 0E 00             sta     INPUTBUFFER-5,y
00CE9A  1  E8                   inx
00CE9B  1  D0 F1                bne     L24C8
00CE9D  1               ; ----------------------------------------------------------------------------
00CE9D  1               ; ADVANCE POINTER TO NEXT TOKEN NAME
00CE9D  1               ; ----------------------------------------------------------------------------
00CE9D  1               L24D7:
00CE9D  1  A6 DD                ldx     TXTPTR
00CE9F  1  E6 5D                inc     EOLPNTR
00CEA1  1               L24DB:
00CEA1  1  C8                   iny
00CEA2  1  B9 83 C0             lda     MATHTBL+28+1,y
00CEA5  1  10 FA                bpl     L24DB
00CEA7  1  B9 84 C0             lda     TOKEN_NAME_TABLE,y
00CEAA  1  D0 B2                bne     L2498
00CEAC  1  B5 00                lda     INPUTBUFFERX,x
00CEAE  1  10 C0                bpl     L24AA
00CEB0  1               ; ---END OF LINE------------------
00CEB0  1               L24EA:
00CEB0  1  99 10 00             sta     INPUTBUFFER-3,y
00CEB3  1  A9 12                lda     #<INPUTBUFFER-1
00CEB5  1  85 DD                sta     TXTPTR
00CEB7  1  60                   rts
00CEB8  1               ; ----------------------------------------------------------------------------
00CEB8  1               ; SEARCH FOR LINE
00CEB8  1               ;
00CEB8  1               ; (LINNUM) = LINE # TO FIND
00CEB8  1               ; IF NOT FOUND:  CARRY = 0
00CEB8  1               ;	LOWTR POINTS AT NEXT LINE
00CEB8  1               ; IF FOUND:      CARRY = 1
00CEB8  1               ;	LOWTR POINTS AT LINE
00CEB8  1               ; ----------------------------------------------------------------------------
00CEB8  1               FNDLIN:
00CEB8  1  A5 79                lda     TXTTAB
00CEBA  1  A6 7A                ldx     TXTTAB+1
00CEBC  1               FL1:
00CEBC  1  A0 01                ldy     #$01
00CEBE  1  85 AA                sta     LOWTR
00CEC0  1  86 AB                stx     LOWTR+1
00CEC2  1  B1 AA                lda     (LOWTR),y
00CEC4  1  F0 1F                beq     L251F
00CEC6  1  C8                   iny
00CEC7  1  C8                   iny
00CEC8  1  A5 12                lda     LINNUM+1
00CECA  1  D1 AA                cmp     (LOWTR),y
00CECC  1  90 18                bcc     L2520
00CECE  1  F0 03                beq     L250D
00CED0  1  88                   dey
00CED1  1  D0 09                bne     L2516
00CED3  1               L250D:
00CED3  1  A5 11                lda     LINNUM
00CED5  1  88                   dey
00CED6  1  D1 AA                cmp     (LOWTR),y
00CED8  1  90 0C                bcc     L2520
00CEDA  1  F0 0A                beq     L2520
00CEDC  1               L2516:
00CEDC  1  88                   dey
00CEDD  1  B1 AA                lda     (LOWTR),y
00CEDF  1  AA                   tax
00CEE0  1  88                   dey
00CEE1  1  B1 AA                lda     (LOWTR),y
00CEE3  1  B0 D7                bcs     FL1
00CEE5  1               L251F:
00CEE5  1  18                   clc
00CEE6  1               L2520:
00CEE6  1  60                   rts
00CEE7  1               ; ----------------------------------------------------------------------------
00CEE7  1               ; "NEW" STATEMENT
00CEE7  1               ; ----------------------------------------------------------------------------
00CEE7  1               NEW:
00CEE7  1  D0 FD                bne     L2520
00CEE9  1               SCRTCH:
00CEE9  1  A9 00                lda     #$00
00CEEB  1  A8                   tay
00CEEC  1  91 79                sta     (TXTTAB),y
00CEEE  1  C8                   iny
00CEEF  1  91 79                sta     (TXTTAB),y
00CEF1  1  A5 79                lda     TXTTAB
00CEF3  1  69 02                adc     #$02
00CEF5  1  85 7B                sta     VARTAB
00CEF7  1  A5 7A                lda     TXTTAB+1
00CEF9  1  69 00                adc     #$00
00CEFB  1  85 7C                sta     VARTAB+1
00CEFD  1               ; ----------------------------------------------------------------------------
00CEFD  1               SETPTRS:
00CEFD  1  20 2D CF             jsr     STXTPT
00CF00  1               ; ----------------------------------------------------------------------------
00CF00  1               ; "CLEAR" STATEMENT
00CF00  1               ; ----------------------------------------------------------------------------
00CF00  1               CLEARC:
00CF00  1  A5 85                lda     MEMSIZ
00CF02  1  A4 86                ldy     MEMSIZ+1
00CF04  1  85 81                sta     FRETOP
00CF06  1  84 82                sty     FRETOP+1
00CF08  1  A5 7B                lda     VARTAB
00CF0A  1  A4 7C                ldy     VARTAB+1
00CF0C  1  85 7D                sta     ARYTAB
00CF0E  1  84 7E                sty     ARYTAB+1
00CF10  1  85 7F                sta     STREND
00CF12  1  84 80                sty     STREND+1
00CF14  1  20 A0 D0             jsr     RESTORE
00CF17  1               ; ----------------------------------------------------------------------------
00CF17  1               STKINI:
00CF17  1  A2 68                ldx     #TEMPST
00CF19  1  86 65                stx     TEMPPT
00CF1B  1  68                   pla
00CF1C  1  8D FD 01             sta     STACK+STACK_TOP+1
00CF1F  1  68                   pla
00CF20  1  8D FE 01             sta     STACK+STACK_TOP+2
00CF23  1  A2 FC                ldx     #STACK_TOP
00CF25  1  9A                   txs
00CF26  1  A9 00                lda     #$00
00CF28  1  85 8C                sta     OLDTEXT+1
00CF2A  1  85 61                sta     SUBFLG
00CF2C  1               L256A:
00CF2C  1  60                   rts
00CF2D  1               ; ----------------------------------------------------------------------------
00CF2D  1               ; SET TXTPTR TO BEGINNING OF PROGRAM
00CF2D  1               ; ----------------------------------------------------------------------------
00CF2D  1               STXTPT:
00CF2D  1  18                   clc
00CF2E  1  A5 79                lda     TXTTAB
00CF30  1  69 FF                adc     #$FF
00CF32  1  85 DD                sta     TXTPTR
00CF34  1  A5 7A                lda     TXTTAB+1
00CF36  1  69 FF                adc     #$FF
00CF38  1  85 DE                sta     TXTPTR+1
00CF3A  1  60                   rts
00CF3B  1               ; ----------------------------------------------------------------------------
00CF3B  1               ; ----------------------------------------------------------------------------
00CF3B  1               ; "LIST" STATEMENT
00CF3B  1               ; ----------------------------------------------------------------------------
00CF3B  1               LIST:
00CF3B  1  90 06                bcc     L2581
00CF3D  1  F0 04                beq     L2581
00CF3F  1  C9 A4                cmp     #TOKEN_MINUS
00CF41  1  D0 E9                bne     L256A
00CF43  1               L2581:
00CF43  1  20 F9 D1             jsr     LINGET
00CF46  1  20 B8 CE             jsr     FNDLIN
00CF49  1  20 DC 00             jsr     CHRGOT
00CF4C  1  F0 0C                beq     L2598
00CF4E  1  C9 A4                cmp     #TOKEN_MINUS
00CF50  1  D0 94                bne     L2520
00CF52  1  20 D6 00             jsr     CHRGET
00CF55  1  20 F9 D1             jsr     LINGET
00CF58  1  D0 8C                bne     L2520
00CF5A  1               L2598:
00CF5A  1  68                   pla
00CF5B  1  68                   pla
00CF5C  1  A5 11                lda     LINNUM
00CF5E  1  05 12                ora     LINNUM+1
00CF60  1  D0 06                bne     L25A6
00CF62  1  A9 FF                lda     #$FF
00CF64  1  85 11                sta     LINNUM
00CF66  1  85 12                sta     LINNUM+1
00CF68  1               L25A6:
00CF68  1  A0 01                ldy     #$01
00CF6A  1  84 60                sty     DATAFLG
00CF6C  1  B1 AA                lda     (LOWTRX),y
00CF6E  1  F0 41                beq     L25E5
00CF70  1  20 AF D0             jsr     ISCNTC
00CF73  1  20 E6 D2             jsr     CRDO
00CF76  1  C8                   iny
00CF77  1  B1 AA                lda     (LOWTRX),y
00CF79  1  AA                   tax
00CF7A  1  C8                   iny
00CF7B  1  B1 AA                lda     (LOWTRX),y
00CF7D  1  C5 12                cmp     LINNUM+1
00CF7F  1  D0 04                bne     L25C1
00CF81  1  E4 11                cpx     LINNUM
00CF83  1  F0 02                beq     L25C3
00CF85  1               L25C1:
00CF85  1  B0 2A                bcs     L25E5
00CF87  1               ; ---LIST ONE LINE----------------
00CF87  1               L25C3:
00CF87  1  84 97                sty     FORPNT
00CF89  1  20 D8 E3             jsr     LINPRT
00CF8C  1  A9 20                lda     #$20
00CF8E  1               L25CA:
00CF8E  1  A4 97                ldy     FORPNT
00CF90  1  29 7F                and     #$7F
00CF92  1               L25CE:
00CF92  1  20 5F D3             jsr     OUTDO
00CF95  1  C9 22                cmp     #$22
00CF97  1  D0 06                bne     LA519
00CF99  1  A5 60                lda     DATAFLG
00CF9B  1  49 FF                eor     #$FF
00CF9D  1  85 60                sta     DATAFLG
00CF9F  1               LA519:
00CF9F  1  C8                   iny
00CFA0  1  B1 AA                lda     (LOWTRX),y
00CFA2  1  D0 10                bne     L25E8
00CFA4  1  A8                   tay
00CFA5  1  B1 AA                lda     (LOWTRX),y
00CFA7  1  AA                   tax
00CFA8  1  C8                   iny
00CFA9  1  B1 AA                lda     (LOWTRX),y
00CFAB  1  86 AA                stx     LOWTRX
00CFAD  1  85 AB                sta     LOWTRX+1
00CFAF  1  D0 B7                bne     L25A6
00CFB1  1               L25E5:
00CFB1  1  4C FA CC             jmp     RESTART
00CFB4  1               L25E8:
00CFB4  1  10 DC                bpl     L25CE
00CFB6  1  C9 FF                cmp     #$FF
00CFB8  1  F0 D8                beq     L25CE
00CFBA  1  24 60                bit     DATAFLG
00CFBC  1  30 D4                bmi     L25CE
00CFBE  1  38                   sec
00CFBF  1  E9 7F                sbc     #$7F
00CFC1  1  AA                   tax
00CFC2  1  84 97                sty     FORPNT
00CFC4  1  A0 FF                ldy     #$FF
00CFC6  1               L25F2:
00CFC6  1  CA                   dex
00CFC7  1  F0 08                beq     L25FD
00CFC9  1               L25F5:
00CFC9  1  C8                   iny
00CFCA  1  B9 84 C0             lda     TOKEN_NAME_TABLE,y
00CFCD  1  10 FA                bpl     L25F5
00CFCF  1  30 F5                bmi     L25F2
00CFD1  1               L25FD:
00CFD1  1  C8                   iny
00CFD2  1  B9 84 C0             lda     TOKEN_NAME_TABLE,y
00CFD5  1  30 B7                bmi     L25CA
00CFD7  1  20 5F D3             jsr     OUTDO
00CFDA  1  D0 F5                bne     L25FD	; always
00CFDC  1               ; ----------------------------------------------------------------------------
00CFDC  1               ; "FOR" STATEMENT
00CFDC  1               ;
00CFDC  1               ; FOR PUSHES 18 BYTES ON THE STACK:
00CFDC  1               ; 2 -- TXTPTR
00CFDC  1               ; 2 -- LINE NUMBER
00CFDC  1               ; 5 -- INITIAL (CURRENT)  FOR VARIABLE VALUE
00CFDC  1               ; 1 -- STEP SIGN
00CFDC  1               ; 5 -- STEP VALUE
00CFDC  1               ; 2 -- ADDRESS OF FOR VARIABLE IN VARTAB
00CFDC  1               ; 1 -- FOR TOKEN ($81)
00CFDC  1               ; ----------------------------------------------------------------------------
00CFDC  1               FOR:
00CFDC  1  A9 80                lda     #$80
00CFDE  1  85 61                sta     SUBFLG
00CFE0  1  20 33 D2             jsr     LET
00CFE3  1  20 27 CC             jsr     GTFORPNT
00CFE6  1  D0 05                bne     L2619
00CFE8  1  8A                   txa
00CFE9  1  69 0D                adc     #FOR_STACK1
00CFEB  1  AA                   tax
00CFEC  1  9A                   txs
00CFED  1               L2619:
00CFED  1  68                   pla
00CFEE  1  68                   pla
00CFEF  1  A9 08                lda     #FOR_STACK2
00CFF1  1  20 98 CC             jsr     CHKMEM
00CFF4  1  20 94 D1             jsr     DATAN
00CFF7  1  18                   clc
00CFF8  1  98                   tya
00CFF9  1  65 DD                adc     TXTPTR
00CFFB  1  48                   pha
00CFFC  1  A5 DE                lda     TXTPTR+1
00CFFE  1  69 00                adc     #$00
00D000  1  48                   pha
00D001  1  A5 88                lda     CURLIN+1
00D003  1  48                   pha
00D004  1  A5 87                lda     CURLIN
00D006  1  48                   pha
00D007  1  A9 9D                lda     #TOKEN_TO
00D009  1  20 7D D6             jsr     SYNCHR
00D00C  1  20 2A D5             jsr     CHKNUM
00D00F  1  20 27 D5             jsr     FRMNUM
00D012  1  A5 B0                lda     FACSIGN
00D014  1  09 7F                ora     #$7F
00D016  1  25 AD                and     FAC+1
00D018  1  85 AD                sta     FAC+1
00D01A  1  A9 25                lda     #<STEP
00D01C  1  A0 D0                ldy     #>STEP
00D01E  1  85 71                sta     INDEX
00D020  1  84 72                sty     INDEX+1
00D022  1  4C E0 D5             jmp     FRM_STACK3
00D025  1               ; ----------------------------------------------------------------------------
00D025  1               ; "STEP" PHRASE OF "FOR" STATEMENT
00D025  1               ; ----------------------------------------------------------------------------
00D025  1               STEP:
00D025  1  A9 16                lda     #<CON_ONE
00D027  1  A0 E0                ldy     #>CON_ONE
00D029  1  20 C5 E1             jsr     LOAD_FAC_FROM_YA
00D02C  1  20 DC 00             jsr     CHRGOT
00D02F  1  C9 A2                cmp     #TOKEN_STEP
00D031  1  D0 06                bne     L2665
00D033  1  20 D6 00             jsr     CHRGET
00D036  1  20 27 D5             jsr     FRMNUM
00D039  1               L2665:
00D039  1  20 44 E2             jsr     SIGN
00D03C  1  20 D5 D5             jsr     FRM_STACK2
00D03F  1  A5 98                lda     FORPNT+1
00D041  1  48                   pha
00D042  1  A5 97                lda     FORPNT
00D044  1  48                   pha
00D045  1  A9 81                lda     #$81
00D047  1  48                   pha
00D048  1               ; ----------------------------------------------------------------------------
00D048  1               ; PERFORM NEXT STATEMENT
00D048  1               ; ----------------------------------------------------------------------------
00D048  1               NEWSTT:
00D048  1  20 AF D0             jsr     ISCNTC
00D04B  1  A5 DD                lda     TXTPTR
00D04D  1  A4 DE                ldy     TXTPTR+1
00D04F  1  F0 06                beq     L2683
00D051  1  85 8B                sta     OLDTEXT
00D053  1  84 8C                sty     OLDTEXT+1
00D055  1  A0 00                ldy     #$00
00D057  1               L2683:
00D057  1  B1 DD                lda     (TXTPTR),y
00D059  1  F0 07                beq     LA5DC	; old: 1 cycle more on generic case
00D05B  1  C9 3A                cmp     #$3A
00D05D  1  F0 1D                beq     NEWSTT2
00D05F  1               SYNERR1:
00D05F  1  4C 86 D6             jmp     SYNERR
00D062  1               LA5DC:
00D062  1  A0 02                ldy     #$02
00D064  1  B1 DD                lda     (TXTPTR),y
00D066  1  18                   clc
00D067  1  F0 62                beq     L2701
00D069  1  C8                   iny
00D06A  1  B1 DD                lda     (TXTPTR),y
00D06C  1  85 87                sta     CURLIN
00D06E  1  C8                   iny
00D06F  1  B1 DD                lda     (TXTPTR),y
00D071  1  85 88                sta     CURLIN+1
00D073  1  98                   tya
00D074  1  65 DD                adc     TXTPTR
00D076  1  85 DD                sta     TXTPTR
00D078  1  90 02                bcc     NEWSTT2
00D07A  1  E6 DE                inc     TXTPTR+1
00D07C  1               NEWSTT2:
00D07C  1  20 D6 00             jsr     CHRGET
00D07F  1  20 85 D0             jsr     EXECUTE_STATEMENT
00D082  1  4C 48 D0             jmp     NEWSTT
00D085  1               ; ----------------------------------------------------------------------------
00D085  1               ; EXECUTE A STATEMENT
00D085  1               ;
00D085  1               ; (A) IS FIRST CHAR OF STATEMENT
00D085  1               ; CARRY IS SET
00D085  1               ; ----------------------------------------------------------------------------
00D085  1               EXECUTE_STATEMENT:
00D085  1  F0 6D                beq     RET1
00D087  1  38                   sec
00D088  1               EXECUTE_STATEMENT1:
00D088  1  E9 80                sbc     #$80
00D08A  1  B0 03 4C 33          jcc     LET	; old: 1 cycle more on instr.
00D08E  1  D2           
00D08F  1               
00D08F  1  C9 1C                cmp     #NUM_TOKENS
00D091  1  B0 CC                bcs     SYNERR1
00D093  1  0A                   asl     a
00D094  1  A8                   tay
00D095  1  B9 01 C0             lda     TOKEN_ADDRESS_TABLE+1,y
00D098  1  48                   pha
00D099  1  B9 00 C0             lda     TOKEN_ADDRESS_TABLE,y
00D09C  1  48                   pha
00D09D  1  4C D6 00             jmp     CHRGET
00D0A0  1               ; ----------------------------------------------------------------------------
00D0A0  1               ; "RESTORE" STATEMENT
00D0A0  1               ; ----------------------------------------------------------------------------
00D0A0  1               RESTORE:
00D0A0  1  38                   sec
00D0A1  1  A5 79                lda     TXTTAB
00D0A3  1  E9 01                sbc     #$01
00D0A5  1  A4 7A                ldy     TXTTAB+1
00D0A7  1  B0 01                bcs     SETDA
00D0A9  1  88                   dey
00D0AA  1               SETDA:
00D0AA  1  85 8F                sta     DATPTR
00D0AC  1  84 90                sty     DATPTR+1
00D0AE  1  60                   rts
00D0AF  1               ; ----------------------------------------------------------------------------
00D0AF  1               ; SEE IF CONTROL-C TYPED
00D0AF  1               ; ----------------------------------------------------------------------------
00D0AF  1               
00D0AF  1               ISCNTC:
00D0AF  1               ; MODIFIED CALL BY G.SEARLE FROM THE ORIGINAL OSI CODE
00D0AF  1  20 86 FF             jsr     MONISCNTC
00D0B2  1               ; runs into "STOP"
00D0B2  1               ; ----------------------------------------------------------------------------
00D0B2  1               ; "STOP" STATEMENT
00D0B2  1               ; ----------------------------------------------------------------------------
00D0B2  1               STOP:
00D0B2  1  B0 01                bcs     END2
00D0B4  1               ; ----------------------------------------------------------------------------
00D0B4  1               ; "END" STATEMENT
00D0B4  1               ; ----------------------------------------------------------------------------
00D0B4  1               END:
00D0B4  1  18                   clc
00D0B5  1               END2:
00D0B5  1  D0 3D                bne     RET1
00D0B7  1  A5 DD                lda     TXTPTR
00D0B9  1  A4 DE                ldy     TXTPTR+1
00D0BB  1  F0 0C                beq     END4
00D0BD  1  85 8B                sta     OLDTEXT
00D0BF  1  84 8C                sty     OLDTEXT+1
00D0C1  1               CONTROL_C_TYPED:
00D0C1  1  A5 87                lda     CURLIN
00D0C3  1  A4 88                ldy     CURLIN+1
00D0C5  1  85 89                sta     OLDLIN
00D0C7  1  84 8A                sty     OLDLIN+1
00D0C9  1               END4:
00D0C9  1  68                   pla
00D0CA  1  68                   pla
00D0CB  1               L2701:
00D0CB  1  A9 99                lda     #<QT_BREAK
00D0CD  1  A0 C1                ldy     #>QT_BREAK
00D0CF  1  A2 00                ldx     #$00
00D0D1  1  86 64                stx     Z14
00D0D3  1  90 03                bcc     L270E
00D0D5  1  4C EF CC             jmp     PRINT_ERROR_LINNUM
00D0D8  1               L270E:
00D0D8  1  4C FA CC             jmp     RESTART
00D0DB  1               ; ----------------------------------------------------------------------------
00D0DB  1               ; "CONT" COMMAND
00D0DB  1               ; ----------------------------------------------------------------------------
00D0DB  1               CONT:
00D0DB  1  D0 17                bne     RET1
00D0DD  1  A2 1E                ldx     #ERR_CANTCONT
00D0DF  1  A4 8C                ldy     OLDTEXT+1
00D0E1  1  D0 03                bne     L271C
00D0E3  1  4C D4 CC             jmp     ERROR
00D0E6  1               L271C:
00D0E6  1  A5 8B                lda     OLDTEXT
00D0E8  1  85 DD                sta     TXTPTR
00D0EA  1  84 DE                sty     TXTPTR+1
00D0EC  1  A5 89                lda     OLDLIN
00D0EE  1  A4 8A                ldy     OLDLIN+1
00D0F0  1  85 87                sta     CURLIN
00D0F2  1  84 88                sty     CURLIN+1
00D0F4  1               RET1:
00D0F4  1  60                   rts
00D0F5  1               NULL:
00D0F5  1  20 28 DE             jsr     GETBYT
00D0F8  1  D0 FA                bne     RET1
00D0FA  1  E8                   inx
00D0FB  1  E0 0A                cpx     #NULL_MAX
00D0FD  1  B0 04                bcs     L2739
00D0FF  1  CA                   dex
00D100  1  86 0D                stx     Z15
00D102  1  60                   rts
00D103  1               L2739:
00D103  1  4C 02 D9             jmp     IQERR
00D106  1               CLEAR:
00D106  1  D0 EC                bne     RET1
00D108  1  4C 00 CF             jmp     CLEARC
00D10B  1               ; ----------------------------------------------------------------------------
00D10B  1               ; "RUN" COMMAND
00D10B  1               ; ----------------------------------------------------------------------------
00D10B  1               RUN:
00D10B  1  D0 03                bne     L27CF
00D10D  1  4C FD CE             jmp     SETPTRS
00D110  1               L27CF:
00D110  1  20 00 CF             jsr     CLEARC
00D113  1  4C 2A D1             jmp     L27E9
00D116  1               ; ----------------------------------------------------------------------------
00D116  1               ; "GOSUB" STATEMENT
00D116  1               ;
00D116  1               ; LEAVES 7 BYTES ON STACK:
00D116  1               ; 2 -- RETURN ADDRESS (NEWSTT)
00D116  1               ; 2 -- TXTPTR
00D116  1               ; 2 -- LINE #
00D116  1               ; 1 -- GOSUB TOKEN
00D116  1               ; ----------------------------------------------------------------------------
00D116  1               GOSUB:
00D116  1  A9 03                lda     #$03
00D118  1  20 98 CC             jsr     CHKMEM
00D11B  1  A5 DE                lda     TXTPTR+1
00D11D  1  48                   pha
00D11E  1  A5 DD                lda     TXTPTR
00D120  1  48                   pha
00D121  1  A5 88                lda     CURLIN+1
00D123  1  48                   pha
00D124  1  A5 87                lda     CURLIN
00D126  1  48                   pha
00D127  1  A9 8C                lda     #TOKEN_GOSUB
00D129  1  48                   pha
00D12A  1               L27E9:
00D12A  1  20 DC 00             jsr     CHRGOT
00D12D  1  20 33 D1             jsr     GOTO
00D130  1  4C 48 D0             jmp     NEWSTT
00D133  1               ; ----------------------------------------------------------------------------
00D133  1               ; "GOTO" STATEMENT
00D133  1               ; ALSO USED BY "RUN" AND "GOSUB"
00D133  1               ; ----------------------------------------------------------------------------
00D133  1               GOTO:
00D133  1  20 F9 D1             jsr     LINGET
00D136  1  20 97 D1             jsr     REMN
00D139  1  A5 88                lda     CURLIN+1
00D13B  1  C5 12                cmp     LINNUM+1
00D13D  1  B0 0B                bcs     L2809
00D13F  1  98                   tya
00D140  1  38                   sec
00D141  1  65 DD                adc     TXTPTR
00D143  1  A6 DE                ldx     TXTPTR+1
00D145  1  90 07                bcc     L280D
00D147  1  E8                   inx
00D148  1  B0 04                bcs     L280D
00D14A  1               L2809:
00D14A  1  A5 79                lda     TXTTAB
00D14C  1  A6 7A                ldx     TXTTAB+1
00D14E  1               L280D:
00D14E  1  20 BC CE             jsr     FL1
00D151  1  90 1E                bcc     UNDERR
00D153  1  A5 AA                lda     LOWTRX
00D155  1  E9 01                sbc     #$01
00D157  1  85 DD                sta     TXTPTR
00D159  1  A5 AB                lda     LOWTRX+1
00D15B  1  E9 00                sbc     #$00
00D15D  1  85 DE                sta     TXTPTR+1
00D15F  1               L281E:
00D15F  1  60                   rts
00D160  1               ; ----------------------------------------------------------------------------
00D160  1               ; "POP" AND "RETURN" STATEMENTS
00D160  1               ; ----------------------------------------------------------------------------
00D160  1               POP:
00D160  1  D0 FD                bne     L281E
00D162  1  A9 FF                lda     #$FF
00D164  1  85 97                sta     FORPNT
00D166  1  20 27 CC             jsr     GTFORPNT
00D169  1  9A                   txs
00D16A  1  C9 8C                cmp     #TOKEN_GOSUB
00D16C  1  F0 0B                beq     RETURN
00D16E  1  A2 04                ldx     #ERR_NOGOSUB
00D170  1  2C                   .byte   $2C
00D171  1               UNDERR:
00D171  1  A2 0E                ldx     #ERR_UNDEFSTAT
00D173  1  4C D4 CC             jmp     ERROR
00D176  1               ; ----------------------------------------------------------------------------
00D176  1               SYNERR2:
00D176  1  4C 86 D6             jmp     SYNERR
00D179  1               ; ----------------------------------------------------------------------------
00D179  1               RETURN:
00D179  1  68                   pla
00D17A  1  68                   pla
00D17B  1  85 87                sta     CURLIN
00D17D  1  68                   pla
00D17E  1  85 88                sta     CURLIN+1
00D180  1  68                   pla
00D181  1  85 DD                sta     TXTPTR
00D183  1  68                   pla
00D184  1  85 DE                sta     TXTPTR+1
00D186  1               ; ----------------------------------------------------------------------------
00D186  1               ; "DATA" STATEMENT
00D186  1               ; EXECUTED BY SKIPPING TO NEXT COLON OR EOL
00D186  1               ; ----------------------------------------------------------------------------
00D186  1               DATA:
00D186  1  20 94 D1             jsr     DATAN
00D189  1               ; ----------------------------------------------------------------------------
00D189  1               ; ADD (Y) TO TXTPTR
00D189  1               ; ----------------------------------------------------------------------------
00D189  1               ADDON:
00D189  1  98                   tya
00D18A  1  18                   clc
00D18B  1  65 DD                adc     TXTPTR
00D18D  1  85 DD                sta     TXTPTR
00D18F  1  90 02                bcc     L2852
00D191  1  E6 DE                inc     TXTPTR+1
00D193  1               L2852:
00D193  1  60                   rts
00D194  1               ; ----------------------------------------------------------------------------
00D194  1               ; SCAN AHEAD TO NEXT ":" OR EOL
00D194  1               ; ----------------------------------------------------------------------------
00D194  1               DATAN:
00D194  1  A2 3A                ldx     #$3A
00D196  1  2C                   .byte   $2C
00D197  1               REMN:
00D197  1  A2 00                ldx     #$00
00D199  1  86 5B                stx     CHARAC
00D19B  1  A0 00                ldy     #$00
00D19D  1  84 5C                sty     ENDCHR
00D19F  1               L285E:
00D19F  1  A5 5C                lda     ENDCHR
00D1A1  1  A6 5B                ldx     CHARAC
00D1A3  1  85 5B                sta     CHARAC
00D1A5  1  86 5C                stx     ENDCHR
00D1A7  1               L2866:
00D1A7  1  B1 DD                lda     (TXTPTR),y
00D1A9  1  F0 E8                beq     L2852
00D1AB  1  C5 5C                cmp     ENDCHR
00D1AD  1  F0 E4                beq     L2852
00D1AF  1  C8                   iny
00D1B0  1  C9 22                cmp     #$22
00D1B2  1  F0 EB                beq     L285E; old: swap & cont is faster
00D1B4  1  D0 F1                bne     L2866
00D1B6  1               ; ----------------------------------------------------------------------------
00D1B6  1               ; "IF" STATEMENT
00D1B6  1               ; ----------------------------------------------------------------------------
00D1B6  1               IF:
00D1B6  1  20 3B D5             jsr     FRMEVL
00D1B9  1  20 DC 00             jsr     CHRGOT
00D1BC  1  C9 88                cmp     #TOKEN_GOTO
00D1BE  1  F0 05                beq     L2884
00D1C0  1  A9 A0                lda     #TOKEN_THEN
00D1C2  1  20 7D D6             jsr     SYNCHR
00D1C5  1               L2884:
00D1C5  1  A5 AC                lda     FAC
00D1C7  1  D0 05                bne     L288D
00D1C9  1               ; ----------------------------------------------------------------------------
00D1C9  1               ; "REM" STATEMENT, OR FALSE "IF" STATEMENT
00D1C9  1               ; ----------------------------------------------------------------------------
00D1C9  1               REM:
00D1C9  1  20 97 D1             jsr     REMN
00D1CC  1  F0 BB                beq     ADDON
00D1CE  1               L288D:
00D1CE  1  20 DC 00             jsr     CHRGOT
00D1D1  1  B0 03                bcs     L2895
00D1D3  1  4C 33 D1             jmp     GOTO
00D1D6  1               L2895:
00D1D6  1  4C 85 D0             jmp     EXECUTE_STATEMENT
00D1D9  1               ; ----------------------------------------------------------------------------
00D1D9  1               ; "ON" STATEMENT
00D1D9  1               ;
00D1D9  1               ; ON <EXP> GOTO <LIST>
00D1D9  1               ; ON <EXP> GOSUB <LIST>
00D1D9  1               ; ----------------------------------------------------------------------------
00D1D9  1               ON:
00D1D9  1  20 28 DE             jsr     GETBYT
00D1DC  1  48                   pha
00D1DD  1  C9 8C                cmp     #TOKEN_GOSUB
00D1DF  1  F0 04                beq     L28A4
00D1E1  1               L28A0:
00D1E1  1  C9 88                cmp     #TOKEN_GOTO
00D1E3  1  D0 91                bne     SYNERR2
00D1E5  1               L28A4:
00D1E5  1  C6 AF                dec     FAC_LAST
00D1E7  1  D0 04                bne     L28AC
00D1E9  1  68                   pla
00D1EA  1  4C 88 D0             jmp     EXECUTE_STATEMENT1
00D1ED  1               L28AC:
00D1ED  1  20 D6 00             jsr     CHRGET
00D1F0  1  20 F9 D1             jsr     LINGET
00D1F3  1  C9 2C                cmp     #$2C
00D1F5  1  F0 EE                beq     L28A4
00D1F7  1  68                   pla
00D1F8  1               L28B7:
00D1F8  1  60                   rts
00D1F9  1               ; ----------------------------------------------------------------------------
00D1F9  1               ; CONVERT LINE NUMBER
00D1F9  1               ; ----------------------------------------------------------------------------
00D1F9  1               LINGET:
00D1F9  1  A2 00                ldx     #$00
00D1FB  1  86 11                stx     LINNUM
00D1FD  1  86 12                stx     LINNUM+1
00D1FF  1               L28BE:
00D1FF  1  B0 F7                bcs     L28B7
00D201  1  E9 2F                sbc     #$2F
00D203  1  85 5B                sta     CHARAC
00D205  1  A5 12                lda     LINNUM+1
00D207  1  85 71                sta     INDEX
00D209  1  C9 19                cmp     #$19
00D20B  1  B0 D4                bcs     L28A0
00D20D  1               ; <<<<<DANGEROUS CODE>>>>>
00D20D  1               ; NOTE THAT IF (A) = $AB ON THE LINE ABOVE,
00D20D  1               ; ON.1 WILL COMPARE = AND CAUSE A CATASTROPHIC
00D20D  1               ; JUMP TO $22D9 (FOR GOTO), OR OTHER LOCATIONS
00D20D  1               ; FOR OTHER CALLS TO LINGET.
00D20D  1               ;
00D20D  1               ; YOU CAN SEE THIS IS YOU FIRST PUT "BRK" IN $22D9,
00D20D  1               ; THEN TYPE "GO TO 437761".
00D20D  1               ;
00D20D  1               ; ANY VALUE FROM 437760 THROUGH 440319 WILL CAUSE
00D20D  1               ; THE PROBLEM.  ($AB00 - $ABFF)
00D20D  1               ; <<<<<DANGEROUS CODE>>>>>
00D20D  1  A5 11                lda     LINNUM
00D20F  1  0A                   asl     a
00D210  1  26 71                rol     INDEX
00D212  1  0A                   asl     a
00D213  1  26 71                rol     INDEX
00D215  1  65 11                adc     LINNUM
00D217  1  85 11                sta     LINNUM
00D219  1  A5 71                lda     INDEX
00D21B  1  65 12                adc     LINNUM+1
00D21D  1  85 12                sta     LINNUM+1
00D21F  1  06 11                asl     LINNUM
00D221  1  26 12                rol     LINNUM+1
00D223  1  A5 11                lda     LINNUM
00D225  1  65 5B                adc     CHARAC
00D227  1  85 11                sta     LINNUM
00D229  1  90 02                bcc     L28EC
00D22B  1  E6 12                inc     LINNUM+1
00D22D  1               L28EC:
00D22D  1  20 D6 00             jsr     CHRGET
00D230  1  4C FF D1             jmp     L28BE
00D233  1               ; ----------------------------------------------------------------------------
00D233  1               ; "LET" STATEMENT
00D233  1               ;
00D233  1               ; LET <VAR> = <EXP>
00D233  1               ; <VAR> = <EXP>
00D233  1               ; ----------------------------------------------------------------------------
00D233  1               LET:
00D233  1  20 85 D7             jsr     PTRGET
00D236  1  85 97                sta     FORPNT
00D238  1  84 98                sty     FORPNT+1
00D23A  1  A9 AB                lda     #TOKEN_EQUAL
00D23C  1  20 7D D6             jsr     SYNCHR
00D23F  1  A5 5F                lda     VALTYP
00D241  1  48                   pha
00D242  1  20 3B D5             jsr     FRMEVL
00D245  1  68                   pla
00D246  1  2A                   rol     a
00D247  1  20 2D D5             jsr     CHKVAL
00D24A  1  D0 03                bne     LETSTRING
00D24C  1               ; ----------------------------------------------------------------------------
00D24C  1               ; REAL VARIABLE = EXPRESSION
00D24C  1               ; ----------------------------------------------------------------------------
00D24C  1  4C EE E1             jmp     SETFOR
00D24F  1               LETSTRING:
00D24F  1               ; ----------------------------------------------------------------------------
00D24F  1               ; INSTALL STRING, DESCRIPTOR ADDRESS IS AT FAC+3,4
00D24F  1               ; ----------------------------------------------------------------------------
00D24F  1  A0 02                ldy     #$02
00D251  1  B1 AE                lda     (FAC_LAST-1),y
00D253  1  C5 82                cmp     FRETOP+1
00D255  1  90 17                bcc     L2946
00D257  1  D0 07                bne     L2938
00D259  1  88                   dey
00D25A  1  B1 AE                lda     (FAC_LAST-1),y
00D25C  1  C5 81                cmp     FRETOP
00D25E  1  90 0E                bcc     L2946
00D260  1               L2938:
00D260  1  A4 AF                ldy     FAC_LAST
00D262  1  C4 7C                cpy     VARTAB+1
00D264  1  90 08                bcc     L2946
00D266  1  D0 0D                bne     L294D
00D268  1  A5 AE                lda     FAC_LAST-1
00D26A  1  C5 7B                cmp     VARTAB
00D26C  1  B0 07                bcs     L294D
00D26E  1               L2946:
00D26E  1  A5 AE                lda     FAC_LAST-1
00D270  1  A4 AF                ldy     FAC_LAST
00D272  1  4C 8B D2             jmp     L2963
00D275  1               L294D:
00D275  1  A0 00                ldy     #$00
00D277  1  B1 AE                lda     (FAC_LAST-1),y
00D279  1  20 16 DB             jsr     STRINI
00D27C  1  A5 9E                lda     DSCPTR
00D27E  1  A4 9F                ldy     DSCPTR+1
00D280  1  85 B8                sta     STRNG1
00D282  1  84 B9                sty     STRNG1+1
00D284  1  20 04 DD             jsr     MOVINS
00D287  1  A9 AC                lda     #FAC
00D289  1  A0 00                ldy     #$00
00D28B  1               L2963:
00D28B  1  85 9E                sta     DSCPTR
00D28D  1  84 9F                sty     DSCPTR+1
00D28F  1  20 65 DD             jsr     FRETMS
00D292  1  A0 00                ldy     #$00
00D294  1  B1 9E                lda     (DSCPTR),y
00D296  1  91 97                sta     (FORPNT),y
00D298  1  C8                   iny
00D299  1  B1 9E                lda     (DSCPTR),y
00D29B  1  91 97                sta     (FORPNT),y
00D29D  1  C8                   iny
00D29E  1  B1 9E                lda     (DSCPTR),y
00D2A0  1  91 97                sta     (FORPNT),y
00D2A2  1  60                   rts
00D2A3  1               PRSTRING:
00D2A3  1  20 40 D3             jsr     STRPRT
00D2A6  1               L297E:
00D2A6  1  20 DC 00             jsr     CHRGOT
00D2A9  1               ; ----------------------------------------------------------------------------
00D2A9  1               ; "PRINT" STATEMENT
00D2A9  1               ; ----------------------------------------------------------------------------
00D2A9  1               PRINT:
00D2A9  1  F0 3B                beq     CRDO
00D2AB  1               PRINT2:
00D2AB  1  F0 57                beq     L29DD
00D2AD  1  C9 9C                cmp     #TOKEN_TAB
00D2AF  1  F0 6B                beq     L29F5
00D2B1  1  C9 9F                cmp     #TOKEN_SPC
00D2B3  1  F0 67                beq     L29F5
00D2B5  1  C9 2C                cmp     #','
00D2B7  1  F0 4C                beq     L29DE
00D2B9  1  C9 3B                cmp     #$3B
00D2BB  1  F0 7A                beq     L2A0D
00D2BD  1  20 3B D5             jsr     FRMEVL
00D2C0  1  24 5F                bit     VALTYP
00D2C2  1  30 DF                bmi     PRSTRING
00D2C4  1  20 E8 E3             jsr     FOUT
00D2C7  1  20 28 DB             jsr     STRLIT
00D2CA  1  A0 00                ldy     #$00
00D2CC  1  B1 AE                lda     (FAC_LAST-1),y
00D2CE  1  18                   clc
00D2CF  1  65 0E                adc     POSX
00D2D1  1  C5 0F                cmp     Z17
00D2D3  1  90 03                bcc     L29B1
00D2D5  1  20 E6 D2             jsr     CRDO
00D2D8  1               L29B1:
00D2D8  1  20 40 D3             jsr     STRPRT
00D2DB  1  20 5A D3             jsr     OUTSP
00D2DE  1  D0 C6                bne     L297E ; branch always
00D2E0  1               L29B9:
00D2E0  1  A0 00                ldy     #$00
00D2E2  1  94 13                sty     INPUTBUFFER,x
00D2E4  1  A2 12                ldx     #LINNUM+1
00D2E6  1               CRDO:
00D2E6  1  A9 0D                lda     #CRLF_1
00D2E8  1  85 0E                sta     POSX
00D2EA  1  20 5F D3             jsr     OUTDO
00D2ED  1  A9 0A                lda     #CRLF_2
00D2EF  1  20 5F D3             jsr     OUTDO
00D2F2  1               PRINTNULLS:
00D2F2  1  8A                   txa
00D2F3  1  48                   pha
00D2F4  1  A6 0D                ldx     Z15
00D2F6  1  F0 08                beq     L29D9
00D2F8  1  A9 00                lda     #$00
00D2FA  1               L29D3:
00D2FA  1  20 5F D3             jsr     OUTDO
00D2FD  1  CA                   dex
00D2FE  1  D0 FA                bne     L29D3
00D300  1               L29D9:
00D300  1  86 0E                stx     POSX
00D302  1  68                   pla
00D303  1  AA                   tax
00D304  1               L29DD:
00D304  1  60                   rts
00D305  1               L29DE:
00D305  1  A5 0E                lda     POSX
00D307  1  C5 10                cmp     Z18
00D309  1  90 06                bcc     L29EA
00D30B  1  20 E6 D2             jsr     CRDO
00D30E  1  4C 37 D3             jmp     L2A0D
00D311  1               L29EA:
00D311  1  38                   sec
00D312  1               L29EB:
00D312  1  E9 0E                sbc     #$0E
00D314  1  B0 FC                bcs     L29EB
00D316  1  49 FF                eor     #$FF
00D318  1  69 01                adc     #$01
00D31A  1  D0 14                bne     L2A08
00D31C  1               L29F5:
00D31C  1  48                   pha
00D31D  1  20 25 DE             jsr     GTBYTC
00D320  1  C9 29                cmp     #')'
00D322  1  D0 66                bne     SYNERR4
00D324  1  68                   pla
00D325  1  C9 9C                cmp     #TOKEN_TAB
00D327  1  D0 08                bne     L2A0A
00D329  1  8A                   txa
00D32A  1  E5 0E                sbc     POSX
00D32C  1  90 09                bcc     L2A0D
00D32E  1  F0 07                beq     L2A0D
00D330  1               L2A08:
00D330  1  AA                   tax
00D331  1               L2A0A:
00D331  1  20 5A D3             jsr     OUTSP
00D334  1  CA                   dex
00D335  1  D0 FA                bne     L2A0A
00D337  1               L2A0D:
00D337  1  20 D6 00             jsr     CHRGET
00D33A  1  4C AB D2             jmp     PRINT2
00D33D  1               ; ----------------------------------------------------------------------------
00D33D  1               ; PRINT STRING AT (Y,A)
00D33D  1               ; ----------------------------------------------------------------------------
00D33D  1               STROUT:
00D33D  1  20 28 DB             jsr     STRLIT
00D340  1               ; ----------------------------------------------------------------------------
00D340  1               ; PRINT STRING AT (FACMO,FACLO)
00D340  1               ; ----------------------------------------------------------------------------
00D340  1               STRPRT:
00D340  1  20 30 DD             jsr     FREFAC
00D343  1  AA                   tax
00D344  1  A0 00                ldy     #$00
00D346  1  E8                   inx
00D347  1               L2A22:
00D347  1  CA                   dex
00D348  1  F0 BA                beq     L29DD
00D34A  1  B1 71                lda     (INDEX),y
00D34C  1  20 5F D3             jsr     OUTDO
00D34F  1  C8                   iny
00D350  1  C9 0D                cmp     #$0D
00D352  1  D0 F3                bne     L2A22
00D354  1  20 F2 D2             jsr     PRINTNULLS
00D357  1  4C 47 D3             jmp     L2A22
00D35A  1               ; ----------------------------------------------------------------------------
00D35A  1               OUTSP:
00D35A  1  A9 20                lda     #$20
00D35C  1  2C                   .byte   $2C
00D35D  1               OUTQUES:
00D35D  1  A9 3F                lda     #$3F
00D35F  1               ; ----------------------------------------------------------------------------
00D35F  1               ; PRINT CHAR FROM (A)
00D35F  1               ; ----------------------------------------------------------------------------
00D35F  1               OUTDO:
00D35F  1  24 64                bit     Z14
00D361  1  30 18                bmi     L2A56
00D363  1               ; Commodore forgot to remove this in CBM1
00D363  1  48                   pha
00D364  1  C9 20                cmp     #$20
00D366  1  90 0B                bcc     L2A4E
00D368  1  A5 0E                lda     POSX
00D36A  1  C5 0F                cmp     Z17
00D36C  1  D0 03                bne     L2A4C
00D36E  1  20 E6 D2             jsr     CRDO
00D371  1               L2A4C:
00D371  1  E6 0E                inc     POSX
00D373  1               L2A4E:
00D373  1               ; Commodore forgot to remove this in CBM1
00D373  1  68                   pla
00D374  1  20 67 FF             jsr     MONCOUT
00D377  1  EA                   nop
00D378  1  EA                   nop
00D379  1  EA                   nop
00D37A  1  EA                   nop
00D37B  1               L2A56:
00D37B  1  29 FF                and     #$FF
00D37D  1  60                   rts
00D37E  1               ; ----------------------------------------------------------------------------
00D37E  1               ; ???
00D37E  1               ; ----------------------------------------------------------------------------
00D37E  1               ; ----------------------------------------------------------------------------
00D37E  1               ; INPUT CONVERSION ERROR:  ILLEGAL CHARACTER
00D37E  1               ; IN NUMERIC FIELD.  MUST DISTINGUISH
00D37E  1               ; BETWEEN INPUT, READ, AND GET
00D37E  1               ; ----------------------------------------------------------------------------
00D37E  1               INPUTERR:
00D37E  1  A5 62                lda     INPUTFLG
00D380  1  F0 0B                beq     RESPERR	; INPUT
00D382  1               ; without this, it treats GET errors
00D382  1               ; like READ errors
00D382  1  A5 8D                lda     Z8C
00D384  1  A4 8E                ldy     Z8C+1
00D386  1  85 87                sta     CURLIN
00D388  1  84 88                sty     CURLIN+1
00D38A  1               SYNERR4:
00D38A  1  4C 86 D6             jmp     SYNERR
00D38D  1               RESPERR:
00D38D  1  A9 A7                lda     #<ERRREENTRY
00D38F  1  A0 D4                ldy     #>ERRREENTRY
00D391  1  20 3D D3             jsr     STROUT
00D394  1  A5 8B                lda     OLDTEXT
00D396  1  A4 8C                ldy     OLDTEXT+1
00D398  1  85 DD                sta     TXTPTR
00D39A  1  84 DE                sty     TXTPTR+1
00D39C  1  60                   rts
00D39D  1               ; ----------------------------------------------------------------------------
00D39D  1               ; "GET" STATEMENT
00D39D  1               ; ----------------------------------------------------------------------------
00D39D  1               GET:
00D39D  1               ; ----------------------------------------------------------------------------
00D39D  1               ; "INPUT#" STATEMENT
00D39D  1               ; ----------------------------------------------------------------------------
00D39D  1               ; ----------------------------------------------------------------------------
00D39D  1               ; "INPUT" STATEMENT
00D39D  1               ; ----------------------------------------------------------------------------
00D39D  1               INPUT:
00D39D  1  46 64                lsr     Z14
00D39F  1  C9 22                cmp     #$22
00D3A1  1  D0 0B                bne     L2A9E
00D3A3  1  20 3B D6             jsr     STRTXT
00D3A6  1  A9 3B                lda     #$3B
00D3A8  1  20 7D D6             jsr     SYNCHR
00D3AB  1  20 40 D3             jsr     STRPRT
00D3AE  1               L2A9E:
00D3AE  1  20 4E DA             jsr     ERRDIR
00D3B1  1  A9 2C                lda     #$2C
00D3B3  1  85 12                sta     INPUTBUFFER-1
00D3B5  1  20 C0 D3             jsr     NXIN
00D3B8  1  A5 13                lda     INPUTBUFFER
00D3BA  1  D0 12                bne     L2ABE
00D3BC  1  18                   clc
00D3BD  1  4C C1 D0             jmp     CONTROL_C_TYPED
00D3C0  1               NXIN:
00D3C0  1  20 5D D3             jsr     OUTQUES	; '?'
00D3C3  1  20 5A D3             jsr     OUTSP
00D3C6  1  4C DD CD             jmp     INLIN
00D3C9  1               ; ----------------------------------------------------------------------------
00D3C9  1               ; "GETC" STATEMENT
00D3C9  1               ; ----------------------------------------------------------------------------
00D3C9  1               ; ----------------------------------------------------------------------------
00D3C9  1               ; "READ" STATEMENT
00D3C9  1               ; ----------------------------------------------------------------------------
00D3C9  1               READ:
00D3C9  1  A6 8F                ldx     DATPTR
00D3CB  1  A4 90                ldy     DATPTR+1
00D3CD  1               ; AppleSoft II, too
00D3CD  1  A9                   .byte   $A9	; LDA #$98
00D3CE  1               L2ABE:
00D3CE  1  98                   tya
00D3CF  1               ; ----------------------------------------------------------------------------
00D3CF  1               ; PROCESS INPUT LIST
00D3CF  1               ;
00D3CF  1               ; (Y,X) IS ADDRESS OF INPUT DATA STRING
00D3CF  1               ; (A) = VALUE FOR INPUTFLG:  $00 FOR INPUT
00D3CF  1               ; 				$40 FOR GET
00D3CF  1               ;				$98 FOR READ
00D3CF  1               ; ----------------------------------------------------------------------------
00D3CF  1  85 62                sta     INPUTFLG
00D3D1  1  86 91                stx     INPTR
00D3D3  1  84 92                sty     INPTR+1
00D3D5  1               PROCESS_INPUT_ITEM:
00D3D5  1  20 85 D7             jsr     PTRGET
00D3D8  1  85 97                sta     FORPNT
00D3DA  1  84 98                sty     FORPNT+1
00D3DC  1  A5 DD                lda     TXTPTR
00D3DE  1  A4 DE                ldy     TXTPTR+1
00D3E0  1  85 11                sta     TXPSV
00D3E2  1  84 12                sty     TXPSV+1
00D3E4  1  A6 91                ldx     INPTR
00D3E6  1  A4 92                ldy     INPTR+1
00D3E8  1  86 DD                stx     TXTPTR
00D3EA  1  84 DE                sty     TXTPTR+1
00D3EC  1  20 DC 00             jsr     CHRGOT
00D3EF  1  D0 0E                bne     INSTART
00D3F1  1  24 62                bit     INPUTFLG
00D3F3  1               ; BUG: The beq/bne L2AF8 below is supposed
00D3F3  1               ; to be always taken. For this to happen,
00D3F3  1               ; the last load must be a 0 for beq
00D3F3  1               ; and != 0 for bne. The original Microsoft
00D3F3  1               ; code had ldx/ldy/bne here, which was only
00D3F3  1               ; correct for a non-ZP INPUTBUFFER. Commodore
00D3F3  1               ; fixed it in CBMBASIC V1 by swapping the
00D3F3  1               ; ldx and the ldy. It was broken on KIM,
00D3F3  1               ; but okay on APPLE and CBM2, because
00D3F3  1               ; these used a non-ZP INPUTBUFFER.
00D3F3  1               ; Microsoft fixed this somewhere after KIM
00D3F3  1               ; and before MICROTAN, by using beq instead
00D3F3  1               ; of bne in the ZP case.
00D3F3  1  30 62                bmi     FINDATA
00D3F5  1  20 5D D3             jsr     OUTQUES
00D3F8  1  20 C0 D3             jsr     NXIN
00D3FB  1  86 DD                stx     TXTPTR
00D3FD  1  84 DE                sty     TXTPTR+1
00D3FF  1               ; ----------------------------------------------------------------------------
00D3FF  1               INSTART:
00D3FF  1  20 D6 00             jsr     CHRGET
00D402  1  24 5F                bit     VALTYP
00D404  1  10 24                bpl     L2B34
00D406  1  85 5B                sta     CHARAC
00D408  1  C9 22                cmp     #$22
00D40A  1  F0 07                beq     L2B1D
00D40C  1  A9 3A                lda     #$3A
00D40E  1  85 5B                sta     CHARAC
00D410  1  A9 2C                lda     #$2C
00D412  1  18                   clc
00D413  1               L2B1D:
00D413  1  85 5C                sta     ENDCHR
00D415  1  A5 DD                lda     TXTPTR
00D417  1  A4 DE                ldy     TXTPTR+1
00D419  1  69 00                adc     #$00
00D41B  1  90 01                bcc     L2B28
00D41D  1  C8                   iny
00D41E  1               L2B28:
00D41E  1  20 2E DB             jsr     STRLT2
00D421  1  20 6D DE             jsr     POINT
00D424  1  20 4F D2             jsr     LETSTRING
00D427  1  4C 30 D4             jmp     INPUT_MORE
00D42A  1               ; ----------------------------------------------------------------------------
00D42A  1               L2B34:
00D42A  1  20 01 E3             jsr     FIN
00D42D  1  20 EE E1             jsr     SETFOR
00D430  1               ; ----------------------------------------------------------------------------
00D430  1               INPUT_MORE:
00D430  1  20 DC 00             jsr     CHRGOT
00D433  1  F0 07                beq     L2B48
00D435  1  C9 2C                cmp     #$2C
00D437  1  F0 03                beq     L2B48
00D439  1  4C 7E D3             jmp     INPUTERR
00D43C  1               L2B48:
00D43C  1  A5 DD                lda     TXTPTR
00D43E  1  A4 DE                ldy     TXTPTR+1
00D440  1  85 91                sta     INPTR
00D442  1  84 92                sty     INPTR+1
00D444  1  A5 11                lda     TXPSV
00D446  1  A4 12                ldy     TXPSV+1
00D448  1  85 DD                sta     TXTPTR
00D44A  1  84 DE                sty     TXTPTR+1
00D44C  1  20 DC 00             jsr     CHRGOT
00D44F  1  F0 2C                beq     INPDONE
00D451  1  20 7B D6             jsr     CHKCOM
00D454  1  4C D5 D3             jmp     PROCESS_INPUT_ITEM
00D457  1               ; ----------------------------------------------------------------------------
00D457  1               FINDATA:
00D457  1  20 94 D1             jsr     DATAN
00D45A  1  C8                   iny
00D45B  1  AA                   tax
00D45C  1  D0 12                bne     L2B7C
00D45E  1  A2 06                ldx     #ERR_NODATA
00D460  1  C8                   iny
00D461  1  B1 DD                lda     (TXTPTR),y
00D463  1  F0 69                beq     GERR
00D465  1  C8                   iny
00D466  1  B1 DD                lda     (TXTPTR),y
00D468  1  85 8D                sta     Z8C
00D46A  1  C8                   iny
00D46B  1  B1 DD                lda     (TXTPTR),y
00D46D  1  C8                   iny
00D46E  1  85 8E                sta     Z8C+1
00D470  1               L2B7C:
00D470  1  B1 DD                lda     (TXTPTR),y
00D472  1  AA                   tax
00D473  1  20 89 D1             jsr     ADDON
00D476  1  E0 83                cpx     #$83
00D478  1  D0 DD                bne     FINDATA
00D47A  1  4C FF D3             jmp     INSTART
00D47D  1               ; ---NO MORE INPUT REQUESTED------
00D47D  1               INPDONE:
00D47D  1  A5 91                lda     INPTR
00D47F  1  A4 92                ldy     INPTR+1
00D481  1  A6 62                ldx     INPUTFLG
00D483  1  F0 03                beq     L2B94 ; INPUT
00D485  1  4C AA D0             jmp     SETDA
00D488  1               L2B94:
00D488  1  A0 00                ldy     #$00
00D48A  1  B1 91                lda     (INPTR),y
00D48C  1  F0 07                beq     L2BA1
00D48E  1  A9 96                lda     #<ERREXTRA
00D490  1  A0 D4                ldy     #>ERREXTRA
00D492  1  4C 3D D3             jmp     STROUT
00D495  1               L2BA1:
00D495  1  60                   rts
00D496  1               ; ----------------------------------------------------------------------------
00D496  1               ERREXTRA:
00D496  1  3F 45 58 54          .byte   "?EXTRA IGNORED"
00D49A  1  52 41 20 49  
00D49E  1  47 4E 4F 52  
00D4A4  1               
00D4A4  1               
00D4A4  1  0D 0A 00             .byte   $0D,$0A,$00
00D4A7  1               ERRREENTRY:
00D4A7  1  3F 52 45 44          .byte   "?REDO FROM START"
00D4AB  1  4F 20 46 52  
00D4AF  1  4F 4D 20 53  
00D4B7  1               
00D4B7  1               
00D4B7  1  0D 0A 00             .byte   $0D,$0A,$00
00D4BA  1               ; ----------------------------------------------------------------------------
00D4BA  1               ; "NEXT" STATEMENT
00D4BA  1               ; ----------------------------------------------------------------------------
00D4BA  1               NEXT:
00D4BA  1  D0 04                bne     NEXT1
00D4BC  1  A0 00                ldy     #$00
00D4BE  1  F0 03                beq     NEXT2
00D4C0  1               NEXT1:
00D4C0  1  20 85 D7             jsr     PTRGET
00D4C3  1               NEXT2:
00D4C3  1  85 97                sta     FORPNT
00D4C5  1  84 98                sty     FORPNT+1
00D4C7  1  20 27 CC             jsr     GTFORPNT
00D4CA  1  F0 04                beq     NEXT3
00D4CC  1  A2 00                ldx     #$00
00D4CE  1               GERR:
00D4CE  1  F0 68                beq     JERROR
00D4D0  1               NEXT3:
00D4D0  1  9A                   txs
00D4D1  1  E8                   inx
00D4D2  1  E8                   inx
00D4D3  1  E8                   inx
00D4D4  1  E8                   inx
00D4D5  1  8A                   txa
00D4D6  1  E8                   inx
00D4D7  1  E8                   inx
00D4D8  1  E8                   inx
00D4D9  1  E8                   inx
00D4DA  1  E8                   inx
00D4DB  1  86 73                stx     DEST
00D4DD  1  A0 01                ldy     #>STACK
00D4DF  1  20 C5 E1             jsr     LOAD_FAC_FROM_YA
00D4E2  1  BA                   tsx
00D4E3  1  BD 08 01             lda     STACK+BYTES_FP+4,x
00D4E6  1  85 B0                sta     FACSIGN
00D4E8  1  A5 97                lda     FORPNT
00D4EA  1  A4 98                ldy     FORPNT+1
00D4EC  1  20 E6 DE             jsr     FADD
00D4EF  1  20 EE E1             jsr     SETFOR
00D4F2  1  A0 01                ldy     #>STACK
00D4F4  1  20 74 E2             jsr     FCOMP2
00D4F7  1  BA                   tsx
00D4F8  1  38                   sec
00D4F9  1  FD 08 01             sbc     STACK+BYTES_FP+4,x
00D4FC  1  F0 17                beq     L2C22
00D4FE  1  BD 0D 01             lda     STACK+2*BYTES_FP+5,x
00D501  1  85 87                sta     CURLIN
00D503  1  BD 0E 01             lda     STACK+2*BYTES_FP+6,x
00D506  1  85 88                sta     CURLIN+1
00D508  1  BD 10 01             lda     STACK+2*BYTES_FP+8,x
00D50B  1  85 DD                sta     TXTPTR
00D50D  1  BD 0F 01             lda     STACK+2*BYTES_FP+7,x
00D510  1  85 DE                sta     TXTPTR+1
00D512  1               L2C1F:
00D512  1  4C 48 D0             jmp     NEWSTT
00D515  1               L2C22:
00D515  1  8A                   txa
00D516  1  69 0F                adc     #2*BYTES_FP+7
00D518  1  AA                   tax
00D519  1  9A                   txs
00D51A  1  20 DC 00             jsr     CHRGOT
00D51D  1  C9 2C                cmp     #$2C
00D51F  1  D0 F1                bne     L2C1F
00D521  1  20 D6 00             jsr     CHRGET
00D524  1  20 C0 D4             jsr     NEXT1
00D527  1               ; ----------------------------------------------------------------------------
00D527  1               ; EVALUATE EXPRESSION, MAKE SURE IT IS NUMERIC
00D527  1               ; ----------------------------------------------------------------------------
00D527  1               FRMNUM:
00D527  1  20 3B D5             jsr     FRMEVL
00D52A  1               ; ----------------------------------------------------------------------------
00D52A  1               ; MAKE SURE (FAC) IS NUMERIC
00D52A  1               ; ----------------------------------------------------------------------------
00D52A  1               CHKNUM:
00D52A  1  18                   clc
00D52B  1  24                   .byte   $24
00D52C  1               ; ----------------------------------------------------------------------------
00D52C  1               ; MAKE SURE (FAC) IS STRING
00D52C  1               ; ----------------------------------------------------------------------------
00D52C  1               CHKSTR:
00D52C  1  38                   sec
00D52D  1               ; ----------------------------------------------------------------------------
00D52D  1               ; MAKE SURE (FAC) IS CORRECT TYPE
00D52D  1               ; IF C=0, TYPE MUST BE NUMERIC
00D52D  1               ; IF C=1, TYPE MUST BE STRING
00D52D  1               ; ----------------------------------------------------------------------------
00D52D  1               CHKVAL:
00D52D  1  24 5F                bit     VALTYP
00D52F  1  30 03                bmi     L2C41
00D531  1  B0 03                bcs     L2C43
00D533  1               L2C40:
00D533  1  60                   rts
00D534  1               L2C41:
00D534  1  B0 FD                bcs     L2C40
00D536  1               L2C43:
00D536  1  A2 18                ldx     #ERR_BADTYPE
00D538  1               JERROR:
00D538  1  4C D4 CC             jmp     ERROR
00D53B  1               ; ----------------------------------------------------------------------------
00D53B  1               ; EVALUATE THE EXPRESSION AT TXTPTR, LEAVING THE
00D53B  1               ; RESULT IN FAC.  WORKS FOR BOTH STRING AND NUMERIC
00D53B  1               ; EXPRESSIONS.
00D53B  1               ; ----------------------------------------------------------------------------
00D53B  1               FRMEVL:
00D53B  1  A6 DD                ldx     TXTPTR
00D53D  1  D0 02                bne     L2C4E
00D53F  1  C6 DE                dec     TXTPTR+1
00D541  1               L2C4E:
00D541  1  C6 DD                dec     TXTPTR
00D543  1  A2 00                ldx     #$00
00D545  1  24                   .byte   $24
00D546  1               FRMEVL1:
00D546  1  48                   pha
00D547  1  8A                   txa
00D548  1  48                   pha
00D549  1  A9 01                lda     #$01
00D54B  1  20 98 CC             jsr     CHKMEM
00D54E  1  20 1A D6             jsr     FRM_ELEMENT
00D551  1  A9 00                lda     #$00
00D553  1  85 9B                sta     CPRTYP
00D555  1               FRMEVL2:
00D555  1  20 DC 00             jsr     CHRGOT
00D558  1               L2C65:
00D558  1  38                   sec
00D559  1  E9 AA                sbc     #TOKEN_GREATER
00D55B  1  90 17                bcc     L2C81
00D55D  1  C9 03                cmp     #$03
00D55F  1  B0 13                bcs     L2C81
00D561  1  C9 01                cmp     #$01
00D563  1  2A                   rol     a
00D564  1  49 01                eor     #$01
00D566  1  45 9B                eor     CPRTYP
00D568  1  C5 9B                cmp     CPRTYP
00D56A  1  90 61                bcc     SNTXERR
00D56C  1  85 9B                sta     CPRTYP
00D56E  1  20 D6 00             jsr     CHRGET
00D571  1  4C 58 D5             jmp     L2C65
00D574  1               L2C81:
00D574  1  A6 9B                ldx     CPRTYP
00D576  1  D0 2C                bne     FRM_RELATIONAL
00D578  1  B0 78                bcs     L2D02
00D57A  1  69 07                adc     #$07
00D57C  1  90 74                bcc     L2D02
00D57E  1  65 5F                adc     VALTYP
00D580  1  D0 03                bne     L2C92
00D582  1  4C C7 DC             jmp     CAT
00D585  1               L2C92:
00D585  1  69 FF                adc     #$FF
00D587  1  85 71                sta     INDEX
00D589  1  0A                   asl     a
00D58A  1  65 71                adc     INDEX
00D58C  1  A8                   tay
00D58D  1               FRM_PRECEDENCE_TEST:
00D58D  1  68                   pla
00D58E  1  D9 66 C0             cmp     MATHTBL,y
00D591  1  B0 64                bcs     FRM_PERFORM1
00D593  1  20 2A D5             jsr     CHKNUM
00D596  1               L2CA3:
00D596  1  48                   pha
00D597  1               L2CA4:
00D597  1  20 BD D5             jsr     FRM_RECURSE
00D59A  1  68                   pla
00D59B  1  A4 99                ldy     LASTOP
00D59D  1  10 17                bpl     PREFNC
00D59F  1  AA                   tax
00D5A0  1  F0 53                beq     GOEX
00D5A2  1  D0 5C                bne     FRM_PERFORM2
00D5A4  1               ; ----------------------------------------------------------------------------
00D5A4  1               ; FOUND ONE OR MORE RELATIONAL OPERATORS <,=,>
00D5A4  1               ; ----------------------------------------------------------------------------
00D5A4  1               FRM_RELATIONAL:
00D5A4  1  46 5F                lsr     VALTYP
00D5A6  1  8A                   txa
00D5A7  1  2A                   rol     a
00D5A8  1  A6 DD                ldx     TXTPTR
00D5AA  1  D0 02                bne     L2CBB
00D5AC  1  C6 DE                dec     TXTPTR+1
00D5AE  1               L2CBB:
00D5AE  1  C6 DD                dec     TXTPTR
00D5B0  1  A0 1B                ldy     #$1B
00D5B2  1  85 9B                sta     CPRTYP
00D5B4  1  D0 D7                bne     FRM_PRECEDENCE_TEST
00D5B6  1               PREFNC:
00D5B6  1  D9 66 C0             cmp     MATHTBL,y
00D5B9  1  B0 45                bcs     FRM_PERFORM2
00D5BB  1  90 D9                bcc     L2CA3
00D5BD  1               ; ----------------------------------------------------------------------------
00D5BD  1               ; STACK THIS OPERATION AND CALL FRMEVL FOR
00D5BD  1               ; ANOTHER ONE
00D5BD  1               ; ----------------------------------------------------------------------------
00D5BD  1               FRM_RECURSE:
00D5BD  1  B9 68 C0             lda     MATHTBL+2,y
00D5C0  1  48                   pha
00D5C1  1  B9 67 C0             lda     MATHTBL+1,y
00D5C4  1  48                   pha
00D5C5  1  20 D0 D5             jsr     FRM_STACK1
00D5C8  1  A5 9B                lda     CPRTYP
00D5CA  1  4C 46 D5             jmp     FRMEVL1
00D5CD  1               SNTXERR:
00D5CD  1  4C 86 D6             jmp     SYNERR
00D5D0  1               ; ----------------------------------------------------------------------------
00D5D0  1               ; STACK (FAC)
00D5D0  1               ; THREE ENTRY POINTS:
00D5D0  1               ; 	1, FROM FRMEVL
00D5D0  1               ;	2, FROM "STEP"
00D5D0  1               ;	3, FROM "FOR"
00D5D0  1               ; ----------------------------------------------------------------------------
00D5D0  1               FRM_STACK1:
00D5D0  1  A5 B0                lda     FACSIGN
00D5D2  1  BE 66 C0             ldx     MATHTBL,y
00D5D5  1               ; ----------------------------------------------------------------------------
00D5D5  1               ; ENTER HERE FROM "STEP", TO PUSH STEP SIGN AND VALUE
00D5D5  1               ; ----------------------------------------------------------------------------
00D5D5  1               FRM_STACK2:
00D5D5  1  A8                   tay
00D5D6  1  68                   pla
00D5D7  1  85 71                sta     INDEX
00D5D9  1  E6 71                inc     INDEX ; bug: assumes not on page boundary
00D5DB  1               ; bug exists on AppleSoft II
00D5DB  1  68                   pla
00D5DC  1  85 72                sta     INDEX+1
00D5DE  1  98                   tya
00D5DF  1  48                   pha
00D5E0  1               ; ----------------------------------------------------------------------------
00D5E0  1               ; ENTER HERE FROM "FOR", WITH (INDEX) = STEP,
00D5E0  1               ; TO PUSH INITIAL VALUE OF "FOR" VARIABLE
00D5E0  1               ; ----------------------------------------------------------------------------
00D5E0  1               FRM_STACK3:
00D5E0  1  20 34 E2             jsr     ROUND_FAC
00D5E3  1  A5 AF                lda     FAC+3
00D5E5  1  48                   pha
00D5E6  1  A5 AE                lda     FAC+2
00D5E8  1  48                   pha
00D5E9  1  A5 AD                lda     FAC+1
00D5EB  1  48                   pha
00D5EC  1  A5 AC                lda     FAC
00D5EE  1  48                   pha
00D5EF  1  6C 71 00             jmp     (INDEX)
00D5F2  1               L2D02:
00D5F2  1  A0 FF                ldy     #$FF
00D5F4  1  68                   pla
00D5F5  1               GOEX:
00D5F5  1  F0 20                beq     EXIT
00D5F7  1               ; ----------------------------------------------------------------------------
00D5F7  1               ; PERFORM STACKED OPERATION
00D5F7  1               ;
00D5F7  1               ; (A) = PRECEDENCE BYTE
00D5F7  1               ; STACK:  1 -- CPRMASK
00D5F7  1               ;	5 -- (ARG)
00D5F7  1               ;	2 -- ADDR OF PERFORMER
00D5F7  1               ; ----------------------------------------------------------------------------
00D5F7  1               FRM_PERFORM1:
00D5F7  1  C9 64                cmp     #$64
00D5F9  1  F0 03                beq     L2D0E
00D5FB  1  20 2A D5             jsr     CHKNUM
00D5FE  1               L2D0E:
00D5FE  1  84 99                sty     LASTOP
00D600  1               FRM_PERFORM2:
00D600  1  68                   pla
00D601  1  4A                   lsr     a
00D602  1  85 63                sta     CPRMASK
00D604  1  68                   pla
00D605  1  85 B3                sta     ARG
00D607  1  68                   pla
00D608  1  85 B4                sta     ARG+1
00D60A  1  68                   pla
00D60B  1  85 B5                sta     ARG+2
00D60D  1  68                   pla
00D60E  1  85 B6                sta     ARG+3
00D610  1  68                   pla
00D611  1  85 B7                sta     ARGSIGN
00D613  1  45 B0                eor     FACSIGN
00D615  1  85 B8                sta     SGNCPR
00D617  1               EXIT:
00D617  1  A5 AC                lda     FAC
00D619  1  60                   rts
00D61A  1               ; ----------------------------------------------------------------------------
00D61A  1               ; GET ELEMENT IN EXPRESSION
00D61A  1               ;
00D61A  1               ; GET VALUE OF VARIABLE OR NUMBER AT TXTPNT, OR POINT
00D61A  1               ; TO STRING DESCRIPTOR IF A STRING, AND PUT IN FAC.
00D61A  1               ; ----------------------------------------------------------------------------
00D61A  1               FRM_ELEMENT:
00D61A  1  A9 00                lda     #$00
00D61C  1  85 5F                sta     VALTYP
00D61E  1               L2D31:
00D61E  1  20 D6 00             jsr     CHRGET
00D621  1  B0 03                bcs     L2D39
00D623  1               L2D36:
00D623  1  4C 01 E3             jmp     FIN
00D626  1               L2D39:
00D626  1  20 FB D7             jsr     ISLETC
00D629  1  B0 67                bcs     FRM_VARIABLE
00D62B  1               CON_PI:
00D62B  1  C9 2E                cmp     #$2E
00D62D  1  F0 F4                beq     L2D36
00D62F  1  C9 A4                cmp     #TOKEN_MINUS
00D631  1  F0 58                beq     MIN
00D633  1  C9 A3                cmp     #TOKEN_PLUS
00D635  1  F0 E7                beq     L2D31
00D637  1  C9 22                cmp     #$22
00D639  1  D0 0F                bne     NOT_
00D63B  1               ; ----------------------------------------------------------------------------
00D63B  1               ; STRING CONSTANT ELEMENT
00D63B  1               ;
00D63B  1               ; SET Y,A = (TXTPTR)+CARRY
00D63B  1               ; ----------------------------------------------------------------------------
00D63B  1               STRTXT:
00D63B  1  A5 DD                lda     TXTPTR
00D63D  1  A4 DE                ldy     TXTPTR+1
00D63F  1  69 00                adc     #$00
00D641  1  90 01                bcc     L2D57
00D643  1  C8                   iny
00D644  1               L2D57:
00D644  1  20 28 DB             jsr     STRLIT
00D647  1  4C 6D DE             jmp     POINT
00D64A  1               ; ----------------------------------------------------------------------------
00D64A  1               ; "NOT" FUNCTION
00D64A  1               ; IF FAC=0, RETURN FAC=1
00D64A  1               ; IF FAC<>0, RETURN FAC=0
00D64A  1               ; ----------------------------------------------------------------------------
00D64A  1               NOT_:
00D64A  1  C9 A1                cmp     #TOKEN_NOT
00D64C  1  D0 13                bne     L2D74
00D64E  1  A0 18                ldy     #$18
00D650  1  D0 3B                bne     EQUL
00D652  1               ; ----------------------------------------------------------------------------
00D652  1               ; COMPARISON FOR EQUALITY (= OPERATOR)
00D652  1               ; ALSO USED TO EVALUATE "NOT" FUNCTION
00D652  1               ; ----------------------------------------------------------------------------
00D652  1               EQUOP:
00D652  1  20 7F D8             jsr     AYINT
00D655  1  A5 AF                lda     FAC_LAST
00D657  1  49 FF                eor     #$FF
00D659  1  A8                   tay
00D65A  1  A5 AE                lda     FAC_LAST-1
00D65C  1  49 FF                eor     #$FF
00D65E  1  4C 3B DA             jmp     GIVAYF
00D661  1               L2D74:
00D661  1  C9 9E                cmp     #TOKEN_FN
00D663  1  D0 03                bne     L2D7B
00D665  1  4C 98 DA             jmp     L31F3
00D668  1               L2D7B:
00D668  1  C9 AD                cmp     #TOKEN_SGN
00D66A  1  90 03                bcc     PARCHK
00D66C  1  4C A1 D6             jmp     UNARY
00D66F  1               ; ----------------------------------------------------------------------------
00D66F  1               ; EVALUATE "(EXPRESSION)"
00D66F  1               ; ----------------------------------------------------------------------------
00D66F  1               PARCHK:
00D66F  1  20 78 D6             jsr     CHKOPN
00D672  1  20 3B D5             jsr     FRMEVL
00D675  1               CHKCLS:
00D675  1  A9 29                lda     #$29
00D677  1  2C                   .byte   $2C
00D678  1               CHKOPN:
00D678  1  A9 28                lda     #$28
00D67A  1  2C                   .byte   $2C
00D67B  1               CHKCOM:
00D67B  1  A9 2C                lda     #$2C
00D67D  1               ; ----------------------------------------------------------------------------
00D67D  1               ; UNLESS CHAR AT TXTPTR = (A), SYNTAX ERROR
00D67D  1               ; ----------------------------------------------------------------------------
00D67D  1               SYNCHR:	; XXX all CBM code calls SYNCHR instead of CHKCOM
00D67D  1  A0 00                ldy     #$00
00D67F  1  D1 DD                cmp     (TXTPTR),y
00D681  1  D0 03                bne     SYNERR
00D683  1  4C D6 00             jmp     CHRGET
00D686  1               ; ----------------------------------------------------------------------------
00D686  1               SYNERR:
00D686  1  A2 02                ldx     #ERR_SYNTAX
00D688  1  4C D4 CC             jmp     ERROR
00D68B  1               ; ----------------------------------------------------------------------------
00D68B  1               MIN:
00D68B  1  A0 15                ldy     #$15
00D68D  1               EQUL:
00D68D  1  68                   pla
00D68E  1  68                   pla
00D68F  1  4C 97 D5             jmp     L2CA4
00D692  1               ; ----------------------------------------------------------------------------
00D692  1               FRM_VARIABLE:
00D692  1  20 85 D7             jsr     PTRGET
00D695  1               FRM_VARIABLE_CALL	= *-1
00D695  1  85 AE                sta     FAC_LAST-1
00D697  1  84 AF                sty     FAC_LAST
00D699  1  A6 5F                ldx     VALTYP
00D69B  1  F0 01                beq     L2DB1
00D69D  1               ; bugfix?
00D69D  1               ; fixed on AppleSoft II, not on any CBM
00D69D  1  60                   rts
00D69E  1               L2DB1:
00D69E  1  4C C5 E1             jmp     LOAD_FAC_FROM_YA
00D6A1  1               ; ----------------------------------------------------------------------------
00D6A1  1               UNARY:
00D6A1  1  0A                   asl     a
00D6A2  1  48                   pha
00D6A3  1  AA                   tax
00D6A4  1  20 D6 00             jsr     CHRGET
00D6A7  1  E0 81                cpx     #<(TOKEN_LEFTSTR*2-1)
00D6A9  1  90 20                bcc     L2DEF
00D6AB  1  20 78 D6             jsr     CHKOPN
00D6AE  1  20 3B D5             jsr     FRMEVL
00D6B1  1  20 7B D6             jsr     CHKCOM
00D6B4  1  20 2C D5             jsr     CHKSTR
00D6B7  1  68                   pla
00D6B8  1  AA                   tax
00D6B9  1  A5 AF                lda     FAC_LAST
00D6BB  1  48                   pha
00D6BC  1  A5 AE                lda     FAC_LAST-1
00D6BE  1  48                   pha
00D6BF  1  8A                   txa
00D6C0  1  48                   pha
00D6C1  1  20 28 DE             jsr     GETBYT
00D6C4  1  68                   pla
00D6C5  1  A8                   tay
00D6C6  1  8A                   txa
00D6C7  1  48                   pha
00D6C8  1  4C D0 D6             jmp     L2DF4
00D6CB  1               L2DEF:
00D6CB  1  20 6F D6             jsr     PARCHK
00D6CE  1  68                   pla
00D6CF  1  A8                   tay
00D6D0  1               L2DF4:
00D6D0  1  B9 DE BF             lda     UNFNC+($80-TOKEN_SGN)*2,y
00D6D3  1  85 A2                sta     JMPADRS+1
00D6D5  1  B9 DF BF             lda     UNFNC+($80-TOKEN_SGN)*2+1,y
00D6D8  1  85 A3                sta     JMPADRS+2
00D6DA  1  20 A1 00             jsr     JMPADRS
00D6DD  1  4C 2A D5             jmp     CHKNUM
00D6E0  1               ; ----------------------------------------------------------------------------
00D6E0  1               OR:
00D6E0  1  A0 FF                ldy     #$FF
00D6E2  1  2C                   .byte   $2C
00D6E3  1               ; ----------------------------------------------------------------------------
00D6E3  1               TAND:
00D6E3  1  A0 00                ldy     #$00
00D6E5  1  84 5D                sty     EOLPNTR
00D6E7  1  20 7F D8             jsr     AYINT
00D6EA  1  A5 AE                lda     FAC_LAST-1
00D6EC  1  45 5D                eor     EOLPNTR
00D6EE  1  85 5B                sta     CHARAC
00D6F0  1  A5 AF                lda     FAC_LAST
00D6F2  1  45 5D                eor     EOLPNTR
00D6F4  1  85 5C                sta     ENDCHR
00D6F6  1  20 15 E2             jsr     COPY_ARG_TO_FAC
00D6F9  1  20 7F D8             jsr     AYINT
00D6FC  1  A5 AF                lda     FAC_LAST
00D6FE  1  45 5D                eor     EOLPNTR
00D700  1  25 5C                and     ENDCHR
00D702  1  45 5D                eor     EOLPNTR
00D704  1  A8                   tay
00D705  1  A5 AE                lda     FAC_LAST-1
00D707  1  45 5D                eor     EOLPNTR
00D709  1  25 5B                and     CHARAC
00D70B  1  45 5D                eor     EOLPNTR
00D70D  1  4C 3B DA             jmp     GIVAYF
00D710  1               ; ----------------------------------------------------------------------------
00D710  1               ; PERFORM RELATIONAL OPERATIONS
00D710  1               ; ----------------------------------------------------------------------------
00D710  1               RELOPS:
00D710  1  20 2D D5             jsr     CHKVAL
00D713  1  B0 13                bcs     STRCMP
00D715  1  A5 B7                lda     ARGSIGN
00D717  1  09 7F                ora     #$7F
00D719  1  25 B4                and     ARG+1
00D71B  1  85 B4                sta     ARG+1
00D71D  1  A9 B3                lda     #<ARG
00D71F  1  A0 00                ldy     #$00
00D721  1  20 72 E2             jsr     FCOMP
00D724  1  AA                   tax
00D725  1  4C 5B D7             jmp     NUMCMP
00D728  1               ; ----------------------------------------------------------------------------
00D728  1               ; STRING COMPARISON
00D728  1               ; ----------------------------------------------------------------------------
00D728  1               STRCMP:
00D728  1  A9 00                lda     #$00
00D72A  1  85 5F                sta     VALTYP
00D72C  1  C6 9B                dec     CPRTYP
00D72E  1  20 30 DD             jsr     FREFAC
00D731  1  85 AC                sta     FAC
00D733  1  86 AD                stx     FAC+1
00D735  1  84 AE                sty     FAC+2
00D737  1  A5 B5                lda     ARG_LAST-1
00D739  1  A4 B6                ldy     ARG_LAST
00D73B  1  20 34 DD             jsr     FRETMP
00D73E  1  86 B5                stx     ARG_LAST-1
00D740  1  84 B6                sty     ARG_LAST
00D742  1  AA                   tax
00D743  1  38                   sec
00D744  1  E5 AC                sbc     FAC
00D746  1  F0 08                beq     L2E74
00D748  1  A9 01                lda     #$01
00D74A  1  90 04                bcc     L2E74
00D74C  1  A6 AC                ldx     FAC
00D74E  1  A9 FF                lda     #$FF
00D750  1               L2E74:
00D750  1  85 B0                sta     FACSIGN
00D752  1  A0 FF                ldy     #$FF
00D754  1  E8                   inx
00D755  1               STRCMP1:
00D755  1  C8                   iny
00D756  1  CA                   dex
00D757  1  D0 07                bne     L2E84
00D759  1  A6 B0                ldx     FACSIGN
00D75B  1               NUMCMP:
00D75B  1  30 0F                bmi     CMPDONE
00D75D  1  18                   clc
00D75E  1  90 0C                bcc     CMPDONE
00D760  1               L2E84:
00D760  1  B1 B5                lda     (ARG_LAST-1),y
00D762  1  D1 AD                cmp     (FAC+1),y
00D764  1  F0 EF                beq     STRCMP1
00D766  1  A2 FF                ldx     #$FF
00D768  1  B0 02                bcs     CMPDONE
00D76A  1  A2 01                ldx     #$01
00D76C  1               CMPDONE:
00D76C  1  E8                   inx
00D76D  1  8A                   txa
00D76E  1  2A                   rol     a
00D76F  1  25 63                and     CPRMASK
00D771  1  F0 02                beq     L2E99
00D773  1  A9 FF                lda     #$FF
00D775  1               L2E99:
00D775  1  4C 55 E2             jmp     FLOAT
00D778  1               ; ----------------------------------------------------------------------------
00D778  1               ; "DIM" STATEMENT
00D778  1               ; ----------------------------------------------------------------------------
00D778  1               NXDIM:
00D778  1  20 7B D6             jsr     CHKCOM
00D77B  1               DIM:
00D77B  1  AA                   tax
00D77C  1  20 8A D7             jsr     PTRGET2
00D77F  1  20 DC 00             jsr     CHRGOT
00D782  1  D0 F4                bne     NXDIM
00D784  1  60                   rts
00D785  1               ; ----------------------------------------------------------------------------
00D785  1               ; PTRGET -- GENERAL VARIABLE SCAN
00D785  1               ;
00D785  1               ; SCANS VARIABLE NAME AT TXTPTR, AND SEARCHES THE
00D785  1               ; VARTAB AND ARYTAB FOR THE NAME.
00D785  1               ; IF NOT FOUND, CREATE VARIABLE OF APPROPRIATE TYPE.
00D785  1               ; RETURN WITH ADDRESS IN VARPNT AND Y,A
00D785  1               ;
00D785  1               ; ACTUAL ACTIVITY CONTROLLED SOMEWHAT BY TWO FLAGS:
00D785  1               ;	DIMFLG -- NONZERO IF CALLED FROM "DIM"
00D785  1               ;		ELSE = 0
00D785  1               ;
00D785  1               ;	SUBFLG -- = $00
00D785  1               ;		= $40 IF CALLED FROM "GETARYPT"
00D785  1               ; ----------------------------------------------------------------------------
00D785  1               PTRGET:
00D785  1  A2 00                ldx     #$00
00D787  1  20 DC 00             jsr     CHRGOT
00D78A  1               PTRGET2:
00D78A  1  86 5E                stx     DIMFLG
00D78C  1               PTRGET3:
00D78C  1  85 93                sta     VARNAM
00D78E  1  20 DC 00             jsr     CHRGOT
00D791  1  20 FB D7             jsr     ISLETC
00D794  1  B0 03                bcs     NAMOK
00D796  1  4C 86 D6             jmp     SYNERR
00D799  1               NAMOK:
00D799  1  A2 00                ldx     #$00
00D79B  1  86 5F                stx     VALTYP
00D79D  1  20 D6 00             jsr     CHRGET
00D7A0  1  90 05                bcc     L2ECD
00D7A2  1  20 FB D7             jsr     ISLETC
00D7A5  1  90 0B                bcc     L2ED8
00D7A7  1               L2ECD:
00D7A7  1  AA                   tax
00D7A8  1               L2ECE:
00D7A8  1  20 D6 00             jsr     CHRGET
00D7AB  1  90 FB                bcc     L2ECE
00D7AD  1  20 FB D7             jsr     ISLETC
00D7B0  1  B0 F6                bcs     L2ECE
00D7B2  1               L2ED8:
00D7B2  1  C9 24                cmp     #$24
00D7B4  1  D0 0B                bne     L2EF9
00D7B6  1  A9 FF                lda     #$FF
00D7B8  1  85 5F                sta     VALTYP
00D7BA  1  8A                   txa
00D7BB  1  09 80                ora     #$80
00D7BD  1  AA                   tax
00D7BE  1  20 D6 00             jsr     CHRGET
00D7C1  1               L2EF9:
00D7C1  1  86 94                stx     VARNAM+1
00D7C3  1  38                   sec
00D7C4  1  05 61                ora     SUBFLG
00D7C6  1  E9 28                sbc     #$28
00D7C8  1  D0 03                bne     L2F05
00D7CA  1  4C 91 D8             jmp     ARRAY
00D7CD  1               L2F05:
00D7CD  1  A9 00                lda     #$00
00D7CF  1  85 61                sta     SUBFLG
00D7D1  1  A5 7B                lda     VARTAB
00D7D3  1  A6 7C                ldx     VARTAB+1
00D7D5  1  A0 00                ldy     #$00
00D7D7  1               L2F0F:
00D7D7  1  86 AB                stx     LOWTR+1
00D7D9  1               L2F11:
00D7D9  1  85 AA                sta     LOWTR
00D7DB  1  E4 7E                cpx     ARYTAB+1
00D7DD  1  D0 04                bne     L2F1B
00D7DF  1  C5 7D                cmp     ARYTAB
00D7E1  1  F0 22                beq     NAMENOTFOUND
00D7E3  1               L2F1B:
00D7E3  1  A5 93                lda     VARNAM
00D7E5  1  D1 AA                cmp     (LOWTR),y
00D7E7  1  D0 08                bne     L2F29
00D7E9  1  A5 94                lda     VARNAM+1
00D7EB  1  C8                   iny
00D7EC  1  D1 AA                cmp     (LOWTR),y
00D7EE  1  F0 61                beq     SET_VARPNT_AND_YA
00D7F0  1  88                   dey
00D7F1  1               L2F29:
00D7F1  1  18                   clc
00D7F2  1  A5 AA                lda     LOWTR
00D7F4  1  69 06                adc     #BYTES_PER_VARIABLE
00D7F6  1  90 E1                bcc     L2F11
00D7F8  1  E8                   inx
00D7F9  1  D0 DC                bne     L2F0F
00D7FB  1               ; ----------------------------------------------------------------------------
00D7FB  1               ; CHECK IF (A) IS ASCII LETTER A-Z
00D7FB  1               ;
00D7FB  1               ; RETURN CARRY = 1 IF A-Z
00D7FB  1               ;	= 0 IF NOT
00D7FB  1               ; ----------------------------------------------------------------------------
00D7FB  1               ISLETC:
00D7FB  1  C9 41                cmp     #$41
00D7FD  1  90 05                bcc     L2F3C
00D7FF  1  E9 5B                sbc     #$5B
00D801  1  38                   sec
00D802  1  E9 A5                sbc     #$A5
00D804  1               L2F3C:
00D804  1  60                   rts
00D805  1               ; ----------------------------------------------------------------------------
00D805  1               ; VARIABLE NOT FOUND, SO MAKE ONE
00D805  1               ; ----------------------------------------------------------------------------
00D805  1               NAMENOTFOUND:
00D805  1  68                   pla
00D806  1  48                   pha
00D807  1  C9 94                cmp     #<FRM_VARIABLE_CALL
00D809  1  D0 07                bne     MAKENEWVARIABLE
00D80B  1  A9 10                lda     #<C_ZERO
00D80D  1  A0 D8                ldy     #>C_ZERO
00D80F  1  60                   rts
00D810  1               ; ----------------------------------------------------------------------------
00D810  1               C_ZERO:
00D810  1  00 00                .byte   $00,$00
00D812  1               ; ----------------------------------------------------------------------------
00D812  1               ; MAKE A NEW SIMPLE VARIABLE
00D812  1               ;
00D812  1               ; MOVE ARRAYS UP 7 BYTES TO MAKE ROOM FOR NEW VARIABLE
00D812  1               ; ENTER 7-BYTE VARIABLE DATA IN THE HOLE
00D812  1               ; ----------------------------------------------------------------------------
00D812  1               MAKENEWVARIABLE:
00D812  1  A5 7D                lda     ARYTAB
00D814  1  A4 7E                ldy     ARYTAB+1
00D816  1  85 AA                sta     LOWTR
00D818  1  84 AB                sty     LOWTR+1
00D81A  1  A5 7F                lda     STREND
00D81C  1  A4 80                ldy     STREND+1
00D81E  1  85 A6                sta     HIGHTR
00D820  1  84 A7                sty     HIGHTR+1
00D822  1  18                   clc
00D823  1  69 06                adc     #BYTES_PER_VARIABLE
00D825  1  90 01                bcc     L2F68
00D827  1  C8                   iny
00D828  1               L2F68:
00D828  1  85 A4                sta     HIGHDS
00D82A  1  84 A5                sty     HIGHDS+1
00D82C  1  20 55 CC             jsr     BLTU
00D82F  1  A5 A4                lda     HIGHDS
00D831  1  A4 A5                ldy     HIGHDS+1
00D833  1  C8                   iny
00D834  1  85 7D                sta     ARYTAB
00D836  1  84 7E                sty     ARYTAB+1
00D838  1  A0 00                ldy     #$00
00D83A  1  A5 93                lda     VARNAM
00D83C  1  91 AA                sta     (LOWTR),y
00D83E  1  C8                   iny
00D83F  1  A5 94                lda     VARNAM+1
00D841  1  91 AA                sta     (LOWTR),y
00D843  1  A9 00                lda     #$00
00D845  1  C8                   iny
00D846  1  91 AA                sta     (LOWTR),y
00D848  1  C8                   iny
00D849  1  91 AA                sta     (LOWTR),y
00D84B  1  C8                   iny
00D84C  1  91 AA                sta     (LOWTR),y
00D84E  1  C8                   iny
00D84F  1  91 AA                sta     (LOWTR),y
00D851  1               ; ----------------------------------------------------------------------------
00D851  1               ; PUT ADDRESS OF VALUE OF VARIABLE IN VARPNT AND Y,A
00D851  1               ; ----------------------------------------------------------------------------
00D851  1               SET_VARPNT_AND_YA:
00D851  1  A5 AA                lda     LOWTR
00D853  1  18                   clc
00D854  1  69 02                adc     #$02
00D856  1  A4 AB                ldy     LOWTR+1
00D858  1  90 01                bcc     L2F9E
00D85A  1  C8                   iny
00D85B  1               L2F9E:
00D85B  1  85 95                sta     VARPNT
00D85D  1  84 96                sty     VARPNT+1
00D85F  1  60                   rts
00D860  1               ; ----------------------------------------------------------------------------
00D860  1               ; COMPUTE ADDRESS OF FIRST VALUE IN ARRAY
00D860  1               ; ARYPNT = (LOWTR) + #DIMS*2 + 5
00D860  1               ; ----------------------------------------------------------------------------
00D860  1               GETARY:
00D860  1  A5 5D                lda     EOLPNTR
00D862  1  0A                   asl     a
00D863  1  69 05                adc     #$05
00D865  1  65 AA                adc     LOWTR
00D867  1  A4 AB                ldy     LOWTR+1
00D869  1  90 01                bcc     L2FAF
00D86B  1  C8                   iny
00D86C  1               L2FAF:
00D86C  1  85 A4                sta     HIGHDS
00D86E  1  84 A5                sty     HIGHDS+1
00D870  1  60                   rts
00D871  1               ; ----------------------------------------------------------------------------
00D871  1               NEG32768:
00D871  1  90 80 00 00          .byte   $90,$80,$00,$00
00D875  1               ; ----------------------------------------------------------------------------
00D875  1               ; EVALUATE NUMERIC FORMULA AT TXTPTR
00D875  1               ; CONVERTING RESULT TO INTEGER 0 <= X <= 32767
00D875  1               ; IN FAC+3,4
00D875  1               ; ----------------------------------------------------------------------------
00D875  1               MAKINT:
00D875  1  20 D6 00             jsr     CHRGET
00D878  1  20 27 D5             jsr     FRMNUM
00D87B  1               ; ----------------------------------------------------------------------------
00D87B  1               ; CONVERT FAC TO INTEGER
00D87B  1               ; MUST BE POSITIVE AND LESS THAN 32768
00D87B  1               ; ----------------------------------------------------------------------------
00D87B  1               MKINT:
00D87B  1  A5 B0                lda     FACSIGN
00D87D  1  30 0D                bmi     MI1
00D87F  1               ; ----------------------------------------------------------------------------
00D87F  1               ; CONVERT FAC TO INTEGER
00D87F  1               ; MUST BE -32767 <= FAC <= 32767
00D87F  1               ; ----------------------------------------------------------------------------
00D87F  1               AYINT:
00D87F  1  A5 AC                lda     FAC
00D881  1  C9 90                cmp     #$90
00D883  1  90 09                bcc     MI2
00D885  1  A9 71                lda     #<NEG32768
00D887  1  A0 D8                ldy     #>NEG32768
00D889  1  20 72 E2             jsr     FCOMP
00D88C  1               MI1:
00D88C  1  D0 74                bne     IQERR
00D88E  1               MI2:
00D88E  1  4C AB E2             jmp     QINT
00D891  1               ; ----------------------------------------------------------------------------
00D891  1               ; LOCATE ARRAY ELEMENT OR CREATE AN ARRAY
00D891  1               ; ----------------------------------------------------------------------------
00D891  1               ARRAY:
00D891  1  A5 5E                lda     DIMFLG
00D893  1  48                   pha
00D894  1  A5 5F                lda     VALTYP
00D896  1  48                   pha
00D897  1  A0 00                ldy     #$00
00D899  1               L2FDE:
00D899  1  98                   tya
00D89A  1  48                   pha
00D89B  1  A5 94                lda     VARNAM+1
00D89D  1  48                   pha
00D89E  1  A5 93                lda     VARNAM
00D8A0  1  48                   pha
00D8A1  1  20 75 D8             jsr     MAKINT
00D8A4  1  68                   pla
00D8A5  1  85 93                sta     VARNAM
00D8A7  1  68                   pla
00D8A8  1  85 94                sta     VARNAM+1
00D8AA  1  68                   pla
00D8AB  1  A8                   tay
00D8AC  1  BA                   tsx
00D8AD  1  BD 02 01             lda     STACK+2,x
00D8B0  1  48                   pha
00D8B1  1  BD 01 01             lda     STACK+1,x
00D8B4  1  48                   pha
00D8B5  1  A5 AE                lda     FAC_LAST-1
00D8B7  1  9D 02 01             sta     STACK+2,x
00D8BA  1  A5 AF                lda     FAC_LAST
00D8BC  1  9D 01 01             sta     STACK+1,x
00D8BF  1  C8                   iny
00D8C0  1  20 DC 00             jsr     CHRGOT
00D8C3  1  C9 2C                cmp     #$2C
00D8C5  1  F0 D2                beq     L2FDE
00D8C7  1  84 5D                sty     EOLPNTR
00D8C9  1  20 75 D6             jsr     CHKCLS
00D8CC  1  68                   pla
00D8CD  1  85 5F                sta     VALTYP
00D8CF  1  68                   pla
00D8D0  1  85 5E                sta     DIMFLG
00D8D2  1               ; ----------------------------------------------------------------------------
00D8D2  1               ; SEARCH ARRAY TABLE FOR THIS ARRAY NAME
00D8D2  1               ; ----------------------------------------------------------------------------
00D8D2  1  A6 7D                ldx     ARYTAB
00D8D4  1  A5 7E                lda     ARYTAB+1
00D8D6  1               L301F:
00D8D6  1  86 AA                stx     LOWTR
00D8D8  1  85 AB                sta     LOWTR+1
00D8DA  1  C5 80                cmp     STREND+1
00D8DC  1  D0 04                bne     L302B
00D8DE  1  E4 7F                cpx     STREND
00D8E0  1  F0 39                beq     MAKE_NEW_ARRAY
00D8E2  1               L302B:
00D8E2  1  A0 00                ldy     #$00
00D8E4  1  B1 AA                lda     (LOWTR),y
00D8E6  1  C8                   iny
00D8E7  1  C5 93                cmp     VARNAM
00D8E9  1  D0 06                bne     L303A
00D8EB  1  A5 94                lda     VARNAM+1
00D8ED  1  D1 AA                cmp     (LOWTR),y
00D8EF  1  F0 16                beq     USE_OLD_ARRAY
00D8F1  1               L303A:
00D8F1  1  C8                   iny
00D8F2  1  B1 AA                lda     (LOWTR),y
00D8F4  1  18                   clc
00D8F5  1  65 AA                adc     LOWTR
00D8F7  1  AA                   tax
00D8F8  1  C8                   iny
00D8F9  1  B1 AA                lda     (LOWTR),y
00D8FB  1  65 AB                adc     LOWTR+1
00D8FD  1  90 D7                bcc     L301F
00D8FF  1               ; ----------------------------------------------------------------------------
00D8FF  1               ; ERROR:  BAD SUBSCRIPTS
00D8FF  1               ; ----------------------------------------------------------------------------
00D8FF  1               SUBERR:
00D8FF  1  A2 10                ldx     #ERR_BADSUBS
00D901  1  2C                   .byte   $2C
00D902  1               ; ----------------------------------------------------------------------------
00D902  1               ; ERROR:  ILLEGAL QUANTITY
00D902  1               ; ----------------------------------------------------------------------------
00D902  1               IQERR:
00D902  1  A2 08                ldx     #ERR_ILLQTY
00D904  1               JER:
00D904  1  4C D4 CC             jmp     ERROR
00D907  1               ; ----------------------------------------------------------------------------
00D907  1               ; FOUND THE ARRAY
00D907  1               ; ----------------------------------------------------------------------------
00D907  1               USE_OLD_ARRAY:
00D907  1  A2 12                ldx     #ERR_REDIMD
00D909  1  A5 5E                lda     DIMFLG
00D90B  1  D0 F7                bne     JER
00D90D  1  20 60 D8             jsr     GETARY
00D910  1  A5 5D                lda     EOLPNTR
00D912  1  A0 04                ldy     #$04
00D914  1  D1 AA                cmp     (LOWTR),y
00D916  1  D0 E7                bne     SUBERR
00D918  1  4C 9E D9             jmp     FIND_ARRAY_ELEMENT
00D91B  1               ; ----------------------------------------------------------------------------
00D91B  1               ; CREATE A NEW ARRAY, UNLESS CALLED FROM GETARYPT
00D91B  1               ; ----------------------------------------------------------------------------
00D91B  1               MAKE_NEW_ARRAY:
00D91B  1  20 60 D8             jsr     GETARY
00D91E  1  20 A5 CC             jsr     REASON
00D921  1  A9 00                lda     #$00
00D923  1  A8                   tay
00D924  1  85 BB                sta     STRNG2+1
00D926  1  A2 04                ldx     #BYTES_PER_ELEMENT
00D928  1  86 BA                stx     STRNG2
00D92A  1  A5 93                lda     VARNAM
00D92C  1  91 AA                sta     (LOWTR),y
00D92E  1  C8                   iny
00D92F  1  A5 94                lda     VARNAM+1
00D931  1  91 AA                sta     (LOWTR),y
00D933  1  A5 5D                lda     EOLPNTR
00D935  1  C8                   iny
00D936  1  C8                   iny
00D937  1  C8                   iny
00D938  1  91 AA                sta     (LOWTR),y
00D93A  1               L308A:
00D93A  1  A2 0B                ldx     #$0B
00D93C  1  A9 00                lda     #$00
00D93E  1  24 5E                bit     DIMFLG
00D940  1  50 08                bvc     L309A
00D942  1  68                   pla
00D943  1  18                   clc
00D944  1  69 01                adc     #$01
00D946  1  AA                   tax
00D947  1  68                   pla
00D948  1  69 00                adc     #$00
00D94A  1               L309A:
00D94A  1  C8                   iny
00D94B  1  91 AA                sta     (LOWTR),y
00D94D  1  C8                   iny
00D94E  1  8A                   txa
00D94F  1  91 AA                sta     (LOWTR),y
00D951  1  20 F6 D9             jsr     MULTIPLY_SUBSCRIPT
00D954  1  86 BA                stx     STRNG2
00D956  1  85 BB                sta     STRNG2+1
00D958  1  A4 71                ldy     INDEX
00D95A  1  C6 5D                dec     EOLPNTR
00D95C  1  D0 DC                bne     L308A
00D95E  1  65 A5                adc     HIGHDS+1
00D960  1  B0 5D                bcs     GME
00D962  1  85 A5                sta     HIGHDS+1
00D964  1  A8                   tay
00D965  1  8A                   txa
00D966  1  65 A4                adc     HIGHDS
00D968  1  90 03                bcc     L30BD
00D96A  1  C8                   iny
00D96B  1  F0 52                beq     GME
00D96D  1               L30BD:
00D96D  1  20 A5 CC             jsr     REASON
00D970  1  85 7F                sta     STREND
00D972  1  84 80                sty     STREND+1
00D974  1  A9 00                lda     #$00
00D976  1  E6 BB                inc     STRNG2+1
00D978  1  A4 BA                ldy     STRNG2
00D97A  1  F0 05                beq     L30D1
00D97C  1               L30CC:
00D97C  1  88                   dey
00D97D  1  91 A4                sta     (HIGHDS),y
00D97F  1  D0 FB                bne     L30CC
00D981  1               L30D1:
00D981  1  C6 A5                dec     HIGHDS+1
00D983  1  C6 BB                dec     STRNG2+1
00D985  1  D0 F5                bne     L30CC
00D987  1  E6 A5                inc     HIGHDS+1
00D989  1  38                   sec
00D98A  1  A5 7F                lda     STREND
00D98C  1  E5 AA                sbc     LOWTR
00D98E  1  A0 02                ldy     #$02
00D990  1  91 AA                sta     (LOWTR),y
00D992  1  A5 80                lda     STREND+1
00D994  1  C8                   iny
00D995  1  E5 AB                sbc     LOWTR+1
00D997  1  91 AA                sta     (LOWTR),y
00D999  1  A5 5E                lda     DIMFLG
00D99B  1  D0 58                bne     RTS9
00D99D  1  C8                   iny
00D99E  1               ; ----------------------------------------------------------------------------
00D99E  1               ; FIND SPECIFIED ARRAY ELEMENT
00D99E  1               ;
00D99E  1               ; (LOWTR),Y POINTS AT # OF DIMS IN ARRAY DESCRIPTOR
00D99E  1               ; THE SUBSCRIPTS ARE ALL ON THE STACK AS INTEGERS
00D99E  1               ; ----------------------------------------------------------------------------
00D99E  1               FIND_ARRAY_ELEMENT:
00D99E  1  B1 AA                lda     (LOWTR),y
00D9A0  1  85 5D                sta     EOLPNTR
00D9A2  1  A9 00                lda     #$00
00D9A4  1  85 BA                sta     STRNG2
00D9A6  1               L30F6:
00D9A6  1  85 BB                sta     STRNG2+1
00D9A8  1  C8                   iny
00D9A9  1  68                   pla
00D9AA  1  AA                   tax
00D9AB  1  85 AE                sta     FAC_LAST-1
00D9AD  1  68                   pla
00D9AE  1  85 AF                sta     FAC_LAST
00D9B0  1  D1 AA                cmp     (LOWTR),y
00D9B2  1  90 0E                bcc     FAE2
00D9B4  1  D0 06                bne     GSE
00D9B6  1  C8                   iny
00D9B7  1  8A                   txa
00D9B8  1  D1 AA                cmp     (LOWTR),y
00D9BA  1  90 07                bcc     FAE3
00D9BC  1               ; ----------------------------------------------------------------------------
00D9BC  1               GSE:
00D9BC  1  4C FF D8             jmp     SUBERR
00D9BF  1               GME:
00D9BF  1  4C D2 CC             jmp     MEMERR
00D9C2  1               ; ----------------------------------------------------------------------------
00D9C2  1               FAE2:
00D9C2  1  C8                   iny
00D9C3  1               FAE3:
00D9C3  1  A5 BB                lda     STRNG2+1
00D9C5  1  05 BA                ora     STRNG2
00D9C7  1  18                   clc
00D9C8  1  F0 0A                beq     L3124
00D9CA  1  20 F6 D9             jsr     MULTIPLY_SUBSCRIPT
00D9CD  1  8A                   txa
00D9CE  1  65 AE                adc     FAC_LAST-1
00D9D0  1  AA                   tax
00D9D1  1  98                   tya
00D9D2  1  A4 71                ldy     INDEX
00D9D4  1               L3124:
00D9D4  1  65 AF                adc     FAC_LAST
00D9D6  1  86 BA                stx     STRNG2
00D9D8  1  C6 5D                dec     EOLPNTR
00D9DA  1  D0 CA                bne     L30F6
00D9DC  1  06 BA                asl     STRNG2
00D9DE  1  2A                   rol     a
00D9DF  1  B0 DB                bcs     GSE
00D9E1  1  06 BA                asl     STRNG2
00D9E3  1  2A                   rol     a
00D9E4  1  B0 D6                bcs     GSE
00D9E6  1  A8                   tay
00D9E7  1  A5 BA                lda     STRNG2
00D9E9  1  65 A4                adc     HIGHDS
00D9EB  1  85 95                sta     VARPNT
00D9ED  1  98                   tya
00D9EE  1  65 A5                adc     HIGHDS+1
00D9F0  1  85 96                sta     VARPNT+1
00D9F2  1  A8                   tay
00D9F3  1  A5 95                lda     VARPNT
00D9F5  1               RTS9:
00D9F5  1  60                   rts
00D9F6  1               ; ----------------------------------------------------------------------------
00D9F6  1               ; MULTIPLY (STRNG2) BY ((LOWTR),Y)
00D9F6  1               ; LEAVING PRODUCT IN A,X.  (HI-BYTE ALSO IN Y.)
00D9F6  1               ; USED ONLY BY ARRAY SUBSCRIPT ROUTINES
00D9F6  1               ; ----------------------------------------------------------------------------
00D9F6  1               MULTIPLY_SUBSCRIPT:
00D9F6  1  84 71                sty     INDEX
00D9F8  1  B1 AA                lda     (LOWTR),y
00D9FA  1  85 76                sta     RESULT_LAST-2
00D9FC  1  88                   dey
00D9FD  1  B1 AA                lda     (LOWTR),y
00D9FF  1  85 77                sta     RESULT_LAST-1
00DA01  1  A9 10                lda     #$10
00DA03  1  85 A8                sta     INDX
00DA05  1  A2 00                ldx     #$00
00DA07  1  A0 00                ldy     #$00
00DA09  1               L3163:
00DA09  1  8A                   txa
00DA0A  1  0A                   asl     a
00DA0B  1  AA                   tax
00DA0C  1  98                   tya
00DA0D  1  2A                   rol     a
00DA0E  1  A8                   tay
00DA0F  1  B0 AE                bcs     GME
00DA11  1  06 BA                asl     STRNG2
00DA13  1  26 BB                rol     STRNG2+1
00DA15  1  90 0B                bcc     L317C
00DA17  1  18                   clc
00DA18  1  8A                   txa
00DA19  1  65 76                adc     RESULT_LAST-2
00DA1B  1  AA                   tax
00DA1C  1  98                   tya
00DA1D  1  65 77                adc     RESULT_LAST-1
00DA1F  1  A8                   tay
00DA20  1  B0 9D                bcs     GME
00DA22  1               L317C:
00DA22  1  C6 A8                dec     INDX
00DA24  1  D0 E3                bne     L3163
00DA26  1  60                   rts
00DA27  1               ; ----------------------------------------------------------------------------
00DA27  1               ; "FRE" FUNCTION
00DA27  1               ;
00DA27  1               ; COLLECTS GARBAGE AND RETURNS # BYTES OF MEMORY LEFT
00DA27  1               ; ----------------------------------------------------------------------------
00DA27  1               FRE:
00DA27  1  A5 5F                lda     VALTYP
00DA29  1  F0 03                beq     L3188
00DA2B  1  20 30 DD             jsr     FREFAC
00DA2E  1               L3188:
00DA2E  1  20 C1 DB             jsr     GARBAG
00DA31  1  38                   sec
00DA32  1  A5 81                lda     FRETOP
00DA34  1  E5 7F                sbc     STREND
00DA36  1  A8                   tay
00DA37  1  A5 82                lda     FRETOP+1
00DA39  1  E5 80                sbc     STREND+1
00DA3B  1               ; FALL INTO GIVAYF TO FLOAT THE VALUE
00DA3B  1               ; NOTE THAT VALUES OVER 32767 WILL RETURN AS NEGATIVE
00DA3B  1               ; ----------------------------------------------------------------------------
00DA3B  1               ; FLOAT THE SIGNED INTEGER IN A,Y
00DA3B  1               ; ----------------------------------------------------------------------------
00DA3B  1               GIVAYF:
00DA3B  1  A2 00                ldx     #$00
00DA3D  1  86 5F                stx     VALTYP
00DA3F  1  85 AD                sta     FAC+1
00DA41  1  84 AE                sty     FAC+2
00DA43  1  A2 90                ldx     #$90
00DA45  1  4C 5D E2             jmp     FLOAT1
00DA48  1               POS:
00DA48  1  A4 0E                ldy     POSX
00DA4A  1               ; ----------------------------------------------------------------------------
00DA4A  1               ; FLOAT (Y) INTO FAC, GIVING VALUE 0-255
00DA4A  1               ; ----------------------------------------------------------------------------
00DA4A  1               SNGFLT:
00DA4A  1  A9 00                lda     #$00
00DA4C  1  F0 ED                beq     GIVAYF
00DA4E  1               ; ----------------------------------------------------------------------------
00DA4E  1               ; CHECK FOR DIRECT OR RUNNING MODE
00DA4E  1               ; GIVING ERROR IF DIRECT MODE
00DA4E  1               ; ----------------------------------------------------------------------------
00DA4E  1               ERRDIR:
00DA4E  1  A6 88                ldx     CURLIN+1
00DA50  1  E8                   inx
00DA51  1  D0 A2                bne     RTS9
00DA53  1  A2 16                ldx     #ERR_ILLDIR
00DA55  1               L31AF:
00DA55  1  4C D4 CC             jmp     ERROR
00DA58  1               DEF:
00DA58  1  20 85 DA             jsr     FNC
00DA5B  1  20 4E DA             jsr     ERRDIR
00DA5E  1  20 78 D6             jsr     CHKOPN
00DA61  1  A9 80                lda     #$80
00DA63  1  85 61                sta     SUBFLG
00DA65  1  20 85 D7             jsr     PTRGET
00DA68  1  20 2A D5             jsr     CHKNUM
00DA6B  1  20 75 D6             jsr     CHKCLS
00DA6E  1  A9 AB                lda     #TOKEN_EQUAL
00DA70  1  20 7D D6             jsr     SYNCHR
00DA73  1  A5 96                lda     VARPNT+1
00DA75  1  48                   pha
00DA76  1  A5 95                lda     VARPNT
00DA78  1  48                   pha
00DA79  1  A5 DE                lda     TXTPTR+1
00DA7B  1  48                   pha
00DA7C  1  A5 DD                lda     TXTPTR
00DA7E  1  48                   pha
00DA7F  1  20 86 D1             jsr     DATA
00DA82  1  4C F4 DA             jmp     L3250
00DA85  1               FNC:
00DA85  1  A9 9E                lda     #TOKEN_FN
00DA87  1  20 7D D6             jsr     SYNCHR
00DA8A  1  09 80                ora     #$80
00DA8C  1  85 61                sta     SUBFLG
00DA8E  1  20 8C D7             jsr     PTRGET3
00DA91  1  85 9C                sta     FNCNAM
00DA93  1  84 9D                sty     FNCNAM+1
00DA95  1  4C 2A D5             jmp     CHKNUM
00DA98  1               L31F3:
00DA98  1  20 85 DA             jsr     FNC
00DA9B  1  A5 9D                lda     FNCNAM+1
00DA9D  1  48                   pha
00DA9E  1  A5 9C                lda     FNCNAM
00DAA0  1  48                   pha
00DAA1  1  20 6F D6             jsr     PARCHK
00DAA4  1  20 2A D5             jsr     CHKNUM
00DAA7  1  68                   pla
00DAA8  1  85 9C                sta     FNCNAM
00DAAA  1  68                   pla
00DAAB  1  85 9D                sta     FNCNAM+1
00DAAD  1  A0 02                ldy     #$02
00DAAF  1  A2 20                ldx     #ERR_UNDEFFN
00DAB1  1  B1 9C                lda     (FNCNAM),y
00DAB3  1  F0 A0                beq     L31AF
00DAB5  1  85 95                sta     VARPNT
00DAB7  1  AA                   tax
00DAB8  1  C8                   iny
00DAB9  1  B1 9C                lda     (FNCNAM),y
00DABB  1  85 96                sta     VARPNT+1
00DABD  1               L3219:
00DABD  1  B1 95                lda     (VARPNT),y
00DABF  1  48                   pha
00DAC0  1  88                   dey
00DAC1  1  10 FA                bpl     L3219
00DAC3  1  A4 96                ldy     VARPNT+1
00DAC5  1  20 F2 E1             jsr     STORE_FAC_AT_YX_ROUNDED
00DAC8  1  A5 DE                lda     TXTPTR+1
00DACA  1  48                   pha
00DACB  1  A5 DD                lda     TXTPTR
00DACD  1  48                   pha
00DACE  1  B1 9C                lda     (FNCNAM),y
00DAD0  1  85 DD                sta     TXTPTR
00DAD2  1  C8                   iny
00DAD3  1  B1 9C                lda     (FNCNAM),y
00DAD5  1  85 DE                sta     TXTPTR+1
00DAD7  1  A5 96                lda     VARPNT+1
00DAD9  1  48                   pha
00DADA  1  A5 95                lda     VARPNT
00DADC  1  48                   pha
00DADD  1  20 27 D5             jsr     FRMNUM
00DAE0  1  68                   pla
00DAE1  1  85 9C                sta     FNCNAM
00DAE3  1  68                   pla
00DAE4  1  85 9D                sta     FNCNAM+1
00DAE6  1  20 DC 00             jsr     CHRGOT
00DAE9  1  F0 03                beq     L324A
00DAEB  1  4C 86 D6             jmp     SYNERR
00DAEE  1               L324A:
00DAEE  1  68                   pla
00DAEF  1  85 DD                sta     TXTPTR
00DAF1  1  68                   pla
00DAF2  1  85 DE                sta     TXTPTR+1
00DAF4  1               L3250:
00DAF4  1  A0 00                ldy     #$00
00DAF6  1  68                   pla
00DAF7  1  91 9C                sta     (FNCNAM),y
00DAF9  1  68                   pla
00DAFA  1  C8                   iny
00DAFB  1  91 9C                sta     (FNCNAM),y
00DAFD  1  68                   pla
00DAFE  1  C8                   iny
00DAFF  1  91 9C                sta     (FNCNAM),y
00DB01  1  68                   pla
00DB02  1  C8                   iny
00DB03  1  91 9C                sta     (FNCNAM),y
00DB05  1  60                   rts
00DB06  1               ; ----------------------------------------------------------------------------
00DB06  1               ; "STR$" FUNCTION
00DB06  1               ; ----------------------------------------------------------------------------
00DB06  1               STR:
00DB06  1  20 2A D5             jsr     CHKNUM
00DB09  1  A0 00                ldy     #$00
00DB0B  1  20 EA E3             jsr     FOUT1
00DB0E  1  68                   pla
00DB0F  1  68                   pla
00DB10  1  A9 FF                lda     #$FF
00DB12  1  A0 00                ldy     #$00
00DB14  1  F0 12                beq     STRLIT
00DB16  1               ; ----------------------------------------------------------------------------
00DB16  1               ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
00DB16  1               ; ADDRESS IS IN FAC+3,4 AND WHOSE LENGTH IS IN A-REG
00DB16  1               ; ----------------------------------------------------------------------------
00DB16  1               STRINI:
00DB16  1  A6 AE                ldx     FAC_LAST-1
00DB18  1  A4 AF                ldy     FAC_LAST
00DB1A  1  86 9E                stx     DSCPTR
00DB1C  1  84 9F                sty     DSCPTR+1
00DB1E  1               ; ----------------------------------------------------------------------------
00DB1E  1               ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
00DB1E  1               ; ADDRESS IS IN Y,X AND WHOSE LENGTH IS IN A-REG
00DB1E  1               ; ----------------------------------------------------------------------------
00DB1E  1               STRSPA:
00DB1E  1  20 8F DB             jsr     GETSPA
00DB21  1  86 AD                stx     FAC+1
00DB23  1  84 AE                sty     FAC+2
00DB25  1  85 AC                sta     FAC
00DB27  1  60                   rts
00DB28  1               ; ----------------------------------------------------------------------------
00DB28  1               ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
00DB28  1               ; AND TERMINATED BY $00 OR QUOTATION MARK
00DB28  1               ; RETURN WITH DESCRIPTOR IN A TEMPORARY
00DB28  1               ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
00DB28  1               ; ----------------------------------------------------------------------------
00DB28  1               STRLIT:
00DB28  1  A2 22                ldx     #$22
00DB2A  1  86 5B                stx     CHARAC
00DB2C  1  86 5C                stx     ENDCHR
00DB2E  1               ; ----------------------------------------------------------------------------
00DB2E  1               ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
00DB2E  1               ; AND TERMINATED BY $00, (CHARAC), OR (ENDCHR)
00DB2E  1               ;
00DB2E  1               ; RETURN WITH DESCRIPTOR IN A TEMPORARY
00DB2E  1               ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
00DB2E  1               ; ----------------------------------------------------------------------------
00DB2E  1               STRLT2:
00DB2E  1  85 B8                sta     STRNG1
00DB30  1  84 B9                sty     STRNG1+1
00DB32  1  85 AD                sta     FAC+1
00DB34  1  84 AE                sty     FAC+2
00DB36  1  A0 FF                ldy     #$FF
00DB38  1               L3298:
00DB38  1  C8                   iny
00DB39  1  B1 B8                lda     (STRNG1),y
00DB3B  1  F0 0C                beq     L32A9
00DB3D  1  C5 5B                cmp     CHARAC
00DB3F  1  F0 04                beq     L32A5
00DB41  1  C5 5C                cmp     ENDCHR
00DB43  1  D0 F3                bne     L3298
00DB45  1               L32A5:
00DB45  1  C9 22                cmp     #$22
00DB47  1  F0 01                beq     L32AA
00DB49  1               L32A9:
00DB49  1  18                   clc
00DB4A  1               L32AA:
00DB4A  1  84 AC                sty     FAC
00DB4C  1  98                   tya
00DB4D  1  65 B8                adc     STRNG1
00DB4F  1  85 BA                sta     STRNG2
00DB51  1  A6 B9                ldx     STRNG1+1
00DB53  1  90 01                bcc     L32B6
00DB55  1  E8                   inx
00DB56  1               L32B6:
00DB56  1  86 BB                stx     STRNG2+1
00DB58  1  A5 B9                lda     STRNG1+1
00DB5A  1  D0 0B                bne     PUTNEW
00DB5C  1  98                   tya
00DB5D  1  20 16 DB             jsr     STRINI
00DB60  1  A6 B8                ldx     STRNG1
00DB62  1  A4 B9                ldy     STRNG1+1
00DB64  1  20 12 DD             jsr     MOVSTR
00DB67  1               ; ----------------------------------------------------------------------------
00DB67  1               ; STORE DESCRIPTOR IN TEMPORARY DESCRIPTOR STACK
00DB67  1               ;
00DB67  1               ; THE DESCRIPTOR IS NOW IN FAC, FAC+1, FAC+2
00DB67  1               ; PUT ADDRESS OF TEMP DESCRIPTOR IN FAC+3,4
00DB67  1               ; ----------------------------------------------------------------------------
00DB67  1               PUTNEW:
00DB67  1  A6 65                ldx     TEMPPT
00DB69  1  E0 71                cpx     #TEMPST+9
00DB6B  1  D0 05                bne     PUTEMP
00DB6D  1  A2 1C                ldx     #ERR_FRMCPX
00DB6F  1               JERR:
00DB6F  1  4C D4 CC             jmp     ERROR
00DB72  1               PUTEMP:
00DB72  1  A5 AC                lda     FAC
00DB74  1  95 00                sta     0,x
00DB76  1  A5 AD                lda     FAC+1
00DB78  1  95 01                sta     1,x
00DB7A  1  A5 AE                lda     FAC+2
00DB7C  1  95 02                sta     2,x
00DB7E  1  A0 00                ldy     #$00
00DB80  1  86 AE                stx     FAC_LAST-1
00DB82  1  84 AF                sty     FAC_LAST
00DB84  1  88                   dey
00DB85  1  84 5F                sty     VALTYP
00DB87  1  86 66                stx     LASTPT
00DB89  1  E8                   inx
00DB8A  1  E8                   inx
00DB8B  1  E8                   inx
00DB8C  1  86 65                stx     TEMPPT
00DB8E  1  60                   rts
00DB8F  1               ; ----------------------------------------------------------------------------
00DB8F  1               ; MAKE SPACE FOR STRING AT BOTTOM OF STRING SPACE
00DB8F  1               ; (A)=# BYTES SPACE TO MAKE
00DB8F  1               ;
00DB8F  1               ; RETURN WITH (A) SAME,
00DB8F  1               ;	AND Y,X = ADDRESS OF SPACE ALLOCATED
00DB8F  1               ; ----------------------------------------------------------------------------
00DB8F  1               GETSPA:
00DB8F  1  46 60                lsr     DATAFLG
00DB91  1               L32F1:
00DB91  1  48                   pha
00DB92  1  49 FF                eor     #$FF
00DB94  1  38                   sec
00DB95  1  65 81                adc     FRETOP
00DB97  1  A4 82                ldy     FRETOP+1
00DB99  1  B0 01                bcs     L32FC
00DB9B  1  88                   dey
00DB9C  1               L32FC:
00DB9C  1  C4 80                cpy     STREND+1
00DB9E  1  90 11                bcc     L3311
00DBA0  1  D0 04                bne     L3306
00DBA2  1  C5 7F                cmp     STREND
00DBA4  1  90 0B                bcc     L3311
00DBA6  1               L3306:
00DBA6  1  85 81                sta     FRETOP
00DBA8  1  84 82                sty     FRETOP+1
00DBAA  1  85 83                sta     FRESPC
00DBAC  1  84 84                sty     FRESPC+1
00DBAE  1  AA                   tax
00DBAF  1  68                   pla
00DBB0  1  60                   rts
00DBB1  1               L3311:
00DBB1  1  A2 0C                ldx     #ERR_MEMFULL
00DBB3  1  A5 60                lda     DATAFLG
00DBB5  1  30 B8                bmi     JERR
00DBB7  1  20 C1 DB             jsr     GARBAG
00DBBA  1  A9 80                lda     #$80
00DBBC  1  85 60                sta     DATAFLG
00DBBE  1  68                   pla
00DBBF  1  D0 D0                bne     L32F1
00DBC1  1               ; ----------------------------------------------------------------------------
00DBC1  1               ; SHOVE ALL REFERENCED STRINGS AS HIGH AS POSSIBLE
00DBC1  1               ; IN MEMORY (AGAINST HIMEM), FREEING UP SPACE
00DBC1  1               ; BELOW STRING AREA DOWN TO STREND.
00DBC1  1               ; ----------------------------------------------------------------------------
00DBC1  1               GARBAG:
00DBC1  1  A6 85                ldx     MEMSIZ
00DBC3  1  A5 86                lda     MEMSIZ+1
00DBC5  1               FINDHIGHESTSTRING:
00DBC5  1  86 81                stx     FRETOP
00DBC7  1  85 82                sta     FRETOP+1
00DBC9  1  A0 00                ldy     #$00
00DBCB  1  84 9D                sty     FNCNAM+1
00DBCD  1  A5 7F                lda     STREND
00DBCF  1  A6 80                ldx     STREND+1
00DBD1  1  85 AA                sta     LOWTR
00DBD3  1  86 AB                stx     LOWTR+1
00DBD5  1  A9 68                lda     #TEMPST
00DBD7  1  A2 00                ldx     #$00
00DBD9  1  85 71                sta     INDEX
00DBDB  1  86 72                stx     INDEX+1
00DBDD  1               L333D:
00DBDD  1  C5 65                cmp     TEMPPT
00DBDF  1  F0 05                beq     L3346
00DBE1  1  20 53 DC             jsr     CHECK_VARIABLE
00DBE4  1  F0 F7                beq     L333D
00DBE6  1               L3346:
00DBE6  1  A9 06                lda     #BYTES_PER_VARIABLE
00DBE8  1  85 A0                sta     DSCLEN
00DBEA  1  A5 7B                lda     VARTAB
00DBEC  1  A6 7C                ldx     VARTAB+1
00DBEE  1  85 71                sta     INDEX
00DBF0  1  86 72                stx     INDEX+1
00DBF2  1               L3352:
00DBF2  1  E4 7E                cpx     ARYTAB+1
00DBF4  1  D0 04                bne     L335A
00DBF6  1  C5 7D                cmp     ARYTAB
00DBF8  1  F0 05                beq     L335F
00DBFA  1               L335A:
00DBFA  1  20 4D DC             jsr     CHECK_SIMPLE_VARIABLE
00DBFD  1  F0 F3                beq     L3352
00DBFF  1               L335F:
00DBFF  1  85 A4                sta     HIGHDS
00DC01  1  86 A5                stx     HIGHDS+1
00DC03  1  A9 03                lda     #$03	; OSI GC bugfix -> $04 ???
00DC05  1  85 A0                sta     DSCLEN
00DC07  1               L3367:
00DC07  1  A5 A4                lda     HIGHDS
00DC09  1  A6 A5                ldx     HIGHDS+1
00DC0B  1               L336B:
00DC0B  1  E4 80                cpx     STREND+1
00DC0D  1  D0 07                bne     L3376
00DC0F  1  C5 7F                cmp     STREND
00DC11  1  D0 03                bne     L3376
00DC13  1  4C 92 DC             jmp     MOVE_HIGHEST_STRING_TO_TOP
00DC16  1               L3376:
00DC16  1  85 71                sta     INDEX
00DC18  1  86 72                stx     INDEX+1
00DC1A  1  A0 01                ldy     #$01
00DC1C  1  B1 71                lda     (INDEX),y
00DC1E  1  08                   php
00DC1F  1  C8                   iny
00DC20  1  B1 71                lda     (INDEX),y
00DC22  1  65 A4                adc     HIGHDS
00DC24  1  85 A4                sta     HIGHDS
00DC26  1  C8                   iny
00DC27  1  B1 71                lda     (INDEX),y
00DC29  1  65 A5                adc     HIGHDS+1
00DC2B  1  85 A5                sta     HIGHDS+1
00DC2D  1  28                   plp
00DC2E  1  10 D7                bpl     L3367
00DC30  1  C8                   iny
00DC31  1  B1 71                lda     (INDEX),y
00DC33  1  0A                   asl     a
00DC34  1  69 05                adc     #$05
00DC36  1  65 71                adc     INDEX
00DC38  1  85 71                sta     INDEX
00DC3A  1  90 02                bcc     L33A7
00DC3C  1  E6 72                inc     INDEX+1
00DC3E  1               L33A7:
00DC3E  1  A6 72                ldx     INDEX+1
00DC40  1               L33A9:
00DC40  1  E4 A5                cpx     HIGHDS+1
00DC42  1  D0 04                bne     L33B1
00DC44  1  C5 A4                cmp     HIGHDS
00DC46  1  F0 C3                beq     L336B
00DC48  1               L33B1:
00DC48  1  20 53 DC             jsr     CHECK_VARIABLE
00DC4B  1  F0 F3                beq     L33A9
00DC4D  1               ; ----------------------------------------------------------------------------
00DC4D  1               ; PROCESS A SIMPLE VARIABLE
00DC4D  1               ; ----------------------------------------------------------------------------
00DC4D  1               CHECK_SIMPLE_VARIABLE:
00DC4D  1  C8                   iny
00DC4E  1  B1 71                lda     (INDEX),y
00DC50  1  10 30                bpl     CHECK_BUMP
00DC52  1  C8                   iny
00DC53  1               ; ----------------------------------------------------------------------------
00DC53  1               ; IF STRING IS NOT EMPTY, CHECK IF IT IS HIGHEST
00DC53  1               ; ----------------------------------------------------------------------------
00DC53  1               CHECK_VARIABLE:
00DC53  1  B1 71                lda     (INDEX),y
00DC55  1  F0 2B                beq     CHECK_BUMP
00DC57  1  C8                   iny
00DC58  1  B1 71                lda     (INDEX),y
00DC5A  1  AA                   tax
00DC5B  1  C8                   iny
00DC5C  1  B1 71                lda     (INDEX),y
00DC5E  1  C5 82                cmp     FRETOP+1
00DC60  1  90 06                bcc     L33D5
00DC62  1  D0 1E                bne     CHECK_BUMP
00DC64  1  E4 81                cpx     FRETOP
00DC66  1  B0 1A                bcs     CHECK_BUMP
00DC68  1               L33D5:
00DC68  1  C5 AB                cmp     LOWTR+1
00DC6A  1  90 16                bcc     CHECK_BUMP
00DC6C  1  D0 04                bne     L33DF
00DC6E  1  E4 AA                cpx     LOWTR
00DC70  1  90 10                bcc     CHECK_BUMP
00DC72  1               L33DF:
00DC72  1  86 AA                stx     LOWTR
00DC74  1  85 AB                sta     LOWTR+1
00DC76  1  A5 71                lda     INDEX
00DC78  1  A6 72                ldx     INDEX+1
00DC7A  1  85 9C                sta     FNCNAM
00DC7C  1  86 9D                stx     FNCNAM+1
00DC7E  1  A5 A0                lda     DSCLEN
00DC80  1  85 A2                sta     Z52
00DC82  1               ; ----------------------------------------------------------------------------
00DC82  1               ; ADD (DSCLEN) TO PNTR IN INDEX
00DC82  1               ; RETURN WITH Y=0, PNTR ALSO IN X,A
00DC82  1               ; ----------------------------------------------------------------------------
00DC82  1               CHECK_BUMP:
00DC82  1  A5 A0                lda     DSCLEN
00DC84  1  18                   clc
00DC85  1  65 71                adc     INDEX
00DC87  1  85 71                sta     INDEX
00DC89  1  90 02                bcc     L33FA
00DC8B  1  E6 72                inc     INDEX+1
00DC8D  1               L33FA:
00DC8D  1  A6 72                ldx     INDEX+1
00DC8F  1  A0 00                ldy     #$00
00DC91  1  60                   rts
00DC92  1               ; ----------------------------------------------------------------------------
00DC92  1               ; FOUND HIGHEST NON-EMPTY STRING, SO MOVE IT
00DC92  1               ; TO TOP AND GO BACK FOR ANOTHER
00DC92  1               ; ----------------------------------------------------------------------------
00DC92  1               MOVE_HIGHEST_STRING_TO_TOP:
00DC92  1  A6 9D                ldx     FNCNAM+1
00DC94  1  F0 F7                beq     L33FA
00DC96  1  A5 A2                lda     Z52
00DC98  1  29 04                and     #$04
00DC9A  1  4A                   lsr     a
00DC9B  1  A8                   tay
00DC9C  1  85 A2                sta     Z52
00DC9E  1  B1 9C                lda     (FNCNAM),y
00DCA0  1  65 AA                adc     LOWTR
00DCA2  1  85 A6                sta     HIGHTR
00DCA4  1  A5 AB                lda     LOWTR+1
00DCA6  1  69 00                adc     #$00
00DCA8  1  85 A7                sta     HIGHTR+1
00DCAA  1  A5 81                lda     FRETOP
00DCAC  1  A6 82                ldx     FRETOP+1
00DCAE  1  85 A4                sta     HIGHDS
00DCB0  1  86 A5                stx     HIGHDS+1
00DCB2  1  20 5C CC             jsr     BLTU2
00DCB5  1  A4 A2                ldy     Z52
00DCB7  1  C8                   iny
00DCB8  1  A5 A4                lda     HIGHDS
00DCBA  1  91 9C                sta     (FNCNAM),y
00DCBC  1  AA                   tax
00DCBD  1  E6 A5                inc     HIGHDS+1
00DCBF  1  A5 A5                lda     HIGHDS+1
00DCC1  1  C8                   iny
00DCC2  1  91 9C                sta     (FNCNAM),y
00DCC4  1  4C C5 DB             jmp     FINDHIGHESTSTRING
00DCC7  1               ; ----------------------------------------------------------------------------
00DCC7  1               ; CONCATENATE TWO STRINGS
00DCC7  1               ; ----------------------------------------------------------------------------
00DCC7  1               CAT:
00DCC7  1  A5 AF                lda     FAC_LAST
00DCC9  1  48                   pha
00DCCA  1  A5 AE                lda     FAC_LAST-1
00DCCC  1  48                   pha
00DCCD  1  20 1A D6             jsr     FRM_ELEMENT
00DCD0  1  20 2C D5             jsr     CHKSTR
00DCD3  1  68                   pla
00DCD4  1  85 B8                sta     STRNG1
00DCD6  1  68                   pla
00DCD7  1  85 B9                sta     STRNG1+1
00DCD9  1  A0 00                ldy     #$00
00DCDB  1  B1 B8                lda     (STRNG1),y
00DCDD  1  18                   clc
00DCDE  1  71 AE                adc     (FAC_LAST-1),y
00DCE0  1  90 05                bcc     L3454
00DCE2  1  A2 1A                ldx     #ERR_STRLONG
00DCE4  1  4C D4 CC             jmp     ERROR
00DCE7  1               L3454:
00DCE7  1  20 16 DB             jsr     STRINI
00DCEA  1  20 04 DD             jsr     MOVINS
00DCED  1  A5 9E                lda     DSCPTR
00DCEF  1  A4 9F                ldy     DSCPTR+1
00DCF1  1  20 34 DD             jsr     FRETMP
00DCF4  1  20 16 DD             jsr     MOVSTR1
00DCF7  1  A5 B8                lda     STRNG1
00DCF9  1  A4 B9                ldy     STRNG1+1
00DCFB  1  20 34 DD             jsr     FRETMP
00DCFE  1  20 67 DB             jsr     PUTNEW
00DD01  1  4C 55 D5             jmp     FRMEVL2
00DD04  1               ; ----------------------------------------------------------------------------
00DD04  1               ; GET STRING DESCRIPTOR POINTED AT BY (STRNG1)
00DD04  1               ; AND MOVE DESCRIBED STRING TO (FRESPC)
00DD04  1               ; ----------------------------------------------------------------------------
00DD04  1               MOVINS:
00DD04  1  A0 00                ldy     #$00
00DD06  1  B1 B8                lda     (STRNG1),y
00DD08  1  48                   pha
00DD09  1  C8                   iny
00DD0A  1  B1 B8                lda     (STRNG1),y
00DD0C  1  AA                   tax
00DD0D  1  C8                   iny
00DD0E  1  B1 B8                lda     (STRNG1),y
00DD10  1  A8                   tay
00DD11  1  68                   pla
00DD12  1               ; ----------------------------------------------------------------------------
00DD12  1               ; MOVE STRING AT (Y,X) WITH LENGTH (A)
00DD12  1               ; TO DESTINATION WHOSE ADDRESS IS IN FRESPC,FRESPC+1
00DD12  1               ; ----------------------------------------------------------------------------
00DD12  1               MOVSTR:
00DD12  1  86 71                stx     INDEX
00DD14  1  84 72                sty     INDEX+1
00DD16  1               MOVSTR1:
00DD16  1  A8                   tay
00DD17  1  F0 0A                beq     L3490
00DD19  1  48                   pha
00DD1A  1               L3487:
00DD1A  1  88                   dey
00DD1B  1  B1 71                lda     (INDEX),y
00DD1D  1  91 83                sta     (FRESPC),y
00DD1F  1  98                   tya
00DD20  1  D0 F8                bne     L3487
00DD22  1  68                   pla
00DD23  1               L3490:
00DD23  1  18                   clc
00DD24  1  65 83                adc     FRESPC
00DD26  1  85 83                sta     FRESPC
00DD28  1  90 02                bcc     L3499
00DD2A  1  E6 84                inc     FRESPC+1
00DD2C  1               L3499:
00DD2C  1  60                   rts
00DD2D  1               ; ----------------------------------------------------------------------------
00DD2D  1               ; IF (FAC) IS A TEMPORARY STRING, RELEASE DESCRIPTOR
00DD2D  1               ; ----------------------------------------------------------------------------
00DD2D  1               FRESTR:
00DD2D  1  20 2C D5             jsr     CHKSTR
00DD30  1               ; ----------------------------------------------------------------------------
00DD30  1               ; IF STRING DESCRIPTOR POINTED TO BY FAC+3,4 IS
00DD30  1               ; A TEMPORARY STRING, RELEASE IT.
00DD30  1               ; ----------------------------------------------------------------------------
00DD30  1               FREFAC:
00DD30  1  A5 AE                lda     FAC_LAST-1
00DD32  1  A4 AF                ldy     FAC_LAST
00DD34  1               ; ----------------------------------------------------------------------------
00DD34  1               ; IF STRING DESCRIPTOR WHOSE ADDRESS IS IN Y,A IS
00DD34  1               ; A TEMPORARY STRING, RELEASE IT.
00DD34  1               ; ----------------------------------------------------------------------------
00DD34  1               FRETMP:
00DD34  1  85 71                sta     INDEX
00DD36  1  84 72                sty     INDEX+1
00DD38  1  20 65 DD             jsr     FRETMS
00DD3B  1  08                   php
00DD3C  1  A0 00                ldy     #$00
00DD3E  1  B1 71                lda     (INDEX),y
00DD40  1  48                   pha
00DD41  1  C8                   iny
00DD42  1  B1 71                lda     (INDEX),y
00DD44  1  AA                   tax
00DD45  1  C8                   iny
00DD46  1  B1 71                lda     (INDEX),y
00DD48  1  A8                   tay
00DD49  1  68                   pla
00DD4A  1  28                   plp
00DD4B  1  D0 13                bne     L34CD
00DD4D  1  C4 82                cpy     FRETOP+1
00DD4F  1  D0 0F                bne     L34CD
00DD51  1  E4 81                cpx     FRETOP
00DD53  1  D0 0B                bne     L34CD
00DD55  1  48                   pha
00DD56  1  18                   clc
00DD57  1  65 81                adc     FRETOP
00DD59  1  85 81                sta     FRETOP
00DD5B  1  90 02                bcc     L34CC
00DD5D  1  E6 82                inc     FRETOP+1
00DD5F  1               L34CC:
00DD5F  1  68                   pla
00DD60  1               L34CD:
00DD60  1  86 71                stx     INDEX
00DD62  1  84 72                sty     INDEX+1
00DD64  1  60                   rts
00DD65  1               ; ----------------------------------------------------------------------------
00DD65  1               ; RELEASE TEMPORARY DESCRIPTOR IF Y,A = LASTPT
00DD65  1               ; ----------------------------------------------------------------------------
00DD65  1               FRETMS:
00DD65  1  C4 67                cpy     LASTPT+1
00DD67  1  D0 0C                bne     L34E2
00DD69  1  C5 66                cmp     LASTPT
00DD6B  1  D0 08                bne     L34E2
00DD6D  1  85 65                sta     TEMPPT
00DD6F  1  E9 03                sbc     #$03
00DD71  1  85 66                sta     LASTPT
00DD73  1  A0 00                ldy     #$00
00DD75  1               L34E2:
00DD75  1  60                   rts
00DD76  1               ; ----------------------------------------------------------------------------
00DD76  1               ; "CHR$" FUNCTION
00DD76  1               ; ----------------------------------------------------------------------------
00DD76  1               CHRSTR:
00DD76  1  20 2B DE             jsr     CONINT
00DD79  1  8A                   txa
00DD7A  1  48                   pha
00DD7B  1  A9 01                lda     #$01
00DD7D  1  20 1E DB             jsr     STRSPA
00DD80  1  68                   pla
00DD81  1  A0 00                ldy     #$00
00DD83  1  91 AD                sta     (FAC+1),y
00DD85  1  68                   pla
00DD86  1  68                   pla
00DD87  1  4C 67 DB             jmp     PUTNEW
00DD8A  1               ; ----------------------------------------------------------------------------
00DD8A  1               ; "LEFT$" FUNCTION
00DD8A  1               ; ----------------------------------------------------------------------------
00DD8A  1               LEFTSTR:
00DD8A  1  20 E9 DD             jsr     SUBSTRING_SETUP
00DD8D  1  D1 9E                cmp     (DSCPTR),y
00DD8F  1  98                   tya
00DD90  1               SUBSTRING1:
00DD90  1  90 04                bcc     L3503
00DD92  1  B1 9E                lda     (DSCPTR),y
00DD94  1  AA                   tax
00DD95  1  98                   tya
00DD96  1               L3503:
00DD96  1  48                   pha
00DD97  1               SUBSTRING2:
00DD97  1  8A                   txa
00DD98  1               SUBSTRING3:
00DD98  1  48                   pha
00DD99  1  20 1E DB             jsr     STRSPA
00DD9C  1  A5 9E                lda     DSCPTR
00DD9E  1  A4 9F                ldy     DSCPTR+1
00DDA0  1  20 34 DD             jsr     FRETMP
00DDA3  1  68                   pla
00DDA4  1  A8                   tay
00DDA5  1  68                   pla
00DDA6  1  18                   clc
00DDA7  1  65 71                adc     INDEX
00DDA9  1  85 71                sta     INDEX
00DDAB  1  90 02                bcc     L351C
00DDAD  1  E6 72                inc     INDEX+1
00DDAF  1               L351C:
00DDAF  1  98                   tya
00DDB0  1  20 16 DD             jsr     MOVSTR1
00DDB3  1  4C 67 DB             jmp     PUTNEW
00DDB6  1               ; ----------------------------------------------------------------------------
00DDB6  1               ; "RIGHT$" FUNCTION
00DDB6  1               ; ----------------------------------------------------------------------------
00DDB6  1               RIGHTSTR:
00DDB6  1  20 E9 DD             jsr     SUBSTRING_SETUP
00DDB9  1  18                   clc
00DDBA  1  F1 9E                sbc     (DSCPTR),y
00DDBC  1  49 FF                eor     #$FF
00DDBE  1  4C 90 DD             jmp     SUBSTRING1
00DDC1  1               ; ----------------------------------------------------------------------------
00DDC1  1               ; "MID$" FUNCTION
00DDC1  1               ; ----------------------------------------------------------------------------
00DDC1  1               MIDSTR:
00DDC1  1  A9 FF                lda     #$FF
00DDC3  1  85 AF                sta     FAC_LAST
00DDC5  1  20 DC 00             jsr     CHRGOT
00DDC8  1  C9 29                cmp     #$29
00DDCA  1  F0 06                beq     L353F
00DDCC  1  20 7B D6             jsr     CHKCOM
00DDCF  1  20 28 DE             jsr     GETBYT
00DDD2  1               L353F:
00DDD2  1  20 E9 DD             jsr     SUBSTRING_SETUP
00DDD5  1  CA                   dex
00DDD6  1  8A                   txa
00DDD7  1  48                   pha
00DDD8  1  18                   clc
00DDD9  1  A2 00                ldx     #$00
00DDDB  1  F1 9E                sbc     (DSCPTR),y
00DDDD  1  B0 B8                bcs     SUBSTRING2
00DDDF  1  49 FF                eor     #$FF
00DDE1  1  C5 AF                cmp     FAC_LAST
00DDE3  1  90 B3                bcc     SUBSTRING3
00DDE5  1  A5 AF                lda     FAC_LAST
00DDE7  1  B0 AF                bcs     SUBSTRING3
00DDE9  1               ; ----------------------------------------------------------------------------
00DDE9  1               ; COMMON SETUP ROUTINE FOR LEFT$, RIGHT$, MID$:
00DDE9  1               ; REQUIRE ")"; POP RETURN ADRS, GET DESCRIPTOR
00DDE9  1               ; ADDRESS, GET 1ST PARAMETER OF COMMAND
00DDE9  1               ; ----------------------------------------------------------------------------
00DDE9  1               SUBSTRING_SETUP:
00DDE9  1  20 75 D6             jsr     CHKCLS
00DDEC  1  68                   pla
00DDED  1  85 A2                sta     JMPADRS+1
00DDEF  1  68                   pla
00DDF0  1  85 A3                sta     JMPADRS+2
00DDF2  1  68                   pla
00DDF3  1  68                   pla
00DDF4  1  68                   pla
00DDF5  1  AA                   tax
00DDF6  1  68                   pla
00DDF7  1  85 9E                sta     DSCPTR
00DDF9  1  68                   pla
00DDFA  1  85 9F                sta     DSCPTR+1
00DDFC  1  A0 00                ldy     #$00
00DDFE  1  8A                   txa
00DDFF  1  F0 21                beq     GOIQ
00DE01  1  E6 A2                inc     JMPADRS+1
00DE03  1  6C A2 00             jmp     (JMPADRS+1)
00DE06  1               ; ----------------------------------------------------------------------------
00DE06  1               ; "LEN" FUNCTION
00DE06  1               ; ----------------------------------------------------------------------------
00DE06  1               LEN:
00DE06  1  20 0C DE             jsr     GETSTR
00DE09  1               SNGFLT1:
00DE09  1  4C 4A DA             jmp     SNGFLT
00DE0C  1               ; ----------------------------------------------------------------------------
00DE0C  1               ; IF LAST RESULT IS A TEMPORARY STRING, FREE IT
00DE0C  1               ; MAKE VALTYP NUMERIC, RETURN LENGTH IN Y-REG
00DE0C  1               ; ----------------------------------------------------------------------------
00DE0C  1               GETSTR:
00DE0C  1  20 2D DD             jsr     FRESTR
00DE0F  1  A2 00                ldx     #$00
00DE11  1  86 5F                stx     VALTYP
00DE13  1  A8                   tay
00DE14  1  60                   rts
00DE15  1               ; ----------------------------------------------------------------------------
00DE15  1               ; "ASC" FUNCTION
00DE15  1               ; ----------------------------------------------------------------------------
00DE15  1               ASC:
00DE15  1  20 0C DE             jsr     GETSTR
00DE18  1  F0 08                beq     GOIQ
00DE1A  1  A0 00                ldy     #$00
00DE1C  1  B1 71                lda     (INDEX),y
00DE1E  1  A8                   tay
00DE1F  1  4C 09 DE             jmp     SNGFLT1
00DE22  1               ; ----------------------------------------------------------------------------
00DE22  1               GOIQ:
00DE22  1  4C 02 D9             jmp     IQERR
00DE25  1               ; ----------------------------------------------------------------------------
00DE25  1               ; SCAN TO NEXT CHARACTER AND CONVERT EXPRESSION
00DE25  1               ; TO SINGLE BYTE IN X-REG
00DE25  1               ; ----------------------------------------------------------------------------
00DE25  1               GTBYTC:
00DE25  1  20 D6 00             jsr     CHRGET
00DE28  1               ; ----------------------------------------------------------------------------
00DE28  1               ; EVALUATE EXPRESSION AT TXTPTR, AND
00DE28  1               ; CONVERT IT TO SINGLE BYTE IN X-REG
00DE28  1               ; ----------------------------------------------------------------------------
00DE28  1               GETBYT:
00DE28  1  20 27 D5             jsr     FRMNUM
00DE2B  1               ; ----------------------------------------------------------------------------
00DE2B  1               ; CONVERT (FAC) TO SINGLE BYTE INTEGER IN X-REG
00DE2B  1               ; ----------------------------------------------------------------------------
00DE2B  1               CONINT:
00DE2B  1  20 7B D8             jsr     MKINT
00DE2E  1  A6 AE                ldx     FAC_LAST-1
00DE30  1  D0 F0                bne     GOIQ
00DE32  1  A6 AF                ldx     FAC_LAST
00DE34  1  4C DC 00             jmp     CHRGOT
00DE37  1               ; ----------------------------------------------------------------------------
00DE37  1               ; "VAL" FUNCTION
00DE37  1               ; ----------------------------------------------------------------------------
00DE37  1               VAL:
00DE37  1  20 0C DE             jsr     GETSTR
00DE3A  1  D0 03                bne     L35AC
00DE3C  1  4C 6B DF             jmp     ZERO_FAC
00DE3F  1               L35AC:
00DE3F  1  A6 DD                ldx     TXTPTR
00DE41  1  A4 DE                ldy     TXTPTR+1
00DE43  1  86 BA                stx     STRNG2
00DE45  1  84 BB                sty     STRNG2+1
00DE47  1  A6 71                ldx     INDEX
00DE49  1  86 DD                stx     TXTPTR
00DE4B  1  18                   clc
00DE4C  1  65 71                adc     INDEX
00DE4E  1  85 73                sta     DEST
00DE50  1  A6 72                ldx     INDEX+1
00DE52  1  86 DE                stx     TXTPTR+1
00DE54  1  90 01                bcc     L35C4
00DE56  1  E8                   inx
00DE57  1               L35C4:
00DE57  1  86 74                stx     DEST+1
00DE59  1  A0 00                ldy     #$00
00DE5B  1  B1 73                lda     (DEST),y
00DE5D  1  48                   pha
00DE5E  1  A9 00                lda     #$00
00DE60  1  91 73                sta     (DEST),y
00DE62  1  20 DC 00             jsr     CHRGOT
00DE65  1  20 01 E3             jsr     FIN
00DE68  1  68                   pla
00DE69  1  A0 00                ldy     #$00
00DE6B  1  91 73                sta     (DEST),y
00DE6D  1               ; ----------------------------------------------------------------------------
00DE6D  1               ; COPY STRNG2 INTO TXTPTR
00DE6D  1               ; ----------------------------------------------------------------------------
00DE6D  1               POINT:
00DE6D  1  A6 BA                ldx     STRNG2
00DE6F  1  A4 BB                ldy     STRNG2+1
00DE71  1  86 DD                stx     TXTPTR
00DE73  1  84 DE                sty     TXTPTR+1
00DE75  1  60                   rts
00DE76  1               ; ----------------------------------------------------------------------------
00DE76  1               ; EVALUATE "EXP1,EXP2"
00DE76  1               ;
00DE76  1               ; CONVERT EXP1 TO 16-BIT NUMBER IN LINNUM
00DE76  1               ; CONVERT EXP2 TO 8-BIT NUMBER IN X-REG
00DE76  1               ; ----------------------------------------------------------------------------
00DE76  1               GTNUM:
00DE76  1  20 27 D5             jsr     FRMNUM
00DE79  1  20 82 DE             jsr     GETADR
00DE7C  1               ; ----------------------------------------------------------------------------
00DE7C  1               ; EVALUATE ",EXPRESSION"
00DE7C  1               ; CONVERT EXPRESSION TO SINGLE BYTE IN X-REG
00DE7C  1               ; ----------------------------------------------------------------------------
00DE7C  1               COMBYTE:
00DE7C  1  20 7B D6             jsr     CHKCOM
00DE7F  1  4C 28 DE             jmp     GETBYT
00DE82  1               ; ----------------------------------------------------------------------------
00DE82  1               ; CONVERT (FAC) TO A 16-BIT VALUE IN LINNUM
00DE82  1               ; ----------------------------------------------------------------------------
00DE82  1               GETADR:
00DE82  1  A5 B0                lda     FACSIGN
00DE84  1  30 9C                bmi     GOIQ
00DE86  1  A5 AC                lda     FAC
00DE88  1  C9 91                cmp     #$91
00DE8A  1  B0 96                bcs     GOIQ
00DE8C  1  20 AB E2             jsr     QINT
00DE8F  1  A5 AE                lda     FAC_LAST-1
00DE91  1  A4 AF                ldy     FAC_LAST
00DE93  1  84 11                sty     LINNUM
00DE95  1  85 12                sta     LINNUM+1
00DE97  1  60                   rts
00DE98  1               ; ----------------------------------------------------------------------------
00DE98  1               ; "PEEK" FUNCTION
00DE98  1               ; ----------------------------------------------------------------------------
00DE98  1               PEEK:
00DE98  1  20 82 DE             jsr     GETADR
00DE9B  1  A0 00                ldy     #$00
00DE9D  1               ; disallow PEEK between $C000 and $DFFF
00DE9D  1  B1 11                lda     (LINNUM),y
00DE9F  1  A8                   tay
00DEA0  1  4C 4A DA             jmp     SNGFLT
00DEA3  1               ; ----------------------------------------------------------------------------
00DEA3  1               ; "POKE" STATEMENT
00DEA3  1               ; ----------------------------------------------------------------------------
00DEA3  1               POKE:
00DEA3  1  20 76 DE             jsr     GTNUM
00DEA6  1  8A                   txa
00DEA7  1  A0 00                ldy     #$00
00DEA9  1  91 11                sta     (LINNUM),y
00DEAB  1  60                   rts
00DEAC  1               ; ----------------------------------------------------------------------------
00DEAC  1               ; "WAIT" STATEMENT
00DEAC  1               ; ----------------------------------------------------------------------------
00DEAC  1               WAIT:
00DEAC  1  20 76 DE             jsr     GTNUM
00DEAF  1  86 97                stx     FORPNT
00DEB1  1  A2 00                ldx     #$00
00DEB3  1  20 DC 00             jsr     CHRGOT
00DEB6  1  F0 03                beq     L3628
00DEB8  1  20 7C DE             jsr     COMBYTE
00DEBB  1               L3628:
00DEBB  1  86 98                stx     FORPNT+1
00DEBD  1  A0 00                ldy     #$00
00DEBF  1               L362C:
00DEBF  1  B1 11                lda     (LINNUM),y
00DEC1  1  45 98                eor     FORPNT+1
00DEC3  1  25 97                and     FORPNT
00DEC5  1  F0 F8                beq     L362C
00DEC7  1               RTS3:
00DEC7  1  60                   rts
00DEC8  1               TEMP1X = TEMP1+(5-BYTES_FP)
00DEC8  1               ; ----------------------------------------------------------------------------
00DEC8  1               ; ADD 0.5 TO FAC
00DEC8  1               ; ----------------------------------------------------------------------------
00DEC8  1               FADDH:
00DEC8  1  A9 10                lda     #<CON_HALF
00DECA  1  A0 E5                ldy     #>CON_HALF
00DECC  1  4C E6 DE             jmp     FADD
00DECF  1               ; ----------------------------------------------------------------------------
00DECF  1               ; FAC = (Y,A) - FAC
00DECF  1               ; ----------------------------------------------------------------------------
00DECF  1               FSUB:
00DECF  1  20 C7 E0             jsr     LOAD_ARG_FROM_YA
00DED2  1               ; ----------------------------------------------------------------------------
00DED2  1               ; FAC = ARG - FAC
00DED2  1               ; ----------------------------------------------------------------------------
00DED2  1               FSUBT:
00DED2  1  A5 B0                lda     FACSIGN
00DED4  1  49 FF                eor     #$FF
00DED6  1  85 B0                sta     FACSIGN
00DED8  1  45 B7                eor     ARGSIGN
00DEDA  1  85 B8                sta     SGNCPR
00DEDC  1  A5 AC                lda     FAC
00DEDE  1  4C E9 DE             jmp     FADDT
00DEE1  1               ; ----------------------------------------------------------------------------
00DEE1  1               ; Commodore BASIC V2 Easter Egg
00DEE1  1               ; ----------------------------------------------------------------------------
00DEE1  1               ; ----------------------------------------------------------------------------
00DEE1  1               ; SHIFT SMALLER ARGUMENT MORE THAN 7 BITS
00DEE1  1               ; ----------------------------------------------------------------------------
00DEE1  1               FADD1:
00DEE1  1  20 F5 DF             jsr     SHIFT_RIGHT
00DEE4  1  90 3C                bcc     FADD3
00DEE6  1               ; ----------------------------------------------------------------------------
00DEE6  1               ; FAC = (Y,A) + FAC
00DEE6  1               ; ----------------------------------------------------------------------------
00DEE6  1               FADD:
00DEE6  1  20 C7 E0             jsr     LOAD_ARG_FROM_YA
00DEE9  1               ; ----------------------------------------------------------------------------
00DEE9  1               ; FAC = ARG + FAC
00DEE9  1               ; ----------------------------------------------------------------------------
00DEE9  1               FADDT:
00DEE9  1  D0 03                bne     L365B
00DEEB  1  4C 15 E2             jmp     COPY_ARG_TO_FAC
00DEEE  1               L365B:
00DEEE  1  A6 B9                ldx     FACEXTENSION
00DEF0  1  86 A3                stx     ARGEXTENSION
00DEF2  1  A2 B3                ldx     #ARG
00DEF4  1  A5 B3                lda     ARG
00DEF6  1               FADD2:
00DEF6  1  A8                   tay
00DEF7  1  F0 CE                beq     RTS3
00DEF9  1  38                   sec
00DEFA  1  E5 AC                sbc     FAC
00DEFC  1  F0 24                beq     FADD3
00DEFE  1  90 12                bcc     L367F
00DF00  1  84 AC                sty     FAC
00DF02  1  A4 B7                ldy     ARGSIGN
00DF04  1  84 B0                sty     FACSIGN
00DF06  1  49 FF                eor     #$FF
00DF08  1  69 00                adc     #$00
00DF0A  1  A0 00                ldy     #$00
00DF0C  1  84 A3                sty     ARGEXTENSION
00DF0E  1  A2 AC                ldx     #FAC
00DF10  1  D0 04                bne     L3683
00DF12  1               L367F:
00DF12  1  A0 00                ldy     #$00
00DF14  1  84 B9                sty     FACEXTENSION
00DF16  1               L3683:
00DF16  1  C9 F9                cmp     #$F9
00DF18  1  30 C7                bmi     FADD1
00DF1A  1  A8                   tay
00DF1B  1  A5 B9                lda     FACEXTENSION
00DF1D  1  56 01                lsr     1,x
00DF1F  1  20 0C E0             jsr     SHIFT_RIGHT4
00DF22  1               FADD3:
00DF22  1  24 B8                bit     SGNCPR
00DF24  1  10 4C                bpl     FADD4
00DF26  1  A0 AC                ldy     #FAC
00DF28  1  E0 B3                cpx     #ARG
00DF2A  1  F0 02                beq     L369B
00DF2C  1  A0 B3                ldy     #ARG
00DF2E  1               L369B:
00DF2E  1  38                   sec
00DF2F  1  49 FF                eor     #$FF
00DF31  1  65 A3                adc     ARGEXTENSION
00DF33  1  85 B9                sta     FACEXTENSION
00DF35  1  B9 03 00             lda     3,y
00DF38  1  F5 03                sbc     3,x
00DF3A  1  85 AF                sta     FAC+3
00DF3C  1  B9 02 00             lda     2,y
00DF3F  1  F5 02                sbc     2,x
00DF41  1  85 AE                sta     FAC+2
00DF43  1  B9 01 00             lda     1,y
00DF46  1  F5 01                sbc     1,x
00DF48  1  85 AD                sta     FAC+1
00DF4A  1               ; ----------------------------------------------------------------------------
00DF4A  1               ; NORMALIZE VALUE IN FAC
00DF4A  1               ; ----------------------------------------------------------------------------
00DF4A  1               NORMALIZE_FAC1:
00DF4A  1  B0 03                bcs     NORMALIZE_FAC2
00DF4C  1  20 B1 DF             jsr     COMPLEMENT_FAC
00DF4F  1               NORMALIZE_FAC2:
00DF4F  1  A0 00                ldy     #$00
00DF51  1  98                   tya
00DF52  1  18                   clc
00DF53  1               L36C7:
00DF53  1  A6 AD                ldx     FAC+1
00DF55  1  D0 3E                bne     NORMALIZE_FAC4
00DF57  1  A6 AE                ldx     FAC+2
00DF59  1  86 AD                stx     FAC+1
00DF5B  1  A6 AF                ldx     FAC+3
00DF5D  1  86 AE                stx     FAC+2
00DF5F  1  A6 B9                ldx     FACEXTENSION
00DF61  1  86 AF                stx     FAC+3
00DF63  1  84 B9                sty     FACEXTENSION
00DF65  1  69 08                adc     #$08
00DF67  1               ; bugfix?
00DF67  1               ; fix does not exist on AppleSoft 2
00DF67  1  C9 18                cmp     #MANTISSA_BYTES*8
00DF69  1  D0 E8                bne     L36C7
00DF6B  1               ; ----------------------------------------------------------------------------
00DF6B  1               ; SET FAC = 0
00DF6B  1               ; (ONLY NECESSARY TO ZERO EXPONENT AND SIGN CELLS)
00DF6B  1               ; ----------------------------------------------------------------------------
00DF6B  1               ZERO_FAC:
00DF6B  1  A9 00                lda     #$00
00DF6D  1               STA_IN_FAC_SIGN_AND_EXP:
00DF6D  1  85 AC                sta     FAC
00DF6F  1               STA_IN_FAC_SIGN:
00DF6F  1  85 B0                sta     FACSIGN
00DF71  1  60                   rts
00DF72  1               ; ----------------------------------------------------------------------------
00DF72  1               ; ADD MANTISSAS OF FAC AND ARG INTO FAC
00DF72  1               ; ----------------------------------------------------------------------------
00DF72  1               FADD4:
00DF72  1  65 A3                adc     ARGEXTENSION
00DF74  1  85 B9                sta     FACEXTENSION
00DF76  1  A5 AF                lda     FAC+3
00DF78  1  65 B6                adc     ARG+3
00DF7A  1  85 AF                sta     FAC+3
00DF7C  1  A5 AE                lda     FAC+2
00DF7E  1  65 B5                adc     ARG+2
00DF80  1  85 AE                sta     FAC+2
00DF82  1  A5 AD                lda     FAC+1
00DF84  1  65 B4                adc     ARG+1
00DF86  1  85 AD                sta     FAC+1
00DF88  1  4C A2 DF             jmp     NORMALIZE_FAC5
00DF8B  1               ; ----------------------------------------------------------------------------
00DF8B  1               ; FINISH NORMALIZING FAC
00DF8B  1               ; ----------------------------------------------------------------------------
00DF8B  1               NORMALIZE_FAC3:
00DF8B  1  69 01                adc     #$01
00DF8D  1  06 B9                asl     FACEXTENSION
00DF8F  1  26 AF                rol     FAC+3
00DF91  1  26 AE                rol     FAC+2
00DF93  1  26 AD                rol     FAC+1
00DF95  1               NORMALIZE_FAC4:
00DF95  1  10 F4                bpl     NORMALIZE_FAC3
00DF97  1  38                   sec
00DF98  1  E5 AC                sbc     FAC
00DF9A  1  B0 CF                bcs     ZERO_FAC
00DF9C  1  49 FF                eor     #$FF
00DF9E  1  69 01                adc     #$01
00DFA0  1  85 AC                sta     FAC
00DFA2  1               NORMALIZE_FAC5:
00DFA2  1  90 0C                bcc     L3764
00DFA4  1               NORMALIZE_FAC6:
00DFA4  1  E6 AC                inc     FAC
00DFA6  1  F0 36                beq     OVERFLOW
00DFA8  1  66 AD                ror     FAC+1
00DFAA  1  66 AE                ror     FAC+2
00DFAC  1  66 AF                ror     FAC+3
00DFAE  1  66 B9                ror     FACEXTENSION
00DFB0  1               L3764:
00DFB0  1  60                   rts
00DFB1  1               ; ----------------------------------------------------------------------------
00DFB1  1               ; 2'S COMPLEMENT OF FAC
00DFB1  1               ; ----------------------------------------------------------------------------
00DFB1  1               COMPLEMENT_FAC:
00DFB1  1  A5 B0                lda     FACSIGN
00DFB3  1  49 FF                eor     #$FF
00DFB5  1  85 B0                sta     FACSIGN
00DFB7  1               ; ----------------------------------------------------------------------------
00DFB7  1               ; 2'S COMPLEMENT OF FAC MANTISSA ONLY
00DFB7  1               ; ----------------------------------------------------------------------------
00DFB7  1               COMPLEMENT_FAC_MANTISSA:
00DFB7  1  A5 AD                lda     FAC+1
00DFB9  1  49 FF                eor     #$FF
00DFBB  1  85 AD                sta     FAC+1
00DFBD  1  A5 AE                lda     FAC+2
00DFBF  1  49 FF                eor     #$FF
00DFC1  1  85 AE                sta     FAC+2
00DFC3  1  A5 AF                lda     FAC+3
00DFC5  1  49 FF                eor     #$FF
00DFC7  1  85 AF                sta     FAC+3
00DFC9  1  A5 B9                lda     FACEXTENSION
00DFCB  1  49 FF                eor     #$FF
00DFCD  1  85 B9                sta     FACEXTENSION
00DFCF  1  E6 B9                inc     FACEXTENSION
00DFD1  1  D0 0A                bne     RTS12
00DFD3  1               ; ----------------------------------------------------------------------------
00DFD3  1               ; INCREMENT FAC MANTISSA
00DFD3  1               ; ----------------------------------------------------------------------------
00DFD3  1               INCREMENT_FAC_MANTISSA:
00DFD3  1  E6 AF                inc     FAC+3
00DFD5  1  D0 06                bne     RTS12
00DFD7  1  E6 AE                inc     FAC+2
00DFD9  1  D0 02                bne     RTS12
00DFDB  1  E6 AD                inc     FAC+1
00DFDD  1               RTS12:
00DFDD  1  60                   rts
00DFDE  1               OVERFLOW:
00DFDE  1  A2 0A                ldx     #ERR_OVERFLOW
00DFE0  1  4C D4 CC             jmp     ERROR
00DFE3  1               ; ----------------------------------------------------------------------------
00DFE3  1               ; SHIFT 1,X THRU 5,X RIGHT
00DFE3  1               ; (A) = NEGATIVE OF SHIFT COUNT
00DFE3  1               ; (X) = POINTER TO BYTES TO BE SHIFTED
00DFE3  1               ;
00DFE3  1               ; RETURN WITH (Y)=0, CARRY=0, EXTENSION BITS IN A-REG
00DFE3  1               ; ----------------------------------------------------------------------------
00DFE3  1               SHIFT_RIGHT1:
00DFE3  1  A2 74                ldx     #RESULT-1
00DFE5  1               SHIFT_RIGHT2:
00DFE5  1  B4 03                ldy     3,x
00DFE7  1  84 B9                sty     FACEXTENSION
00DFE9  1  B4 02                ldy     2,x
00DFEB  1  94 03                sty     3,x
00DFED  1  B4 01                ldy     1,x
00DFEF  1  94 02                sty     2,x
00DFF1  1  A4 B2                ldy     SHIFTSIGNEXT
00DFF3  1  94 01                sty     1,x
00DFF5  1               ; ----------------------------------------------------------------------------
00DFF5  1               ; MAIN ENTRY TO RIGHT SHIFT SUBROUTINE
00DFF5  1               ; ----------------------------------------------------------------------------
00DFF5  1               SHIFT_RIGHT:
00DFF5  1  69 08                adc     #$08
00DFF7  1  30 EC                bmi     SHIFT_RIGHT2
00DFF9  1  F0 EA                beq     SHIFT_RIGHT2
00DFFB  1  E9 08                sbc     #$08
00DFFD  1  A8                   tay
00DFFE  1  A5 B9                lda     FACEXTENSION
00E000  1  B0 12                bcs     SHIFT_RIGHT5
00E002  1               LB588:
00E002  1  16 01                asl     1,x
00E004  1  90 02                bcc     LB58E
00E006  1  F6 01                inc     1,x
00E008  1               LB58E:
00E008  1  76 01                ror     1,x
00E00A  1  76 01                ror     1,x
00E00C  1               ; ----------------------------------------------------------------------------
00E00C  1               ; ENTER HERE FOR SHORT SHIFTS WITH NO SIGN EXTENSION
00E00C  1               ; ----------------------------------------------------------------------------
00E00C  1               SHIFT_RIGHT4:
00E00C  1  76 02                ror     2,x
00E00E  1  76 03                ror     3,x
00E010  1  6A                   ror     a
00E011  1  C8                   iny
00E012  1  D0 EE                bne     LB588
00E014  1               SHIFT_RIGHT5:
00E014  1  18                   clc
00E015  1  60                   rts
00E016  1               ; ----------------------------------------------------------------------------
00E016  1               CON_ONE:
00E016  1  81 00 00 00          .byte   $81,$00,$00,$00
00E01A  1               POLY_LOG:
00E01A  1  02           		.byte	$02
00E01B  1  80 19 56 62  		.byte   $80,$19,$56,$62
00E01F  1  80 76 22 F3  		.byte   $80,$76,$22,$F3
00E023  1  82 38 AA 40  		.byte   $82,$38,$AA,$40
00E027  1               CON_SQR_HALF:
00E027  1  80 35 04 F3  		.byte   $80,$35,$04,$F3
00E02B  1               CON_SQR_TWO:
00E02B  1  81 35 04 F3  		.byte   $81,$35,$04,$F3
00E02F  1               CON_NEG_HALF:
00E02F  1  80 80 00 00  		.byte   $80,$80,$00,$00
00E033  1               CON_LOG_TWO:
00E033  1  80 31 72 18  		.byte   $80,$31,$72,$18
00E037  1               ; ----------------------------------------------------------------------------
00E037  1               ; "LOG" FUNCTION
00E037  1               ; ----------------------------------------------------------------------------
00E037  1               LOG:
00E037  1  20 44 E2             jsr     SIGN
00E03A  1  F0 02                beq     GIQ
00E03C  1  10 03                bpl     LOG2
00E03E  1               GIQ:
00E03E  1  4C 02 D9             jmp     IQERR
00E041  1               LOG2:
00E041  1  A5 AC                lda     FAC
00E043  1  E9 7F                sbc     #$7F
00E045  1  48                   pha
00E046  1  A9 80                lda     #$80
00E048  1  85 AC                sta     FAC
00E04A  1  A9 27                lda     #<CON_SQR_HALF
00E04C  1  A0 E0                ldy     #>CON_SQR_HALF
00E04E  1  20 E6 DE             jsr     FADD
00E051  1  A9 2B                lda     #<CON_SQR_TWO
00E053  1  A0 E0                ldy     #>CON_SQR_TWO
00E055  1  20 44 E1             jsr     FDIV
00E058  1  A9 16                lda     #<CON_ONE
00E05A  1  A0 E0                ldy     #>CON_ONE
00E05C  1  20 CF DE             jsr     FSUB
00E05F  1  A9 1A                lda     #<POLY_LOG
00E061  1  A0 E0                ldy     #>POLY_LOG
00E063  1  20 E8 E5             jsr     POLYNOMIAL_ODD
00E066  1  A9 2F                lda     #<CON_NEG_HALF
00E068  1  A0 E0                ldy     #>CON_NEG_HALF
00E06A  1  20 E6 DE             jsr     FADD
00E06D  1  68                   pla
00E06E  1  20 8C E3             jsr     ADDACC
00E071  1  A9 33                lda     #<CON_LOG_TWO
00E073  1  A0 E0                ldy     #>CON_LOG_TWO
00E075  1               ; ----------------------------------------------------------------------------
00E075  1               ; FAC = (Y,A) * FAC
00E075  1               ; ----------------------------------------------------------------------------
00E075  1               FMULT:
00E075  1  20 C7 E0             jsr     LOAD_ARG_FROM_YA
00E078  1               ; ----------------------------------------------------------------------------
00E078  1               ; FAC = ARG * FAC
00E078  1               ; ----------------------------------------------------------------------------
00E078  1               FMULTT:
00E078  1  F0 4C                beq     L3903
00E07A  1  20 ED E0             jsr     ADD_EXPONENTS
00E07D  1  A9 00                lda     #$00
00E07F  1  85 75                sta     RESULT
00E081  1  85 76                sta     RESULT+1
00E083  1  85 77                sta     RESULT+2
00E085  1  A5 B9                lda     FACEXTENSION
00E087  1  20 9C E0             jsr     MULTIPLY1
00E08A  1  A5 AF                lda     FAC+3
00E08C  1  20 9C E0             jsr     MULTIPLY1
00E08F  1  A5 AE                lda     FAC+2
00E091  1  20 9C E0             jsr     MULTIPLY1
00E094  1  A5 AD                lda     FAC+1
00E096  1  20 A1 E0             jsr     MULTIPLY2
00E099  1  4C B6 E1             jmp     COPY_RESULT_INTO_FAC
00E09C  1               ; ----------------------------------------------------------------------------
00E09C  1               ; MULTIPLY ARG BY (A) INTO RESULT
00E09C  1               ; ----------------------------------------------------------------------------
00E09C  1               MULTIPLY1:
00E09C  1  D0 03                bne     MULTIPLY2
00E09E  1  4C E3 DF             jmp     SHIFT_RIGHT1
00E0A1  1               MULTIPLY2:
00E0A1  1  4A                   lsr     a
00E0A2  1  09 80                ora     #$80
00E0A4  1               L38A7:
00E0A4  1  A8                   tay
00E0A5  1  90 13                bcc     L38C3
00E0A7  1  18                   clc
00E0A8  1  A5 77                lda     RESULT+2
00E0AA  1  65 B6                adc     ARG+3
00E0AC  1  85 77                sta     RESULT+2
00E0AE  1  A5 76                lda     RESULT+1
00E0B0  1  65 B5                adc     ARG+2
00E0B2  1  85 76                sta     RESULT+1
00E0B4  1  A5 75                lda     RESULT
00E0B6  1  65 B4                adc     ARG+1
00E0B8  1  85 75                sta     RESULT
00E0BA  1               L38C3:
00E0BA  1  66 75                ror     RESULT
00E0BC  1  66 76                ror     RESULT+1
00E0BE  1               ; this seems to be a bad byte in the dump
00E0BE  1  66 77                ror     RESULT+2
00E0C0  1  66 B9                ror     FACEXTENSION
00E0C2  1  98                   tya
00E0C3  1  4A                   lsr     a
00E0C4  1  D0 DE                bne     L38A7
00E0C6  1               L3903:
00E0C6  1  60                   rts
00E0C7  1               ; ----------------------------------------------------------------------------
00E0C7  1               ; UNPACK NUMBER AT (Y,A) INTO ARG
00E0C7  1               ; ----------------------------------------------------------------------------
00E0C7  1               LOAD_ARG_FROM_YA:
00E0C7  1  85 71                sta     INDEX
00E0C9  1  84 72                sty     INDEX+1
00E0CB  1  A0 03                ldy     #BYTES_FP-1
00E0CD  1  B1 71                lda     (INDEX),y
00E0CF  1  85 B6                sta     ARG+3
00E0D1  1  88                   dey
00E0D2  1  B1 71                lda     (INDEX),y
00E0D4  1  85 B5                sta     ARG+2
00E0D6  1  88                   dey
00E0D7  1  B1 71                lda     (INDEX),y
00E0D9  1  85 B7                sta     ARGSIGN
00E0DB  1  45 B0                eor     FACSIGN
00E0DD  1  85 B8                sta     SGNCPR
00E0DF  1  A5 B7                lda     ARGSIGN
00E0E1  1  09 80                ora     #$80
00E0E3  1  85 B4                sta     ARG+1
00E0E5  1  88                   dey
00E0E6  1  B1 71                lda     (INDEX),y
00E0E8  1  85 B3                sta     ARG
00E0EA  1  A5 AC                lda     FAC
00E0EC  1  60                   rts
00E0ED  1               ; ----------------------------------------------------------------------------
00E0ED  1               ; ADD EXPONENTS OF ARG AND FAC
00E0ED  1               ; (CALLED BY FMULT AND FDIV)
00E0ED  1               ;
00E0ED  1               ; ALSO CHECK FOR OVERFLOW, AND SET RESULT SIGN
00E0ED  1               ; ----------------------------------------------------------------------------
00E0ED  1               ADD_EXPONENTS:
00E0ED  1  A5 B3                lda     ARG
00E0EF  1               ADD_EXPONENTS1:
00E0EF  1  F0 1F                beq     ZERO
00E0F1  1  18                   clc
00E0F2  1  65 AC                adc     FAC
00E0F4  1  90 04                bcc     L393C
00E0F6  1  30 1D                bmi     JOV
00E0F8  1  18                   clc
00E0F9  1  2C                   .byte   $2C
00E0FA  1               L393C:
00E0FA  1  10 14                bpl     ZERO
00E0FC  1  69 80                adc     #$80
00E0FE  1  85 AC                sta     FAC
00E100  1  D0 03                bne     L3947
00E102  1  4C 6F DF             jmp     STA_IN_FAC_SIGN
00E105  1               L3947:
00E105  1  A5 B8                lda     SGNCPR
00E107  1  85 B0                sta     FACSIGN
00E109  1  60                   rts
00E10A  1               ; ----------------------------------------------------------------------------
00E10A  1               ; IF (FAC) IS POSITIVE, GIVE "OVERFLOW" ERROR
00E10A  1               ; IF (FAC) IS NEGATIVE, SET FAC=0, POP ONE RETURN, AND RTS
00E10A  1               ; CALLED FROM "EXP" FUNCTION
00E10A  1               ; ----------------------------------------------------------------------------
00E10A  1               OUTOFRNG:
00E10A  1  A5 B0                lda     FACSIGN
00E10C  1  49 FF                eor     #$FF
00E10E  1  30 05                bmi     JOV
00E110  1               ; ----------------------------------------------------------------------------
00E110  1               ; POP RETURN ADDRESS AND SET FAC=0
00E110  1               ; ----------------------------------------------------------------------------
00E110  1               ZERO:
00E110  1  68                   pla
00E111  1  68                   pla
00E112  1  4C 6B DF             jmp     ZERO_FAC
00E115  1               JOV:
00E115  1  4C DE DF             jmp     OVERFLOW
00E118  1               ; ----------------------------------------------------------------------------
00E118  1               ; MULTIPLY FAC BY 10
00E118  1               ; ----------------------------------------------------------------------------
00E118  1               MUL10:
00E118  1  20 25 E2             jsr     COPY_FAC_TO_ARG_ROUNDED
00E11B  1  AA                   tax
00E11C  1  F0 10                beq     L3970
00E11E  1  18                   clc
00E11F  1  69 02                adc     #$02
00E121  1  B0 F2                bcs     JOV
00E123  1  A2 00                ldx     #$00
00E125  1  86 B8                stx     SGNCPR
00E127  1  20 F6 DE             jsr     FADD2
00E12A  1  E6 AC                inc     FAC
00E12C  1  F0 E7                beq     JOV
00E12E  1               L3970:
00E12E  1  60                   rts
00E12F  1               ; ----------------------------------------------------------------------------
00E12F  1               CONTEN:
00E12F  1  84 20 00 00          .byte   $84,$20,$00,$00
00E133  1               ; ----------------------------------------------------------------------------
00E133  1               ; DIVIDE FAC BY 10
00E133  1               ; ----------------------------------------------------------------------------
00E133  1               DIV10:
00E133  1  20 25 E2             jsr     COPY_FAC_TO_ARG_ROUNDED
00E136  1  A9 2F                lda     #<CONTEN
00E138  1  A0 E1                ldy     #>CONTEN
00E13A  1  A2 00                ldx     #$00
00E13C  1               ; ----------------------------------------------------------------------------
00E13C  1               ; FAC = ARG / (Y,A)
00E13C  1               ; ----------------------------------------------------------------------------
00E13C  1               DIV:
00E13C  1  86 B8                stx     SGNCPR
00E13E  1  20 C5 E1             jsr     LOAD_FAC_FROM_YA
00E141  1  4C 47 E1             jmp     FDIVT
00E144  1               ; ----------------------------------------------------------------------------
00E144  1               ; FAC = (Y,A) / FAC
00E144  1               ; ----------------------------------------------------------------------------
00E144  1               FDIV:
00E144  1  20 C7 E0             jsr     LOAD_ARG_FROM_YA
00E147  1               ; ----------------------------------------------------------------------------
00E147  1               ; FAC = ARG / FAC
00E147  1               ; ----------------------------------------------------------------------------
00E147  1               FDIVT:
00E147  1  F0 68                beq     L3A02
00E149  1  20 34 E2             jsr     ROUND_FAC
00E14C  1  A9 00                lda     #$00
00E14E  1  38                   sec
00E14F  1  E5 AC                sbc     FAC
00E151  1  85 AC                sta     FAC
00E153  1  20 ED E0             jsr     ADD_EXPONENTS
00E156  1  E6 AC                inc     FAC
00E158  1  F0 BB                beq     JOV
00E15A  1  A2 FD                ldx     #-MANTISSA_BYTES+256
00E15C  1  A9 01                lda     #$01
00E15E  1               L39A1:
00E15E  1  A4 B4                ldy     ARG+1
00E160  1  C4 AD                cpy     FAC+1
00E162  1  D0 0A                bne     L39B7
00E164  1  A4 B5                ldy     ARG+2
00E166  1  C4 AE                cpy     FAC+2
00E168  1  D0 04                bne     L39B7
00E16A  1  A4 B6                ldy     ARG+3
00E16C  1  C4 AF                cpy     FAC+3
00E16E  1               L39B7:
00E16E  1  08                   php
00E16F  1  2A                   rol     a
00E170  1  90 09                bcc     L39C4
00E172  1  E8                   inx
00E173  1  95 77                sta     RESULT_LAST-1,x
00E175  1  F0 2A                beq     L39F2
00E177  1  10 2C                bpl     L39F6
00E179  1  A9 01                lda     #$01
00E17B  1               L39C4:
00E17B  1  28                   plp
00E17C  1  B0 0C                bcs     L39D5
00E17E  1               L39C7:
00E17E  1  06 B6                asl     ARG_LAST
00E180  1  26 B5                rol     ARG+2
00E182  1  26 B4                rol     ARG+1
00E184  1  B0 E8                bcs     L39B7
00E186  1  30 D6                bmi     L39A1
00E188  1  10 E4                bpl     L39B7
00E18A  1               L39D5:
00E18A  1  A8                   tay
00E18B  1  A5 B6                lda     ARG+3
00E18D  1  E5 AF                sbc     FAC+3
00E18F  1  85 B6                sta     ARG+3
00E191  1  A5 B5                lda     ARG+2
00E193  1  E5 AE                sbc     FAC+2
00E195  1  85 B5                sta     ARG+2
00E197  1  A5 B4                lda     ARG+1
00E199  1  E5 AD                sbc     FAC+1
00E19B  1  85 B4                sta     ARG+1
00E19D  1  98                   tya
00E19E  1  4C 7E E1             jmp     L39C7
00E1A1  1               L39F2:
00E1A1  1  A9 40                lda     #$40
00E1A3  1  D0 D6                bne     L39C4
00E1A5  1               L39F6:
00E1A5  1  0A                   asl     a
00E1A6  1  0A                   asl     a
00E1A7  1  0A                   asl     a
00E1A8  1  0A                   asl     a
00E1A9  1  0A                   asl     a
00E1AA  1  0A                   asl     a
00E1AB  1  85 B9                sta     FACEXTENSION
00E1AD  1  28                   plp
00E1AE  1  4C B6 E1             jmp     COPY_RESULT_INTO_FAC
00E1B1  1               L3A02:
00E1B1  1  A2 14                ldx     #ERR_ZERODIV
00E1B3  1  4C D4 CC             jmp     ERROR
00E1B6  1               ; ----------------------------------------------------------------------------
00E1B6  1               ; COPY RESULT INTO FAC MANTISSA, AND NORMALIZE
00E1B6  1               ; ----------------------------------------------------------------------------
00E1B6  1               COPY_RESULT_INTO_FAC:
00E1B6  1  A5 75                lda     RESULT
00E1B8  1  85 AD                sta     FAC+1
00E1BA  1  A5 76                lda     RESULT+1
00E1BC  1  85 AE                sta     FAC+2
00E1BE  1  A5 77                lda     RESULT+2
00E1C0  1  85 AF                sta     FAC+3
00E1C2  1  4C 4F DF             jmp     NORMALIZE_FAC2
00E1C5  1               ; ----------------------------------------------------------------------------
00E1C5  1               ; UNPACK (Y,A) INTO FAC
00E1C5  1               ; ----------------------------------------------------------------------------
00E1C5  1               LOAD_FAC_FROM_YA:
00E1C5  1  85 71                sta     INDEX
00E1C7  1  84 72                sty     INDEX+1
00E1C9  1  A0 03                ldy     #MANTISSA_BYTES
00E1CB  1  B1 71                lda     (INDEX),y
00E1CD  1  85 AF                sta     FAC+3
00E1CF  1  88                   dey
00E1D0  1  B1 71                lda     (INDEX),y
00E1D2  1  85 AE                sta     FAC+2
00E1D4  1  88                   dey
00E1D5  1  B1 71                lda     (INDEX),y
00E1D7  1  85 B0                sta     FACSIGN
00E1D9  1  09 80                ora     #$80
00E1DB  1  85 AD                sta     FAC+1
00E1DD  1  88                   dey
00E1DE  1  B1 71                lda     (INDEX),y
00E1E0  1  85 AC                sta     FAC
00E1E2  1  84 B9                sty     FACEXTENSION
00E1E4  1  60                   rts
00E1E5  1               ; ----------------------------------------------------------------------------
00E1E5  1               ; ROUND FAC, STORE IN TEMP2
00E1E5  1               ; ----------------------------------------------------------------------------
00E1E5  1               STORE_FAC_IN_TEMP2_ROUNDED:
00E1E5  1  A2 A8                ldx     #TEMP2
00E1E7  1  2C                   .byte   $2C
00E1E8  1               ; ----------------------------------------------------------------------------
00E1E8  1               ; ROUND FAC, STORE IN TEMP1
00E1E8  1               ; ----------------------------------------------------------------------------
00E1E8  1               STORE_FAC_IN_TEMP1_ROUNDED:
00E1E8  1  A2 A4                ldx     #TEMP1X
00E1EA  1  A0 00                ldy     #$00
00E1EC  1  F0 04                beq     STORE_FAC_AT_YX_ROUNDED
00E1EE  1               ; ----------------------------------------------------------------------------
00E1EE  1               ; ROUND FAC, AND STORE WHERE FORPNT POINTS
00E1EE  1               ; ----------------------------------------------------------------------------
00E1EE  1               SETFOR:
00E1EE  1  A6 97                ldx     FORPNT
00E1F0  1  A4 98                ldy     FORPNT+1
00E1F2  1               ; ----------------------------------------------------------------------------
00E1F2  1               ; ROUND FAC, AND STORE AT (Y,X)
00E1F2  1               ; ----------------------------------------------------------------------------
00E1F2  1               STORE_FAC_AT_YX_ROUNDED:
00E1F2  1  20 34 E2             jsr     ROUND_FAC
00E1F5  1  86 71                stx     INDEX
00E1F7  1  84 72                sty     INDEX+1
00E1F9  1  A0 03                ldy     #MANTISSA_BYTES
00E1FB  1  A5 AF                lda     FAC+3
00E1FD  1  91 71                sta     (INDEX),y
00E1FF  1  88                   dey
00E200  1  A5 AE                lda     FAC+2
00E202  1  91 71                sta     (INDEX),y
00E204  1  88                   dey
00E205  1  A5 B0                lda     FACSIGN
00E207  1  09 7F                ora     #$7F
00E209  1  25 AD                and     FAC+1
00E20B  1  91 71                sta     (INDEX),y
00E20D  1  88                   dey
00E20E  1  A5 AC                lda     FAC
00E210  1  91 71                sta     (INDEX),y
00E212  1  84 B9                sty     FACEXTENSION
00E214  1  60                   rts
00E215  1               ; ----------------------------------------------------------------------------
00E215  1               ; COPY ARG INTO FAC
00E215  1               ; ----------------------------------------------------------------------------
00E215  1               COPY_ARG_TO_FAC:
00E215  1  A5 B7                lda     ARGSIGN
00E217  1               MFA:
00E217  1  85 B0                sta     FACSIGN
00E219  1  A2 04                ldx     #BYTES_FP
00E21B  1               L3A7A:
00E21B  1  B5 B2                lda     SHIFTSIGNEXT,x
00E21D  1  95 AB                sta     EXPSGN,x
00E21F  1  CA                   dex
00E220  1  D0 F9                bne     L3A7A
00E222  1  86 B9                stx     FACEXTENSION
00E224  1  60                   rts
00E225  1               ; ----------------------------------------------------------------------------
00E225  1               ; ROUND FAC AND COPY TO ARG
00E225  1               ; ----------------------------------------------------------------------------
00E225  1               COPY_FAC_TO_ARG_ROUNDED:
00E225  1  20 34 E2             jsr     ROUND_FAC
00E228  1               MAF:
00E228  1  A2 05                ldx     #BYTES_FP+1
00E22A  1               L3A89:
00E22A  1  B5 AB                lda     EXPSGN,x
00E22C  1  95 B2                sta     SHIFTSIGNEXT,x
00E22E  1  CA                   dex
00E22F  1  D0 F9                bne     L3A89
00E231  1  86 B9                stx     FACEXTENSION
00E233  1               RTS14:
00E233  1  60                   rts
00E234  1               ; ----------------------------------------------------------------------------
00E234  1               ; ROUND FAC USING EXTENSION BYTE
00E234  1               ; ----------------------------------------------------------------------------
00E234  1               ROUND_FAC:
00E234  1  A5 AC                lda     FAC
00E236  1  F0 FB                beq     RTS14
00E238  1  06 B9                asl     FACEXTENSION
00E23A  1  90 F7                bcc     RTS14
00E23C  1               ; ----------------------------------------------------------------------------
00E23C  1               ; INCREMENT MANTISSA AND RE-NORMALIZE IF CARRY
00E23C  1               ; ----------------------------------------------------------------------------
00E23C  1               INCREMENT_MANTISSA:
00E23C  1  20 D3 DF             jsr     INCREMENT_FAC_MANTISSA
00E23F  1  D0 F2                bne     RTS14
00E241  1  4C A4 DF             jmp     NORMALIZE_FAC6
00E244  1               ; ----------------------------------------------------------------------------
00E244  1               ; TEST FAC FOR ZERO AND SIGN
00E244  1               ;
00E244  1               ; FAC > 0, RETURN +1
00E244  1               ; FAC = 0, RETURN  0
00E244  1               ; FAC < 0, RETURN -1
00E244  1               ; ----------------------------------------------------------------------------
00E244  1               SIGN:
00E244  1  A5 AC                lda     FAC
00E246  1  F0 09                beq     RTS15
00E248  1               L3AA7:
00E248  1  A5 B0                lda     FACSIGN
00E24A  1               SIGN2:
00E24A  1  2A                   rol     a
00E24B  1  A9 FF                lda     #$FF
00E24D  1  B0 02                bcs     RTS15
00E24F  1  A9 01                lda     #$01
00E251  1               RTS15:
00E251  1  60                   rts
00E252  1               ; ----------------------------------------------------------------------------
00E252  1               ; "SGN" FUNCTION
00E252  1               ; ----------------------------------------------------------------------------
00E252  1               SGN:
00E252  1  20 44 E2             jsr     SIGN
00E255  1               ; ----------------------------------------------------------------------------
00E255  1               ; CONVERT (A) INTO FAC, AS SIGNED VALUE -128 TO +127
00E255  1               ; ----------------------------------------------------------------------------
00E255  1               FLOAT:
00E255  1  85 AD                sta     FAC+1
00E257  1  A9 00                lda     #$00
00E259  1  85 AE                sta     FAC+2
00E25B  1  A2 88                ldx     #$88
00E25D  1               ; ----------------------------------------------------------------------------
00E25D  1               ; FLOAT UNSIGNED VALUE IN FAC+1,2
00E25D  1               ; (X) = EXPONENT
00E25D  1               ; ----------------------------------------------------------------------------
00E25D  1               FLOAT1:
00E25D  1  A5 AD                lda     FAC+1
00E25F  1  49 FF                eor     #$FF
00E261  1  2A                   rol     a
00E262  1               ; ----------------------------------------------------------------------------
00E262  1               ; FLOAT UNSIGNED VALUE IN FAC+1,2
00E262  1               ; (X) = EXPONENT
00E262  1               ; C=0 TO MAKE VALUE NEGATIVE
00E262  1               ; C=1 TO MAKE VALUE POSITIVE
00E262  1               ; ----------------------------------------------------------------------------
00E262  1               FLOAT2:
00E262  1  A9 00                lda     #$00
00E264  1  85 AF                sta     FAC+3
00E266  1  86 AC                stx     FAC
00E268  1  85 B9                sta     FACEXTENSION
00E26A  1  85 B0                sta     FACSIGN
00E26C  1  4C 4A DF             jmp     NORMALIZE_FAC1
00E26F  1               ; ----------------------------------------------------------------------------
00E26F  1               ; "ABS" FUNCTION
00E26F  1               ; ----------------------------------------------------------------------------
00E26F  1               ABS:
00E26F  1  46 B0                lsr     FACSIGN
00E271  1  60                   rts
00E272  1               ; ----------------------------------------------------------------------------
00E272  1               ; COMPARE FAC WITH PACKED # AT (Y,A)
00E272  1               ; RETURN A=1,0,-1 AS (Y,A) IS <,=,> FAC
00E272  1               ; ----------------------------------------------------------------------------
00E272  1               FCOMP:
00E272  1  85 73                sta     DEST
00E274  1               ; ----------------------------------------------------------------------------
00E274  1               ; SPECIAL ENTRY FROM "NEXT" PROCESSOR
00E274  1               ; "DEST" ALREADY SET UP
00E274  1               ; ----------------------------------------------------------------------------
00E274  1               FCOMP2:
00E274  1  84 74                sty     DEST+1
00E276  1  A0 00                ldy     #$00
00E278  1  B1 73                lda     (DEST),y
00E27A  1  C8                   iny
00E27B  1  AA                   tax
00E27C  1  F0 C6                beq     SIGN
00E27E  1  B1 73                lda     (DEST),y
00E280  1  45 B0                eor     FACSIGN
00E282  1  30 C4                bmi     L3AA7
00E284  1  E4 AC                cpx     FAC
00E286  1  D0 1A                bne     L3B0A
00E288  1  B1 73                lda     (DEST),y
00E28A  1  09 80                ora     #$80
00E28C  1  C5 AD                cmp     FAC+1
00E28E  1  D0 12                bne     L3B0A
00E290  1  C8                   iny
00E291  1  B1 73                lda     (DEST),y
00E293  1  C5 AE                cmp     FAC+2
00E295  1  D0 0B                bne     L3B0A
00E297  1  C8                   iny
00E298  1  A9 7F                lda     #$7F
00E29A  1  C5 B9                cmp     FACEXTENSION
00E29C  1  B1 73                lda     (DEST),y
00E29E  1  E5 AF                sbc     FAC_LAST
00E2A0  1  F0 28                beq     L3B32
00E2A2  1               L3B0A:
00E2A2  1  A5 B0                lda     FACSIGN
00E2A4  1  90 02                bcc     L3B10
00E2A6  1  49 FF                eor     #$FF
00E2A8  1               L3B10:
00E2A8  1  4C 4A E2             jmp     SIGN2
00E2AB  1               ; ----------------------------------------------------------------------------
00E2AB  1               ; QUICK INTEGER FUNCTION
00E2AB  1               ;
00E2AB  1               ; CONVERTS FP VALUE IN FAC TO INTEGER VALUE
00E2AB  1               ; IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
00E2AB  1               ; EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
00E2AB  1               ;
00E2AB  1               ; THIS SUBROUTINE ASSUMES THE EXPONENT < 32.
00E2AB  1               ; ----------------------------------------------------------------------------
00E2AB  1               QINT:
00E2AB  1  A5 AC                lda     FAC
00E2AD  1  F0 4A                beq     QINT3
00E2AF  1  38                   sec
00E2B0  1  E9 98                sbc     #120+8*BYTES_FP
00E2B2  1  24 B0                bit     FACSIGN
00E2B4  1  10 09                bpl     L3B27
00E2B6  1  AA                   tax
00E2B7  1  A9 FF                lda     #$FF
00E2B9  1  85 B2                sta     SHIFTSIGNEXT
00E2BB  1  20 B7 DF             jsr     COMPLEMENT_FAC_MANTISSA
00E2BE  1  8A                   txa
00E2BF  1               L3B27:
00E2BF  1  A2 AC                ldx     #FAC
00E2C1  1  C9 F9                cmp     #$F9
00E2C3  1  10 06                bpl     QINT2
00E2C5  1  20 F5 DF             jsr     SHIFT_RIGHT
00E2C8  1  84 B2                sty     SHIFTSIGNEXT
00E2CA  1               L3B32:
00E2CA  1  60                   rts
00E2CB  1               QINT2:
00E2CB  1  A8                   tay
00E2CC  1  A5 B0                lda     FACSIGN
00E2CE  1  29 80                and     #$80
00E2D0  1  46 AD                lsr     FAC+1
00E2D2  1  05 AD                ora     FAC+1
00E2D4  1  85 AD                sta     FAC+1
00E2D6  1  20 0C E0             jsr     SHIFT_RIGHT4
00E2D9  1  84 B2                sty     SHIFTSIGNEXT
00E2DB  1  60                   rts
00E2DC  1               ; ----------------------------------------------------------------------------
00E2DC  1               ; "INT" FUNCTION
00E2DC  1               ;
00E2DC  1               ; USES QINT TO CONVERT (FAC) TO INTEGER FORM,
00E2DC  1               ; AND THEN REFLOATS THE INTEGER.
00E2DC  1               ; ----------------------------------------------------------------------------
00E2DC  1               INT:
00E2DC  1  A5 AC                lda     FAC
00E2DE  1  C9 98                cmp     #120+8*BYTES_FP
00E2E0  1  B0 1E                bcs     RTS17
00E2E2  1  20 AB E2             jsr     QINT
00E2E5  1  84 B9                sty     FACEXTENSION
00E2E7  1  A5 B0                lda     FACSIGN
00E2E9  1  84 B0                sty     FACSIGN
00E2EB  1  49 80                eor     #$80
00E2ED  1  2A                   rol     a
00E2EE  1  A9 98                lda     #120+8*BYTES_FP
00E2F0  1  85 AC                sta     FAC
00E2F2  1  A5 AF                lda     FAC_LAST
00E2F4  1  85 5B                sta     CHARAC
00E2F6  1  4C 4A DF             jmp     NORMALIZE_FAC1
00E2F9  1               QINT3:
00E2F9  1  85 AD                sta     FAC+1
00E2FB  1  85 AE                sta     FAC+2
00E2FD  1  85 AF                sta     FAC+3
00E2FF  1  A8                   tay
00E300  1               RTS17:
00E300  1  60                   rts
00E301  1               ; ----------------------------------------------------------------------------
00E301  1               ; CONVERT STRING TO FP VALUE IN FAC
00E301  1               ;
00E301  1               ; STRING POINTED TO BY TXTPTR
00E301  1               ; FIRST CHAR ALREADY SCANNED BY CHRGET
00E301  1               ; (A) = FIRST CHAR, C=0 IF DIGIT.
00E301  1               ; ----------------------------------------------------------------------------
00E301  1               FIN:
00E301  1  A0 00                ldy     #$00
00E303  1  A2 09                ldx     #SERLEN-TMPEXP
00E305  1               L3B6F:
00E305  1  94 A8                sty     TMPEXP,x
00E307  1  CA                   dex
00E308  1  10 FB                bpl     L3B6F
00E30A  1  90 0F                bcc     FIN2
00E30C  1  C9 2D                cmp     #$2D
00E30E  1  D0 04                bne     L3B7E
00E310  1  86 B1                stx     SERLEN
00E312  1  F0 04                beq     FIN1
00E314  1               L3B7E:
00E314  1  C9 2B                cmp     #$2B
00E316  1  D0 05                bne     FIN3
00E318  1               FIN1:
00E318  1  20 D6 00             jsr     CHRGET
00E31B  1               FIN2:
00E31B  1  90 5B                bcc     FIN9
00E31D  1               FIN3:
00E31D  1  C9 2E                cmp     #$2E
00E31F  1  F0 2E                beq     FIN10
00E321  1  C9 45                cmp     #$45
00E323  1  D0 30                bne     FIN7
00E325  1  20 D6 00             jsr     CHRGET
00E328  1  90 17                bcc     FIN5
00E32A  1  C9 A4                cmp     #TOKEN_MINUS
00E32C  1  F0 0E                beq     L3BA6
00E32E  1  C9 2D                cmp     #$2D
00E330  1  F0 0A                beq     L3BA6
00E332  1  C9 A3                cmp     #TOKEN_PLUS
00E334  1  F0 08                beq     FIN4
00E336  1  C9 2B                cmp     #$2B
00E338  1  F0 04                beq     FIN4
00E33A  1  D0 07                bne     FIN6
00E33C  1               L3BA6:
00E33C  1  66 AB                ror     EXPSGN
00E33E  1               FIN4:
00E33E  1  20 D6 00             jsr     CHRGET
00E341  1               FIN5:
00E341  1  90 5C                bcc     GETEXP
00E343  1               FIN6:
00E343  1  24 AB                bit     EXPSGN
00E345  1  10 0E                bpl     FIN7
00E347  1  A9 00                lda     #$00
00E349  1  38                   sec
00E34A  1  E5 A9                sbc     EXPON
00E34C  1  4C 57 E3             jmp     FIN8
00E34F  1               ; ----------------------------------------------------------------------------
00E34F  1               ; FOUND A DECIMAL POINT
00E34F  1               ; ----------------------------------------------------------------------------
00E34F  1               FIN10:
00E34F  1  66 AA                ror     LOWTR
00E351  1  24 AA                bit     LOWTR
00E353  1  50 C3                bvc     FIN1
00E355  1               ; ----------------------------------------------------------------------------
00E355  1               ; NUMBER TERMINATED, ADJUST EXPONENT NOW
00E355  1               ; ----------------------------------------------------------------------------
00E355  1               FIN7:
00E355  1  A5 A9                lda     EXPON
00E357  1               FIN8:
00E357  1  38                   sec
00E358  1  E5 A8                sbc     INDX
00E35A  1  85 A9                sta     EXPON
00E35C  1  F0 12                beq     L3BEE
00E35E  1  10 09                bpl     L3BE7
00E360  1               L3BDE:
00E360  1  20 33 E1             jsr     DIV10
00E363  1  E6 A9                inc     EXPON
00E365  1  D0 F9                bne     L3BDE
00E367  1  F0 07                beq     L3BEE
00E369  1               L3BE7:
00E369  1  20 18 E1             jsr     MUL10
00E36C  1  C6 A9                dec     EXPON
00E36E  1  D0 F9                bne     L3BE7
00E370  1               L3BEE:
00E370  1  A5 B1                lda     SERLEN
00E372  1  30 01                bmi     L3BF3
00E374  1  60                   rts
00E375  1               L3BF3:
00E375  1  4C 69 E5             jmp     NEGOP
00E378  1               ; ----------------------------------------------------------------------------
00E378  1               ; ACCUMULATE A DIGIT INTO FAC
00E378  1               ; ----------------------------------------------------------------------------
00E378  1               FIN9:
00E378  1  48                   pha
00E379  1  24 AA                bit     LOWTR
00E37B  1  10 02                bpl     L3BFD
00E37D  1  E6 A8                inc     INDX
00E37F  1               L3BFD:
00E37F  1  20 18 E1             jsr     MUL10
00E382  1  68                   pla
00E383  1  38                   sec
00E384  1  E9 30                sbc     #$30
00E386  1  20 8C E3             jsr     ADDACC
00E389  1  4C 18 E3             jmp     FIN1
00E38C  1               ; ----------------------------------------------------------------------------
00E38C  1               ; ADD (A) TO FAC
00E38C  1               ; ----------------------------------------------------------------------------
00E38C  1               ADDACC:
00E38C  1  48                   pha
00E38D  1  20 25 E2             jsr     COPY_FAC_TO_ARG_ROUNDED
00E390  1  68                   pla
00E391  1  20 55 E2             jsr     FLOAT
00E394  1  A5 B7                lda     ARGSIGN
00E396  1  45 B0                eor     FACSIGN
00E398  1  85 B8                sta     SGNCPR
00E39A  1  A6 AC                ldx     FAC
00E39C  1  4C E9 DE             jmp     FADDT
00E39F  1               ; ----------------------------------------------------------------------------
00E39F  1               ; ACCUMULATE DIGIT OF EXPONENT
00E39F  1               ; ----------------------------------------------------------------------------
00E39F  1               GETEXP:
00E39F  1  A5 A9                lda     EXPON
00E3A1  1  C9 0A                cmp     #MAX_EXPON
00E3A3  1  90 09                bcc     L3C2C
00E3A5  1  A9 64                lda     #$64
00E3A7  1  24 AB                bit     EXPSGN
00E3A9  1  30 11                bmi     L3C3A
00E3AB  1  4C DE DF             jmp     OVERFLOW
00E3AE  1               L3C2C:
00E3AE  1  0A                   asl     a
00E3AF  1  0A                   asl     a
00E3B0  1  18                   clc
00E3B1  1  65 A9                adc     EXPON
00E3B3  1  0A                   asl     a
00E3B4  1  18                   clc
00E3B5  1  A0 00                ldy     #$00
00E3B7  1  71 DD                adc     (TXTPTR),y
00E3B9  1  38                   sec
00E3BA  1  E9 30                sbc     #$30
00E3BC  1               L3C3A:
00E3BC  1  85 A9                sta     EXPON
00E3BE  1  4C 3E E3             jmp     FIN4
00E3C1  1               ; ----------------------------------------------------------------------------
00E3C1  1               ; these values are /1000 of what the labels say
00E3C1  1               CON_99999999_9:
00E3C1  1  91 43 4F F8          .byte   $91,$43,$4F,$F8
00E3C5  1               CON_999999999:
00E3C5  1  94 74 23 F7  		.byte   $94,$74,$23,$F7
00E3C9  1               CON_BILLION:
00E3C9  1  94 74 24 00          .byte   $94,$74,$24,$00
00E3CD  1               ; ----------------------------------------------------------------------------
00E3CD  1               ; PRINT "IN <LINE #>"
00E3CD  1               ; ----------------------------------------------------------------------------
00E3CD  1               INPRT:
00E3CD  1  A9 8D                lda     #<QT_IN
00E3CF  1  A0 C1                ldy     #>QT_IN
00E3D1  1  20 E5 E3             jsr     GOSTROUT2
00E3D4  1  A5 88                lda     CURLIN+1
00E3D6  1  A6 87                ldx     CURLIN
00E3D8  1               ; ----------------------------------------------------------------------------
00E3D8  1               ; PRINT A,X AS DECIMAL INTEGER
00E3D8  1               ; ----------------------------------------------------------------------------
00E3D8  1               LINPRT:
00E3D8  1  85 AD                sta     FAC+1
00E3DA  1  86 AE                stx     FAC+2
00E3DC  1  A2 90                ldx     #$90
00E3DE  1  38                   sec
00E3DF  1  20 62 E2             jsr     FLOAT2
00E3E2  1  20 E8 E3             jsr     FOUT
00E3E5  1               GOSTROUT2:
00E3E5  1  4C 3D D3             jmp     STROUT
00E3E8  1               ; ----------------------------------------------------------------------------
00E3E8  1               ; CONVERT (FAC) TO STRING STARTING AT STACK
00E3E8  1               ; RETURN WITH (Y,A) POINTING AT STRING
00E3E8  1               ; ----------------------------------------------------------------------------
00E3E8  1               FOUT:
00E3E8  1  A0 01                ldy     #$01
00E3EA  1               ; ----------------------------------------------------------------------------
00E3EA  1               ; "STR$" FUNCTION ENTERS HERE, WITH (Y)=0
00E3EA  1               ; SO THAT RESULT STRING STARTS AT STACK-1
00E3EA  1               ; (THIS IS USED AS A FLAG)
00E3EA  1               ; ----------------------------------------------------------------------------
00E3EA  1               FOUT1:
00E3EA  1  A9 20                lda     #$20
00E3EC  1  24 B0                bit     FACSIGN
00E3EE  1  10 02                bpl     L3C73
00E3F0  1  A9 2D                lda     #$2D
00E3F2  1               L3C73:
00E3F2  1  99 FF 00             sta     $FF,y
00E3F5  1  85 B0                sta     FACSIGN
00E3F7  1  84 BA                sty     STRNG2
00E3F9  1  C8                   iny
00E3FA  1  A9 30                lda     #$30
00E3FC  1  A6 AC                ldx     FAC
00E3FE  1  D0 03                bne     L3C84
00E400  1  4C 03 E5             jmp     FOUT4
00E403  1               L3C84:
00E403  1  A9 00                lda     #$00
00E405  1  E0 80                cpx     #$80
00E407  1  F0 02                beq     L3C8C
00E409  1  B0 09                bcs     L3C95
00E40B  1               L3C8C:
00E40B  1  A9 C9                lda     #<CON_BILLION
00E40D  1  A0 E3                ldy     #>CON_BILLION
00E40F  1  20 75 E0             jsr     FMULT
00E412  1  A9 FA                lda     #-6+256 ; exponent adjustment
00E414  1               L3C95:
00E414  1  85 A8                sta     INDX
00E416  1               ; ----------------------------------------------------------------------------
00E416  1               ; ADJUST UNTIL 1E8 <= (FAC) <1E9
00E416  1               ; ----------------------------------------------------------------------------
00E416  1               L3C97:
00E416  1  A9 C5                lda     #<CON_999999999
00E418  1  A0 E3                ldy     #>CON_999999999
00E41A  1  20 72 E2             jsr     FCOMP
00E41D  1  F0 1E                beq     L3CBE
00E41F  1  10 12                bpl     L3CB4
00E421  1               L3CA2:
00E421  1  A9 C1                lda     #<CON_99999999_9
00E423  1  A0 E3                ldy     #>CON_99999999_9
00E425  1  20 72 E2             jsr     FCOMP
00E428  1  F0 02                beq     L3CAD
00E42A  1  10 0E                bpl     L3CBB
00E42C  1               L3CAD:
00E42C  1  20 18 E1             jsr     MUL10
00E42F  1  C6 A8                dec     INDX
00E431  1  D0 EE                bne     L3CA2
00E433  1               L3CB4:
00E433  1  20 33 E1             jsr     DIV10
00E436  1  E6 A8                inc     INDX
00E438  1  D0 DC                bne     L3C97
00E43A  1               L3CBB:
00E43A  1  20 C8 DE             jsr     FADDH
00E43D  1               L3CBE:
00E43D  1  20 AB E2             jsr     QINT
00E440  1               ; ----------------------------------------------------------------------------
00E440  1               ; FAC+1...FAC+4 IS NOW IN INTEGER FORM
00E440  1               ; WITH POWER OF TEN ADJUSTMENT IN TMPEXP
00E440  1               ;
00E440  1               ; IF -10 < TMPEXP > 1, PRINT IN DECIMAL FORM
00E440  1               ; OTHERWISE, PRINT IN EXPONENTIAL FORM
00E440  1               ; ----------------------------------------------------------------------------
00E440  1  A2 01                ldx     #$01
00E442  1  A5 A8                lda     INDX
00E444  1  18                   clc
00E445  1  69 07                adc     #3*BYTES_FP-5
00E447  1  30 09                bmi     L3CD3
00E449  1  C9 08                cmp     #3*BYTES_FP-4
00E44B  1  B0 06                bcs     L3CD4
00E44D  1  69 FF                adc     #$FF
00E44F  1  AA                   tax
00E450  1  A9 02                lda     #$02
00E452  1               L3CD3:
00E452  1  38                   sec
00E453  1               L3CD4:
00E453  1  E9 02                sbc     #$02
00E455  1  85 A9                sta     EXPON
00E457  1  86 A8                stx     INDX
00E459  1  8A                   txa
00E45A  1  F0 02                beq     L3CDF
00E45C  1  10 13                bpl     L3CF2
00E45E  1               L3CDF:
00E45E  1  A4 BA                ldy     STRNG2
00E460  1  A9 2E                lda     #$2E
00E462  1  C8                   iny
00E463  1  99 FF 00             sta     $FF,y
00E466  1  8A                   txa
00E467  1  F0 06                beq     L3CF0
00E469  1  A9 30                lda     #$30
00E46B  1  C8                   iny
00E46C  1  99 FF 00             sta     $FF,y
00E46F  1               L3CF0:
00E46F  1  84 BA                sty     STRNG2
00E471  1               ; ----------------------------------------------------------------------------
00E471  1               ; NOW DIVIDE BY POWERS OF TEN TO GET SUCCESSIVE DIGITS
00E471  1               ; ----------------------------------------------------------------------------
00E471  1               L3CF2:
00E471  1  A0 00                ldy     #$00
00E473  1  A2 80                ldx     #$80
00E475  1               L3CF6:
00E475  1  A5 AF                lda     FAC_LAST
00E477  1  18                   clc
00E478  1  79 16 E5             adc     DECTBL+2,y
00E47B  1  85 AF                sta     FAC+3
00E47D  1  A5 AE                lda     FAC+2
00E47F  1  79 15 E5             adc     DECTBL+1,y
00E482  1  85 AE                sta     FAC+2
00E484  1  A5 AD                lda     FAC+1
00E486  1  79 14 E5             adc     DECTBL,y
00E489  1  85 AD                sta     FAC+1
00E48B  1  E8                   inx
00E48C  1  B0 04                bcs     L3D1A
00E48E  1  10 E5                bpl     L3CF6
00E490  1  30 02                bmi     L3D1C
00E492  1               L3D1A:
00E492  1  30 E1                bmi     L3CF6
00E494  1               L3D1C:
00E494  1  8A                   txa
00E495  1  90 04                bcc     L3D23
00E497  1  49 FF                eor     #$FF
00E499  1  69 0A                adc     #$0A
00E49B  1               L3D23:
00E49B  1  69 2F                adc     #$2F
00E49D  1  C8                   iny
00E49E  1  C8                   iny
00E49F  1  C8                   iny
00E4A0  1  84 95                sty     VARPNT
00E4A2  1  A4 BA                ldy     STRNG2
00E4A4  1  C8                   iny
00E4A5  1  AA                   tax
00E4A6  1  29 7F                and     #$7F
00E4A8  1  99 FF 00             sta     $FF,y
00E4AB  1  C6 A8                dec     INDX
00E4AD  1  D0 06                bne     L3D3E
00E4AF  1  A9 2E                lda     #$2E
00E4B1  1  C8                   iny
00E4B2  1  99 FF 00             sta     $FF,y
00E4B5  1               L3D3E:
00E4B5  1  84 BA                sty     STRNG2
00E4B7  1  A4 95                ldy     VARPNT
00E4B9  1  8A                   txa
00E4BA  1  49 FF                eor     #$FF
00E4BC  1  29 80                and     #$80
00E4BE  1  AA                   tax
00E4BF  1  C0 12                cpy     #DECTBL_END-DECTBL
00E4C1  1  D0 B2                bne     L3CF6
00E4C3  1               ; ----------------------------------------------------------------------------
00E4C3  1               ; NINE DIGITS HAVE BEEN STORED IN STRING.  NOW LOOK
00E4C3  1               ; BACK AND LOP OFF TRAILING ZEROES AND A TRAILING
00E4C3  1               ; DECIMAL POINT.
00E4C3  1               ; ----------------------------------------------------------------------------
00E4C3  1  A4 BA                ldy     STRNG2
00E4C5  1               L3D4E:
00E4C5  1  B9 FF 00             lda     $FF,y
00E4C8  1  88                   dey
00E4C9  1  C9 30                cmp     #$30
00E4CB  1  F0 F8                beq     L3D4E
00E4CD  1  C9 2E                cmp     #$2E
00E4CF  1  F0 01                beq     L3D5B
00E4D1  1  C8                   iny
00E4D2  1               L3D5B:
00E4D2  1  A9 2B                lda     #$2B
00E4D4  1  A6 A9                ldx     EXPON
00E4D6  1  F0 2E                beq     L3D8F
00E4D8  1  10 08                bpl     L3D6B
00E4DA  1  A9 00                lda     #$00
00E4DC  1  38                   sec
00E4DD  1  E5 A9                sbc     EXPON
00E4DF  1  AA                   tax
00E4E0  1  A9 2D                lda     #$2D
00E4E2  1               L3D6B:
00E4E2  1  99 01 01             sta     STACK+1,y
00E4E5  1  A9 45                lda     #$45
00E4E7  1  99 00 01             sta     STACK,y
00E4EA  1  8A                   txa
00E4EB  1  A2 2F                ldx     #$2F
00E4ED  1  38                   sec
00E4EE  1               L3D77:
00E4EE  1  E8                   inx
00E4EF  1  E9 0A                sbc     #$0A
00E4F1  1  B0 FB                bcs     L3D77
00E4F3  1  69 3A                adc     #$3A
00E4F5  1  99 03 01             sta     STACK+3,y
00E4F8  1  8A                   txa
00E4F9  1  99 02 01             sta     STACK+2,y
00E4FC  1  A9 00                lda     #$00
00E4FE  1  99 04 01             sta     STACK+4,y
00E501  1  F0 08                beq     L3D94
00E503  1               FOUT4:
00E503  1  99 FF 00             sta     $FF,y
00E506  1               L3D8F:
00E506  1  A9 00                lda     #$00
00E508  1  99 00 01             sta     STACK,y
00E50B  1               L3D94:
00E50B  1  A9 00                lda     #$00
00E50D  1  A0 01                ldy     #$01
00E50F  1  60                   rts
00E510  1               ; ----------------------------------------------------------------------------
00E510  1               CON_HALF:
00E510  1  80 00 00 00          .byte   $80,$00,$00,$00
00E514  1               ; ----------------------------------------------------------------------------
00E514  1               ; POWERS OF 10 FROM 1E8 DOWN TO 1,
00E514  1               ; AS 32-BIT INTEGERS, WITH ALTERNATING SIGNS
00E514  1               ; ----------------------------------------------------------------------------
00E514  1               DECTBL:
00E514  1  FE 79 60             .byte   $FE,$79,$60 ; -100000
00E517  1  00 27 10     		.byte	$00,$27,$10 ; 10000
00E51A  1  FF FC 18     		.byte	$FF,$FC,$18 ; -1000
00E51D  1  00 00 64     		.byte	$00,$00,$64 ; 100
00E520  1  FF FF F6     		.byte	$FF,$FF,$F6 ; -10
00E523  1  00 00 01     		.byte	$00,$00,$01 ; 1
00E526  1               DECTBL_END:
00E526  1               ; ----------------------------------------------------------------------------
00E526  1               ; "SQR" FUNCTION
00E526  1               ; ----------------------------------------------------------------------------
00E526  1               SQR:
00E526  1  20 25 E2             jsr     COPY_FAC_TO_ARG_ROUNDED
00E529  1  A9 10                lda     #<CON_HALF
00E52B  1  A0 E5                ldy     #>CON_HALF
00E52D  1  20 C5 E1             jsr     LOAD_FAC_FROM_YA
00E530  1               ; ----------------------------------------------------------------------------
00E530  1               ; EXPONENTIATION OPERATION
00E530  1               ;
00E530  1               ; ARG ^ FAC  =  EXP( LOG(ARG) * FAC )
00E530  1               ; ----------------------------------------------------------------------------
00E530  1               FPWRT:
00E530  1  F0 63                beq     EXP
00E532  1  A5 B3                lda     ARG
00E534  1  D0 03                bne     L3DD5
00E536  1  4C 6D DF             jmp     STA_IN_FAC_SIGN_AND_EXP
00E539  1               L3DD5:
00E539  1  A2 9C                ldx     #TEMP3
00E53B  1  A0 00                ldy     #$00
00E53D  1  20 F2 E1             jsr     STORE_FAC_AT_YX_ROUNDED
00E540  1  A5 B7                lda     ARGSIGN
00E542  1  10 0F                bpl     L3DEF
00E544  1  20 DC E2             jsr     INT
00E547  1  A9 9C                lda     #TEMP3
00E549  1  A0 00                ldy     #$00
00E54B  1  20 72 E2             jsr     FCOMP
00E54E  1  D0 03                bne     L3DEF
00E550  1  98                   tya
00E551  1  A4 5B                ldy     CHARAC
00E553  1               L3DEF:
00E553  1  20 17 E2             jsr     MFA
00E556  1  98                   tya
00E557  1  48                   pha
00E558  1  20 37 E0             jsr     LOG
00E55B  1  A9 9C                lda     #TEMP3
00E55D  1  A0 00                ldy     #$00
00E55F  1  20 75 E0             jsr     FMULT
00E562  1  20 95 E5             jsr     EXP
00E565  1  68                   pla
00E566  1  4A                   lsr     a
00E567  1  90 0A                bcc     L3E0F
00E569  1               ; ----------------------------------------------------------------------------
00E569  1               ; NEGATE VALUE IN FAC
00E569  1               ; ----------------------------------------------------------------------------
00E569  1               NEGOP:
00E569  1  A5 AC                lda     FAC
00E56B  1  F0 06                beq     L3E0F
00E56D  1  A5 B0                lda     FACSIGN
00E56F  1  49 FF                eor     #$FF
00E571  1  85 B0                sta     FACSIGN
00E573  1               L3E0F:
00E573  1  60                   rts
00E574  1               ; ----------------------------------------------------------------------------
00E574  1               CON_LOG_E:
00E574  1  81 38 AA 3B          .byte   $81,$38,$AA,$3B
00E578  1               POLY_EXP:
00E578  1  06           		.byte	$06
00E579  1  74 63 90 8C  		.byte	$74,$63,$90,$8C
00E57D  1  77 23 0C AB  		.byte	$77,$23,$0C,$AB
00E581  1  7A 1E 94 00  		.byte	$7A,$1E,$94,$00
00E585  1  7C 63 42 80  		.byte	$7C,$63,$42,$80
00E589  1  7E 75 FE D0  		.byte	$7E,$75,$FE,$D0
00E58D  1  80 31 72 15  		.byte	$80,$31,$72,$15
00E591  1  81 00 00 00  		.byte	$81,$00,$00,$00
00E595  1               ; ----------------------------------------------------------------------------
00E595  1               ; "EXP" FUNCTION
00E595  1               ;
00E595  1               ; FAC = E ^ FAC
00E595  1               ; ----------------------------------------------------------------------------
00E595  1               EXP:
00E595  1  A9 74                lda     #<CON_LOG_E
00E597  1  A0 E5                ldy     #>CON_LOG_E
00E599  1  20 75 E0             jsr     FMULT
00E59C  1  A5 B9                lda     FACEXTENSION
00E59E  1  69 50                adc     #$50
00E5A0  1  90 03                bcc     L3E4E
00E5A2  1  20 3C E2             jsr     INCREMENT_MANTISSA
00E5A5  1               L3E4E:
00E5A5  1  85 A3                sta     ARGEXTENSION
00E5A7  1  20 28 E2             jsr     MAF
00E5AA  1  A5 AC                lda     FAC
00E5AC  1  C9 88                cmp     #$88
00E5AE  1  90 03                bcc     L3E5C
00E5B0  1               L3E59:
00E5B0  1  20 0A E1             jsr     OUTOFRNG
00E5B3  1               L3E5C:
00E5B3  1  20 DC E2             jsr     INT
00E5B6  1  A5 5B                lda     CHARAC
00E5B8  1  18                   clc
00E5B9  1  69 81                adc     #$81
00E5BB  1  F0 F3                beq     L3E59
00E5BD  1  38                   sec
00E5BE  1  E9 01                sbc     #$01
00E5C0  1  48                   pha
00E5C1  1  A2 04                ldx     #BYTES_FP
00E5C3  1               L3E6C:
00E5C3  1  B5 B3                lda     ARG,x
00E5C5  1  B4 AC                ldy     FAC,x
00E5C7  1  95 AC                sta     FAC,x
00E5C9  1  94 B3                sty     ARG,x
00E5CB  1  CA                   dex
00E5CC  1  10 F5                bpl     L3E6C
00E5CE  1  A5 A3                lda     ARGEXTENSION
00E5D0  1  85 B9                sta     FACEXTENSION
00E5D2  1  20 D2 DE             jsr     FSUBT
00E5D5  1  20 69 E5             jsr     NEGOP
00E5D8  1  A9 78                lda     #<POLY_EXP
00E5DA  1  A0 E5                ldy     #>POLY_EXP
00E5DC  1  20 FE E5             jsr     POLYNOMIAL
00E5DF  1  A9 00                lda     #$00
00E5E1  1  85 B8                sta     SGNCPR
00E5E3  1  68                   pla
00E5E4  1  20 EF E0             jsr     ADD_EXPONENTS1
00E5E7  1  60                   rts
00E5E8  1               ; ----------------------------------------------------------------------------
00E5E8  1               ; ODD POLYNOMIAL SUBROUTINE
00E5E8  1               ;
00E5E8  1               ; F(X) = X * P(X^2)
00E5E8  1               ;
00E5E8  1               ; WHERE:  X IS VALUE IN FAC
00E5E8  1               ;	Y,A POINTS AT COEFFICIENT TABLE
00E5E8  1               ;	FIRST BYTE OF COEFF. TABLE IS N
00E5E8  1               ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
00E5E8  1               ;
00E5E8  1               ; P(X^2) COMPUTED USING NORMAL POLYNOMIAL SUBROUTINE
00E5E8  1               ; ----------------------------------------------------------------------------
00E5E8  1               POLYNOMIAL_ODD:
00E5E8  1  85 BA                sta     STRNG2
00E5EA  1  84 BB                sty     STRNG2+1
00E5EC  1  20 E8 E1             jsr     STORE_FAC_IN_TEMP1_ROUNDED
00E5EF  1  A9 A4                lda     #TEMP1X
00E5F1  1  20 75 E0             jsr     FMULT
00E5F4  1  20 02 E6             jsr     SERMAIN
00E5F7  1  A9 A4                lda     #TEMP1X
00E5F9  1  A0 00                ldy     #$00
00E5FB  1  4C 75 E0             jmp     FMULT
00E5FE  1               ; ----------------------------------------------------------------------------
00E5FE  1               ; NORMAL POLYNOMIAL SUBROUTINE
00E5FE  1               ;
00E5FE  1               ; P(X) = C(0)*X^N + C(1)*X^(N-1) + ... + C(N)
00E5FE  1               ;
00E5FE  1               ; WHERE:  X IS VALUE IN FAC
00E5FE  1               ;	Y,A POINTS AT COEFFICIENT TABLE
00E5FE  1               ;	FIRST BYTE OF COEFF. TABLE IS N
00E5FE  1               ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
00E5FE  1               ; ----------------------------------------------------------------------------
00E5FE  1               POLYNOMIAL:
00E5FE  1  85 BA                sta     STRNG2
00E600  1  84 BB                sty     STRNG2+1
00E602  1               SERMAIN:
00E602  1  20 E5 E1             jsr     STORE_FAC_IN_TEMP2_ROUNDED
00E605  1  B1 BA                lda     (STRNG2),y
00E607  1  85 B1                sta     SERLEN
00E609  1  A4 BA                ldy     STRNG2
00E60B  1  C8                   iny
00E60C  1  98                   tya
00E60D  1  D0 02                bne     L3EBA
00E60F  1  E6 BB                inc     STRNG2+1
00E611  1               L3EBA:
00E611  1  85 BA                sta     STRNG2
00E613  1  A4 BB                ldy     STRNG2+1
00E615  1               L3EBE:
00E615  1  20 75 E0             jsr     FMULT
00E618  1  A5 BA                lda     STRNG2
00E61A  1  A4 BB                ldy     STRNG2+1
00E61C  1  18                   clc
00E61D  1  69 04                adc     #BYTES_FP
00E61F  1  90 01                bcc     L3ECB
00E621  1  C8                   iny
00E622  1               L3ECB:
00E622  1  85 BA                sta     STRNG2
00E624  1  84 BB                sty     STRNG2+1
00E626  1  20 E6 DE             jsr     FADD
00E629  1  A9 A8                lda     #TEMP2
00E62B  1  A0 00                ldy     #$00
00E62D  1  C6 B1                dec     SERLEN
00E62F  1  D0 E4                bne     L3EBE
00E631  1               RTS19:
00E631  1  60                   rts
00E632  1               ; ----------------------------------------------------------------------------
00E632  1               ; "RND" FUNCTION
00E632  1               ; ----------------------------------------------------------------------------
00E632  1               CONRND1:
00E632  1  98 35 44 7A          .byte   $98,$35,$44,$7A
00E636  1               CONRND2:
00E636  1  68 28 B1 46          .byte   $68,$28,$B1,$46
00E63A  1               RND:
00E63A  1  20 44 E2             jsr     SIGN
00E63D  1  AA                   tax
00E63E  1  30 18                bmi     L3F01
00E640  1  A9 EE                lda     #<RNDSEED
00E642  1  A0 00                ldy     #>RNDSEED
00E644  1  20 C5 E1             jsr     LOAD_FAC_FROM_YA
00E647  1  8A                   txa
00E648  1  F0 E7                beq     RTS19
00E64A  1  A9 32                lda     #<CONRND1
00E64C  1  A0 E6                ldy     #>CONRND1
00E64E  1  20 75 E0             jsr     FMULT
00E651  1  A9 36                lda     #<CONRND2
00E653  1  A0 E6                ldy     #>CONRND2
00E655  1  20 E6 DE             jsr     FADD
00E658  1               L3F01:
00E658  1  A6 AF                ldx     FAC_LAST
00E65A  1  A5 AD                lda     FAC+1
00E65C  1  85 AF                sta     FAC_LAST
00E65E  1  86 AD                stx     FAC+1
00E660  1  A9 00                lda     #$00
00E662  1  85 B0                sta     FACSIGN
00E664  1  A5 AC                lda     FAC
00E666  1  85 B9                sta     FACEXTENSION
00E668  1  A9 80                lda     #$80
00E66A  1  85 AC                sta     FAC
00E66C  1  20 4F DF             jsr     NORMALIZE_FAC2
00E66F  1  A2 EE                ldx     #<RNDSEED
00E671  1  A0 00                ldy     #>RNDSEED
00E673  1               GOMOVMF:
00E673  1  4C F2 E1             jmp     STORE_FAC_AT_YX_ROUNDED
00E676  1               ; ----------------------------------------------------------------------------
00E676  1               ; "COS" FUNCTION
00E676  1               ; ----------------------------------------------------------------------------
00E676  1               COS:
00E676  1  A9 F2                lda     #<CON_PI_HALF
00E678  1  A0 E6                ldy     #>CON_PI_HALF
00E67A  1  20 E6 DE             jsr     FADD
00E67D  1               ; ----------------------------------------------------------------------------
00E67D  1               ; "SIN" FUNCTION
00E67D  1               ; ----------------------------------------------------------------------------
00E67D  1               SIN:
00E67D  1  20 25 E2             jsr     COPY_FAC_TO_ARG_ROUNDED
00E680  1  A9 F6                lda     #<CON_PI_DOUB
00E682  1  A0 E6                ldy     #>CON_PI_DOUB
00E684  1  A6 B7                ldx     ARGSIGN
00E686  1  20 3C E1             jsr     DIV
00E689  1  20 25 E2             jsr     COPY_FAC_TO_ARG_ROUNDED
00E68C  1  20 DC E2             jsr     INT
00E68F  1  A9 00                lda     #$00
00E691  1  85 B8                sta     STRNG1
00E693  1  20 D2 DE             jsr     FSUBT
00E696  1               ; ----------------------------------------------------------------------------
00E696  1               ; (FAC) = ANGLE AS A FRACTION OF A FULL CIRCLE
00E696  1               ;
00E696  1               ; NOW FOLD THE RANGE INTO A QUARTER CIRCLE
00E696  1               ;
00E696  1               ; <<< THERE ARE MUCH SIMPLER WAYS TO DO THIS >>>
00E696  1               ; ----------------------------------------------------------------------------
00E696  1  A9 FA                lda     #<QUARTER
00E698  1  A0 E6                ldy     #>QUARTER
00E69A  1  20 CF DE             jsr     FSUB
00E69D  1  A5 B0                lda     FACSIGN
00E69F  1  48                   pha
00E6A0  1  10 0D                bpl     SIN1
00E6A2  1  20 C8 DE             jsr     FADDH
00E6A5  1  A5 B0                lda     FACSIGN
00E6A7  1  30 09                bmi     L3F5B
00E6A9  1  A5 63                lda     CPRMASK
00E6AB  1  49 FF                eor     #$FF
00E6AD  1  85 63                sta     CPRMASK
00E6AF  1               ; ----------------------------------------------------------------------------
00E6AF  1               ; IF FALL THRU, RANGE IS 0...1/2
00E6AF  1               ; IF BRANCH HERE, RANGE IS 0...1/4
00E6AF  1               ; ----------------------------------------------------------------------------
00E6AF  1               SIN1:
00E6AF  1  20 69 E5             jsr     NEGOP
00E6B2  1               ; ----------------------------------------------------------------------------
00E6B2  1               ; IF FALL THRU, RANGE IS -1/2...0
00E6B2  1               ; IF BRANCH HERE, RANGE IS -1/4...0
00E6B2  1               ; ----------------------------------------------------------------------------
00E6B2  1               L3F5B:
00E6B2  1  A9 FA                lda     #<QUARTER
00E6B4  1  A0 E6                ldy     #>QUARTER
00E6B6  1  20 E6 DE             jsr     FADD
00E6B9  1  68                   pla
00E6BA  1  10 03                bpl     L3F68
00E6BC  1  20 69 E5             jsr     NEGOP
00E6BF  1               L3F68:
00E6BF  1  A9 FE                lda     #<POLY_SIN
00E6C1  1  A0 E6                ldy     #>POLY_SIN
00E6C3  1  4C E8 E5             jmp     POLYNOMIAL_ODD
00E6C6  1               ; ----------------------------------------------------------------------------
00E6C6  1               ; "TAN" FUNCTION
00E6C6  1               ;
00E6C6  1               ; COMPUTE TAN(X) = SIN(X) / COS(X)
00E6C6  1               ; ----------------------------------------------------------------------------
00E6C6  1               TAN:
00E6C6  1  20 E8 E1             jsr     STORE_FAC_IN_TEMP1_ROUNDED
00E6C9  1  A9 00                lda     #$00
00E6CB  1  85 63                sta     CPRMASK
00E6CD  1  20 7D E6             jsr     SIN
00E6D0  1  A2 9C                ldx     #TEMP3
00E6D2  1  A0 00                ldy     #$00
00E6D4  1  20 73 E6             jsr     GOMOVMF
00E6D7  1  A9 A4                lda     #TEMP1+(5-BYTES_FP)
00E6D9  1  A0 00                ldy     #$00
00E6DB  1  20 C5 E1             jsr     LOAD_FAC_FROM_YA
00E6DE  1  A9 00                lda     #$00
00E6E0  1  85 B0                sta     FACSIGN
00E6E2  1  A5 63                lda     CPRMASK
00E6E4  1  20 EE E6             jsr     TAN1
00E6E7  1  A9 9C                lda     #TEMP3
00E6E9  1  A0 00                ldy     #$00
00E6EB  1  4C 44 E1             jmp     FDIV
00E6EE  1               TAN1:
00E6EE  1  48                   pha
00E6EF  1  4C AF E6             jmp     SIN1
00E6F2  1               ; ----------------------------------------------------------------------------
00E6F2  1               CON_PI_HALF:
00E6F2  1  81 49 0F DB          .byte   $81,$49,$0F,$DB
00E6F6  1               CON_PI_DOUB:
00E6F6  1  83 49 0F DB          .byte   $83,$49,$0F,$DB
00E6FA  1               QUARTER:
00E6FA  1  7F 00 00 00          .byte   $7F,$00,$00,$00
00E6FE  1               POLY_SIN:
00E6FE  1  04 86 1E D7          .byte   $04,$86,$1E,$D7,$FB,$87,$99,$26
00E702  1  FB 87 99 26  
00E706  1  65 87 23 34          .byte   $65,$87,$23,$34,$58,$86,$A5,$5D
00E70A  1  58 86 A5 5D  
00E70E  1  E1 83 49 0F          .byte   $E1,$83,$49,$0F,$DB
00E712  1  DB           
00E713  1               
00E713  1               ; ----------------------------------------------------------------------------
00E713  1               ; "ATN" FUNCTION
00E713  1               ; ----------------------------------------------------------------------------
00E713  1               ATN:
00E713  1  A5 B0                lda     FACSIGN
00E715  1  48                   pha
00E716  1  10 03                bpl     L3FDB
00E718  1  20 69 E5             jsr     NEGOP
00E71B  1               L3FDB:
00E71B  1  A5 AC                lda     FAC
00E71D  1  48                   pha
00E71E  1  C9 81                cmp     #$81
00E720  1  90 07                bcc     L3FE9
00E722  1  A9 16                lda     #<CON_ONE
00E724  1  A0 E0                ldy     #>CON_ONE
00E726  1  20 44 E1             jsr     FDIV
00E729  1               ; ----------------------------------------------------------------------------
00E729  1               ; 0 <= X <= 1
00E729  1               ; 0 <= ATN(X) <= PI/8
00E729  1               ; ----------------------------------------------------------------------------
00E729  1               L3FE9:
00E729  1  A9 43                lda     #<POLY_ATN
00E72B  1  A0 E7                ldy     #>POLY_ATN
00E72D  1  20 E8 E5             jsr     POLYNOMIAL_ODD
00E730  1  68                   pla
00E731  1  C9 81                cmp     #$81
00E733  1  90 07                bcc     L3FFC
00E735  1  A9 F2                lda     #<CON_PI_HALF
00E737  1  A0 E6                ldy     #>CON_PI_HALF
00E739  1  20 CF DE             jsr     FSUB
00E73C  1               L3FFC:
00E73C  1  68                   pla
00E73D  1  10 03                bpl     L4002
00E73F  1  4C 69 E5             jmp     NEGOP
00E742  1               L4002:
00E742  1  60                   rts
00E743  1               ; ----------------------------------------------------------------------------
00E743  1               POLY_ATN:
00E743  1  08                   .byte   $08
00E744  1  78 3A C5 37  		.byte	$78,$3A,$C5,$37
00E748  1  7B 83 A2 5C  		.byte	$7B,$83,$A2,$5C
00E74C  1  7C 2E DD 4D  		.byte	$7C,$2E,$DD,$4D
00E750  1  7D 99 B0 1E  		.byte	$7D,$99,$B0,$1E
00E754  1  7D 59 ED 24  		.byte	$7D,$59,$ED,$24
00E758  1  7E 91 72 00  		.byte	$7E,$91,$72,$00
00E75C  1  7E 4C B9 73  		.byte	$7E,$4C,$B9,$73
00E760  1  7F AA AA 53  		.byte	$7F,$AA,$AA,$53
00E764  1  81 00 00 00  		.byte	$81,$00,$00,$00
00E768  1               GENERIC_CHRGET:
00E768  1  E6 DD                inc     TXTPTR
00E76A  1  D0 02                bne     GENERIC_CHRGOT
00E76C  1  E6 DE                inc     TXTPTR+1
00E76E  1               GENERIC_CHRGOT:
00E76E  1               GENERIC_TXTPTR = GENERIC_CHRGOT + 1
00E76E  1  AD 60 EA             lda     $EA60
00E771  1  C9 3A                cmp     #$3A
00E773  1  B0 0A                bcs     L4058
00E775  1               GENERIC_CHRGOT2:
00E775  1  C9 20                cmp     #$20
00E777  1  F0 EF                beq     GENERIC_CHRGET
00E779  1  38                   sec
00E77A  1  E9 30                sbc     #$30
00E77C  1  38                   sec
00E77D  1  E9 D0                sbc     #$D0
00E77F  1               L4058:
00E77F  1  60                   rts
00E780  1               GENERIC_RNDSEED:
00E780  1               ; random number seed
00E780  1  80 4F C7 52          .byte   $80,$4F,$C7,$52
00E784  1               GENERIC_CHRGET_END:
00E784  1               ; ----------------------------------------------------------------------------
00E784  1               PR_WRITTEN_BY:
00E784  1  A9 C8                lda     #<QT_WRITTEN_BY
00E786  1  A0 E8                ldy     #>QT_WRITTEN_BY
00E788  1  20 3D D3             jsr     STROUT
00E78B  1               COLD_START:
00E78B  1  A2 FF                ldx     #$FF
00E78D  1  86 88                stx     CURLIN+1
00E78F  1  9A                   txs
00E790  1  A9 8B                lda     #<COLD_START
00E792  1  A0 E7                ldy     #>COLD_START
00E794  1  85 08                sta     GORESTART+1
00E796  1  84 09                sty     GORESTART+2
00E798  1  85 0B                sta     GOSTROUT+1
00E79A  1  84 0C                sty     GOSTROUT+2
00E79C  1  A9 7F                lda     #<AYINT
00E79E  1  A0 D8                ldy     #>AYINT
00E7A0  1  85 0D                sta     GOAYINT
00E7A2  1  84 0E                sty     GOAYINT+1
00E7A4  1  A9 3B                lda     #<GIVAYF
00E7A6  1  A0 DA                ldy     #>GIVAYF
00E7A8  1  85 0F                sta     GOGIVEAYF
00E7AA  1  84 10                sty     GOGIVEAYF+1
00E7AC  1  A9 4C                lda     #$4C
00E7AE  1  85 07                sta     GORESTART
00E7B0  1  85 0A                sta     GOSTROUT
00E7B2  1  85 A1                sta     JMPADRS
00E7B4  1  85 0A                sta     USR
00E7B6  1  A9 02                lda     #<IQERR
00E7B8  1  A0 D9                ldy     #>IQERR
00E7BA  1  85 0B                sta     USR+1
00E7BC  1  84 0C                sty     USR+2
00E7BE  1  A9 48                lda     #WIDTH
00E7C0  1  85 0F                sta     Z17
00E7C2  1  A9 38                lda     #WIDTH2
00E7C4  1  85 10                sta     Z18
00E7C6  1  A2 1C                ldx     #GENERIC_CHRGET_END-GENERIC_CHRGET
00E7C8  1               L4098:
00E7C8  1  BD 67 E7             lda     GENERIC_CHRGET-1,x
00E7CB  1  95 D5                sta     CHRGET-1,x
00E7CD  1  CA                   dex
00E7CE  1  D0 F8                bne     L4098
00E7D0  1  8A                   txa
00E7D1  1  85 B2                sta     SHIFTSIGNEXT
00E7D3  1  85 67                sta     LASTPT+1
00E7D5  1  85 0D                sta     Z15
00E7D7  1  85 0E                sta     POSX
00E7D9  1  48                   pha
00E7DA  1  85 64                sta     Z14
00E7DC  1  A9 03                lda     #$03
00E7DE  1  85 A0                sta     DSCLEN
00E7E0  1  A9 2C                lda     #$2C
00E7E2  1  85 12                sta     LINNUM+1
00E7E4  1  20 E6 D2             jsr     CRDO
00E7E7  1  A2 68                ldx     #TEMPST
00E7E9  1  86 65                stx     TEMPPT
00E7EB  1  A9 EC                lda     #<QT_MEMORY_SIZE
00E7ED  1  A0 E8                ldy     #>QT_MEMORY_SIZE
00E7EF  1  20 3D D3             jsr     STROUT
00E7F2  1  20 C0 D3             jsr     NXIN
00E7F5  1  86 DD                stx     TXTPTR
00E7F7  1  84 DE                sty     TXTPTR+1
00E7F9  1  20 D6 00             jsr     CHRGET
00E7FC  1  C9 41                cmp     #$41
00E7FE  1  F0 84                beq     PR_WRITTEN_BY
00E800  1  A8                   tay
00E801  1  D0 21                bne     L40EE
00E803  1  A9 00                lda     #<RAMSTART2
00E805  1  A0 06                ldy     #>RAMSTART2
00E807  1  85 11                sta     LINNUM
00E809  1  84 12                sty     LINNUM+1
00E80B  1  A0 00                ldy     #$00
00E80D  1               L40D7:
00E80D  1  E6 11                inc     LINNUM
00E80F  1  D0 02                bne     L40DD
00E811  1  E6 12                inc     LINNUM+1
00E813  1               L40DD:
00E813  1  A9 92                lda     #$92 ; 10010010 / 00100100
00E815  1  91 11                sta     (LINNUM),y
00E817  1  D1 11                cmp     (LINNUM),y
00E819  1  D0 15                bne     L40FA
00E81B  1  0A                   asl     a
00E81C  1  91 11                sta     (LINNUM),y
00E81E  1  D1 11                cmp     (LINNUM),y
00E820  1  F0 EB                beq     L40D7; old: faster
00E822  1  D0 0C                bne     L40FA
00E824  1               L40EE:
00E824  1  20 DC 00             jsr     CHRGOT
00E827  1  20 F9 D1             jsr     LINGET
00E82A  1  A8                   tay
00E82B  1  F0 03                beq     L40FA
00E82D  1  4C 86 D6             jmp     SYNERR
00E830  1               L40FA:
00E830  1  A5 11                lda     LINNUM
00E832  1  A4 12                ldy     LINNUM+1
00E834  1  85 85                sta     MEMSIZ
00E836  1  84 86                sty     MEMSIZ+1
00E838  1  85 81                sta     FRETOP
00E83A  1  84 82                sty     FRETOP+1
00E83C  1               L4106:
00E83C  1  A9 FA                lda     #<QT_TERMINAL_WIDTH
00E83E  1  A0 E8                ldy     #>QT_TERMINAL_WIDTH
00E840  1  20 3D D3             jsr     STROUT
00E843  1  20 C0 D3             jsr     NXIN
00E846  1  86 DD                stx     TXTPTR
00E848  1  84 DE                sty     TXTPTR+1
00E84A  1  20 D6 00             jsr     CHRGET
00E84D  1  A8                   tay
00E84E  1  F0 1C                beq     L4136
00E850  1  20 F9 D1             jsr     LINGET
00E853  1  A5 12                lda     LINNUM+1
00E855  1  D0 E5                bne     L4106
00E857  1  A5 11                lda     LINNUM
00E859  1  C9 10                cmp     #$10
00E85B  1  90 DF                bcc     L4106
00E85D  1  85 0F                sta     Z17
00E85F  1               L4129:
00E85F  1  E9 0E                sbc     #$0E
00E861  1  B0 FC                bcs     L4129
00E863  1  49 FF                eor     #$FF
00E865  1  E9 0C                sbc     #$0C
00E867  1  18                   clc
00E868  1  65 0F                adc     Z17
00E86A  1  85 10                sta     Z18
00E86C  1               L4136:
00E86C  1  A2 00                ldx     #<RAMSTART2
00E86E  1  A0 06                ldy     #>RAMSTART2
00E870  1  86 79                stx     TXTTAB
00E872  1  84 7A                sty     TXTTAB+1
00E874  1  A0 00                ldy     #$00
00E876  1  98                   tya
00E877  1  91 79                sta     (TXTTAB),y
00E879  1  E6 79                inc     TXTTAB
00E87B  1  D0 02                bne     L4192
00E87D  1  E6 7A                inc     TXTTAB+1
00E87F  1               L4192:
00E87F  1  A5 79                lda     TXTTAB
00E881  1  A4 7A                ldy     TXTTAB+1
00E883  1  20 A5 CC             jsr     REASON
00E886  1  20 E6 D2             jsr     CRDO
00E889  1  A5 85                lda     MEMSIZ
00E88B  1  38                   sec
00E88C  1  E5 79                sbc     TXTTAB
00E88E  1  AA                   tax
00E88F  1  A5 86                lda     MEMSIZ+1
00E891  1  E5 7A                sbc     TXTTAB+1
00E893  1  20 D8 E3             jsr     LINPRT
00E896  1  A9 09                lda     #<QT_BYTES_FREE
00E898  1  A0 E9                ldy     #>QT_BYTES_FREE
00E89A  1  20 3D D3             jsr     STROUT
00E89D  1  A9 3D                lda     #<STROUT
00E89F  1  A0 D3                ldy     #>STROUT
00E8A1  1  85 0B                sta     GOSTROUT+1
00E8A3  1  84 0C                sty     GOSTROUT+2
00E8A5  1  20 E9 CE             jsr     SCRTCH
00E8A8  1  A9 FA                lda     #<RESTART
00E8AA  1  A0 CC                ldy     #>RESTART
00E8AC  1  85 08                sta     GORESTART+1
00E8AE  1  84 09                sty     GORESTART+2
00E8B0  1  6C 08 00             jmp     (GORESTART+1)
00E8B3  1               
00E8B3  1               ; OSI is compiled for ROM, but includes
00E8B3  1               ; this unused string
00E8B3  1  57 41 4E 54          .byte   "WANT SIN-COS-TAN-ATN"
00E8B7  1  20 53 49 4E  
00E8BB  1  2D 43 4F 53  
00E8C7  1  00                   .byte   0
00E8C8  1               QT_WRITTEN_BY:
00E8C8  1  0D 0A 0C             .byte   CR,LF,$0C ; FORM FEED
00E8CB  1  57 52 49 54          .byte   "WRITTEN BY RICHARD W. WEILAND."
00E8CF  1  54 45 4E 20  
00E8D3  1  42 59 20 52  
00E8E9  1  0D 0A 00             .byte   CR,LF,0
00E8EC  1               QT_MEMORY_SIZE:
00E8EC  1  02 5F 4D 45          .byte   $02,"_MEMORY SIZE"
00E8F0  1  4D 4F 52 59  
00E8F4  1  20 53 49 5A  
00E8F9  1  00                   .byte   0
00E8FA  1               QT_TERMINAL_WIDTH:
00E8FA  1  54 45 52 4D          .byte   "TERMINAL WIDTH"
00E8FE  1  49 4E 41 4C  
00E902  1  20 57 49 44  
00E908  1  00                   .byte   0
00E909  1               QT_BYTES_FREE:
00E909  1  20 42 59 54          .byte   " BYTES FREE"
00E90D  1  45 53 20 46  
00E911  1  52 45 45     
00E914  1  0D 0A 0D 0A          .byte   CR,LF,CR,LF
00E918  1  4F 53 49 20          .byte   "OSI 6502 BASIC VERSION 1.0 REV 3.2"
00E91C  1  36 35 30 32  
00E920  1  20 42 41 53  
00E93A  1  0D 0A                .byte   CR,LF
00E93C  1  43 4F 50 59          .byte   "COPYRIGHT 1977 BY MICROSOFT CO."
00E940  1  52 49 47 48  
00E944  1  54 20 31 39  
00E95B  1  0D 0A 00             .byte   CR,LF,0
00E95E  1               
00E95E  1               XPL:
00E95E  1  0C 1B 5B 31  	.byte	$0C, $1B, "[12;26H"
00E962  1  32 3B 32 36  
00E966  1  48           
00E967  1  20 58 58 20  	.byte	    " XX     XX  PPPP   LL     ",CR,LF
00E96B  1  20 20 20 20  
00E96F  1  58 58 20 20  
00E983  1  1B 5B 31 33  	.byte	$1B, "[13;26H"
00E987  1  3B 32 36 48  
00E98B  1  20 20 58 58  	.byte	    "  XX   XX   PP PP  LL     ",CR,LF
00E98F  1  20 20 20 58  
00E993  1  58 20 20 20  
00E9A7  1  1B 5B 31 34  	.byte	$1B, "[14;26H"
00E9AB  1  3B 32 36 48  
00E9AF  1  20 20 20 58  	.byte	    "   XXXXX    PPPPP  LL     ",CR,LF
00E9B3  1  58 58 58 58  
00E9B7  1  20 20 20 20  
00E9CB  1  1B 5B 31 35  	.byte	$1B, "[15;26H"
00E9CF  1  3B 32 36 48  
00E9D3  1  20 20 58 58  	.byte	    "  XX   XX   PP     LL  32 ",CR,LF
00E9D7  1  20 20 20 58  
00E9DB  1  58 20 20 20  
00E9EF  1  1B 5B 31 36  	.byte	$1B, "[16;26H"
00E9F3  1  3B 32 36 48  
00E9F7  1  20 58 58 20  	.byte	    " XX     XX  PP     LLLLLLL",CR,LF
00E9FB  1  20 20 20 20  
00E9FF  1  58 58 20 20  
00EA13  1  00           	.byte	$00
00EA14  1               
00EA14  1               ; XPL-32 LOAD/SAVE ROUTINES =================================================================
00EA14  1               ; BY Waverider 2021/2022 ===============================================================
00EA14  1               
00EA14  1               SMCHECK:
00EA14  1  20 08 C9     	JSR	rxpoll
00EA17  1  AD 00 80     	LDA	ACIAData
00EA1A  1  85 BC        	STA	XYLODSAV2	; save to tmp var
00EA1C  1  C9 53        	cmp	#'S'		; If "s" is pressed
00EA1E  1  F0 0F        	BEQ	SDET		; then use serial
00EA20  1  A5 BC        	LDA	XYLODSAV2	; load tmp var
00EA22  1  C9 4D        	cmp	#'M'		; If "m" is pressed
00EA24  1  F0 0D        	BEQ	MDET		; then use a memory card
00EA26  1  A5 BC        	LDA	XYLODSAV2	; load tmp var
00EA28  1  C9 54        	cmp	#'T'		; If "t" is pressed
00EA2A  1  F0 0B        	BEQ	TDET		; then use tape
00EA2C  1  4C 14 EA     	JMP	SMCHECK
00EA2F  1               SDET:
00EA2F  1  38           	sec
00EA30  1  A9 00        	lda #0
00EA32  1  60           	rts
00EA33  1               MDET:
00EA33  1  18           	clc
00EA34  1  A9 00        	lda #0
00EA36  1  60           	rts
00EA37  1               TDET:
00EA37  1  A9 FF        	lda #$ff
00EA39  1  60           	rts
00EA3A  1               
00EA3A  1               JMP_TLOAD:
00EA3A  1  4C EA CA     	jmp tload
00EA3D  1  60           	rts
00EA3E  1               
00EA3E  1               LOAD:
00EA3E  1  48           	pha
00EA3F  1  8A           	txa
00EA40  1  48           	pha 	; save registers
00EA41  1  98           	tya
00EA42  1  48           	pha
00EA43  1  20 AB EB     	jsr 	WRITE_TRANSFER_MSG
00EA46  1  20 14 EA     	jsr	SMCHECK
00EA49  1  D0 EF        	bne	JMP_TLOAD
00EA4B  1  B0 03        	bcs	SERIAL_LOAD
00EA4D  1  4C 9F EA     	jmp 	MEMORY_LOAD
00EA50  1               SERIAL_LOAD:
00EA50  1  A2 2B        	ldx	#<SERIAL_MSG
00EA52  1  A0 ED        	ldy	#>SERIAL_MSG
00EA54  1  20 24 C9     	jsr	w_acia_full
00EA57  1  20 08 C9     	jsr	rxpoll
00EA5A  1               receive_serial:
00EA5A  1  A2 00          	ldx 	#0
00EA5C  1               rcloopadd:
00EA5C  1  A9 01          	lda 	#$01
00EA5E  1  85 BC          	sta 	XYLODSAV2
00EA60  1  A9 06        	lda	#$06
00EA62  1  85 BD        	sta	XYLODSAV2+1
00EA64  1  A0 00          	ldy 	#0
00EA66  1               rsl:
00EA66  1  20 08 C9       	jsr 	rxpoll
00EA69  1  AD 00 80       	lda 	ACIAData
00EA6C  1  91 BC          	sta 	(XYLODSAV2),Y
00EA6E  1  F0 10        	beq	rseof
00EA70  1               rsnot:
00EA70  1  A9 2E          	lda 	#$2e		; for debug
00EA72  1  20 67 FF       	jsr 	MONCOUT		;
00EA75  1  E6 BC        	inc	XYLODSAV2
00EA77  1  A5 BC        	lda	XYLODSAV2
00EA79  1  F0 02        	beq	ssl
00EA7B  1  E6 BD        	inc	XYLODSAV2+1
00EA7D  1               ssl:
00EA7D  1  4C 66 EA     	jmp rsl
00EA80  1               rseof:
00EA80  1  A0 01        	ldy	#1
00EA82  1  20 08 C9     	jsr	rxpoll
00EA85  1  91 BC        	sta	(XYLODSAV2),Y
00EA87  1  D0 E7        	bne	rsnot
00EA89  1  A0 02        	ldy	#2
00EA8B  1  20 08 C9     	jsr	rxpoll
00EA8E  1  91 BC        	sta	(XYLODSAV2),Y
00EA90  1  D0 DE        	bne	rsnot
00EA92  1               
00EA92  1               sdone:
00EA92  1  A2 45          	ldx	#<LOAD_DONE
00EA94  1  A0 ED        	ldy	#>LOAD_DONE
00EA96  1  20 24 C9     	jsr	w_acia_full
00EA99  1               stop_sl:
00EA99  1  68             	pla
00EA9A  1  A8           	tay
00EA9B  1  68             	pla
00EA9C  1  AA           	tax
00EA9D  1  68             	pla
00EA9E  1  60             	rts
00EA9F  1               
00EA9F  1               MEMORY_LOAD:
00EA9F  1  20 1F EB     	jsr	rootsetup
00EAA2  1  20 65 EB     	jsr	list
00EAA5  1  20 D6 EA     	jsr	type
00EAA8  1  A0 7F        	ldy #>sdbuffer
00EAAA  1  A2 F2        	ldx #<sdbuffer
00EAAC  1  20 1C C8     	jsr fat32_finddirent
00EAAF  1  90 03        	bcc foundfile
00EAB1  1               	; File not found
00EAB1  1  4C 32 EB     	jmp transfer_error
00EAB4  1               foundfile:
00EAB4  1               	; Open file
00EAB4  1  20 A7 C5     	jsr fat32_opendirent
00EAB7  1  A2 76        	ldx #<lodmsg
00EAB9  1  A0 ED         	ldy #>lodmsg
00EABB  1  20 24 C9       	jsr w_acia_full
00EABE  1  A9 01          	lda #$01
00EAC0  1  85 CC          	sta fat32_address
00EAC2  1  A9 06          	lda #$06
00EAC4  1  85 CD          	sta fat32_address+1
00EAC6  1  20 7C C8       	jsr fat32_file_read  ; Yes. It is finally time to read the file.
00EAC9  1  A2 45          	ldx #<LOAD_DONE
00EACB  1  A0 ED          	ldy #>LOAD_DONE
00EACD  1  20 24 C9       	jsr w_acia_full
00EAD0  1  68             	pla
00EAD1  1  A8             	tay
00EAD2  1  68             	pla
00EAD3  1  AA             	tax
00EAD4  1  68             	pla
00EAD5  1  60             	rts
00EAD6  1               
00EAD6  1               type:			; typing a filename
00EAD6  1  A2 00          ldx	#0
00EAD8  1               lodbufloop:
00EAD8  1  BD A0 ED       lda	loadbuf,x	; copy the buffer into ram
00EADB  1  9D F2 7F       sta	sdbuffer,x	; so we can use it
00EADE  1  E8             inx
00EADF  1  E0 0C          cpx	#12
00EAE1  1  D0 F5          bne	lodbufloop
00EAE3  1               
00EAE3  1  A2 93          ldx #<typemsg		; Filename:_
00EAE5  1  A0 ED          ldy #>typemsg
00EAE7  1  20 24 C9       jsr w_acia_full
00EAEA  1  A2 00          ldx #0
00EAEC  1  A9 20          lda #' '
00EAEE  1  85 00          sta charbuffer
00EAF0  1               
00EAF0  1               typeloop:		; loop to type filenames
00EAF0  1  20 08 C9       jsr rxpoll		; read a charactor
00EAF3  1  AD 00 80       lda ACIAData
00EAF6  1  20 10 C9       jsr print_chara	; echo back
00EAF9  1  85 00          sta charbuffer	; store
00EAFB  1  C9 0D          cmp #$0d		; enter?
00EAFD  1  F0 10          beq exitloop		; if so, load
00EAFF  1  A5 00          lda charbuffer
00EB01  1  C9 08          cmp #$08		; backspace??
00EB03  1  F0 11          beq backspace		; then go there
00EB05  1  A5 00          lda charbuffer	; now store it in the filename buffer
00EB07  1  9D F2 7F       sta sdbuffer,x
00EB0A  1  E8             inx
00EB0B  1  E0 08          cpx #8		; no more then *8 characters*
00EB0D  1  D0 E1          bne typeloop
00EB0F  1               exitloop:
00EB0F  1  20 E0 C8       jsr crlf
00EB12  1  20 1F EB       jsr rootsetup
00EB15  1  60             rts
00EB16  1               backspace:
00EB16  1  CA             dex
00EB17  1  A9 20          lda #$20
00EB19  1  9D A0 ED       sta loadbuf,x
00EB1C  1  4C F0 EA       jmp typeloop
00EB1F  1               
00EB1F  1               rootsetup:		; setup <ROOT>
00EB1F  1               
00EB1F  1                 ; Open root directory
00EB1F  1  20 8F C5       jsr fat32_openroot
00EB22  1               
00EB22  1                 ; Find the subdirectory by name
00EB22  1  A2 10          ldx #<dirname
00EB24  1  A0 CC          ldy #>dirname
00EB26  1  20 1C C8       jsr fat32_finddirent
00EB29  1  90 03          bcc foundsub
00EB2B  1               
00EB2B  1                 ; Subdirectory not found
00EB2B  1  4C 32 EB       jmp transfer_error
00EB2E  1               
00EB2E  1               foundsub:
00EB2E  1               
00EB2E  1                 ; Open subdirectory
00EB2E  1  20 A7 C5       jsr fat32_opendirent	; open folder
00EB31  1               
00EB31  1  60             rts			; done
00EB32  1               
00EB32  1               transfer_error:
00EB32  1  A0 CC          ldy #>errormsg
00EB34  1  A2 1C          ldx #<errormsg
00EB36  1  20 24 C9       jsr w_acia_full
00EB39  1  20 CC CB       jsr error_sound
00EB3C  1  4C 99 EA       jmp stop_sl
00EB3F  1               
00EB3F  1               other:
00EB3F  1  20 00 C9       jsr txpoll		; Write a letter of the filename currently being read
00EB42  1  B1 01          lda (zp_sd_address),y
00EB44  1  8D 00 80       sta ACIAData
00EB47  1  C8             iny
00EB48  1  60             rts
00EB49  1               
00EB49  1               listmsg:
00EB49  1  4C 69 73 74    .byte "Listing Of SDCARD/folder:",CR,LF,0
00EB4D  1  69 6E 67 20  
00EB51  1  4F 66 20 53  
00EB65  1               
00EB65  1               list:			; list file dir
00EB65  1  A2 49          ldx #<listmsg
00EB67  1  A0 EB          ldy #>listmsg
00EB69  1  20 24 C9       jsr w_acia_full
00EB6C  1               listing:
00EB6C  1  20 E6 C7       jsr fat32_readdirent	; files?
00EB6F  1  B0 36          bcs nofiles
00EB71  1  29 40          and #$40
00EB73  1  F0 05          beq arc
00EB75  1               dir:
00EB75  1  A9 44          lda #'D'		; directorys show up as
00EB77  1  4C 7C EB       jmp ebut		; D YOURFILENAME     D TEST      D FOLDER  ...Etc
00EB7A  1               arc:
00EB7A  1  A9 46          lda #'F'		; files show up as
00EB7C  1               ebut:			; F TEST.XPL         F MUSIC.XPL        F FILE.BIN  ...Etc
00EB7C  1  20 10 C9       jsr print_chara	; f or d
00EB7F  1  A9 20          lda #$20		; space
00EB81  1  20 10 C9       jsr print_chara
00EB84  1                 ; At this point, we know that there are no files, files, or a suddir
00EB84  1                 ; Now for the name
00EB84  1  A0 00          ldy #0
00EB86  1               nameloop:
00EB86  1  C0 08          cpy #8
00EB88  1  F0 06          beq dot
00EB8A  1  20 3F EB       jsr other
00EB8D  1  4C 86 EB       jmp nameloop
00EB90  1               dot:
00EB90  1  A9 2E          lda #'.'		; shows a file extention
00EB92  1  20 10 C9       jsr print_chara
00EB95  1               lopii:
00EB95  1  C0 0B          cpy #11
00EB97  1  F0 06          beq endthat		; print 3-letter file extention
00EB99  1  20 3F EB       jsr other
00EB9C  1  4C 95 EB       jmp lopii
00EB9F  1               endthat:
00EB9F  1  A9 09          lda #$09 ; Tab
00EBA1  1  20 10 C9       jsr print_chara	; tab
00EBA4  1  4C 6C EB       jmp listing 		; go again (next file if there are any left)
00EBA7  1               nofiles:		; if not,
00EBA7  1               endlist:		; exit listing code
00EBA7  1  20 E0 C8       jsr crlf
00EBAA  1  60             rts
00EBAB  1               
00EBAB  1               WRITE_TRANSFER_MSG:
00EBAB  1  A2 01          	LDX 	#<TRANSFER_MSG
00EBAD  1  A0 ED        	LDY	#>TRANSFER_MSG
00EBAF  1  20 24 C9     	JSR	w_acia_full
00EBB2  1  60             	RTS
00EBB3  1               TAPE_SAVE:
00EBB3  1               	; lets loop through the BASIC code to see how long it is.
00EBB3  1  A9 06        	lda #$06
00EBB5  1  85 03        	sta len+1
00EBB7  1  85 01        	sta cnt+1
00EBB9  1  A9 01        	lda #$01
00EBBB  1  85 02        	sta len
00EBBD  1  85 00        	sta cnt
00EBBF  1  A0 00        	ldy #0
00EBC1  1  20 DC EB     tslp:	jsr inctapeindex
00EBC4  1  D0 FB        	bne tslp
00EBC6  1  20 DC EB     	jsr inctapeindex
00EBC9  1  D0 F6        	bne tslp
00EBCB  1  20 DC EB     	jsr inctapeindex
00EBCE  1  D0 F1        	bne tslp
00EBD0  1  20 DC EB     	jsr inctapeindex
00EBD3  1  20 DC EB     	jsr inctapeindex ; just to be safe
00EBD6  1               	; ok, start address in cnt and end address in len
00EBD6  1               	; time to save.
00EBD6  1  20 47 C9     	jsr tsave
00EBD9  1  4C 41 EC     	jmp END_SERIAL_SAVE
00EBDC  1               
00EBDC  1               inctapeindex:
00EBDC  1  E6 02        	inc len
00EBDE  1  D0 02        	bne tnotinc
00EBE0  1  E6 03        	inc len+1
00EBE2  1               tnotinc:
00EBE2  1  B1 02        	lda (len),y
00EBE4  1  60           	rts
00EBE5  1               
00EBE5  1               SAVE:				; BUG serial save dont work
00EBE5  1  48           	PHA
00EBE6  1  8A           	TXA
00EBE7  1  48           	PHA			; Push registers on the stack
00EBE8  1  98           	TYA
00EBE9  1  48           	PHA
00EBEA  1  20 AB EB     	JSR	WRITE_TRANSFER_MSG
00EBED  1  20 14 EA     	JSR	SMCHECK
00EBF0  1  D0 C1        	bne	TAPE_SAVE
00EBF2  1  B0 03        	bcs	SERIAL_SAVE
00EBF4  1  4C 54 EC     	jmp	MEMORY_SAVE
00EBF7  1               SERIAL_SAVE:
00EBF7  1  A2 2B        	LDX	#<SERIAL_MSG
00EBF9  1  A0 ED        	LDY	#>SERIAL_MSG
00EBFB  1  20 24 C9     	jsr	w_acia_full
00EBFE  1  20 08 C9     	jsr	rxpoll
00EC01  1  A2 00        	LDX	#0
00EC03  1  A0 00        	LDY	#0
00EC05  1  A9 01        	LDA	#$01
00EC07  1  85 BC        	STA	XYLODSAV2	; set to start of RAM
00EC09  1  A9 06        	LDA	#$06
00EC0B  1  85 BD        	STA	XYLODSAV2+1
00EC0D  1               	; now for the loop
00EC0D  1               SAVELOOP:
00EC0D  1  B1 BC        	LDA	(XYLODSAV2),Y	; save out a byte
00EC0F  1  48           	PHA
00EC10  1  20 67 FF     	JSR	MONCOUT
00EC13  1  68           	PLA
00EC14  1  F0 0B        	BEQ	SAVE_EOF_CHECK
00EC16  1               notit:
00EC16  1  E6 BC        	INC	XYLODSAV2
00EC18  1  F0 02        	BEQ	SAVE_NOT16BIT
00EC1A  1  E6 BD        	INC	XYLODSAV2+1
00EC1C  1               SAVE_NOT16BIT:
00EC1C  1  20 86 FF     	JSR	MONISCNTC	; check if control+c is pressed.
00EC1F  1  90 EC        	BCC	SAVELOOP	; if not, then send the next byte
00EC21  1               SAVE_EOF_CHECK:			; if so, then send break error message
00EC21  1  A0 01        	ldy	#1
00EC23  1  B1 BC        	lda	(XYLODSAV2),Y	; End Of File? (NULL followed by another NULL)
00EC25  1  D0 EF        	bne	notit
00EC27  1  A0 02        	ldy	#2
00EC29  1  B1 BC        	lda	(XYLODSAV2),Y	; by a n o t h e r N U L L
00EC2B  1  D0 E9        	bne	notit
00EC2D  1  4C 41 EC     	jmp	END_SERIAL_SAVE
00EC30  1               SAVE_CUT:
00EC30  1  A2 69        	ldx	#<ABORT_MSG
00EC32  1  A0 ED        	ldy	#>ABORT_MSG
00EC34  1  20 24 C9     	jsr	w_acia_full
00EC37  1  4C 41 EC     	jmp	END_SERIAL_SAVE
00EC3A  1               SAVE_END_WRITE:
00EC3A  1  A2 56        	ldx	#<SAVE_DONE
00EC3C  1  A0 ED        	ldy	#>SAVE_DONE
00EC3E  1  20 24 C9     	jsr	w_acia_full
00EC41  1               END_SERIAL_SAVE:
00EC41  1  68           	PLA
00EC42  1  A8           	TAY
00EC43  1  68           	PLA
00EC44  1  AA           	TAX			; pull registers off stack
00EC45  1  68           	PLA
00EC46  1  60           	RTS
00EC47  1               msincremaining:
00EC47  1  E6 D2                inc fat32_bytesremaining
00EC49  1  D0 02                bne msinca
00EC4B  1  E6 D2                inc fat32_bytesremaining
00EC4D  1               msinca:
00EC4D  1  E6 BC                inc XYLODSAV2
00EC4F  1  D0 02                bne msincb
00EC51  1  E6 BD                inc XYLODSAV2+1
00EC53  1               msincb:
00EC53  1  60                   rts
00EC54  1               MEMORY_SAVE:
00EC54  1                       ; BUG this doesent work
00EC54  1  20 1F EB     	jsr rootsetup
00EC57  1  20 65 EB     	jsr list
00EC5A  1  20 D6 EA     	jsr type
00EC5D  1  20 92 C6             jsr fat32_findnextfreecluster
00EC60  1  A0 7F        	ldy #>sdbuffer
00EC62  1  A2 F2        	ldx #<sdbuffer
00EC64  1  20 1C C8     	jsr fat32_finddirent
00EC67  1  B0 05        	bcs saveok
00EC69  1  20 B8 EC     	jsr file_exists
00EC6C  1  B0 44        	bcs stopmemsave
00EC6E  1               saveok:
00EC6E  1                       ; Now calculate file size and store it in fat32_bytesremaining.
00EC6E  1  A9 01                lda #$01
00EC70  1  85 BC                sta XYLODSAV2
00EC72  1  A9 06                lda #$06
00EC74  1  85 BD                sta XYLODSAV2+1
00EC76  1  A9 00                lda #0
00EC78  1  85 D2                sta fat32_bytesremaining
00EC7A  1  85 D2                sta fat32_bytesremaining
00EC7C  1  A0 00                ldy #0
00EC7E  1               savecalclp:
00EC7E  1  B1 BC                lda (XYLODSAV2),y
00EC80  1  F0 06                beq mszero
00EC82  1  20 47 EC             jsr msincremaining
00EC85  1  4C 7E EC             jmp savecalclp
00EC88  1               mszero:
00EC88  1  20 47 EC             jsr msincremaining
00EC8B  1  B1 BC                lda (XYLODSAV2),y
00EC8D  1  D0 EF                bne savecalclp
00EC8F  1  20 47 EC             jsr msincremaining
00EC92  1  B1 BC                lda (XYLODSAV2),y
00EC94  1  D0 E8                bne savecalclp
00EC96  1                       ; done
00EC96  1  20 DA C5     	jsr fat32_writedirent
00EC99  1  A2 85        	ldx #<savmsg
00EC9B  1  A0 ED         	ldy #>savmsg
00EC9D  1  20 24 C9       	jsr w_acia_full
00ECA0  1  A9 01          	lda #$01
00ECA2  1  85 CC          	sta fat32_address
00ECA4  1  A9 06          	lda #$06
00ECA6  1  85 CD          	sta fat32_address+1
00ECA8  1  20 9C C8       	jsr fat32_file_write  ; Yes. It is finally time to save the file.
00ECAB  1  A2 56          	ldx #<SAVE_DONE
00ECAD  1  A0 ED          	ldy #>SAVE_DONE
00ECAF  1  20 24 C9       	jsr w_acia_full
00ECB2  1               stopmemsave:
00ECB2  1  68           	PLA
00ECB3  1  A8           	TAY
00ECB4  1  68           	PLA
00ECB5  1  AA           	TAX
00ECB6  1  68           	PLA
00ECB7  1  60           	RTS
00ECB8  1               
00ECB8  1               file_exists:
00ECB8  1               	; clc if 'y'
00ECB8  1               	; sec if 'n'
00ECB8  1  A2 DC        	ldx #<EXIST_MSG
00ECBA  1  A0 EC        	ldy #>EXIST_MSG
00ECBC  1  20 24 C9     	jsr w_acia_full
00ECBF  1               fexlp:
00ECBF  1  20 08 C9     	jsr rxpoll
00ECC2  1  AD 00 80     	lda ACIAData
00ECC5  1  48           	pha
00ECC6  1  C9 79        	cmp #'y'
00ECC8  1  F0 08        	beq exy
00ECCA  1  C9 6E        	cmp #'n'
00ECCC  1  F0 09        	beq exn
00ECCE  1  68           	pla
00ECCF  1  4C BF EC     	jmp fexlp
00ECD2  1               exy:
00ECD2  1  20 E0 C8     	jsr crlf
00ECD5  1  18           	clc
00ECD6  1  60           	rts
00ECD7  1               exn:
00ECD7  1  20 E0 C8     	jsr crlf
00ECDA  1  38           	sec
00ECDB  1  60           	rts
00ECDC  1               
00ECDC  1               EXIST_MSG:
00ECDC  1  46 69 6C 65    .byte "File Exists. Overwrite? (y) or (n): ",$00
00ECE0  1  20 45 78 69  
00ECE4  1  73 74 73 2E  
00ED01  1               TRANSFER_MSG:
00ED01  1  53 65 72 69    .byte	"Serial [S] or Memory Card [M] Transfer?",CR,LF,$00
00ED05  1  61 6C 20 5B  
00ED09  1  53 5D 20 6F  
00ED2B  1               SERIAL_MSG:
00ED2B  1  50 72 65 73    .byte	"Press Any Key To Begin.",CR,LF,$00
00ED2F  1  73 20 41 6E  
00ED33  1  79 20 4B 65  
00ED45  1               LOAD_DONE:
00ED45  1  4C 6F 61 64    .byte	"Load Complete.",CR,LF,$00
00ED49  1  20 43 6F 6D  
00ED4D  1  70 6C 65 74  
00ED56  1               SAVE_DONE:
00ED56  1  0D 0A 53 61    .byte	CR,LF,"Save Complete.",CR,LF,$00
00ED5A  1  76 65 20 43  
00ED5E  1  6F 6D 70 6C  
00ED69  1               ABORT_MSG:
00ED69  1  0D 0A 41 62    .byte	CR,LF,"Aborted.",CR,LF,0
00ED6D  1  6F 72 74 65  
00ED71  1  64 2E 0D 0A  
00ED76  1               lodmsg:
00ED76  1  0D 0A 4C 6F    .byte $0d, $0a, "Loading...", $0d, $0a, $00
00ED7A  1  61 64 69 6E  
00ED7E  1  67 2E 2E 2E  
00ED85  1               savmsg:
00ED85  1  0D 0A 53 61    .byte $0d, $0a, "Saving...", $0d, $0a, $00
00ED89  1  76 69 6E 67  
00ED8D  1  2E 2E 2E 0D  
00ED93  1               typemsg:
00ED93  1  46 69 6C 65    .byte "Filename: ", $02, "_", $00
00ED97  1  6E 61 6D 65  
00ED9B  1  3A 20 02 5F  
00EDA0  1               loadbuf:
00EDA0  1  20 20 20 20    .byte $20, $20, $20, $20, $20, $20, $20, $20
00EDA4  1  20 20 20 20  
00EDA8  1  42 41 53       .byte "BAS"
00EDAB  1               fat_error:
00EDAB  1  46 41 54 33    .byte "FAT32 Initialization Failed at Stage"
00EDAF  1  32 20 49 6E  
00EDB3  1  69 74 69 61  
00EDCF  1               sd_msg:
00EDCF  1  0E 14 0F 12    .byte	$0e, 20, $0f, 18
00EDD3  1  02 20          .byte $02, $20
00EDD5  1  49 6E 69 74    .byte "Initializing SD Card...",0
00EDD9  1  69 61 6C 69  
00EDDD  1  7A 69 6E 67  
00EDED  1               
00EDED  1               
00EDED  1               ; STARTUP AND SERIAL I/O ROUTINES ===========================================================
00EDED  1               ; BY G. SEARLE 2013 =========================================================================
00EDED  1               ACIA := $8000
00EDED  1               ACIAControl := ACIA+3
00EDED  1               ACIACommand := ACIA+2
00EDED  1               ACIAStatus := ACIA+1
00EDED  1               ACIAData := ACIA+0
00EDED  1               
00EDED  1               .segment "IOHANDLER"
000000r 1               .org $FF00
00FF00  1               Reset:
00FF00  1  A2 FC        	LDX     #STACK_TOP
00FF02  1  9A           	TXS
00FF03  1               
00FF03  1  A9 0B        	LDA	#$0B
00FF05  1  8D 02 80     	STA	ACIACommand
00FF08  1  A9 1F        	LDA 	#$1F		; Set ACIA baud rate, word size and Rx interrupt (to control RTS)
00FF0A  1  8D 03 80     	STA	ACIAControl
00FF0D  1               
00FF0D  1  A2 5E        	LDX	#<XPL
00FF0F  1  A0 E9        	LDY	#>XPL
00FF11  1  20 24 C9     	JSR	w_acia_full
00FF14  1               
00FF14  1               ;NextStart:
00FF14  1               ;	LDY	#$FF
00FF14  1               ;InnerDelayLoop:
00FF14  1               ;	LDX	#$FF
00FF14  1               ;Wee:
00FF14  1               ;	NOP
00FF14  1               ;	NOP
00FF14  1               ;	NOP
00FF14  1               ;	NOP
00FF14  1               ;	NOP
00FF14  1               ;	NOP
00FF14  1               ;	DEX
00FF14  1               ;	BNE Wee
00FF14  1               ;
00FF14  1               ;	DEY
00FF14  1               ;	BNE InnerDelayLoop
00FF14  1               
00FF14  1  A2 CF        	ldx #<sd_msg
00FF16  1  A0 ED        	ldy #>sd_msg
00FF18  1  20 24 C9     	jsr w_acia_full
00FF1B  1               
00FF1B  1  20 A1 C1      	jsr via_init
00FF1E  1  20 B6 C1     	jsr sd_init
00FF21  1  B0 22                bcs dispstart
00FF23  1  20 83 C3     	jsr fat32_init
00FF26  1  90 1D        	bcc dispstart
00FF28  1               
00FF28  1               	; Error during FAT32 initialization
00FF28  1               
00FF28  1  20 F5 C8     	jsr cleardisplay
00FF2B  1  A0 ED        	ldy #>fat_error
00FF2D  1  A2 AB        	ldx #<fat_error
00FF2F  1  20 24 C9     	jsr w_acia_full
00FF32  1  A5 D2        	lda fat32_errorstage
00FF34  1  20 C9 C8     	jsr print_hex_acia
00FF37  1  A9 21        	lda #'!'
00FF39  1  20 10 C9     	jsr print_chara
00FF3C  1  20 E0 C8     	jsr crlf
00FF3F  1  4C 45 FF     	jmp dispstart
00FF42  1               JMPToReset:
00FF42  1  4C 00 FF     	jmp	Reset
00FF45  1               dispstart:
00FF45  1               ; Display startup message
00FF45  1  A0 00        	LDY #0
00FF47  1               ShowStartMsg:
00FF47  1  B9 93 FF     	LDA	StartupMessage,Y
00FF4A  1  F0 06        	BEQ	WaitForKeypress
00FF4C  1  20 67 FF     	JSR	MONCOUT
00FF4F  1  C8           	INY
00FF50  1  D0 F5        	BNE	ShowStartMsg
00FF52  1               
00FF52  1               ; Wait for a cold/warm start selection
00FF52  1               WaitForKeypress:
00FF52  1  20 76 FF     	JSR	MONRDKEY
00FF55  1  90 FB        	BCC	WaitForKeypress
00FF57  1               
00FF57  1  29 DF        	AND	#$DF			; Make upper case
00FF59  1  C9 57        	CMP	#'W'			; compare with [W]arm start
00FF5B  1  F0 07        	BEQ	WarmStart
00FF5D  1               
00FF5D  1  C9 43        	CMP	#'C'			; compare with [C]old start
00FF5F  1  D0 E1        	BNE	JMPToReset
00FF61  1               
00FF61  1  4C 8B E7     	JMP	COLD_START	; BASIC cold start
00FF64  1               
00FF64  1               WarmStart:
00FF64  1  4C FA CC     	JMP	RESTART		; BASIC warm start
00FF67  1               
00FF67  1               MONCOUT:
00FF67  1  48           	PHA
00FF68  1               SerialOutWait:
00FF68  1  AD 01 80     	LDA	ACIAStatus
00FF6B  1  29 10        	AND	#$10
00FF6D  1  C9 10        	CMP	#$10
00FF6F  1  D0 F7        	BNE	SerialOutWait
00FF71  1  68           	PLA
00FF72  1  8D 00 80     	STA	ACIAData
00FF75  1  60           	RTS
00FF76  1               
00FF76  1               MONRDKEY:
00FF76  1  AD 01 80     	LDA	ACIAStatus
00FF79  1  29 08        	AND	#$08
00FF7B  1  C9 08        	CMP	#$08
00FF7D  1  D0 05        	BNE	NoDataIn
00FF7F  1  AD 00 80     	LDA	ACIAData
00FF82  1  38           	SEC		; Carry set if key available
00FF83  1  60           	RTS
00FF84  1               NoDataIn:
00FF84  1  18           	CLC		; Carry clear if no key pressed
00FF85  1  60           	RTS
00FF86  1               
00FF86  1               MONISCNTC:
00FF86  1  20 76 FF     	JSR	MONRDKEY
00FF89  1  90 06        	BCC	NotCTRLC ; If no key pressed then exit
00FF8B  1  C9 03        	CMP	#3
00FF8D  1  D0 02        	BNE	NotCTRLC ; if CTRL-C not pressed then exit
00FF8F  1  38           	SEC		; Carry set if control C pressed
00FF90  1  60           	RTS
00FF91  1               NotCTRLC:
00FF91  1  18           	CLC		; Carry clear if control C not pressed
00FF92  1  60           	RTS
00FF93  1               
00FF93  1               StartupMessage:
00FF93  1  0C 43 6F 6C  	.byte	$0C,"Cold [C] or warm [W] start?",$0D,$0A,$00
00FF97  1  64 20 5B 43  
00FF9B  1  5D 20 6F 72  
00FFB2  1               
00FFB2  1               ; ======================================================
00FFB2  1               ; --------------------- Vectors ------------------------
00FFB2  1               ; ======================================================
00FFB2  1               
00FFB2  1               .segment "VECTS"
000000r 1               .org $FFFA
00FFFA  1  00 FF        	.word	Reset		; NMI
00FFFC  1  00 FF        	.word	Reset		; RESET
00FFFE  1  00 FF        	.word	Reset		; IRQ
010000  1               
010000  1               ;   ______ _   _ _____
010000  1               ;  |  ____| \ | |  __ \
010000  1               ;  | |__  |  \| | |  | |
010000  1               ;  |  __| | . ` | |  | |
010000  1               ;  | |____| |\  | |__| |
010000  1               ;  |______|_| \_|_____/
010000  1               
010000  1               
