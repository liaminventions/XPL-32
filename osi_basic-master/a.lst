F00:0001       ; Save test
F00:0002       ; 
F00:0003       ; this code is just for debugging the sd card saving system.
F00:0004       ; i will use ben eater's debugger for this.
F00:0005       ; BUG not sure if the SD card or the ACIA can run at a low clock rate
F00:0006       ; 
F00:0007       ACIA = $8000
F00:0008       ACIAControl = ACIA+3
F00:0009       ACIACommand = ACIA+2
F00:0010       ACIAStatus = ACIA+1
F00:0011       ACIAData = ACIA
F00:0012       
F00:0013       fat32_workspace = $200      ; two pages
F00:0014       
F00:0015       buffer = $400               ; 512 bytes
F00:0016       endbuf = $600
F00:0017       
F00:0018       zp_sd_address = $40 ; 2
F00:0019       zp_sd_currentsector = $42 ; 4
F00:0020       zp_fat32_variables = $46 ; 32
F00:0021       
F00:0022       XYLODSAV2 = $64 ; 2
F00:0023       
F00:0024       CR=13
F00:0025       LF=10
F00:0026       
F00:0027         .org $c000
F00:0028       reset:
F00:0029         ldx #$ff
               S01:0000C000:  A2 FF
F00:0030         txs
               S01:0000C002:  9A
F00:0031         jsr acia_init
               S01:0000C003:  20 77 C0
F00:0032         ; acia init done
F00:0033         jsr txpoll
               S01:0000C006:  20 BB C0
F00:0034         lda #'A'
               S01:0000C009:  A9 41
F00:0035         sta ACIAData
               S01:0000C00B:  8D 00 80
F00:0036         jsr via_init
               S01:0000C00E:  20 6C C0
F00:0037         ; via init done
F00:0038         jsr txpoll
               S01:0000C011:  20 BB C0
F00:0039         lda #'V'
               S01:0000C014:  A9 56
F00:0040         sta ACIAData
               S01:0000C016:  8D 00 80
F00:0041         jsr sd_init
               S01:0000C019:  20 0C C1
F00:0042         bcs initdone
               S01:0000C01C:  B0 15
F00:0043         ; sd init done
F00:0044         jsr txpoll
               S01:0000C01E:  20 BB C0
F00:0045         lda #'S'
               S01:0000C021:  A9 53
F00:0046         sta ACIAData
               S01:0000C023:  8D 00 80
F00:0047         jsr fat32_init
               S01:0000C026:  20 D9 C2
F00:0048         bcs faterror
               S01:0000C029:  B0 1F
F00:0049         ; fat32 init done
F00:0050         jsr txpoll
               S01:0000C02B:  20 BB C0
F00:0051         lda #'F'
               S01:0000C02E:  A9 46
F00:0052         sta ACIAData
               S01:0000C030:  8D 00 80
F00:0053         ; init done
F00:0054       initdone:
F00:0055         ; now make a dummy file.
F00:0056         ldx #0
               S01:0000C033:  A2 00
F00:0057       dummyloop:
F00:0058         txa
               S01:0000C035:  8A
F00:0059         sta $0601,x
               S01:0000C036:  9D 01 06
F00:0060         inx
               S01:0000C039:  E8
F00:0061         bne dummyloop
               S01:0000C03A:  D0 F9
F00:0062         ; add an EOF
F00:0063         lda #0
               S01:0000C03C:  A9 00
F00:0064         sta $0701
               S01:0000C03E:  8D 01 07
F00:0065         sta $0702
               S01:0000C041:  8D 02 07
F00:0066         sta $0703
               S01:0000C044:  8D 03 07
F00:0067       
F00:0068         jmp MEMORY_SAVE ; OK, here we go.
               S01:0000C047:  4C 83 C8
F00:0069       
F00:0070       faterror:
F00:0071         jsr txpoll
               S01:0000C04A:  20 BB C0
F00:0072         lda #'f'
               S01:0000C04D:  A9 66
F00:0073         sta ACIAData
               S01:0000C04F:  8D 00 80
F00:0074         jmp doneloop
               S01:0000C052:  4C DB C8
F00:0075       
F00:0076       dirname:
F00:0077       	.asciiz "FOLDER     "
               S01:0000C055:  46 4F 4C 44 45 52 20 20 20 20 20
F00:0078       errormsg:
F00:0079       	.byte CR,LF,"ERROR!",CR,LF
               S01:0000C061:  0D
               S01:0000C062:  0A
               S01:0000C063:  45 52 52 4F 52 21
               S01:0000C069:  0D
               S01:0000C06A:  0A
F00:0080       	.byte 0
               S01:0000C06B:  00
F00:0081       
F00:0082         .include "hwconfig.s"
F01:0001       PORTB = $b000
F01:0002       PORTA = $b001
F01:0003       DDRB = $b002
F01:0004       DDRA = $b003
F01:0005       
F01:0006       SD_CS   = %00010000
F01:0007       SD_SCK  = %00001000
F01:0008       SD_MOSI = %00000100
F01:0009       SD_MISO = %00000010
F01:0010       EXTVID  = %10000000
F01:0011       
F01:0012       PORTA_OUTPUTS = EXTVID | SD_CS | SD_SCK | SD_MOSI
F01:0013       
F01:0014       via_init:
F01:0015         lda #%11111111          ; Set all pins on port B to output
               S01:0000C06C:  A9 FF
F01:0016         sta DDRB
               S01:0000C06E:  8D 02 B0
F01:0017         lda #PORTA_OUTPUTS   ; Set various pins on port A to output
               S01:0000C071:  A9 9C
F01:0018         sta DDRA
               S01:0000C073:  8D 03 B0
F01:0019         rts
               S01:0000C076:  60
F01:0020       
F01:0021       
F00:0083         .include "libacia.s"
F02:0001       ;       ------------------ 6551 ACIA Subroutine Library -------------------
F02:0002       ; Includes:
F02:0003       ; acia_init       - Initializes the ACIA
F02:0004       ; print_hex_acia  - Prints a hex value in A
F02:0005       ; crlf		  - Prints <CR> followed by <LF>
F02:0006       ; clear_display   - Sends a <CLS> command
F02:0007       ; txpoll          - Polls the TX bit to see if the ACIA is ready
F02:0008       ; print_chara     - Prints a Character that is stored in A
F02:0009       ; print_char_acia - Same as print_chara
F02:0010       ; ascii_home      - Home the cursor
F02:0011       ; w_acia_full     - Print a NULL-Termintated String with >HIGH in Y and <LOW in X
F02:0012       
F02:0013       acia_init:
F02:0014         pha
               S01:0000C077:  48
F02:0015         lda #%00001011          ; No parity, no echo, no interrupt
               S01:0000C078:  A9 0B
F02:0016         sta $8002
               S01:0000C07A:  8D 02 80
F02:0017         lda #%00011111          ; 1 stop bit, 8 data bits, 19200 baud
               S01:0000C07D:  A9 1F
F02:0018         sta $8003
               S01:0000C07F:  8D 03 80
F02:0019         pla
               S01:0000C082:  68
F02:0020         rts
               S01:0000C083:  60
F02:0021       
F02:0022       print_hex_acia:
F02:0023         pha
               S01:0000C084:  48
F02:0024         ror
               S01:0000C085:  6A
F02:0025         ror
               S01:0000C086:  6A
F02:0026         ror
               S01:0000C087:  6A
F02:0027         ror
               S01:0000C088:  6A
F02:0028         jsr print_nybble   ; This is just som usful hex cod
               S01:0000C089:  20 8D C0
F02:0029         pla
               S01:0000C08C:  68
F02:0030       print_nybble:
F02:0031         and #15
               S01:0000C08D:  29 0F
F02:0032         cmp #10
               S01:0000C08F:  C9 0A
F02:0033         bmi cskipletter
               S01:0000C091:  30 02
F02:0034         adc #6
               S01:0000C093:  69 06
F02:0035       cskipletter:
F02:0036         adc #48
               S01:0000C095:  69 30
F02:0037        ; jsr print_char
F02:0038         jsr print_chara
               S01:0000C097:  20 CB C0
F02:0039         rts
               S01:0000C09A:  60
F02:0040       
F02:0041       crlf:
F02:0042         pha
               S01:0000C09B:  48
F02:0043         txa
               S01:0000C09C:  8A
F02:0044         pha
               S01:0000C09D:  48
F02:0045         tya
               S01:0000C09E:  98
F02:0046         pha
               S01:0000C09F:  48
F02:0047         lda #$0d
               S01:0000C0A0:  A9 0D
F02:0048         jsr print_chara
               S01:0000C0A2:  20 CB C0
F02:0049         lda #$0a
               S01:0000C0A5:  A9 0A
F02:0050         jsr print_chara
               S01:0000C0A7:  20 CB C0
F02:0051         pla
               S01:0000C0AA:  68
F02:0052         tay
               S01:0000C0AB:  A8
F02:0053         pla
               S01:0000C0AC:  68
F02:0054         tax
               S01:0000C0AD:  AA
F02:0055         pla
               S01:0000C0AE:  68
F02:0056         rts
               S01:0000C0AF:  60
F02:0057       
F02:0058       cleardisplay:
F02:0059         pha
               S01:0000C0B0:  48
F02:0060         jsr txpoll  ; Poll the TX bit
               S01:0000C0B1:  20 BB C0
F02:0061         lda #12     ; Print decimal 12 (CLS)
               S01:0000C0B4:  A9 0C
F02:0062         sta $8000
               S01:0000C0B6:  8D 00 80
F02:0063         pla
               S01:0000C0B9:  68
F02:0064         rts
               S01:0000C0BA:  60
F02:0065       
F02:0066       txpoll:
F02:0067         lda $8001
               S01:0000C0BB:  AD 01 80
F02:0068         and #$10    ; Poll the TX bit
               S01:0000C0BE:  29 10
F02:0069         beq txpoll
               S01:0000C0C0:  F0 F9
F02:0070         rts
               S01:0000C0C2:  60
F02:0071       
F02:0072       rxpoll:
F02:0073         lda $8001
               S01:0000C0C3:  AD 01 80
F02:0074         and #$08    ; Poll the RX bit
               S01:0000C0C6:  29 08
F02:0075         beq rxpoll
               S01:0000C0C8:  F0 F9
F02:0076         rts
               S01:0000C0CA:  60
F02:0077       
F02:0078       
F02:0079       print_chara:
F02:0080         pha
               S01:0000C0CB:  48
F02:0081         jsr txpoll  ; Poll the TX bit
               S01:0000C0CC:  20 BB C0
F02:0082         pla
               S01:0000C0CF:  68
F02:0083         sta $8000   ; Print character from A
               S01:0000C0D0:  8D 00 80
F02:0084         rts
               S01:0000C0D3:  60
F02:0085       
F02:0086       print_char_acia:
F02:0087         jmp print_chara  ; Same as "print_chara"
               S01:0000C0D4:  4C CB C0
F02:0088       
F02:0089       ascii_home:
F02:0090         pha
               S01:0000C0D7:  48
F02:0091         lda #1
               S01:0000C0D8:  A9 01
F02:0092         jsr print_chara  ; Print 1 (HOME)
               S01:0000C0DA:  20 CB C0
F02:0093         pla
               S01:0000C0DD:  68
F02:0094         rts
               S01:0000C0DE:  60
F02:0095       
F02:0096       w_acia_full:
F02:0097         pha
               S01:0000C0DF:  48
F02:0098         lda $ff
               S01:0000C0E0:  A5 FF
F02:0099         pha        ; Push Previous States onto the stack
               S01:0000C0E2:  48
F02:0100         lda $fe
               S01:0000C0E3:  A5 FE
F02:0101         pha
               S01:0000C0E5:  48
F02:0102         sty $ff    ; Set Y as the Upper Address (8-15)
               S01:0000C0E6:  84 FF
F02:0103         stx $fe    ; Set X as the Lower Adderss (0-7)
               S01:0000C0E8:  86 FE
F02:0104         ldy #0
               S01:0000C0EA:  A0 00
F02:0105       acia_man:
F02:0106         jsr txpoll   ; Poll TX
               S01:0000C0EC:  20 BB C0
F02:0107         lda ($fe),y  ; Load the Address
               S01:0000C0EF:  B1 FE
F02:0108         sta $8000    ; Print what is at the address
               S01:0000C0F1:  8D 00 80
F02:0109         beq endwacia ; If Done, End
               S01:0000C0F4:  F0 04
F02:0110         iny          ; Next Character
               S01:0000C0F6:  C8
F02:0111         jmp acia_man ; Back to the top
               S01:0000C0F7:  4C EC C0
F02:0112       endwacia:
F02:0113         pla
               S01:0000C0FA:  68
F02:0114         sta $fe
               S01:0000C0FB:  85 FE
F02:0115         pla          ; Restore Variables
               S01:0000C0FD:  68
F02:0116         sta $ff
               S01:0000C0FE:  85 FF
F02:0117         pla
               S01:0000C100:  68
F02:0118         rts
               S01:0000C101:  60
F02:0119       
F00:0084         .include "libsd.s"
F03:0001       ; SD card interface module
F03:0002       ;
F03:0003       ; Requires zero-page variable storage:
F03:0004       ;   zp_sd_address - a bytes
F03:0005       ;   zp_sd_currentsector - 4 bytes
F03:0006       
F03:0007       cmsg:
F03:0008         .byte "Command: ", $00
               S01:0000C102:  43 6F 6D 6D 61 6E 64 3A 20
               S01:0000C10B:  00
F03:0009       
F03:0010       sd_init:
F03:0011         ; Let the SD card boot up, by pumping the clock with SD CS disabled
F03:0012       
F03:0013         ; We need to apply around 80 clock pulses with CS and MOSI higha
F03:0014         ; Normally MOSI doesn't matter when CS is high, but the card is
F03:0015         ; not yet is SPI mode, and in this non-SPI state it does carea
F03:0016       
F03:0017         lda #SD_CS | SD_MOSI
               S01:0000C10C:  A9 14
F03:0018         ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
               S01:0000C10E:  A2 A0
F03:0019       apreinitloop:
F03:0020         eor #SD_SCK
               S01:0000C110:  49 08
F03:0021         sta PORTA
               S01:0000C112:  8D 01 B0
F03:0022         dex
               S01:0000C115:  CA
F03:0023         bne apreinitloop
               S01:0000C116:  D0 F8
F03:0024         
F03:0025       
F03:0026       acmd0: ; GO_IDLE_STATE - resets card to idle state, and SPI mode
F03:0027         lda #<sd_cmd0_bytes
               S01:0000C118:  A9 7F
F03:0028         sta zp_sd_address
               S01:0000C11A:  85 40
F03:0029         lda #>sd_cmd0_bytes
               S01:0000C11C:  A9 C1
F03:0030         sta zp_sd_address+1
               S01:0000C11E:  85 41
F03:0031       
F03:0032         jsr sd_sendcommand
               S01:0000C120:  20 D1 C1
F03:0033       
F03:0034         ; Expect status response $01 (not initialized)
F03:0035        ; cmp #$01
F03:0036        ; bne ainitfailed
F03:0037       
F03:0038       acmd8: ; SEND_IF_COND - tell the card how we want it to operate (3a3V, etc)
F03:0039         lda #<sd_cmd8_bytes
               S01:0000C123:  A9 85
F03:0040         sta zp_sd_address
               S01:0000C125:  85 40
F03:0041         lda #>sd_cmd8_bytes
               S01:0000C127:  A9 C1
F03:0042         sta zp_sd_address+1
               S01:0000C129:  85 41
F03:0043       
F03:0044         jsr sd_sendcommand
               S01:0000C12B:  20 D1 C1
F03:0045       
F03:0046         ; Expect status response $01 (not initialized)
F03:0047         cmp #$01
               S01:0000C12E:  C9 01
F03:0048         bne ainitfailed
               S01:0000C130:  D0 44
F03:0049       
F03:0050         ; Read 3a-bit return value, but ignore it
F03:0051         jsr sd_readbyte
               S01:0000C132:  20 97 C1
F03:0052         jsr sd_readbyte
               S01:0000C135:  20 97 C1
F03:0053         jsr sd_readbyte
               S01:0000C138:  20 97 C1
F03:0054         jsr sd_readbyte
               S01:0000C13B:  20 97 C1
F03:0055       
F03:0056       acmd55: ; APP_CMD - required prefix for ACMD commands
F03:0057         lda #<sd_cmd55_bytes
               S01:0000C13E:  A9 8B
F03:0058         sta zp_sd_address
               S01:0000C140:  85 40
F03:0059         lda #>sd_cmd55_bytes
               S01:0000C142:  A9 C1
F03:0060         sta zp_sd_address+1
               S01:0000C144:  85 41
F03:0061       
F03:0062         jsr sd_sendcommand
               S01:0000C146:  20 D1 C1
F03:0063       
F03:0064         ; Expect status response $01 (not initialized)
F03:0065         cmp #$01
               S01:0000C149:  C9 01
F03:0066         bne ainitfailed
               S01:0000C14B:  D0 29
F03:0067       
F03:0068       acmd41: ; APP_SEND_OP_COND - send operating conditions, initialize card
F03:0069         lda #<sd_cmd41_bytes
               S01:0000C14D:  A9 91
F03:0070         sta zp_sd_address
               S01:0000C14F:  85 40
F03:0071         lda #>sd_cmd41_bytes
               S01:0000C151:  A9 C1
F03:0072         sta zp_sd_address+1
               S01:0000C153:  85 41
F03:0073       
F03:0074         jsr sd_sendcommand
               S01:0000C155:  20 D1 C1
F03:0075       
F03:0076         ; Status response $00 means initialised
F03:0077         cmp #$00
               S01:0000C158:  C9 00
F03:0078         beq ainitialized
               S01:0000C15A:  F0 11
F03:0079       
F03:0080         ; Otherwise expect status response $01 (not initialized)
F03:0081         cmp #$01
               S01:0000C15C:  C9 01
F03:0082         bne ainitfailed
               S01:0000C15E:  D0 16
F03:0083       
F03:0084         ; Not initialized yet, so wait a while then try againa
F03:0085         ; This retry is important, to give the card time to initializea
F03:0086       
F03:0087         ldx #0
               S01:0000C160:  A2 00
F03:0088         ldy #0
               S01:0000C162:  A0 00
F03:0089       adelayloop:
F03:0090         dey
               S01:0000C164:  88
F03:0091         bne adelayloop
               S01:0000C165:  D0 FD
F03:0092         dex
               S01:0000C167:  CA
F03:0093         bne adelayloop
               S01:0000C168:  D0 FA
F03:0094       
F03:0095         jmp acmd55
               S01:0000C16A:  4C 3E C1
F03:0096       
F03:0097       
F03:0098       ainitialized:
F03:0099         ldy #>initmsg
               S01:0000C16D:  A0 C2
F03:0100         ldx #<initmsg
               S01:0000C16F:  A2 CA
F03:0101         jsr w_acia_full
               S01:0000C171:  20 DF C0
F03:0102         clc
               S01:0000C174:  18
F03:0103         rts
               S01:0000C175:  60
F03:0104       
F03:0105       ainitfailed:
F03:0106         ldy #>initfailedmsg
               S01:0000C176:  A0 C2
F03:0107         ldx #<initfailedmsg
               S01:0000C178:  A2 B0
F03:0108         jsr w_acia_full
               S01:0000C17A:  20 DF C0
F03:0109       aloop:
F03:0110         sec
               S01:0000C17D:  38
F03:0111         rts
               S01:0000C17E:  60
F03:0112       
F03:0113       sd_cmd0_bytes:
F03:0114         .byte $40, $00, $00, $00, $00, $95
               S01:0000C17F:  40
               S01:0000C180:  00
               S01:0000C181:  00
               S01:0000C182:  00
               S01:0000C183:  00
               S01:0000C184:  95
F03:0115       sd_cmd8_bytes:
F03:0116         .byte $48, $00, $00, $01, $aa, $87
               S01:0000C185:  48
               S01:0000C186:  00
               S01:0000C187:  00
               S01:0000C188:  01
               S01:0000C189:  AA
               S01:0000C18A:  87
F03:0117       sd_cmd55_bytes:
F03:0118         .byte $77, $00, $00, $00, $00, $01
               S01:0000C18B:  77
               S01:0000C18C:  00
               S01:0000C18D:  00
               S01:0000C18E:  00
               S01:0000C18F:  00
               S01:0000C190:  01
F03:0119       sd_cmd41_bytes:
F03:0120         .byte $69, $40, $00, $00, $00, $01
               S01:0000C191:  69
               S01:0000C192:  40
               S01:0000C193:  00
               S01:0000C194:  00
               S01:0000C195:  00
               S01:0000C196:  01
F03:0121       
F03:0122       
F03:0123       
F03:0124       sd_readbyte:
F03:0125         ; Enable the card and tick the clock 8 times with MOSI high, 
F03:0126         ; capturing bits from MISO and returning them
F03:0127       
F03:0128         ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
               S01:0000C197:  A2 FE
F03:0129       
F03:0130       baloop:
F03:0131       
F03:0132         lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
               S01:0000C199:  A9 04
F03:0133         sta PORTA
               S01:0000C19B:  8D 01 B0
F03:0134       
F03:0135         lda #SD_MOSI | SD_SCK       ; toggle the clock high
               S01:0000C19E:  A9 0C
F03:0136         sta PORTA
               S01:0000C1A0:  8D 01 B0
F03:0137       
F03:0138         lda PORTA                   ; read next bit
               S01:0000C1A3:  AD 01 B0
F03:0139         and #SD_MISO
               S01:0000C1A6:  29 02
F03:0140       
F03:0141         clc                         ; default to clearing the bottom bit
               S01:0000C1A8:  18
F03:0142         beq abitnotset              ; unless MISO was set
               S01:0000C1A9:  F0 01
F03:0143         sec                         ; in which case get ready to set the bottom bit
               S01:0000C1AB:  38
F03:0144       abitnotset:
F03:0145       
F03:0146         txa                         ; transfer partial result from X
               S01:0000C1AC:  8A
F03:0147         rol                         ; rotate carry bit into read result, and loop bit into carry
               S01:0000C1AD:  2A
F03:0148         tax                         ; save partial result back to X
               S01:0000C1AE:  AA
F03:0149         
F03:0150         bcs baloop                   ; loop if we need to read more bits
               S01:0000C1AF:  B0 E8
F03:0151       
F03:0152         rts
               S01:0000C1B1:  60
F03:0153       
F03:0154       
F03:0155       sd_writebyte:
F03:0156         ; Tick the clock 8 times with descending bits on MOSI
F03:0157         ; SD communication is mostly half-duplex so we ignore anything it sends back here
F03:0158       
F03:0159         ldx #8                      ; send 8 bits
               S01:0000C1B2:  A2 08
F03:0160       
F03:0161       arloop:
F03:0162         asl                         ; shift next bit into carry
               S01:0000C1B4:  0A
F03:0163         tay                         ; save remaining bits for later
               S01:0000C1B5:  A8
F03:0164       
F03:0165         lda #0
               S01:0000C1B6:  A9 00
F03:0166         bcc asendbit                ; if carry clear, don't set MOSI for this bit
               S01:0000C1B8:  90 02
F03:0167         ora #SD_MOSI
               S01:0000C1BA:  09 04
F03:0168       
F03:0169       asendbit:
F03:0170         sta PORTA                   ; set MOSI (or not) first with SCK low
               S01:0000C1BC:  8D 01 B0
F03:0171         eor #SD_SCK
               S01:0000C1BF:  49 08
F03:0172         sta PORTA                   ; raise SCK keeping MOSI the same, to send the bit
               S01:0000C1C1:  8D 01 B0
F03:0173       
F03:0174         tya                         ; restore remaining bits to send
               S01:0000C1C4:  98
F03:0175       
F03:0176         dex
               S01:0000C1C5:  CA
F03:0177         bne arloop                   ; loop if there are more bits to send
               S01:0000C1C6:  D0 EC
F03:0178       
F03:0179         rts
               S01:0000C1C8:  60
F03:0180       
F03:0181       
F03:0182       sd_waitresult:
F03:0183         ; Wait for the SD card to return something other than $ff
F03:0184         jsr sd_readbyte
               S01:0000C1C9:  20 97 C1
F03:0185         cmp #$ff
               S01:0000C1CC:  C9 FF
F03:0186         beq sd_waitresult
               S01:0000C1CE:  F0 F9
F03:0187         rts
               S01:0000C1D0:  60
F03:0188       
F03:0189       
F03:0190       sd_sendcommand:
F03:0191         ; Debug print which command is being executed
F03:0192        ; jsr lcd_cleardisplay
F03:0193        ; jsr cleardisplay
F03:0194       
F03:0195       ;  phx
F03:0196       ;  phy
F03:0197       ;  ldx #<cmsg
F03:0198       ;  ldy #>cmsg
F03:0199       ;  jsr w_acia_full
F03:0200       ;  ply
F03:0201       ;  plx
F03:0202       
F03:0203       ;  ldx #0
F03:0204       ;  lda (zp_sd_address,x)
F03:0205       ;  jsr print_hex_acia
F03:0206       
F03:0207       ;  lda #$a0
F03:0208       ;  jsr print_chara
F03:0209       ;  
F03:0210       ;  lda #$a0
F03:0211       ;  jsr print_chara
F03:0212       
F03:0213         lda #SD_MOSI           ; pull CS low to begin command
               S01:0000C1D1:  A9 04
F03:0214         sta PORTA
               S01:0000C1D3:  8D 01 B0
F03:0215       
F03:0216         ldy #0
               S01:0000C1D6:  A0 00
F03:0217         lda (zp_sd_address),y    ; command byte
               S01:0000C1D8:  B1 40
F03:0218         jsr sd_writebyte
               S01:0000C1DA:  20 B2 C1
F03:0219         ldy #1
               S01:0000C1DD:  A0 01
F03:0220         lda (zp_sd_address),y    ; data 1
               S01:0000C1DF:  B1 40
F03:0221         jsr sd_writebyte
               S01:0000C1E1:  20 B2 C1
F03:0222         ldy #2
               S01:0000C1E4:  A0 02
F03:0223         lda (zp_sd_address),y    ; data 2
               S01:0000C1E6:  B1 40
F03:0224         jsr sd_writebyte
               S01:0000C1E8:  20 B2 C1
F03:0225         ldy #3
               S01:0000C1EB:  A0 03
F03:0226         lda (zp_sd_address),y    ; data 3
               S01:0000C1ED:  B1 40
F03:0227         jsr sd_writebyte
               S01:0000C1EF:  20 B2 C1
F03:0228         ldy #4
               S01:0000C1F2:  A0 04
F03:0229         lda (zp_sd_address),y    ; data 4
               S01:0000C1F4:  B1 40
F03:0230         jsr sd_writebyte
               S01:0000C1F6:  20 B2 C1
F03:0231         ldy #5
               S01:0000C1F9:  A0 05
F03:0232         lda (zp_sd_address),y    ; crc
               S01:0000C1FB:  B1 40
F03:0233         jsr sd_writebyte
               S01:0000C1FD:  20 B2 C1
F03:0234       
F03:0235         jsr sd_waitresult
               S01:0000C200:  20 C9 C1
F03:0236         pha
               S01:0000C203:  48
F03:0237       
F03:0238       ;  phy
F03:0239       ;  phx
F03:0240       ;  ldy #>respmsg
F03:0241       ;  ldx #<respmsg
F03:0242       ;  jsr w_acia_full
F03:0243       ;  ply
F03:0244       ;  plx
F03:0245       
F03:0246         ; Debug print the result code
F03:0247       ;  jsr print_hex_acia
F03:0248       
F03:0249       ;  lda #$0d
F03:0250       ;  jsr print_chara
F03:0251       ;  
F03:0252       ;  lda #$0a
F03:0253       ;  jsr print_chara
F03:0254       
F03:0255         ; End command
F03:0256         lda #SD_CS | SD_MOSI   ; set CS high again
               S01:0000C204:  A9 14
F03:0257         sta PORTA
               S01:0000C206:  8D 01 B0
F03:0258       
F03:0259         pla   ; restore result code
               S01:0000C209:  68
F03:0260         rts
               S01:0000C20A:  60
F03:0261       
F03:0262       
F03:0263       sd_readsector:
F03:0264         ; Read a sector from the SD carda  A sector is 512 bytes.
F03:0265         ;
F03:0266         ; Parameters:
F03:0267         ;    zp_sd_currentsector   3a-bit sector number
F03:0268         ;    zp_sd_address     address of buffer to receive data
F03:0269         
F03:0270         lda #SD_MOSI
               S01:0000C20B:  A9 04
F03:0271         sta PORTA
               S01:0000C20D:  8D 01 B0
F03:0272       
F03:0273         ; Command 17, arg is sector number, crc not checked
F03:0274         lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S01:0000C210:  A9 51
F03:0275         jsr sd_writebyte
               S01:0000C212:  20 B2 C1
F03:0276         lda zp_sd_currentsector+3   ; sector 24:31
               S01:0000C215:  A5 45
F03:0277         jsr sd_writebyte
               S01:0000C217:  20 B2 C1
F03:0278         lda zp_sd_currentsector+2   ; sector 16:23
               S01:0000C21A:  A5 44
F03:0279         jsr sd_writebyte
               S01:0000C21C:  20 B2 C1
F03:0280         lda zp_sd_currentsector+1   ; sector 8:15
               S01:0000C21F:  A5 43
F03:0281         jsr sd_writebyte
               S01:0000C221:  20 B2 C1
F03:0282         lda zp_sd_currentsector     ; sector 0:7
               S01:0000C224:  A5 42
F03:0283         jsr sd_writebyte
               S01:0000C226:  20 B2 C1
F03:0284         lda #$01                    ; crc (not checked)
               S01:0000C229:  A9 01
F03:0285         jsr sd_writebyte
               S01:0000C22B:  20 B2 C1
F03:0286       
F03:0287         jsr sd_waitresult
               S01:0000C22E:  20 C9 C1
F03:0288         cmp #$00
               S01:0000C231:  C9 00
F03:0289         bne afail
               S01:0000C233:  D0 53
F03:0290       
F03:0291         ; wait for data
F03:0292         jsr sd_waitresult
               S01:0000C235:  20 C9 C1
F03:0293         cmp #$fe
               S01:0000C238:  C9 FE
F03:0294         bne afail
               S01:0000C23A:  D0 4C
F03:0295       
F03:0296         ; Need to read 512 bytes - two pages of 256 bytes each
F03:0297         jsr areadpage
               S01:0000C23C:  20 91 C2
F03:0298         inc zp_sd_address+1
               S01:0000C23F:  E6 41
F03:0299         jsr areadpage
               S01:0000C241:  20 91 C2
F03:0300         dec zp_sd_address+1
               S01:0000C244:  C6 41
F03:0301       
F03:0302         ; End command
F03:0303         lda #SD_CS | SD_MOSI
               S01:0000C246:  A9 14
F03:0304         sta PORTA
               S01:0000C248:  8D 01 B0
F03:0305         
F03:0306         sec
               S01:0000C24B:  38
F03:0307         rts
               S01:0000C24C:  60
F03:0308       
F03:0309       sd_writesector:
F03:0310         ; Write a sector to the SD card.  A sector is 512 bytes.
F03:0311         ;
F03:0312         ; Parameters:
F03:0313         ;    zp_sd_currentsector   32-bit sector number
F03:0314         ;    zp_sd_address     address of buffer to take data from
F03:0315         
F03:0316         lda #SD_MISO
               S01:0000C24D:  A9 02
F03:0317         sta PORTA
               S01:0000C24F:  8D 01 B0
F03:0318       
F03:0319         ; Command 24, arg is sector number, crc not checked
F03:0320         lda #$58                    ; CMD24 - WRITE_BLOCK
               S01:0000C252:  A9 58
F03:0321         jsr sd_writebyte
               S01:0000C254:  20 B2 C1
F03:0322         lda zp_sd_currentsector+3   ; sector 24:31
               S01:0000C257:  A5 45
F03:0323         jsr sd_writebyte
               S01:0000C259:  20 B2 C1
F03:0324         lda zp_sd_currentsector+2   ; sector 16:23
               S01:0000C25C:  A5 44
F03:0325         jsr sd_writebyte
               S01:0000C25E:  20 B2 C1
F03:0326         lda zp_sd_currentsector+1   ; sector 8:15
               S01:0000C261:  A5 43
F03:0327         jsr sd_writebyte
               S01:0000C263:  20 B2 C1
F03:0328         lda zp_sd_currentsector     ; sector 0:7
               S01:0000C266:  A5 42
F03:0329         jsr sd_writebyte
               S01:0000C268:  20 B2 C1
F03:0330         lda #$01                    ; crc (not checked)
               S01:0000C26B:  A9 01
F03:0331         jsr sd_writebyte
               S01:0000C26D:  20 B2 C1
F03:0332       
F03:0333         jsr sd_waitresult
               S01:0000C270:  20 C9 C1
F03:0334         cmp #$00
               S01:0000C273:  C9 00
F03:0335         bne afail
               S01:0000C275:  D0 11
F03:0336       
F03:0337         ; wait for data
F03:0338         ;jsr sd_waitresult
F03:0339         ;cmp #$fe
F03:0340         ;bne afail
F03:0341         ; BUG I don't think it need to wait for any more data, but I gotta check the datasheet more... (hard to read)
F03:0342       
F03:0343         ; Need to write 512 bytes - two pages of 256 bytes each
F03:0344         jsr awritepage
               S01:0000C277:  20 9C C2
F03:0345         inc zp_sd_address+1
               S01:0000C27A:  E6 41
F03:0346         jsr awritepage
               S01:0000C27C:  20 9C C2
F03:0347         dec zp_sd_address+1
               S01:0000C27F:  C6 41
F03:0348       
F03:0349         ; End command
F03:0350         lda #SD_CS | SD_MOSI ; set cs and mosi high (disconnected)
               S01:0000C281:  A9 14
F03:0351         sta PORTA
               S01:0000C283:  8D 01 B0
F03:0352       
F03:0353         sec
               S01:0000C286:  38
F03:0354         rts
               S01:0000C287:  60
F03:0355       
F03:0356       afail:
F03:0357         ldx #<failedmsg
               S01:0000C288:  A2 B5
F03:0358         ldy #>failedmsg  ;Failed!
               S01:0000C28A:  A0 C2
F03:0359         jsr w_acia_full
               S01:0000C28C:  20 DF C0
F03:0360       afailloop:
F03:0361         clc
               S01:0000C28F:  18
F03:0362         rts
               S01:0000C290:  60
F03:0363       
F03:0364       areadpage:
F03:0365         ; Read 256 bytes to the address at zp_sd_address
F03:0366         ldy #0
               S01:0000C291:  A0 00
F03:0367       areadloop:
F03:0368         jsr sd_readbyte
               S01:0000C293:  20 97 C1
F03:0369         sta (zp_sd_address),y
               S01:0000C296:  91 40
F03:0370         iny
               S01:0000C298:  C8
F03:0371         bne areadloop
               S01:0000C299:  D0 F8
F03:0372         rts
               S01:0000C29B:  60
F03:0373       
F03:0374       awritepage:
F03:0375         ; Write 256 bytes to the sd card
F03:0376         ldy #0
               S01:0000C29C:  A0 00
F03:0377       awriteloop:
F03:0378         lda (zp_sd_address),y
               S01:0000C29E:  B1 40
F03:0379         jsr sd_writebyte
               S01:0000C2A0:  20 B2 C1
F03:0380         iny
               S01:0000C2A3:  C8
F03:0381         bne awriteloop
               S01:0000C2A4:  D0 F8
F03:0382         rts
               S01:0000C2A6:  60
F03:0383       
F03:0384       statusmsg:
F03:0385         .byte "Status: ", $00
               S01:0000C2A7:  53 74 61 74 75 73 3A 20
               S01:0000C2AF:  00
F03:0386       initfailedmsg:
F03:0387         .byte "Init "
               S01:0000C2B0:  49 6E 69 74 20
F03:0388       failedmsg:
F03:0389         .byte "Failed!", $0d, $0a, $00
               S01:0000C2B5:  46 61 69 6C 65 64 21
               S01:0000C2BC:  0D
               S01:0000C2BD:  0A
               S01:0000C2BE:  00
F03:0390       respmsg:
F03:0391         .byte "Response: ", $00
               S01:0000C2BF:  52 65 73 70 6F 6E 73 65 3A 20
               S01:0000C2C9:  00
F03:0392       initmsg:
F03:0393         .byte "Initialized!", $0d, $0a, $00
               S01:0000C2CA:  49 6E 69 74 69 61 6C 69 7A 65 64 21
               S01:0000C2D6:  0D
               S01:0000C2D7:  0A
               S01:0000C2D8:  00
F03:0394       
F00:0085         .include "libfat32.s"
F04:0001       ; FAT32/SD interface library
F04:0002       ;
F04:0003       ; This module requires some RAM workspace to be defined elsewhere:
F04:0004       ; 
F04:0005       ; fat32_workspace    - a large page-aligned 512-byte workspace
F04:0006       ; zp_fat32_variables - 24 bytes of zero-page storage for variables etc
F04:0007       
F04:0008       fat32_readbuffer = fat32_workspace
F04:0009       
F04:0010       fat32_fatstart          	= zp_fat32_variables + $00  ; 4 bytes
F04:0011       fat32_datastart         	= zp_fat32_variables + $04  ; 4 bytes
F04:0012       fat32_rootcluster       	= zp_fat32_variables + $08  ; 4 bytes
F04:0013       fat32_sectorspercluster 	= zp_fat32_variables + $0c  ; 1 byte
F04:0014       fat32_pendingsectors    	= zp_fat32_variables + $0d  ; 1 byte
F04:0015       fat32_address           	= zp_fat32_variables + $0e  ; 2 bytes
F04:0016       fat32_nextcluster       	= zp_fat32_variables + $10  ; 4 bytes
F04:0017       fat32_bytesremaining    	= zp_fat32_variables + $14  ; 4 bytes   	
F04:0018       fat32_lastfoundfreecluster	= zp_fat32_variables + $18  ; 4 bytes
F04:0019       fat32_result			= zp_fat32_variables + $1c  ; 2 bytes
F04:0020       fat32_dwcount			= zp_fat32_variables + $1e  ; 2 bytes
F04:0021       
F04:0022       fat32_errorstage        = fat32_bytesremaining  ; only used during initialization
F04:0023       fat32_filenamepointer   = fat32_bytesremaining  ; only used when searching for a file
F04:0024       fat32_lba		= fat32_bytesremaining  ; only used when making a dirent
F04:0025       
F04:0026       fat32_init:
F04:0027         ; Initialize the module - read the MBR etc, find the partition,
F04:0028         ; and set up the variables ready for navigating the filesystem
F04:0029       
F04:0030         ; Read the MBR and extract pertinent information
F04:0031       
F04:0032         lda #0
               S01:0000C2D9:  A9 00
F04:0033         sta fat32_errorstage
               S01:0000C2DB:  85 5A
F04:0034       
F04:0035         ; Sector 0
F04:0036         lda #0
               S01:0000C2DD:  A9 00
F04:0037         sta zp_sd_currentsector
               S01:0000C2DF:  85 42
F04:0038         sta zp_sd_currentsector+1
               S01:0000C2E1:  85 43
F04:0039         sta zp_sd_currentsector+2
               S01:0000C2E3:  85 44
F04:0040         sta zp_sd_currentsector+3
               S01:0000C2E5:  85 45
F04:0041       
F04:0042         ; Target buffer
F04:0043         lda #<fat32_readbuffer
               S01:0000C2E7:  A9 00
F04:0044         sta zp_sd_address
               S01:0000C2E9:  85 40
F04:0045         lda #>fat32_readbuffer
               S01:0000C2EB:  A9 02
F04:0046         sta zp_sd_address+1
               S01:0000C2ED:  85 41
F04:0047       
F04:0048         ; Do the read
F04:0049         jsr sd_readsector
               S01:0000C2EF:  20 0B C2
F04:0050       
F04:0051       
F04:0052         inc fat32_errorstage ; stage 1 = boot sector signature check
               S01:0000C2F2:  E6 5A
F04:0053       
F04:0054         ; Check some things
F04:0055         lda fat32_readbuffer+510 ; Boot sector signature 55
               S01:0000C2F4:  AD FE 03
F04:0056         cmp #$55
               S01:0000C2F7:  C9 55
F04:0057         bne ufail
               S01:0000C2F9:  D0 2D
F04:0058         lda fat32_readbuffer+511 ; Boot sector signature aa
               S01:0000C2FB:  AD FF 03
F04:0059         cmp #$aa
               S01:0000C2FE:  C9 AA
F04:0060         bne ufail
               S01:0000C300:  D0 26
F04:0061       
F04:0062       
F04:0063         inc fat32_errorstage ; stage 2 = finding partition
               S01:0000C302:  E6 5A
F04:0064       
F04:0065         ; Find a FAT32 partition
F04:0066       uFSTYPE_FAT32 = 12
F04:0067         ldx #0
               S01:0000C304:  A2 00
F04:0068         lda fat32_readbuffer+$1c2,x
               S01:0000C306:  BD C2 03
F04:0069         cmp #uFSTYPE_FAT32
               S01:0000C309:  C9 0C
F04:0070         beq ufoundpart
               S01:0000C30B:  F0 1E
F04:0071         ldx #16
               S01:0000C30D:  A2 10
F04:0072         lda fat32_readbuffer+$1c2,x
               S01:0000C30F:  BD C2 03
F04:0073         cmp #uFSTYPE_FAT32
               S01:0000C312:  C9 0C
F04:0074         beq ufoundpart
               S01:0000C314:  F0 15
F04:0075         ldx #32
               S01:0000C316:  A2 20
F04:0076         lda fat32_readbuffer+$1c2,x
               S01:0000C318:  BD C2 03
F04:0077         cmp #uFSTYPE_FAT32
               S01:0000C31B:  C9 0C
F04:0078         beq ufoundpart
               S01:0000C31D:  F0 0C
F04:0079         ldx #48
               S01:0000C31F:  A2 30
F04:0080         lda fat32_readbuffer+$1c2,x
               S01:0000C321:  BD C2 03
F04:0081         cmp #uFSTYPE_FAT32
               S01:0000C324:  C9 0C
F04:0082         beq ufoundpart
               S01:0000C326:  F0 03
F04:0083       
F04:0084       ufail:
F04:0085         jmp uerror
               S01:0000C328:  4C DF C3
F04:0086       
F04:0087       ufoundpart:
F04:0088       
F04:0089         ; Read the FAT32 BPB
F04:0090         lda fat32_readbuffer+$1c6,x
               S01:0000C32B:  BD C6 03
F04:0091         sta zp_sd_currentsector
               S01:0000C32E:  85 42
F04:0092         lda fat32_readbuffer+$1c7,x
               S01:0000C330:  BD C7 03
F04:0093         sta zp_sd_currentsector+1
               S01:0000C333:  85 43
F04:0094         lda fat32_readbuffer+$1c8,x
               S01:0000C335:  BD C8 03
F04:0095         sta zp_sd_currentsector+2
               S01:0000C338:  85 44
F04:0096         lda fat32_readbuffer+$1c9,x
               S01:0000C33A:  BD C9 03
F04:0097         sta zp_sd_currentsector+3
               S01:0000C33D:  85 45
F04:0098       
F04:0099         jsr sd_readsector
               S01:0000C33F:  20 0B C2
F04:0100       
F04:0101       
F04:0102         inc fat32_errorstage ; stage 3 = BPB signature check
               S01:0000C342:  E6 5A
F04:0103       
F04:0104         ; Check some things
F04:0105         lda fat32_readbuffer+510 ; BPB sector signature 55
               S01:0000C344:  AD FE 03
F04:0106         cmp #$55
               S01:0000C347:  C9 55
F04:0107         bne ufail
               S01:0000C349:  D0 DD
F04:0108         lda fat32_readbuffer+511 ; BPB sector signature aa
               S01:0000C34B:  AD FF 03
F04:0109         cmp #$aa
               S01:0000C34E:  C9 AA
F04:0110         bne ufail
               S01:0000C350:  D0 D6
F04:0111       
F04:0112         inc fat32_errorstage ; stage 4 = RootEntCnt check
               S01:0000C352:  E6 5A
F04:0113       
F04:0114         lda fat32_readbuffer+17 ; RootEntCnt should be 0 for FAT32
               S01:0000C354:  AD 11 02
F04:0115         ora fat32_readbuffer+18
               S01:0000C357:  0D 12 02
F04:0116         bne ufail
               S01:0000C35A:  D0 CC
F04:0117       
F04:0118         inc fat32_errorstage ; stage 5 = TotSec16 check
               S01:0000C35C:  E6 5A
F04:0119       
F04:0120         lda fat32_readbuffer+19 ; TotSec16 should be 0 for FAT32
               S01:0000C35E:  AD 13 02
F04:0121         ora fat32_readbuffer+20
               S01:0000C361:  0D 14 02
F04:0122         bne ufail
               S01:0000C364:  D0 C2
F04:0123       
F04:0124         inc fat32_errorstage ; stage 6 = SectorsPerCluster check
               S01:0000C366:  E6 5A
F04:0125       
F04:0126         ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
F04:0127         lda fat32_readbuffer+11 ; low byte should be zero
               S01:0000C368:  AD 0B 02
F04:0128         bne ufail
               S01:0000C36B:  D0 BB
F04:0129         lda fat32_readbuffer+12 ; high byte is 2 (512), 4, 8, or 16
               S01:0000C36D:  AD 0C 02
F04:0130         cmp #2
               S01:0000C370:  C9 02
F04:0131         bne ufail
               S01:0000C372:  D0 B4
F04:0132       
F04:0133       
F04:0134         ; Calculate the starting sector of the FAT
F04:0135         clc
               S01:0000C374:  18
F04:0136         lda zp_sd_currentsector
               S01:0000C375:  A5 42
F04:0137         adc fat32_readbuffer+14    ; reserved sectors lo
               S01:0000C377:  6D 0E 02
F04:0138         sta fat32_fatstart
               S01:0000C37A:  85 46
F04:0139         sta fat32_datastart
               S01:0000C37C:  85 4A
F04:0140         lda zp_sd_currentsector+1
               S01:0000C37E:  A5 43
F04:0141         adc fat32_readbuffer+15    ; reserved sectors hi
               S01:0000C380:  6D 0F 02
F04:0142         sta fat32_fatstart+1
               S01:0000C383:  85 47
F04:0143         sta fat32_datastart+1
               S01:0000C385:  85 4B
F04:0144         lda zp_sd_currentsector+2
               S01:0000C387:  A5 44
F04:0145         adc #0
               S01:0000C389:  69 00
F04:0146         sta fat32_fatstart+2
               S01:0000C38B:  85 48
F04:0147         sta fat32_datastart+2
               S01:0000C38D:  85 4C
F04:0148         lda zp_sd_currentsector+3
               S01:0000C38F:  A5 45
F04:0149         adc #0
               S01:0000C391:  69 00
F04:0150         sta fat32_fatstart+3
               S01:0000C393:  85 49
F04:0151         sta fat32_datastart+3
               S01:0000C395:  85 4D
F04:0152       
F04:0153         ; Calculate the starting sector of the data area
F04:0154         ldx fat32_readbuffer+16   ; number of FATs
               S01:0000C397:  AE 10 02
F04:0155       uskipfatsloop:
F04:0156         clc
               S01:0000C39A:  18
F04:0157         lda fat32_datastart
               S01:0000C39B:  A5 4A
F04:0158         adc fat32_readbuffer+36 ; fatsize 0
               S01:0000C39D:  6D 24 02
F04:0159         sta fat32_datastart
               S01:0000C3A0:  85 4A
F04:0160         lda fat32_datastart+1
               S01:0000C3A2:  A5 4B
F04:0161         adc fat32_readbuffer+37 ; fatsize 1
               S01:0000C3A4:  6D 25 02
F04:0162         sta fat32_datastart+1
               S01:0000C3A7:  85 4B
F04:0163         lda fat32_datastart+2
               S01:0000C3A9:  A5 4C
F04:0164         adc fat32_readbuffer+38 ; fatsize 2
               S01:0000C3AB:  6D 26 02
F04:0165         sta fat32_datastart+2
               S01:0000C3AE:  85 4C
F04:0166         lda fat32_datastart+3
               S01:0000C3B0:  A5 4D
F04:0167         adc fat32_readbuffer+39 ; fatsize 3
               S01:0000C3B2:  6D 27 02
F04:0168         sta fat32_datastart+3
               S01:0000C3B5:  85 4D
F04:0169         dex
               S01:0000C3B7:  CA
F04:0170         bne uskipfatsloop
               S01:0000C3B8:  D0 E0
F04:0171       
F04:0172         ; Sectors-per-cluster is a power of two from 1 to 128
F04:0173         lda fat32_readbuffer+13
               S01:0000C3BA:  AD 0D 02
F04:0174         sta fat32_sectorspercluster
               S01:0000C3BD:  85 52
F04:0175       
F04:0176         ; Remember the root cluster
F04:0177         lda fat32_readbuffer+44
               S01:0000C3BF:  AD 2C 02
F04:0178         sta fat32_rootcluster
               S01:0000C3C2:  85 4E
F04:0179         lda fat32_readbuffer+45
               S01:0000C3C4:  AD 2D 02
F04:0180         sta fat32_rootcluster+1
               S01:0000C3C7:  85 4F
F04:0181         lda fat32_readbuffer+46
               S01:0000C3C9:  AD 2E 02
F04:0182         sta fat32_rootcluster+2
               S01:0000C3CC:  85 50
F04:0183         lda fat32_readbuffer+47
               S01:0000C3CE:  AD 2F 02
F04:0184         sta fat32_rootcluster+3
               S01:0000C3D1:  85 51
F04:0185       
F04:0186         ; Set the last fount free cluster to 0.
F04:0187         lda #0
               S01:0000C3D3:  A9 00
F04:0188         sta fat32_lastfoundfreecluster
               S01:0000C3D5:  85 5E
F04:0189         sta fat32_lastfoundfreecluster+1
               S01:0000C3D7:  85 5F
F04:0190         sta fat32_lastfoundfreecluster+2
               S01:0000C3D9:  85 60
F04:0191         sta fat32_lastfoundfreecluster+3
               S01:0000C3DB:  85 61
F04:0192         clc
               S01:0000C3DD:  18
F04:0193         rts
               S01:0000C3DE:  60
F04:0194       
F04:0195       uerror:
F04:0196         sec
               S01:0000C3DF:  38
F04:0197         rts
               S01:0000C3E0:  60
F04:0198       
F04:0199       
F04:0200       fat32_seekcluster:
F04:0201         ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
F04:0202         
F04:0203         ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
F04:0204         lda fat32_nextcluster
               S01:0000C3E1:  A5 56
F04:0205         asl
               S01:0000C3E3:  0A
F04:0206         lda fat32_nextcluster+1
               S01:0000C3E4:  A5 57
F04:0207         rol
               S01:0000C3E6:  2A
F04:0208         sta zp_sd_currentsector
               S01:0000C3E7:  85 42
F04:0209         lda fat32_nextcluster+2
               S01:0000C3E9:  A5 58
F04:0210         rol
               S01:0000C3EB:  2A
F04:0211         sta zp_sd_currentsector+1
               S01:0000C3EC:  85 43
F04:0212         lda fat32_nextcluster+3
               S01:0000C3EE:  A5 59
F04:0213         rol
               S01:0000C3F0:  2A
F04:0214         sta zp_sd_currentsector+2
               S01:0000C3F1:  85 44
F04:0215         ; note: cluster numbers never have the top bit set, so no carry can occur
F04:0216       
F04:0217         ; Add FAT starting sector
F04:0218         lda zp_sd_currentsector
               S01:0000C3F3:  A5 42
F04:0219         adc fat32_fatstart
               S01:0000C3F5:  65 46
F04:0220         sta zp_sd_currentsector
               S01:0000C3F7:  85 42
F04:0221         lda zp_sd_currentsector+1
               S01:0000C3F9:  A5 43
F04:0222         adc fat32_fatstart+1
               S01:0000C3FB:  65 47
F04:0223         sta zp_sd_currentsector+1
               S01:0000C3FD:  85 43
F04:0224         lda zp_sd_currentsector+2
               S01:0000C3FF:  A5 44
F04:0225         adc fat32_fatstart+2
               S01:0000C401:  65 48
F04:0226         sta zp_sd_currentsector+2
               S01:0000C403:  85 44
F04:0227         lda #0
               S01:0000C405:  A9 00
F04:0228         adc fat32_fatstart+3
               S01:0000C407:  65 49
F04:0229         sta zp_sd_currentsector+3
               S01:0000C409:  85 45
F04:0230       
F04:0231         ; Target buffer
F04:0232         lda #<fat32_readbuffer
               S01:0000C40B:  A9 00
F04:0233         sta zp_sd_address
               S01:0000C40D:  85 40
F04:0234         lda #>fat32_readbuffer
               S01:0000C40F:  A9 02
F04:0235         sta zp_sd_address+1
               S01:0000C411:  85 41
F04:0236       
F04:0237         ; Read the sector from the FAT
F04:0238         jsr sd_readsector
               S01:0000C413:  20 0B C2
F04:0239       
F04:0240         ; Before using this FAT data, set currentsector ready to read the cluster itself
F04:0241         ; We need to multiply the cluster number minus two by the number of sectors per 
F04:0242         ; cluster, then add the data region start sector
F04:0243       
F04:0244         ; Subtract two from cluster number
F04:0245         sec
               S01:0000C416:  38
F04:0246         lda fat32_nextcluster
               S01:0000C417:  A5 56
F04:0247         sbc #2
               S01:0000C419:  E9 02
F04:0248         sta zp_sd_currentsector
               S01:0000C41B:  85 42
F04:0249         lda fat32_nextcluster+1
               S01:0000C41D:  A5 57
F04:0250         sbc #0
               S01:0000C41F:  E9 00
F04:0251         sta zp_sd_currentsector+1
               S01:0000C421:  85 43
F04:0252         lda fat32_nextcluster+2
               S01:0000C423:  A5 58
F04:0253         sbc #0
               S01:0000C425:  E9 00
F04:0254         sta zp_sd_currentsector+2
               S01:0000C427:  85 44
F04:0255         lda fat32_nextcluster+3
               S01:0000C429:  A5 59
F04:0256         sbc #0
               S01:0000C42B:  E9 00
F04:0257         sta zp_sd_currentsector+3
               S01:0000C42D:  85 45
F04:0258         
F04:0259         ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
F04:0260         lda fat32_sectorspercluster
               S01:0000C42F:  A5 52
F04:0261       uspcshiftloop:
F04:0262         lsr
               S01:0000C431:  4A
F04:0263         bcs uspcshiftloopdone
               S01:0000C432:  B0 0B
F04:0264         asl zp_sd_currentsector
               S01:0000C434:  06 42
F04:0265         rol zp_sd_currentsector+1
               S01:0000C436:  26 43
F04:0266         rol zp_sd_currentsector+2
               S01:0000C438:  26 44
F04:0267         rol zp_sd_currentsector+3
               S01:0000C43A:  26 45
F04:0268         jmp uspcshiftloop
               S01:0000C43C:  4C 31 C4
F04:0269       uspcshiftloopdone:
F04:0270       
F04:0271         ; Add the data region start sector
F04:0272         clc
               S01:0000C43F:  18
F04:0273         lda zp_sd_currentsector
               S01:0000C440:  A5 42
F04:0274         adc fat32_datastart
               S01:0000C442:  65 4A
F04:0275         sta zp_sd_currentsector
               S01:0000C444:  85 42
F04:0276         lda zp_sd_currentsector+1
               S01:0000C446:  A5 43
F04:0277         adc fat32_datastart+1
               S01:0000C448:  65 4B
F04:0278         sta zp_sd_currentsector+1
               S01:0000C44A:  85 43
F04:0279         lda zp_sd_currentsector+2
               S01:0000C44C:  A5 44
F04:0280         adc fat32_datastart+2
               S01:0000C44E:  65 4C
F04:0281         sta zp_sd_currentsector+2
               S01:0000C450:  85 44
F04:0282         lda zp_sd_currentsector+3
               S01:0000C452:  A5 45
F04:0283         adc fat32_datastart+3
               S01:0000C454:  65 4D
F04:0284         sta zp_sd_currentsector+3
               S01:0000C456:  85 45
F04:0285       
F04:0286         ; That's now ready for later code to read this sector in - tell it how many consecutive
F04:0287         ; sectors it can now read
F04:0288         lda fat32_sectorspercluster
               S01:0000C458:  A5 52
F04:0289         sta fat32_pendingsectors
               S01:0000C45A:  85 53
F04:0290       
F04:0291         ; Now go back to looking up the next cluster in the chain
F04:0292         ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
F04:0293       
F04:0294         ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
F04:0295         lda fat32_nextcluster
               S01:0000C45C:  A5 56
F04:0296         and #$7f
               S01:0000C45E:  29 7F
F04:0297         asl
               S01:0000C460:  0A
F04:0298         asl
               S01:0000C461:  0A
F04:0299         tay ; Y = low byte of offset
               S01:0000C462:  A8
F04:0300       
F04:0301         ; Add the potentially carried bit to the high byte of the address
F04:0302         lda zp_sd_address+1
               S01:0000C463:  A5 41
F04:0303         adc #0
               S01:0000C465:  69 00
F04:0304         sta zp_sd_address+1
               S01:0000C467:  85 41
F04:0305       
F04:0306         ; Copy out the next cluster in the chain for later use
F04:0307         lda (zp_sd_address),y
               S01:0000C469:  B1 40
F04:0308         sta fat32_nextcluster
               S01:0000C46B:  85 56
F04:0309         iny
               S01:0000C46D:  C8
F04:0310         lda (zp_sd_address),y
               S01:0000C46E:  B1 40
F04:0311         sta fat32_nextcluster+1
               S01:0000C470:  85 57
F04:0312         iny
               S01:0000C472:  C8
F04:0313         lda (zp_sd_address),y
               S01:0000C473:  B1 40
F04:0314         sta fat32_nextcluster+2
               S01:0000C475:  85 58
F04:0315         iny
               S01:0000C477:  C8
F04:0316         lda (zp_sd_address),y
               S01:0000C478:  B1 40
F04:0317         and #$0f
               S01:0000C47A:  29 0F
F04:0318         sta fat32_nextcluster+3
               S01:0000C47C:  85 59
F04:0319       
F04:0320         ; See if it's the end of the chain
F04:0321         ora #$f0
               S01:0000C47E:  09 F0
F04:0322         and fat32_nextcluster+2
               S01:0000C480:  25 58
F04:0323         and fat32_nextcluster+1
               S01:0000C482:  25 57
F04:0324         cmp #$ff
               S01:0000C484:  C9 FF
F04:0325         bne unotendofchain
               S01:0000C486:  D0 08
F04:0326         lda fat32_nextcluster
               S01:0000C488:  A5 56
F04:0327         cmp #$f8
               S01:0000C48A:  C9 F8
F04:0328         bcc unotendofchain
               S01:0000C48C:  90 02
F04:0329       
F04:0330         ; It's the end of the chain, set the top bits so that we can tell this later on
F04:0331         sta fat32_nextcluster+3
               S01:0000C48E:  85 59
F04:0332       unotendofchain:
F04:0333       
F04:0334         rts
               S01:0000C490:  60
F04:0335       
F04:0336       
F04:0337       fat32_readnextsector:
F04:0338         ; Reads the next sector from a cluster chain into the buffer at fat32_address.
F04:0339         ;
F04:0340         ; Advances the current sector ready for the next read and looks up the next cluster
F04:0341         ; in the chain when necessary.
F04:0342         ;
F04:0343         ; On return, carry is clear if data was read, or set if the cluster chain has ended.
F04:0344       
F04:0345         ; Maybe there are pending sectors in the current cluster
F04:0346         lda fat32_pendingsectors
               S01:0000C491:  A5 53
F04:0347         bne ureadsector
               S01:0000C493:  D0 07
F04:0348       
F04:0349         ; No pending sectors, check for end of cluster chain
F04:0350         lda fat32_nextcluster+3
               S01:0000C495:  A5 59
F04:0351         bmi uendofchain
               S01:0000C497:  30 20
F04:0352       
F04:0353         ; Prepare to read the next cluster
F04:0354         jsr fat32_seekcluster
               S01:0000C499:  20 E1 C3
F04:0355       
F04:0356       ureadsector:
F04:0357         dec fat32_pendingsectors
               S01:0000C49C:  C6 53
F04:0358       
F04:0359         ; Set up target address  
F04:0360         lda fat32_address
               S01:0000C49E:  A5 54
F04:0361         sta zp_sd_address
               S01:0000C4A0:  85 40
F04:0362         lda fat32_address+1
               S01:0000C4A2:  A5 55
F04:0363         sta zp_sd_address+1
               S01:0000C4A4:  85 41
F04:0364       
F04:0365         ; Read the sector
F04:0366         jsr sd_readsector
               S01:0000C4A6:  20 0B C2
F04:0367       
F04:0368         ; Advance to next sector
F04:0369         inc zp_sd_currentsector
               S01:0000C4A9:  E6 42
F04:0370         bne usectorincrementdone
               S01:0000C4AB:  D0 0A
F04:0371         inc zp_sd_currentsector+1
               S01:0000C4AD:  E6 43
F04:0372         bne usectorincrementdone
               S01:0000C4AF:  D0 06
F04:0373         inc zp_sd_currentsector+2
               S01:0000C4B1:  E6 44
F04:0374         bne usectorincrementdone
               S01:0000C4B3:  D0 02
F04:0375         inc zp_sd_currentsector+3
               S01:0000C4B5:  E6 45
F04:0376       usectorincrementdone:
F04:0377       
F04:0378         ; Success - clear carry and return
F04:0379         clc
               S01:0000C4B7:  18
F04:0380         rts
               S01:0000C4B8:  60
F04:0381       
F04:0382       uendofchain:
F04:0383         ; End of chain - set carry and return
F04:0384         sec
               S01:0000C4B9:  38
F04:0385         rts
               S01:0000C4BA:  60
F04:0386       
F04:0387       fat32_writenextsector:
F04:0388         ; Writes the next sector from a cluster chain into the buffer at fat32_address.
F04:0389         ;
F04:0390         ; Advances the current sector ready for the next write and looks up the next cluster
F04:0391         ; in the chain when necessary.
F04:0392         ;
F04:0393         ; On return, carry is set if its the end of the chain.
F04:0394       
F04:0395         ; Maybe there are pending sectors in the current cluster
F04:0396         lda fat32_pendingsectors
               S01:0000C4BB:  A5 53
F04:0397         bne writesector
               S01:0000C4BD:  D0 07
F04:0398       
F04:0399         ; No pending sectors, check for end of cluster chain
F04:0400         lda fat32_nextcluster+3
               S01:0000C4BF:  A5 59
F04:0401         bmi endofchainn
               S01:0000C4C1:  30 20
F04:0402       
F04:0403         ; Prepare to write the next cluster
F04:0404         jsr fat32_seekcluster
               S01:0000C4C3:  20 E1 C3
F04:0405         ; BUG do i use this? or do i need to make a whole other thing so that I can use fat32_file_write..?
F04:0406       
F04:0407       writesector:
F04:0408         dec fat32_pendingsectors
               S01:0000C4C6:  C6 53
F04:0409       
F04:0410         ; Set up target address
F04:0411         lda fat32_address
               S01:0000C4C8:  A5 54
F04:0412         sta zp_sd_address
               S01:0000C4CA:  85 40
F04:0413         lda fat32_address+1
               S01:0000C4CC:  A5 55
F04:0414         sta zp_sd_address+1
               S01:0000C4CE:  85 41
F04:0415       
F04:0416         ; Write the sector
F04:0417         jsr sd_writesector
               S01:0000C4D0:  20 4D C2
F04:0418       
F04:0419         ; Advance to next sector
F04:0420         inc zp_sd_currentsector
               S01:0000C4D3:  E6 42
F04:0421         bne ursectorincrementdone
               S01:0000C4D5:  D0 0A
F04:0422         inc zp_sd_currentsector+1
               S01:0000C4D7:  E6 43
F04:0423         bne ursectorincrementdone
               S01:0000C4D9:  D0 06
F04:0424         inc zp_sd_currentsector+2
               S01:0000C4DB:  E6 44
F04:0425         bne ursectorincrementdone
               S01:0000C4DD:  D0 02
F04:0426         inc zp_sd_currentsector+3
               S01:0000C4DF:  E6 45
F04:0427       ursectorincrementdone:
F04:0428       
F04:0429         ; Success - clear carry and return
F04:0430         clc
               S01:0000C4E1:  18
F04:0431         rts
               S01:0000C4E2:  60
F04:0432       
F04:0433       endofchainn:
F04:0434         ; End of chain - set carry and return
F04:0435         sec
               S01:0000C4E3:  38
F04:0436         rts
               S01:0000C4E4:  60
F04:0437       
F04:0438       fat32_openroot:
F04:0439         ; Prepare to read the root directory
F04:0440       
F04:0441         lda fat32_rootcluster
               S01:0000C4E5:  A5 4E
F04:0442         sta fat32_nextcluster
               S01:0000C4E7:  85 56
F04:0443         lda fat32_rootcluster+1
               S01:0000C4E9:  A5 4F
F04:0444         sta fat32_nextcluster+1
               S01:0000C4EB:  85 57
F04:0445         lda fat32_rootcluster+2
               S01:0000C4ED:  A5 50
F04:0446         sta fat32_nextcluster+2
               S01:0000C4EF:  85 58
F04:0447         lda fat32_rootcluster+3
               S01:0000C4F1:  A5 51
F04:0448         sta fat32_nextcluster+3
               S01:0000C4F3:  85 59
F04:0449       
F04:0450         jsr fat32_seekcluster
               S01:0000C4F5:  20 E1 C3
F04:0451       
F04:0452         ; Set the pointer to a large value so we always read a sector the first time through
F04:0453         lda #$ff
               S01:0000C4F8:  A9 FF
F04:0454         sta zp_sd_address+1
               S01:0000C4FA:  85 41
F04:0455       
F04:0456         rts
               S01:0000C4FC:  60
F04:0457       
F04:0458       fat32_opendirent:
F04:0459         ; Prepare to read/write a file or directory based on a dirent
F04:0460         ;
F04:0461         ; Point zp_sd_address at the dirent
F04:0462       
F04:0463         ; Remember file size in bytes remaining
F04:0464         ldy #28
               S01:0000C4FD:  A0 1C
F04:0465         lda (zp_sd_address),y
               S01:0000C4FF:  B1 40
F04:0466         sta fat32_bytesremaining
               S01:0000C501:  85 5A
F04:0467         iny
               S01:0000C503:  C8
F04:0468         lda (zp_sd_address),y
               S01:0000C504:  B1 40
F04:0469         sta fat32_bytesremaining+1
               S01:0000C506:  85 5B
F04:0470         iny
               S01:0000C508:  C8
F04:0471         lda (zp_sd_address),y
               S01:0000C509:  B1 40
F04:0472         sta fat32_bytesremaining+2
               S01:0000C50B:  85 5C
F04:0473         iny
               S01:0000C50D:  C8
F04:0474         lda (zp_sd_address),y
               S01:0000C50E:  B1 40
F04:0475         sta fat32_bytesremaining+3
               S01:0000C510:  85 5D
F04:0476       
F04:0477         ; Seek to first cluster
F04:0478         ldy #26
               S01:0000C512:  A0 1A
F04:0479         lda (zp_sd_address),y
               S01:0000C514:  B1 40
F04:0480         sta fat32_nextcluster
               S01:0000C516:  85 56
F04:0481         iny
               S01:0000C518:  C8
F04:0482         lda (zp_sd_address),y
               S01:0000C519:  B1 40
F04:0483         sta fat32_nextcluster+1
               S01:0000C51B:  85 57
F04:0484         ldy #20
               S01:0000C51D:  A0 14
F04:0485         lda (zp_sd_address),y
               S01:0000C51F:  B1 40
F04:0486         sta fat32_nextcluster+2
               S01:0000C521:  85 58
F04:0487         iny
               S01:0000C523:  C8
F04:0488         lda (zp_sd_address),y
               S01:0000C524:  B1 40
F04:0489         sta fat32_nextcluster+3
               S01:0000C526:  85 59
F04:0490       
F04:0491         jsr fat32_seekcluster
               S01:0000C528:  20 E1 C3
F04:0492       
F04:0493         ; Set the pointer to a large value so we always read a sector the first time through
F04:0494         lda #$ff
               S01:0000C52B:  A9 FF
F04:0495         sta zp_sd_address+1
               S01:0000C52D:  85 41
F04:0496       
F04:0497         rts
               S01:0000C52F:  60
F04:0498       
F04:0499       fat32_writedirent:
F04:0500         ; Write a directory entry from the open directory
F04:0501         ; requires:
F04:0502         ;   fat32bytesremaining (2 bytes) = file size in bytes (little endian)
F04:0503         ;   and the processes of:
F04:0504         ;     fat32_finddirent
F04:0505         ;     fat32_findnextfreecluster
F04:0506         ; Increment pointer by 32 to point to next entry
F04:0507         clc
               S01:0000C530:  18
F04:0508         lda zp_sd_address
               S01:0000C531:  A5 40
F04:0509         adc #32
               S01:0000C533:  69 20
F04:0510         sta zp_sd_address
               S01:0000C535:  85 40
F04:0511         lda zp_sd_address+1
               S01:0000C537:  A5 41
F04:0512         adc #0
               S01:0000C539:  69 00
F04:0513         sta zp_sd_address+1
               S01:0000C53B:  85 41
F04:0514       
F04:0515         ; If it's not at the end of the buffer, we have data already
F04:0516         cmp #>(fat32_readbuffer+$200)
               S01:0000C53D:  C9 04
F04:0517         bcc wgotdata
               S01:0000C53F:  90 0F
F04:0518       
F04:0519         ; Read another sector
F04:0520         lda #<fat32_readbuffer
               S01:0000C541:  A9 00
F04:0521         sta fat32_address
               S01:0000C543:  85 54
F04:0522         lda #>fat32_readbuffer
               S01:0000C545:  A9 02
F04:0523         sta fat32_address+1
               S01:0000C547:  85 55
F04:0524       
F04:0525         jsr fat32_readnextsector
               S01:0000C549:  20 91 C4
F04:0526         bcc wgotdata
               S01:0000C54C:  90 02
F04:0527       
F04:0528       endofdirectoryy:
F04:0529         sec
               S01:0000C54E:  38
F04:0530         rts
               S01:0000C54F:  60
F04:0531       
F04:0532       wgotdata:
F04:0533         ; Check first character
F04:0534         clc
               S01:0000C550:  18
F04:0535         ldy #0
               S01:0000C551:  A0 00
F04:0536         lda (zp_sd_address),y
               S01:0000C553:  B1 40
F04:0537         pha
               S01:0000C555:  48
F04:0538         bne wdirlpstart
               S01:0000C556:  D0 01
F04:0539         ; End of directory => tell loop
F04:0540         sec
               S01:0000C558:  38
F04:0541       wdirlpstart:
F04:0542         php
               S01:0000C559:  08
F04:0543       wdirlp:
F04:0544         lda (fat32_filenamepointer),y	; copy filename
               S01:0000C55A:  B1 5A
F04:0545         sta (zp_sd_address),y
               S01:0000C55C:  91 40
F04:0546         iny
               S01:0000C55E:  C8
F04:0547         cpy #$0b
               S01:0000C55F:  C0 0B
F04:0548         bne wdirlp
               S01:0000C561:  D0 F7
F04:0549         ; The full Short filename is #11 bytes long so,
F04:0550         ; this start at 0x0b - File type
F04:0551         lda #$20		; File Type: ARCHIVE
               S01:0000C563:  A9 20
F04:0552         sta (zp_sd_address),y
               S01:0000C565:  91 40
F04:0553         iny ; 0x0c - Checksum/File accsess password
               S01:0000C567:  C8
F04:0554         lda #$10		            ; No checksum or password
               S01:0000C568:  A9 10
F04:0555         sta (zp_sd_address),y
               S01:0000C56A:  91 40
F04:0556         pla	; 0x0d - Previous byte at 0x00
               S01:0000C56C:  68
F04:0557         sta (zp_sd_address),y
               S01:0000C56D:  91 40
F04:0558         iny	; 0x0e-0x11 - File creation time/date
               S01:0000C56F:  C8
F04:0559         lda #0
               S01:0000C570:  A9 00
F04:0560         sta (zp_sd_address),y	; No time/date because I don't have an RTC
               S01:0000C572:  91 40
F04:0561         iny
               S01:0000C574:  C8
F04:0562         sta (zp_sd_address),y
               S01:0000C575:  91 40
F04:0563         iny
               S01:0000C577:  C8
F04:0564         sta (zp_sd_address),y
               S01:0000C578:  91 40
F04:0565         iny
               S01:0000C57A:  C8
F04:0566         sta (zp_sd_address),y
               S01:0000C57B:  91 40
F04:0567         ; if you have an RTC, refer to https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#File_Allocation_Table 
F04:0568         ; look at "Directory entry" at 0x0E onward on the table.
F04:0569         iny ; 0x12-0x13 - User ID
               S01:0000C57D:  C8
F04:0570         lda #0
               S01:0000C57E:  A9 00
F04:0571         sta (zp_sd_address),y	; No ID
               S01:0000C580:  91 40
F04:0572         iny
               S01:0000C582:  C8
F04:0573         sta (zp_sd_address),y
               S01:0000C583:  91 40
F04:0574         iny ; 0x14-0x15 - File start cluster (high word)
               S01:0000C585:  C8
F04:0575         lda fat32_lastfoundfreecluster ; WARNING latfoundfreeclster is in this goofy ahh byte order stated here: http://6502.o
               S01:0000C586:  A5 5E
F04:0576         sta (zp_sd_address),y
               S01:0000C588:  91 40
F04:0577         iny ; the byte order works well here though ig...
               S01:0000C58A:  C8
F04:0578         lda fat32_lastfoundfreecluster+1
               S01:0000C58B:  A5 5F
F04:0579         sta (zp_sd_address),y
               S01:0000C58D:  91 40
F04:0580         iny ; 0x16-0x19 - File modifiaction date
               S01:0000C58F:  C8
F04:0581         lda #0
               S01:0000C590:  A9 00
F04:0582         sta (zp_sd_address),y
               S01:0000C592:  91 40
F04:0583         iny
               S01:0000C594:  C8
F04:0584         sta (zp_sd_address),y   ; no rtc aaaaa
               S01:0000C595:  91 40
F04:0585         iny
               S01:0000C597:  C8
F04:0586         sta (zp_sd_address),y
               S01:0000C598:  91 40
F04:0587         iny
               S01:0000C59A:  C8
F04:0588         sta (zp_sd_address),y
               S01:0000C59B:  91 40
F04:0589         iny ; 0x1a-0x1b - File start cluster low word
               S01:0000C59D:  C8
F04:0590         lda fat32_lastfoundfreecluster+2
               S01:0000C59E:  A5 60
F04:0591         sta (zp_sd_address),y
               S01:0000C5A0:  91 40
F04:0592         iny
               S01:0000C5A2:  C8
F04:0593         lda fat32_lastfoundfreecluster+3
               S01:0000C5A3:  A5 61
F04:0594         sta (zp_sd_address),y
               S01:0000C5A5:  91 40
F04:0595         iny ; 0x1c-0x1f File size in bytes
               S01:0000C5A7:  C8
F04:0596         lda fat32_bytesremaining
               S01:0000C5A8:  A5 5A
F04:0597         sta (zp_sd_address),y
               S01:0000C5AA:  91 40
F04:0598         iny
               S01:0000C5AC:  C8
F04:0599         lda fat32_bytesremaining+1
               S01:0000C5AD:  A5 5B
F04:0600         sta (zp_sd_address),y
               S01:0000C5AF:  91 40
F04:0601         iny
               S01:0000C5B1:  C8
F04:0602         lda #0
               S01:0000C5B2:  A9 00
F04:0603         sta (zp_sd_address),y ; Not bigger that 64k
               S01:0000C5B4:  91 40
F04:0604         iny
               S01:0000C5B6:  C8
F04:0605         sta (zp_sd_address),y
               S01:0000C5B7:  91 40
F04:0606         iny
               S01:0000C5B9:  C8
F04:0607         ; are we over the buffer?
F04:0608         lda zp_sd_address+1
               S01:0000C5BA:  A5 41
F04:0609         cmp #>(fat32_readbuffer+$200)
               S01:0000C5BC:  C9 04
F04:0610         bcc wdontt
               S01:0000C5BE:  90 12
F04:0611         jsr fat32_writenextsector ; if so, write the current sector
               S01:0000C5C0:  20 BB C4
F04:0612         jsr fat32_readnextsector  ; then read the next one.
               S01:0000C5C3:  20 91 C4
F04:0613         bcs wdfail
               S01:0000C5C6:  B0 1B
F04:0614         ldy #0
               S01:0000C5C8:  A0 00
F04:0615         lda #<fat32_readbuffer
               S01:0000C5CA:  A9 00
F04:0616         sta zp_sd_address
               S01:0000C5CC:  85 40
F04:0617         lda #>fat32_readbuffer
               S01:0000C5CE:  A9 02
F04:0618         sta zp_sd_address+1
               S01:0000C5D0:  85 41
F04:0619       wdontt:
F04:0620         ; is this the end of the table?
F04:0621         plp
               S01:0000C5D2:  28
F04:0622         bcc wdnot
               S01:0000C5D3:  90 08
F04:0623         php
               S01:0000C5D5:  08
F04:0624         ; if so, next entry is 0
F04:0625         lda #0
               S01:0000C5D6:  A9 00
F04:0626         sta (zp_sd_address),y
               S01:0000C5D8:  91 40
F04:0627         jmp wdobut
               S01:0000C5DA:  4C DE C5
F04:0628       wdnot:
F04:0629         php
               S01:0000C5DD:  08
F04:0630       wdobut:
F04:0631         jsr fat32_writenextsector ; write the data
               S01:0000C5DE:  20 BB C4
F04:0632         clc
               S01:0000C5E1:  18
F04:0633         rts
               S01:0000C5E2:  60
F04:0634       
F04:0635       wdfail:
F04:0636         ; Card Full
F04:0637         sec
               S01:0000C5E3:  38
F04:0638         rts
               S01:0000C5E4:  60
F04:0639       
F04:0640       jmpskipdiv:
F04:0641         jmp skipdiv
               S01:0000C5E5:  4C 8A C6
F04:0642       
F04:0643       fat32_findnextfreecluster:
F04:0644       ; Find next free cluster
F04:0645       ; 
F04:0646       ; This program will search the FAT for an empty entry, and
F04:0647       ; save the 32-bit index (from fat_start) to fat32_lastfoundfreecluter.
F04:0648       ;
F04:0649       ; Also returns a 1 in the carry bit if the SD card is full.
F04:0650       ;
F04:0651         lda fat32_fatstart
               S01:0000C5E8:  A5 46
F04:0652         sta fat32_lba
               S01:0000C5EA:  85 5A
F04:0653         lda fat32_fatstart+1
               S01:0000C5EC:  A5 47
F04:0654         sta fat32_lba+1			; copy fat_start to lba
               S01:0000C5EE:  85 5B
F04:0655         lda fat32_fatstart+2
               S01:0000C5F0:  A5 48
F04:0656         sta fat32_lba+2
               S01:0000C5F2:  85 5C
F04:0657         lda fat32_fatstart+3
               S01:0000C5F4:  A5 49
F04:0658         sta fat32_lba+3
               S01:0000C5F6:  85 5D
F04:0659         clc
               S01:0000C5F8:  18
F04:0660         lda fat32_lastfoundfreecluster	; if there is no previously found free cluster
               S01:0000C5F9:  A5 5E
F04:0661         adc fat32_lastfoundfreecluster+1
               S01:0000C5FB:  65 5F
F04:0662         adc fat32_lastfoundfreecluster+2
               S01:0000C5FD:  65 60
F04:0663         adc fat32_lastfoundfreecluster+3
               S01:0000C5FF:  65 61
F04:0664         beq jmpskipdiv				; then skip the division
               S01:0000C601:  F0 E2
F04:0665         lda fat32_lastfoundfreecluster
               S01:0000C603:  A5 5E
F04:0666         pha
               S01:0000C605:  48
F04:0667         lda fat32_lastfoundfreecluster+1
               S01:0000C606:  A5 5F
F04:0668         pha
               S01:0000C608:  48
F04:0669         lda fat32_lastfoundfreecluster+2	; save original states of the last found sector
               S01:0000C609:  A5 60
F04:0670         pha					; (division clobbers it)
               S01:0000C60B:  48
F04:0671         lda fat32_lastfoundfreecluster+3
               S01:0000C60C:  A5 61
F04:0672         pha
               S01:0000C60E:  48
F04:0673         lda $00				; extra variable usage for division
               S01:0000C60F:  A5 00
F04:0674         pha
               S01:0000C611:  48
F04:0675         lda $01
               S01:0000C612:  A5 01
F04:0676         pha
               S01:0000C614:  48
F04:0677       ; BUG is the math right?
F04:0678         ; result = lastfoundfreecluster / 128
F04:0679         ; 32-bit division from http://6502.org/source/integers/ummodfix/ummodfix.htm
F04:0680         SEC            			                  	; Detect overflow or /0 condition.
               S01:0000C615:  38
F04:0681         LDA     fat32_lastfoundfreecluster      ; Divisor must be more than high cell of dividend.  To
               S01:0000C616:  A5 5E
F04:0682         SBC     #128                        		; find out, subtract divisor from high cell of dividend;
               S01:0000C618:  E9 80
F04:0683         LDA     fat32_lastfoundfreecluster+1    ; if carry flag is still set at the end, the divisor was
               S01:0000C61A:  A5 5F
F04:0684         SBC     #0                         			; not big enough to avoid overflow. This also takes care
               S01:0000C61C:  E9 00
F04:0685         BCS     oflo                      			;	 of any /0 condition.  Branch if overflow or /0 error.
               S01:0000C61E:  B0 2D
F04:0686                                           			; We will loop 16 times; but since we shift the dividend
F04:0687         LDX     #$11    	                  		; over at the same time as shifting the answer in, the
               S01:0000C620:  A2 11
F04:0688                          	                  		; operation must start AND finish with a shift of the
F04:0689                          	                  		; low cell of the dividend (which ends up holding the
F04:0690                          		                  	; quotient), so we start with 17 (11H) in X.
F04:0691       divloop:
F04:0692         ROL     fat32_lastfoundfreecluster+2    ; Move low cell of dividend left one bit, also shifting
               S01:0000C622:  26 60
F04:0693         ROL     fat32_lastfoundfreecluster+3    ; answer in. The 1st rotation brings in a 0, which later
               S01:0000C624:  26 61
F04:0694                               	            		; gets pushed off the other end in the last rotation.
F04:0695         DEX
               S01:0000C626:  CA
F04:0696         BEQ     enddiv    		                  ; Branch to the end if finished.
               S01:0000C627:  F0 2E
F04:0697       
F04:0698         ROL     fat32_lastfoundfreecluster      ; Shift high cell of dividend left one bit, also
               S01:0000C629:  26 5E
F04:0699         ROL     fat32_lastfoundfreecluster+1    ; shifting next bit in from high bit of low cell.
               S01:0000C62B:  26 5F
F04:0700         LDA     #0
               S01:0000C62D:  A9 00
F04:0701         STA     $00   		                   		; Zero old bits of CARRY so subtraction works right.
               S01:0000C62F:  85 00
F04:0702         ROL     $00   		                  		; Store old high bit of dividend in CARRY.  (For STZ
               S01:0000C631:  26 00
F04:0703                          	                  		; one line up, NMOS 6502 will need LDA #0, STA CARRY.)
F04:0704         SEC                               			; See if divisor will fit into high 17 bits of dividend
               S01:0000C633:  38
F04:0705         LDA     fat32_lastfoundfreecluster      ; by subtracting and then looking at carry flag.
               S01:0000C634:  A5 5E
F04:0706         SBC     #128       		                	; First do low byte.
               S01:0000C636:  E9 80
F04:0707         STA     $01     	                  		; Save difference low byte until we know if we need it.
               S01:0000C638:  85 01
F04:0708         LDA     fat32_lastfoundfreecluster+1    ;
               S01:0000C63A:  A5 5F
F04:0709         SBC     #0     	                  			; Then do high byte.
               S01:0000C63C:  E9 00
F04:0710         TAY             		                   	; Save difference high byte until we know if we need it.
               S01:0000C63E:  A8
F04:0711         LDA     $00   			                  	; Bit 0 of CARRY serves as 17th bit.
               S01:0000C63F:  A5 00
F04:0712         SBC     #0      		                  	; Complete the subtraction by doing the 17th bit before
               S01:0000C641:  E9 00
F04:0713         BCC     divloop 	 	                  	; determining if the divisor fit into the high 17 bits
               S01:0000C643:  90 DD
F04:0714                         	                  		; of the dividend.  If so, the carry flag remains set.
F04:0715         LDA     $01                        			; If divisor fit into dividend high 17 bits, update
               S01:0000C645:  A5 01
F04:0716         STA     fat32_lastfoundfreecluster      ; dividend high cell to what it would be after
               S01:0000C647:  85 5E
F04:0717         STY     fat32_lastfoundfreecluster+1    ; subtraction.
               S01:0000C649:  84 5F
F04:0718         BCS     divloop    		                	; Branch If Carry Set.  CMOS WDC65C02 could use BCS here. CA65 doesent allow it 
               S01:0000C64B:  B0 D5
F04:0719       
F04:0720       oflo:  
F04:0721         LDA     #$FF    			                  ; If overflow occurred, put FF
               S01:0000C64D:  A9 FF
F04:0722         STA     fat32_lastfoundfreecluster      ; in remainder low byte
               S01:0000C64F:  85 5E
F04:0723         STA     fat32_lastfoundfreecluster+1    ; and high byte,
               S01:0000C651:  85 5F
F04:0724         STA     fat32_lastfoundfreecluster+2    ; and in quotient low byte
               S01:0000C653:  85 60
F04:0725         STA     fat32_lastfoundfreecluster+3    ; and high byte.
               S01:0000C655:  85 61
F04:0726       enddiv:
F04:0727       	LDA	fat32_lastfoundfreecluster+2
               S01:0000C657:  A5 60
F04:0728       	STA	fat32_result			; store quotient into fat32_result
               S01:0000C659:  85 62
F04:0729       	LDA	fat32_lastfoundfreecluster+3
               S01:0000C65B:  A5 61
F04:0730       	STA	fat32_result+1
               S01:0000C65D:  85 63
F04:0731       	PLA
               S01:0000C65F:  68
F04:0732       	STA	$01
               S01:0000C660:  85 01
F04:0733       	PLA
               S01:0000C662:  68
F04:0734       	STA	$00
               S01:0000C663:  85 00
F04:0735       	PLA					; restore variables
               S01:0000C665:  68
F04:0736       	STA	fat32_lastfoundfreecluster+3
               S01:0000C666:  85 61
F04:0737       	PLA
               S01:0000C668:  68
F04:0738       	STA	fat32_lastfoundfreecluster+2
               S01:0000C669:  85 60
F04:0739       	PLA
               S01:0000C66B:  68
F04:0740       	STA	fat32_lastfoundfreecluster+1
               S01:0000C66C:  85 5F
F04:0741       	PLA
               S01:0000C66E:  68
F04:0742       	STA	fat32_lastfoundfreecluster
               S01:0000C66F:  85 5E
F04:0743       	; add the result to lba
F04:0744       	CLC
               S01:0000C671:  18
F04:0745       	LDA	fat32_lba
               S01:0000C672:  A5 5A
F04:0746       	ADC	fat32_result
               S01:0000C674:  65 62
F04:0747       	STA	fat32_lba
               S01:0000C676:  85 5A
F04:0748       	LDA	fat32_lba+1
               S01:0000C678:  A5 5B
F04:0749       	ADC	fat32_result+1
               S01:0000C67A:  65 63
F04:0750       	STA	fat32_lba+1
               S01:0000C67C:  85 5B
F04:0751       	LDA	fat32_lba+2
               S01:0000C67E:  A5 5C
F04:0752       	ADC	#0
               S01:0000C680:  69 00
F04:0753       	STA	fat32_lba+2
               S01:0000C682:  85 5C
F04:0754       	LDA	fat32_lba+3
               S01:0000C684:  A5 5D
F04:0755       	ADC	#0
               S01:0000C686:  69 00
F04:0756       	STA	fat32_lba+3
               S01:0000C688:  85 5D
F04:0757       skipdiv:
F04:0758         ; now we have preformed LBA=+LASTFOUNDSECTOR/128
F04:0759         ; LBA - FATSTART = RESULT
F04:0760         sec
               S01:0000C68A:  38
F04:0761         lda fat32_lba
               S01:0000C68B:  A5 5A
F04:0762         sbc fat32_fatstart
               S01:0000C68D:  E5 46
F04:0763         sta fat32_dwcount
               S01:0000C68F:  85 64
F04:0764         lda fat32_lba+1
               S01:0000C691:  A5 5B
F04:0765         sbc fat32_fatstart+1
               S01:0000C693:  E5 47
F04:0766         sta fat32_dwcount+1
               S01:0000C695:  85 65
F04:0767         lda fat32_lba+2
               S01:0000C697:  A5 5C
F04:0768         sbc fat32_fatstart+2
               S01:0000C699:  E5 48
F04:0769         sta fat32_dwcount+2
               S01:0000C69B:  85 66
F04:0770         lda fat32_lba+3
               S01:0000C69D:  A5 5D
F04:0771         sbc fat32_fatstart+3
               S01:0000C69F:  E5 49
F04:0772         sta fat32_dwcount+3
               S01:0000C6A1:  85 67
F04:0773         ; Save zp_sd_address for later
F04:0774         lda zp_sd_address
               S01:0000C6A3:  A5 40
F04:0775         pha
               S01:0000C6A5:  48
F04:0776         lda zp_sd_address+1
               S01:0000C6A6:  A5 41
F04:0777         pha 
               S01:0000C6A8:  48
F04:0778         ; Now we will find a free cluster. (finally)
F04:0779       findfreeclusterloop:
F04:0780         ; We will read at sector LBA
F04:0781         lda fat32_lba
               S01:0000C6A9:  A5 5A
F04:0782         sta zp_sd_currentsector
               S01:0000C6AB:  85 42
F04:0783         lda fat32_lba+1
               S01:0000C6AD:  A5 5B
F04:0784         sta zp_sd_currentsector+1
               S01:0000C6AF:  85 43
F04:0785         lda fat32_lba+2
               S01:0000C6B1:  A5 5C
F04:0786         sta zp_sd_currentsector+2
               S01:0000C6B3:  85 44
F04:0787         lda fat32_lba+3
               S01:0000C6B5:  A5 5D
F04:0788         sta zp_sd_currentsector+3
               S01:0000C6B7:  85 45
F04:0789         ; Target buffer
F04:0790         lda #<fat32_readbuffer
               S01:0000C6B9:  A9 00
F04:0791         sta zp_sd_address
               S01:0000C6BB:  85 40
F04:0792         lda #>fat32_readbuffer
               S01:0000C6BD:  A9 02
F04:0793         sta zp_sd_address+1
               S01:0000C6BF:  85 41
F04:0794         ; Read sector
F04:0795         jsr sd_readsector
               S01:0000C6C1:  20 0B C2
F04:0796         ; Now Check each entry in the sector.
F04:0797         ldx #0
               S01:0000C6C4:  A2 00
F04:0798         ldy #0
               S01:0000C6C6:  A0 00
F04:0799       ffcinner:
F04:0800         lda (zp_sd_address),y
               S01:0000C6C8:  B1 40
F04:0801         and #$0f			; First 4 bits are reserved.
               S01:0000C6CA:  29 0F
F04:0802         iny
               S01:0000C6CC:  C8
F04:0803         clc
               S01:0000C6CD:  18
F04:0804         adc (zp_sd_address),y
               S01:0000C6CE:  71 40
F04:0805         iny
               S01:0000C6D0:  C8
F04:0806         adc (zp_sd_address),y
               S01:0000C6D1:  71 40
F04:0807         iny
               S01:0000C6D3:  C8
F04:0808         adc (zp_sd_address),y
               S01:0000C6D4:  71 40
F04:0809         beq gotfreecluster		; If the FAT entry is 0x00000000, we've got the next free cluster
               S01:0000C6D6:  F0 54
F04:0810       
F04:0811         ; Increment the last found free cluster count
F04:0812         inc fat32_lastfoundfreecluster
               S01:0000C6D8:  E6 5E
F04:0813         bne ffcdontinc
               S01:0000C6DA:  D0 0A
F04:0814         inc fat32_lastfoundfreecluster+1
               S01:0000C6DC:  E6 5F
F04:0815         bne ffcdontinc
               S01:0000C6DE:  D0 06
F04:0816         inc fat32_lastfoundfreecluster+2
               S01:0000C6E0:  E6 60
F04:0817         bne ffcdontinc
               S01:0000C6E2:  D0 02
F04:0818         inc fat32_lastfoundfreecluster+3
               S01:0000C6E4:  E6 61
F04:0819       ffcdontinc:
F04:0820         ; Now check if the disk is full.
F04:0821         lda fat32_lastfoundfreecluster
               S01:0000C6E6:  A5 5E
F04:0822         cmp #$ff
               S01:0000C6E8:  C9 FF
F04:0823         bne ffcskip
               S01:0000C6EA:  D0 15
F04:0824         lda fat32_lastfoundfreecluster
               S01:0000C6EC:  A5 5E
F04:0825         cmp #$ff
               S01:0000C6EE:  C9 FF
F04:0826         bne ffcskip
               S01:0000C6F0:  D0 0F
F04:0827         lda fat32_lastfoundfreecluster
               S01:0000C6F2:  A5 5E
F04:0828         cmp #$ff
               S01:0000C6F4:  C9 FF
F04:0829         bne ffcskip
               S01:0000C6F6:  D0 09
F04:0830         lda fat32_lastfoundfreecluster
               S01:0000C6F8:  A5 5E
F04:0831         cmp #$f7
               S01:0000C6FA:  C9 F7
F04:0832         bne ffcskip
               S01:0000C6FC:  D0 03
F04:0833         jmp diskfull	; Disk full
               S01:0000C6FE:  4C 34 C7
F04:0834       ffcskip:
F04:0835         inx
               S01:0000C701:  E8
F04:0836         cpx #129 	; Sector read?
               S01:0000C702:  E0 81
F04:0837         bne ffcinner	; If not go back to read another FAT entry
               S01:0000C704:  D0 C2
F04:0838         ; Increment LBA
F04:0839         inc fat32_lba
               S01:0000C706:  E6 5A
F04:0840         bne dontinclba
               S01:0000C708:  D0 0A
F04:0841         inc fat32_lba+1
               S01:0000C70A:  E6 5B
F04:0842         bne dontinclba
               S01:0000C70C:  D0 06
F04:0843         inc fat32_lba+2
               S01:0000C70E:  E6 5C
F04:0844         bne dontinclba
               S01:0000C710:  D0 02
F04:0845         inc fat32_lba+3
               S01:0000C712:  E6 5D
F04:0846       dontinclba:
F04:0847         ; Out of disk space?
F04:0848         ; BUG i should by comparing this with sectors per FAT, not per cluster...
F04:0849         ; are they the same? (i dont think so...)
F04:0850         dec fat32_sectorspercluster
               S01:0000C714:  C6 52
F04:0851         lda fat32_dwcount
               S01:0000C716:  A5 64
F04:0852         cmp fat32_sectorspercluster
               S01:0000C718:  C5 52
F04:0853         bcs dontsubtractdw
               S01:0000C71A:  B0 05
F04:0854         inc fat32_sectorspercluster
               S01:0000C71C:  E6 52
F04:0855         jmp diskfull ; Disk Full
               S01:0000C71E:  4C 34 C7
F04:0856       dontsubtractdw:
F04:0857         inc fat32_sectorspercluster
               S01:0000C721:  E6 52
F04:0858         ; Increment fat32_dwcount
F04:0859         inc fat32_dwcount
               S01:0000C723:  E6 64
F04:0860         bne dontincdw
               S01:0000C725:  D0 02
F04:0861         inc fat32_dwcount+1
               S01:0000C727:  E6 65
F04:0862       dontincdw:
F04:0863         jmp findfreeclusterloop
               S01:0000C729:  4C A9 C6
F04:0864       gotfreecluster:
F04:0865       ; Got the free cluster. Carry clear.
F04:0866         pla
               S01:0000C72C:  68
F04:0867         sta zp_sd_address+1
               S01:0000C72D:  85 41
F04:0868         pla
               S01:0000C72F:  68
F04:0869         sta zp_sd_address
               S01:0000C730:  85 40
F04:0870         clc
               S01:0000C732:  18
F04:0871         rts
               S01:0000C733:  60
F04:0872       
F04:0873       diskfull:
F04:0874       ; The disk is full. Set carry bit.
F04:0875         pla
               S01:0000C734:  68
F04:0876         sta zp_sd_address+1
               S01:0000C735:  85 41
F04:0877         pla
               S01:0000C737:  68
F04:0878         sta zp_sd_address
               S01:0000C738:  85 40
F04:0879         sec
               S01:0000C73A:  38
F04:0880         rts
               S01:0000C73B:  60
F04:0881       
F04:0882       fat32_readdirent:
F04:0883         ; Read a directory entry from the open directory
F04:0884         ;
F04:0885         ; On exit the carry is set if there were no more directory entries.
F04:0886         ;
F04:0887         ; Otherwise, A is set to the file's attribute byte and
F04:0888         ; zp_sd_address points at the returned directory entry.
F04:0889         ; LFNs and empty entries are ignored automatically.
F04:0890       
F04:0891         ; Increment pointer by 32 to point to next entry
F04:0892         clc
               S01:0000C73C:  18
F04:0893         lda zp_sd_address
               S01:0000C73D:  A5 40
F04:0894         adc #32
               S01:0000C73F:  69 20
F04:0895         sta zp_sd_address
               S01:0000C741:  85 40
F04:0896         lda zp_sd_address+1
               S01:0000C743:  A5 41
F04:0897         adc #0
               S01:0000C745:  69 00
F04:0898         sta zp_sd_address+1
               S01:0000C747:  85 41
F04:0899       
F04:0900         ; If it's not at the end of the buffer, we have data already
F04:0901         cmp #>(fat32_readbuffer+$200)
               S01:0000C749:  C9 04
F04:0902         bcc ugotdata
               S01:0000C74B:  90 0F
F04:0903       
F04:0904         ; Read another sector
F04:0905         lda #<fat32_readbuffer
               S01:0000C74D:  A9 00
F04:0906         sta fat32_address
               S01:0000C74F:  85 54
F04:0907         lda #>fat32_readbuffer
               S01:0000C751:  A9 02
F04:0908         sta fat32_address+1
               S01:0000C753:  85 55
F04:0909       
F04:0910         jsr fat32_readnextsector
               S01:0000C755:  20 91 C4
F04:0911         bcc ugotdata
               S01:0000C758:  90 02
F04:0912       
F04:0913       uendofdirectory:
F04:0914         sec
               S01:0000C75A:  38
F04:0915         rts
               S01:0000C75B:  60
F04:0916       
F04:0917       ugotdata:
F04:0918         ; Check first character
F04:0919         ldy #0
               S01:0000C75C:  A0 00
F04:0920         lda (zp_sd_address),y
               S01:0000C75E:  B1 40
F04:0921       
F04:0922         ; End of directory => abort
F04:0923         beq uendofdirectory
               S01:0000C760:  F0 F8
F04:0924       
F04:0925         ; Empty entry => start again
F04:0926         cmp #$e5
               S01:0000C762:  C9 E5
F04:0927         beq fat32_readdirent
               S01:0000C764:  F0 D6
F04:0928       
F04:0929         ; Check attributes
F04:0930         ldy #11
               S01:0000C766:  A0 0B
F04:0931         lda (zp_sd_address),y
               S01:0000C768:  B1 40
F04:0932         and #$3f
               S01:0000C76A:  29 3F
F04:0933         cmp #$0f ; LFN => start again
               S01:0000C76C:  C9 0F
F04:0934         beq fat32_readdirent
               S01:0000C76E:  F0 CC
F04:0935       
F04:0936         ; Yield this result
F04:0937         clc
               S01:0000C770:  18
F04:0938         rts
               S01:0000C771:  60
F04:0939       
F04:0940       
F04:0941       fat32_finddirent:
F04:0942         ; Finds a particular directory entryu  X,Y point to the 11-character filename to seek.
F04:0943         ; The directory should already be open for iteration.
F04:0944       
F04:0945         ; Form ZP pointer to user's filename
F04:0946         stx fat32_filenamepointer
               S01:0000C772:  86 5A
F04:0947         sty fat32_filenamepointer+1
               S01:0000C774:  84 5B
F04:0948         
F04:0949         ; Iterate until name is found or end of directory
F04:0950       udirentloop:
F04:0951         jsr fat32_readdirent
               S01:0000C776:  20 3C C7
F04:0952         ldy #10
               S01:0000C779:  A0 0A
F04:0953         bcc ucomparenameloop
               S01:0000C77B:  90 01
F04:0954         rts ; with carry set
               S01:0000C77D:  60
F04:0955       
F04:0956       ucomparenameloop:
F04:0957         lda (zp_sd_address),y
               S01:0000C77E:  B1 40
F04:0958         cmp (fat32_filenamepointer),y
               S01:0000C780:  D1 5A
F04:0959         bne udirentloop ; no match
               S01:0000C782:  D0 F2
F04:0960         dey
               S01:0000C784:  88
F04:0961         bpl ucomparenameloop
               S01:0000C785:  10 F7
F04:0962       
F04:0963         ; Found it
F04:0964         clc
               S01:0000C787:  18
F04:0965         rts
               S01:0000C788:  60
F04:0966       
F04:0967       
F04:0968       fat32_file_readbyte:
F04:0969         ; Read a byte from an open file
F04:0970         ;
F04:0971         ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
F04:0972       
F04:0973         sec
               S01:0000C789:  38
F04:0974       
F04:0975         ; Is there any data to read at all?
F04:0976         lda fat32_bytesremaining
               S01:0000C78A:  A5 5A
F04:0977         ora fat32_bytesremaining+1
               S01:0000C78C:  05 5B
F04:0978         ora fat32_bytesremaining+2
               S01:0000C78E:  05 5C
F04:0979         ora fat32_bytesremaining+3
               S01:0000C790:  05 5D
F04:0980         beq urts
               S01:0000C792:  F0 3D
F04:0981       
F04:0982         ; Decrement the remaining byte count
F04:0983         lda fat32_bytesremaining
               S01:0000C794:  A5 5A
F04:0984         sbc #1
               S01:0000C796:  E9 01
F04:0985         sta fat32_bytesremaining
               S01:0000C798:  85 5A
F04:0986         lda fat32_bytesremaining+1
               S01:0000C79A:  A5 5B
F04:0987         sbc #0
               S01:0000C79C:  E9 00
F04:0988         sta fat32_bytesremaining+1
               S01:0000C79E:  85 5B
F04:0989         lda fat32_bytesremaining+2
               S01:0000C7A0:  A5 5C
F04:0990         sbc #0
               S01:0000C7A2:  E9 00
F04:0991         sta fat32_bytesremaining+2
               S01:0000C7A4:  85 5C
F04:0992         lda fat32_bytesremaining+3
               S01:0000C7A6:  A5 5D
F04:0993         sbc #0
               S01:0000C7A8:  E9 00
F04:0994         sta fat32_bytesremaining+3
               S01:0000C7AA:  85 5D
F04:0995         
F04:0996         ; Need to read a new sector?
F04:0997         lda zp_sd_address+1
               S01:0000C7AC:  A5 41
F04:0998         cmp #>(fat32_readbuffer+$200)
               S01:0000C7AE:  C9 04
F04:0999         bcc uegotdata
               S01:0000C7B0:  90 0D
F04:1000       
F04:1001         ; Read another sector
F04:1002         lda #<fat32_readbuffer
               S01:0000C7B2:  A9 00
F04:1003         sta fat32_address
               S01:0000C7B4:  85 54
F04:1004         lda #>fat32_readbuffer
               S01:0000C7B6:  A9 02
F04:1005         sta fat32_address+1
               S01:0000C7B8:  85 55
F04:1006       
F04:1007         jsr fat32_readnextsector
               S01:0000C7BA:  20 91 C4
F04:1008         bcs urts                    ; this shouldn't happen
               S01:0000C7BD:  B0 12
F04:1009       
F04:1010       uegotdata:
F04:1011         ldy #0
               S01:0000C7BF:  A0 00
F04:1012         lda (zp_sd_address),y
               S01:0000C7C1:  B1 40
F04:1013       
F04:1014         inc zp_sd_address
               S01:0000C7C3:  E6 40
F04:1015         bne urts
               S01:0000C7C5:  D0 0A
F04:1016         inc zp_sd_address+1
               S01:0000C7C7:  E6 41
F04:1017         bne urts
               S01:0000C7C9:  D0 06
F04:1018         inc zp_sd_address+2
               S01:0000C7CB:  E6 42
F04:1019         bne urts
               S01:0000C7CD:  D0 02
F04:1020         inc zp_sd_address+3
               S01:0000C7CF:  E6 43
F04:1021       
F04:1022       urts:
F04:1023         rts
               S01:0000C7D1:  60
F04:1024       
F04:1025       
F04:1026       fat32_file_read:
F04:1027         ; Read a whole file into memory.  It's assumed the file has just been opened 
F04:1028         ; and no data has been read yet.
F04:1029         ;
F04:1030         ; Also we read whole sectors, so data in the target region beyond the end of the 
F04:1031         ; file may get overwritten, up to the next 512-byte boundary.
F04:1032         ;
F04:1033         ; And we don't properly support 64k+ files, as it's unnecessary complication given
F04:1034         ; the 6502's small address space
F04:1035       
F04:1036         ; Round the size up to the next whole sector
F04:1037         lda fat32_bytesremaining
               S01:0000C7D2:  A5 5A
F04:1038         cmp #1                      ; set carry if bottom 8 bits not zero
               S01:0000C7D4:  C9 01
F04:1039         lda fat32_bytesremaining+1
               S01:0000C7D6:  A5 5B
F04:1040         adc #0                      ; add carry, if any
               S01:0000C7D8:  69 00
F04:1041         lsr                         ; divide by 2
               S01:0000C7DA:  4A
F04:1042         adc #0                      ; round up
               S01:0000C7DB:  69 00
F04:1043       
F04:1044         ; No data?
F04:1045         beq udone
               S01:0000C7DD:  F0 12
F04:1046       
F04:1047         ; Store sector count - not a byte count any more
F04:1048         sta fat32_bytesremaining
               S01:0000C7DF:  85 5A
F04:1049       
F04:1050         ; Read entire sectors to the user-supplied buffer
F04:1051       uwholesectorreadloop:
F04:1052         ; Read a sector to fat32_address
F04:1053         jsr fat32_readnextsector
               S01:0000C7E1:  20 91 C4
F04:1054       
F04:1055         ; Advance fat32_address by 512 bytes
F04:1056         lda fat32_address+1
               S01:0000C7E4:  A5 55
F04:1057         adc #2                      ; carry already clear
               S01:0000C7E6:  69 02
F04:1058         sta fat32_address+1
               S01:0000C7E8:  85 55
F04:1059       
F04:1060         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
               S01:0000C7EA:  A6 5A
F04:1061         dex
               S01:0000C7EC:  CA
F04:1062         stx fat32_bytesremaining    ; note - actually stores sectors remaining
               S01:0000C7ED:  86 5A
F04:1063       
F04:1064         bne uwholesectorreadloop
               S01:0000C7EF:  D0 F0
F04:1065       
F04:1066       udone:
F04:1067         rts
               S01:0000C7F1:  60
F04:1068       
F04:1069       fat32_file_write:
F04:1070         ; Write a whole file from memory.  It's assumed the file has just been opened 
F04:1071         ; and no data has been written yet.
F04:1072         ;
F04:1073         ; Also we write whole sectors, so data in the target region beyond the end of the 
F04:1074         ; file may get overwritten, up to the next 512-byte boundary.
F04:1075         ;
F04:1076         ; And we don't properly support 64k+ files, as it's unnecessary complication given
F04:1077         ; the 6502's small address space
F04:1078       
F04:1079         ; Round the size up to the next whole sector
F04:1080         lda fat32_bytesremaining
               S01:0000C7F2:  A5 5A
F04:1081         cmp #1                      ; set carry if bottom 8 bits not zero
               S01:0000C7F4:  C9 01
F04:1082         lda fat32_bytesremaining+1
               S01:0000C7F6:  A5 5B
F04:1083         adc #0                      ; add carry, if any
               S01:0000C7F8:  69 00
F04:1084         lsr                         ; divide by 2
               S01:0000C7FA:  4A
F04:1085         adc #0                      ; round up
               S01:0000C7FB:  69 00
F04:1086       
F04:1087         ; No data?
F04:1088         beq urdone
               S01:0000C7FD:  F0 12
F04:1089       
F04:1090         ; Store sector count - not a byte count any more
F04:1091         sta fat32_bytesremaining
               S01:0000C7FF:  85 5A
F04:1092       
F04:1093         ; Write entire sectors from the user-supplied buffer
F04:1094       wholesectorwriteloop:
F04:1095         ; Write a sector from fat32_address
F04:1096         jsr fat32_writenextsector
               S01:0000C801:  20 BB C4
F04:1097       
F04:1098         ; Advance fat32_address by 512 bytes
F04:1099         lda fat32_address+1
               S01:0000C804:  A5 55
F04:1100         adc #2                      ; carry already clear
               S01:0000C806:  69 02
F04:1101         sta fat32_address+1
               S01:0000C808:  85 55
F04:1102       
F04:1103         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
               S01:0000C80A:  A6 5A
F04:1104         dex
               S01:0000C80C:  CA
F04:1105         stx fat32_bytesremaining    ; note - actually stores sectors remaining
               S01:0000C80D:  86 5A
F04:1106       
F04:1107         bne wholesectorwriteloop
               S01:0000C80F:  D0 F0
F04:1108       
F04:1109       urdone:
F04:1110         rts
               S01:0000C811:  60
F04:1111       
F00:0086         .include "errors.s"
F05:0001       error_sound:
F05:0002         jsr clear_sid
               S01:0000C812:  20 4B C8
F05:0003         lda #$0f
               S01:0000C815:  A9 0F
F05:0004         sta $b818
               S01:0000C817:  8D 18 B8
F05:0005         lda #$e7
               S01:0000C81A:  A9 E7
F05:0006         sta $b802
               S01:0000C81C:  8D 02 B8
F05:0007         lda #$0f
               S01:0000C81F:  A9 0F
F05:0008         sta $b805
               S01:0000C821:  8D 05 B8
F05:0009         lda #$f8
               S01:0000C824:  A9 F8
F05:0010         sta $b806
               S01:0000C826:  8D 06 B8
F05:0011         lda #$50 ; freq
               S01:0000C829:  A9 50
F05:0012         sta $b800
               S01:0000C82B:  8D 00 B8
F05:0013         lda #$50 ; freq+1
               S01:0000C82E:  A9 50
F05:0014         sta $b801
               S01:0000C830:  8D 01 B8
F05:0015         lda #$41
               S01:0000C833:  A9 41
F05:0016         sta $b804
               S01:0000C835:  8D 04 B8
F05:0017       
F05:0018       outer:
F05:0019         ldy #$ff
               S01:0000C838:  A0 FF
F05:0020       inner:
F05:0021         ldx #$ff
               S01:0000C83A:  A2 FF
F05:0022       
F05:0023       innerloop:
F05:0024         dex
               S01:0000C83C:  CA
F05:0025         bne innerloop
               S01:0000C83D:  D0 FD
F05:0026       
F05:0027         dey
               S01:0000C83F:  88
F05:0028         beq ende
               S01:0000C840:  F0 03
F05:0029         jmp inner
               S01:0000C842:  4C 3A C8
F05:0030       ende:
F05:0031         lda #$40
               S01:0000C845:  A9 40
F05:0032         sta $b804
               S01:0000C847:  8D 04 B8
F05:0033         rts
               S01:0000C84A:  60
F05:0034       
F05:0035       clear_sid:
F05:0036         ldx #$17
               S01:0000C84B:  A2 17
F05:0037         lda #0
               S01:0000C84D:  A9 00
F05:0038       csid:
F05:0039         sta $b800,x
               S01:0000C84F:  9D 00 B8
F05:0040         dex
               S01:0000C852:  CA
F05:0041         bne csid
               S01:0000C853:  D0 FA
F05:0042         rts
               S01:0000C855:  60
F05:0043       
F05:0044       
F05:0045       
F00:0087       
F00:0088       rootsetup:		; setup <ROOT>
F00:0089       
F00:0090         ; Open root directory
F00:0091         jsr fat32_openroot
               S01:0000C856:  20 E5 C4
F00:0092       
F00:0093         ; Find the subdirectory by name
F00:0094         ldx #<dirname
               S01:0000C859:  A2 55
F00:0095         ldy #>dirname
               S01:0000C85B:  A0 C0
F00:0096         jsr fat32_finddirent
               S01:0000C85D:  20 72 C7
F00:0097         bcc foundsub
               S01:0000C860:  90 03
F00:0098       
F00:0099         ; Subdirectory not found
F00:0100         jmp transfer_error
               S01:0000C862:  4C 69 C8
F00:0101       
F00:0102       foundsub:
F00:0103       
F00:0104         ; Open subdirectory
F00:0105         jsr fat32_opendirent	; open folder
               S01:0000C865:  20 FD C4
F00:0106       	
F00:0107         rts			; done
               S01:0000C868:  60
F00:0108       
F00:0109       transfer_error:
F00:0110         ldy #>errormsg
               S01:0000C869:  A0 C0
F00:0111         ldx #<errormsg
               S01:0000C86B:  A2 61
F00:0112         jsr w_acia_full
               S01:0000C86D:  20 DF C0
F00:0113         jsr error_sound
               S01:0000C870:  20 12 C8
F00:0114         jmp doneloop
               S01:0000C873:  4C DB C8
F00:0115       
F00:0116       msincremaining:
F00:0117         inc fat32_bytesremaining
               S01:0000C876:  E6 5A
F00:0118         bne msinca
               S01:0000C878:  D0 02
F00:0119         inc fat32_bytesremaining
               S01:0000C87A:  E6 5A
F00:0120       msinca:
F00:0121         inc XYLODSAV2
               S01:0000C87C:  E6 64
F00:0122         bne msincb
               S01:0000C87E:  D0 02
F00:0123         inc XYLODSAV2+1
               S01:0000C880:  E6 65
F00:0124       msincb:
F00:0125         rts
               S01:0000C882:  60
F00:0126       MEMORY_SAVE:
F00:0127           ; finally. this is what we need to debug.
F00:0128       	jsr rootsetup
               S01:0000C883:  20 56 C8
F00:0129         jsr fat32_findnextfreecluster
               S01:0000C886:  20 E8 C5
F00:0130       	ldy #>sdbuffer
               S01:0000C889:  A0 C9
F00:0131       	ldx #<sdbuffer
               S01:0000C88B:  A2 02
F00:0132       	jsr fat32_finddirent
               S01:0000C88D:  20 72 C7
F00:0133       	bcs saveok
               S01:0000C890:  B0 05
F00:0134       	jsr file_exists
               S01:0000C892:  20 DE C8
F00:0135       	bcs doneloop
               S01:0000C895:  B0 44
F00:0136       saveok:
F00:0137           ; Now calculate file size and store it in fat32_bytesremaining.
F00:0138         lda #$01
               S01:0000C897:  A9 01
F00:0139         sta XYLODSAV2
               S01:0000C899:  85 64
F00:0140         lda #$06
               S01:0000C89B:  A9 06
F00:0141         sta XYLODSAV2+1
               S01:0000C89D:  85 65
F00:0142         lda #0
               S01:0000C89F:  A9 00
F00:0143         sta fat32_bytesremaining
               S01:0000C8A1:  85 5A
F00:0144         sta fat32_bytesremaining
               S01:0000C8A3:  85 5A
F00:0145         ldy #0
               S01:0000C8A5:  A0 00
F00:0146       savecalclp:
F00:0147         lda (XYLODSAV2),y
               S01:0000C8A7:  B1 64
F00:0148         beq mszero
               S01:0000C8A9:  F0 06
F00:0149         jsr msincremaining
               S01:0000C8AB:  20 76 C8
F00:0150         jmp savecalclp
               S01:0000C8AE:  4C A7 C8
F00:0151       mszero:
F00:0152         jsr msincremaining
               S01:0000C8B1:  20 76 C8
F00:0153         lda (XYLODSAV2),y
               S01:0000C8B4:  B1 64
F00:0154         bne savecalclp
               S01:0000C8B6:  D0 EF
F00:0155         jsr msincremaining
               S01:0000C8B8:  20 76 C8
F00:0156         lda (XYLODSAV2),y
               S01:0000C8BB:  B1 64
F00:0157         bne savecalclp
               S01:0000C8BD:  D0 E8
F00:0158       ; done
F00:0159       	jsr fat32_writedirent
               S01:0000C8BF:  20 30 C5
F00:0160       	ldx #<savmsg
               S01:0000C8C2:  A2 45
F00:0161        	ldy #>savmsg
               S01:0000C8C4:  A0 C9
F00:0162         jsr w_acia_full
               S01:0000C8C6:  20 DF C0
F00:0163         lda #$01
               S01:0000C8C9:  A9 01
F00:0164         sta fat32_address
               S01:0000C8CB:  85 54
F00:0165         lda #$06
               S01:0000C8CD:  A9 06
F00:0166         sta fat32_address+1
               S01:0000C8CF:  85 55
F00:0167         jsr fat32_file_write  ; Yes. It is finally time to save the file.
               S01:0000C8D1:  20 F2 C7
F00:0168         ldx #<SAVE_DONE
               S01:0000C8D4:  A2 32
F00:0169         ldy #>SAVE_DONE
               S01:0000C8D6:  A0 C9
F00:0170         jsr w_acia_full
               S01:0000C8D8:  20 DF C0
F00:0171       doneloop:
F00:0172       	jmp doneloop
               S01:0000C8DB:  4C DB C8
F00:0173       file_exists:
F00:0174       	; clc if 'y'
F00:0175       	; sec if 'n'
F00:0176       	ldx #<EXIST_MSG
               S01:0000C8DE:  A2 0D
F00:0177       	ldy #>EXIST_MSG
               S01:0000C8E0:  A0 C9
F00:0178       	jsr w_acia_full
               S01:0000C8E2:  20 DF C0
F00:0179       fexlp:
F00:0180       	jsr rxpoll
               S01:0000C8E5:  20 C3 C0
F00:0181       	lda ACIAData
               S01:0000C8E8:  AD 00 80
F00:0182       	pha
               S01:0000C8EB:  48
F00:0183       	cmp #'y'
               S01:0000C8EC:  C9 79
F00:0184       	beq exy
               S01:0000C8EE:  F0 08
F00:0185       	cmp #'n'
               S01:0000C8F0:  C9 6E
F00:0186       	beq exn
               S01:0000C8F2:  F0 09
F00:0187       	pla
               S01:0000C8F4:  68
F00:0188       	jmp fexlp
               S01:0000C8F5:  4C E5 C8
F00:0189       exy:
F00:0190       	jsr crlf
               S01:0000C8F8:  20 9B C0
F00:0191       	clc
               S01:0000C8FB:  18
F00:0192       	rts
               S01:0000C8FC:  60
F00:0193       exn:
F00:0194       	jsr crlf
               S01:0000C8FD:  20 9B C0
F00:0195       	sec
               S01:0000C900:  38
F00:0196       	rts
               S01:0000C901:  60
F00:0197       
F00:0198       sdbuffer:
F00:0199         .byte "SAVE    BAS" ; save.bas
               S01:0000C902:  53 41 56 45 20 20 20 20 42 41 53
F00:0200       EXIST_MSG:
F00:0201         .byte "File Exists. Overwrite? (y) or (n): ",$00
               S01:0000C90D:  46 69 6C 65 20 45 78 69 73 74 73 2E 20 4F 76 65
               S01:0000C91D:  72 77 72 69 74 65 3F 20 28 79 29 20 6F 72 20 28
               S01:0000C92D:  00
F00:0202       SAVE_DONE:
F00:0203         .byte	CR,LF,"Save Complete.",CR,LF,$00
               S01:0000C932:  0D
               S01:0000C933:  0A
               S01:0000C934:  53 61 76 65 20 43 6F 6D 70 6C 65 74 65 2E
               S01:0000C942:  0D
               S01:0000C943:  0A
               S01:0000C944:  00
F00:0204       savmsg:
F00:0205         .byte $0d, $0a, "Saving...", $0d, $0a, $00
               S01:0000C945:  0D
               S01:0000C946:  0A
               S01:0000C947:  53 61 76 69 6E 67 2E 2E 2E
               S01:0000C950:  0D
               S01:0000C951:  0A
               S01:0000C952:  00
F00:0206       
F00:0207       nmi:
F00:0208         rti 
               S01:0000C953:  40
F00:0209       irq:
F00:0210         rti
               S01:0000C954:  40
F00:0211       
F00:0212         .org $fffa
F00:0213         .word nmi
               S02:0000FFFA:  53 C9
F00:0214         .word reset
               S02:0000FFFC:  00 C0
F00:0215         .word irq
               S02:0000FFFE:  54 C9


Sections:
S01  segc000
S02  segfffa


Sources:
F00  savetest.s
F01  hwconfig.s
F02  libacia.s
F03  libsd.s
F04  libfat32.s
F05  errors.s


Symbols:
irq EXPR(51540=0xc954) ABS 
nmi EXPR(51539=0xc953) ABS 
exn EXPR(51453=0xc8fd) ABS 
exy EXPR(51448=0xc8f8) ABS 
fexlp EXPR(51429=0xc8e5) ABS 
EXIST_MSG EXPR(51469=0xc90d) ABS 
SAVE_DONE EXPR(51506=0xc932) ABS 
savmsg EXPR(51525=0xc945) ABS 
mszero EXPR(51377=0xc8b1) ABS 
savecalclp EXPR(51367=0xc8a7) ABS 
file_exists EXPR(51422=0xc8de) ABS 
saveok EXPR(51351=0xc897) ABS 
sdbuffer EXPR(51458=0xc902) ABS 
msincb EXPR(51330=0xc882) ABS 
msinca EXPR(51324=0xc87c) ABS 
msincremaining EXPR(51318=0xc876) ABS 
transfer_error EXPR(51305=0xc869) ABS 
foundsub EXPR(51301=0xc865) ABS 
rootsetup EXPR(51286=0xc856) ABS 
csid EXPR(51279=0xc84f) ABS 
ende EXPR(51269=0xc845) ABS 
innerloop EXPR(51260=0xc83c) ABS 
inner EXPR(51258=0xc83a) ABS 
outer EXPR(51256=0xc838) UNUSED ABS 
clear_sid EXPR(51275=0xc84b) ABS 
error_sound EXPR(51218=0xc812) ABS 
wholesectorwriteloop EXPR(51201=0xc801) ABS 
urdone EXPR(51217=0xc811) ABS 
fat32_file_write EXPR(51186=0xc7f2) ABS 
uwholesectorreadloop EXPR(51169=0xc7e1) ABS 
udone EXPR(51185=0xc7f1) ABS 
fat32_file_read EXPR(51154=0xc7d2) UNUSED ABS 
uegotdata EXPR(51135=0xc7bf) ABS 
urts EXPR(51153=0xc7d1) ABS 
fat32_file_readbyte EXPR(51081=0xc789) UNUSED ABS 
ucomparenameloop EXPR(51070=0xc77e) ABS 
udirentloop EXPR(51062=0xc776) ABS 
fat32_finddirent EXPR(51058=0xc772) ABS 
uendofdirectory EXPR(51034=0xc75a) ABS 
ugotdata EXPR(51036=0xc75c) ABS 
fat32_readdirent EXPR(51004=0xc73c) ABS 
dontincdw EXPR(50985=0xc729) ABS 
dontsubtractdw EXPR(50977=0xc721) ABS 
dontinclba EXPR(50964=0xc714) ABS 
diskfull EXPR(50996=0xc734) ABS 
ffcskip EXPR(50945=0xc701) ABS 
ffcdontinc EXPR(50918=0xc6e6) ABS 
gotfreecluster EXPR(50988=0xc72c) ABS 
ffcinner EXPR(50888=0xc6c8) ABS 
findfreeclusterloop EXPR(50857=0xc6a9) ABS 
enddiv EXPR(50775=0xc657) ABS 
divloop EXPR(50722=0xc622) ABS 
oflo EXPR(50765=0xc64d) ABS 
fat32_findnextfreecluster EXPR(50664=0xc5e8) ABS 
skipdiv EXPR(50826=0xc68a) ABS 
jmpskipdiv EXPR(50661=0xc5e5) ABS 
wdobut EXPR(50654=0xc5de) ABS 
wdnot EXPR(50653=0xc5dd) ABS 
wdfail EXPR(50659=0xc5e3) ABS 
wdontt EXPR(50642=0xc5d2) ABS 
wdirlp EXPR(50522=0xc55a) ABS 
wdirlpstart EXPR(50521=0xc559) ABS 
endofdirectoryy EXPR(50510=0xc54e) UNUSED ABS 
wgotdata EXPR(50512=0xc550) ABS 
fat32_writedirent EXPR(50480=0xc530) ABS 
fat32_opendirent EXPR(50429=0xc4fd) ABS 
fat32_openroot EXPR(50405=0xc4e5) ABS 
ursectorincrementdone EXPR(50401=0xc4e1) ABS 
endofchainn EXPR(50403=0xc4e3) ABS 
writesector EXPR(50374=0xc4c6) ABS 
fat32_writenextsector EXPR(50363=0xc4bb) ABS 
usectorincrementdone EXPR(50359=0xc4b7) ABS 
uendofchain EXPR(50361=0xc4b9) ABS 
ureadsector EXPR(50332=0xc49c) ABS 
fat32_readnextsector EXPR(50321=0xc491) ABS 
unotendofchain EXPR(50320=0xc490) ABS 
uspcshiftloopdone EXPR(50239=0xc43f) ABS 
uspcshiftloop EXPR(50225=0xc431) ABS 
fat32_seekcluster EXPR(50145=0xc3e1) ABS 
uskipfatsloop EXPR(50074=0xc39a) ABS 
uerror EXPR(50143=0xc3df) ABS 
ufoundpart EXPR(49963=0xc32b) ABS 
uFSTYPE_FAT32 EXPR(12=0xc) EQU 
ufail EXPR(49960=0xc328) ABS 
fat32_lba EXPR(90=0x5a) EQU 
fat32_filenamepointer EXPR(90=0x5a) EQU 
fat32_errorstage EXPR(90=0x5a) EQU 
fat32_dwcount EXPR(100=0x64) EQU 
fat32_result EXPR(98=0x62) EQU 
fat32_lastfoundfreecluster EXPR(94=0x5e) EQU 
fat32_bytesremaining EXPR(90=0x5a) EQU 
fat32_nextcluster EXPR(86=0x56) EQU 
fat32_address EXPR(84=0x54) EQU 
fat32_pendingsectors EXPR(83=0x53) EQU 
fat32_sectorspercluster EXPR(82=0x52) EQU 
fat32_rootcluster EXPR(78=0x4e) EQU 
fat32_datastart EXPR(74=0x4a) EQU 
fat32_fatstart EXPR(70=0x46) EQU 
fat32_readbuffer EXPR(512=0x200) EQU 
respmsg EXPR(49855=0xc2bf) UNUSED ABS 
statusmsg EXPR(49831=0xc2a7) UNUSED ABS 
awriteloop EXPR(49822=0xc29e) ABS 
areadloop EXPR(49811=0xc293) ABS 
afailloop EXPR(49807=0xc28f) UNUSED ABS 
failedmsg EXPR(49845=0xc2b5) ABS 
awritepage EXPR(49820=0xc29c) ABS 
sd_writesector EXPR(49741=0xc24d) ABS 
areadpage EXPR(49809=0xc291) ABS 
afail EXPR(49800=0xc288) ABS 
sd_readsector EXPR(49675=0xc20b) ABS 
sd_waitresult EXPR(49609=0xc1c9) ABS 
asendbit EXPR(49596=0xc1bc) ABS 
arloop EXPR(49588=0xc1b4) ABS 
sd_writebyte EXPR(49586=0xc1b2) ABS 
abitnotset EXPR(49580=0xc1ac) ABS 
baloop EXPR(49561=0xc199) ABS 
aloop EXPR(49533=0xc17d) UNUSED ABS 
initfailedmsg EXPR(49840=0xc2b0) ABS 
initmsg EXPR(49866=0xc2ca) ABS 
adelayloop EXPR(49508=0xc164) ABS 
ainitialized EXPR(49517=0xc16d) ABS 
sd_cmd41_bytes EXPR(49553=0xc191) ABS 
acmd41 EXPR(49485=0xc14d) UNUSED ABS 
sd_cmd55_bytes EXPR(49547=0xc18b) ABS 
acmd55 EXPR(49470=0xc13e) ABS 
sd_readbyte EXPR(49559=0xc197) ABS 
ainitfailed EXPR(49526=0xc176) ABS 
sd_cmd8_bytes EXPR(49541=0xc185) ABS 
acmd8 EXPR(49443=0xc123) UNUSED ABS 
sd_sendcommand EXPR(49617=0xc1d1) ABS 
sd_cmd0_bytes EXPR(49535=0xc17f) ABS 
acmd0 EXPR(49432=0xc118) UNUSED ABS 
apreinitloop EXPR(49424=0xc110) ABS 
cmsg EXPR(49410=0xc102) UNUSED ABS 
endwacia EXPR(49402=0xc0fa) ABS 
acia_man EXPR(49388=0xc0ec) ABS 
w_acia_full EXPR(49375=0xc0df) ABS 
ascii_home EXPR(49367=0xc0d7) UNUSED ABS 
print_char_acia EXPR(49364=0xc0d4) UNUSED ABS 
rxpoll EXPR(49347=0xc0c3) ABS 
cleardisplay EXPR(49328=0xc0b0) UNUSED ABS 
crlf EXPR(49307=0xc09b) ABS 
print_chara EXPR(49355=0xc0cb) ABS 
cskipletter EXPR(49301=0xc095) ABS 
print_nybble EXPR(49293=0xc08d) ABS 
print_hex_acia EXPR(49284=0xc084) UNUSED ABS 
PORTA_OUTPUTS EXPR(156=0x9c) EQU 
EXTVID EXPR(128=0x80) EQU 
SD_MISO EXPR(2=0x2) EQU 
SD_MOSI EXPR(4=0x4) EQU 
SD_SCK EXPR(8=0x8) EQU 
SD_CS EXPR(16=0x10) EQU 
DDRA EXPR(45059=0xb003) EQU 
DDRB EXPR(45058=0xb002) EQU 
PORTA EXPR(45057=0xb001) EQU 
PORTB EXPR(45056=0xb000) UNUSED EQU 
errormsg EXPR(49249=0xc061) ABS 
dirname EXPR(49237=0xc055) ABS 
doneloop EXPR(51419=0xc8db) ABS 
MEMORY_SAVE EXPR(51331=0xc883) ABS 
dummyloop EXPR(49205=0xc035) ABS 
faterror EXPR(49226=0xc04a) ABS 
fat32_init EXPR(49881=0xc2d9) ABS 
initdone EXPR(49203=0xc033) ABS 
sd_init EXPR(49420=0xc10c) ABS 
via_init EXPR(49260=0xc06c) ABS 
txpoll EXPR(49339=0xc0bb) ABS 
acia_init EXPR(49271=0xc077) ABS 
reset EXPR(49152=0xc000) ABS 
LF EXPR(10=0xa) EQU 
CR EXPR(13=0xd) EQU 
XYLODSAV2 EXPR(100=0x64) EQU 
zp_fat32_variables EXPR(70=0x46) EQU 
zp_sd_currentsector EXPR(66=0x42) EQU 
zp_sd_address EXPR(64=0x40) EQU 
endbuf EXPR(1536=0x600) UNUSED EQU 
buffer EXPR(1024=0x400) UNUSED EQU 
fat32_workspace EXPR(512=0x200) EQU 
ACIAData EXPR(32768=0x8000) EQU 
ACIAStatus EXPR(32769=0x8001) UNUSED EQU 
ACIACommand EXPR(32770=0x8002) UNUSED EQU 
ACIAControl EXPR(32771=0x8003) UNUSED EQU 
ACIA EXPR(32768=0x8000) EQU 
__RPTCNT EXPR(-1=0xffff) INTERNAL 
__VASM EXPR(0=0x0) INTERNAL 

There have been no errors.
