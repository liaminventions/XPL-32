F00:0001       ; writetest
F00:0002       ;
F00:0003       ; !! THIS WILL ERASE THE SD CARD AND MAKE IT REQUIRE A REFORMAT !!
F00:0004       ; 
F00:0005       ; this code is just for debugging the sd_writesector subroutine.
F00:0006       ; it will erase sector 0!
F00:0007       ; 
F00:0008       ; 
F00:0009       
F00:0010       ACIA = $8000
F00:0011       ACIAControl = ACIA+3
F00:0012       ACIACommand = ACIA+2
F00:0013       ACIAStatus = ACIA+1
F00:0014       ACIAData = ACIA
F00:0015       
F00:0016       irqcount = $00
F00:0017       donefact = $01
F00:0018       
F00:0019       ; sd card:
F00:0020       zp_sd_address = $48         ; 2 bytes
F00:0021       zp_sd_currentsector = $4a   ; 4 bytes
F00:0022       zp_fat32_variables = $4f    ; 24 bytes
F00:0023       ; only used during fat32 processing
F00:0024       path = $400		    ; page
F00:0025       fat32_workspace = $500      ; two pages
F00:0026       buffer = $700		    ; two pages
F00:0027       endbuf = $900
F00:0028       
F00:0029       CR=13
F00:0030       LF=10
F00:0031       
F00:0032         .org $0f00
F00:0033       
F00:0034       reset:
F00:0035         ;jsr sd_init
F00:0036         ;bcs sd_fail
F00:0037         ; sd init done
F00:0038         ;lda #'S'
F00:0039         ;sta ACIAData
F00:0040         ;jsr fat32_init
F00:0041         ;bcs faterror
F00:0042         ; fat32 init done
F00:0043         ;jsr txpoll
F00:0044         ;lda #'F'
F00:0045         ;sta ACIAData
F00:0046       
F00:0047         ldx #<hehe
               S01:00000F00:  A2 3F
F00:0048         ldy #>hehe
               S01:00000F02:  A0 0F
F00:0049         jsr w_acia_full
               S01:00000F04:  20 C5 12
F00:0050       
F00:0051         jsr rxpoll
               S01:00000F07:  20 A9 12
F00:0052       
F00:0053         ldx #<goin
               S01:00000F0A:  A2 60
F00:0054         ldy #>goin
               S01:00000F0C:  A0 0F
F00:0055         jsr w_acia_full
               S01:00000F0E:  20 C5 12
F00:0056       
F00:0057         lda #<buffer
               S01:00000F11:  A9 00
F00:0058         sta zp_sd_address
               S01:00000F13:  85 48
F00:0059         lda #>buffer
               S01:00000F15:  A9 07
F00:0060         sta zp_sd_address+1
               S01:00000F17:  85 49
F00:0061         
F00:0062         ; save to sector 3
F00:0063         lda #03
               S01:00000F19:  A9 03
F00:0064         sta zp_sd_currentsector
               S01:00000F1B:  85 4A
F00:0065         stz zp_sd_currentsector+1
               S01:00000F1D:  64 4B
F00:0066         stz zp_sd_currentsector+2
               S01:00000F1F:  64 4C
F00:0067         stz zp_sd_currentsector+3
               S01:00000F21:  64 4D
F00:0068       
F00:0069         jsr sd_readsector
               S01:00000F23:  20 F6 13
F00:0070       
F00:0071       ; make a dummy file.
F00:0072         ldx #$ff
               S01:00000F26:  A2 FF
F00:0073         lda #$aa
               S01:00000F28:  A9 AA
F00:0074       dummyloop:
F00:0075         txa
               S01:00000F2A:  8A
F00:0076         sta $0700,x
               S01:00000F2B:  9D 00 07
F00:0077         sta $0800,x
               S01:00000F2E:  9D 00 08
F00:0078         dex
               S01:00000F31:  CA
F00:0079         bne dummyloop
               S01:00000F32:  D0 F6
F00:0080       
F00:0081         jsr sd_writesector
               S01:00000F34:  20 54 14
F00:0082       
F00:0083         ldx #<ded
               S01:00000F37:  A2 6B
F00:0084         ldy #>ded
               S01:00000F39:  A0 0F
F00:0085         jsr w_acia_full
               S01:00000F3B:  20 C5 12
F00:0086       
F00:0087         rts
               S01:00000F3E:  60
F00:0088       
F00:0089       ;sd_fail:
F00:0090       ;  lda #'s'
F00:0091       ;  jsr print_chara
F00:0092       ;  rts
F00:0093       
F00:0094       hehe:
F00:0095         .byte "Press any key to fill sector 3",CR,LF,0
               S01:00000F3F:  50 72 65 73 73 20 61 6E 79 20 6B 65 79 20 74 6F
               S01:00000F4F:  20 66 69 6C 6C 20 73 65 63 74 6F 72 20 33
               S01:00000F5D:  0D
               S01:00000F5E:  0A
               S01:00000F5F:  00
F00:0096       goin:
F00:0097         .byte "Filling...",0
               S01:00000F60:  46 69 6C 6C 69 6E 67 2E 2E 2E
               S01:00000F6A:  00
F00:0098       ded:
F00:0099         .byte "Done.",CR,LF,0
               S01:00000F6B:  44 6F 6E 65 2E
               S01:00000F70:  0D
               S01:00000F71:  0A
               S01:00000F72:  00
F00:0100       
F00:0101         .include "errors.s"
F01:0001       error_sound:
F01:0002         lda #$55
               S01:00000F73:  A9 55
F01:0003         sta donefact
               S01:00000F75:  85 01
F01:0004         stz irqcount	; reset irq count
               S01:00000F77:  64 00
F01:0005       
F01:0006       runthesound:
F01:0007         sei		; turn off irqs
               S01:00000F79:  78
F01:0008         lda #<irq
               S01:00000F7A:  A9 97
F01:0009         sta $7ffe
               S01:00000F7C:  8D FE 7F
F01:0010         lda #>irq
               S01:00000F7F:  A9 0F
F01:0011         sta $7fff	; store vectors
               S01:00000F81:  8D FF 7F
F01:0012         lda #$c0
               S01:00000F84:  A9 C0
F01:0013         sta $b00e	
               S01:00000F86:  8D 0E B0
F01:0014         lda #0 ; Song Number
               S01:00000F89:  A9 00
F01:0015         jsr InitSid
               S01:00000F8B:  20 BE 0F
F01:0016         lda #$40
               S01:00000F8E:  A9 40
F01:0017         sta $b00d
               S01:00000F90:  8D 0D B0
F01:0018         cli
               S01:00000F93:  58
F01:0019         jmp startupsoundloop
               S01:00000F94:  4C 2F 12
F01:0020       
F01:0021       irq:
F01:0022         lda #$40
               S01:00000F97:  A9 40
F01:0023         sta $b00d
               S01:00000F99:  8D 0D B0
F01:0024         jsr putbut		; refresh timers
               S01:00000F9C:  20 AD 0F
F01:0025         inc irqcount		; a irq has occurred
               S01:00000F9F:  E6 00
F01:0026         lda irqcount
               S01:00000FA1:  A5 00
F01:0027         cmp #$40		; if $32 irqs (end of the error sound)
               S01:00000FA3:  C9 40
F01:0028         bne continue24542 	; end the stream
               S01:00000FA5:  D0 02
F01:0029         stz donefact		; its done, tell the loop
               S01:00000FA7:  64 01
F01:0030       continue24542:
F01:0031         jsr $1006
               S01:00000FA9:  20 06 10
F01:0032         rti			; exit
               S01:00000FAC:  40
F01:0033       
F01:0034       putbut:
F01:0035         ldx #$9e
               S01:00000FAD:  A2 9E
F01:0036         stx $b004
               S01:00000FAF:  8E 04 B0
F01:0037         stx $b006
               S01:00000FB2:  8E 06 B0
F01:0038         ldx #$0f  ; 250Hz IRQ
               S01:00000FB5:  A2 0F
F01:0039         stx $b005
               S01:00000FB7:  8E 05 B0
F01:0040         stx $b007
               S01:00000FBA:  8E 07 B0
F01:0041         rts
               S01:00000FBD:  60
F01:0042       InitSid:
F01:0043         jsr putbut
               S01:00000FBE:  20 AD 0F
F01:0044         jmp $1103
               S01:00000FC1:  4C 03 11
F01:0045       
F01:0046         .org $1006
F01:0047       
F01:0048         .include "errorsound.s"
F02:0001       d400_sVoc1FreqLo = $b800
F02:0002       d404_sVoc1Control = $b804
F02:0003       d40b_sVoc2Control = $b80b
F02:0004       d412_sVoc3Control = $b812
F02:0005       
F02:0006         .org $1006
F02:0007       
F02:0008       PlaySid             ldx #$18
               S02:00001006:  A2 18
F02:0009       L1008               lda $04,x
               S02:00001008:  B5 04
F02:0010                           sta d400_sVoc1FreqLo,x
               S02:0000100A:  9D 00 B8
F02:0011                           dex
               S02:0000100D:  CA
F02:0012                           bpl L1008
               S02:0000100E:  10 F8
F02:0013                           dec $02
               S02:00001010:  C6 02
F02:0014                           bmi L1015
               S02:00001012:  30 01
F02:0015                           rts
               S02:00001014:  60
F02:0016                           
F02:0017       L1015               stx $02
               S02:00001015:  86 02
F02:0018                           lda $03
               S02:00001017:  A5 03
F02:0019                           bne L1033
               S02:00001019:  D0 18
F02:0020                           jsr $001f
               S02:0000101B:  20 1F 00
F02:0021                           beq L1038
               S02:0000101E:  F0 18
F02:0022                           cmp #$a0
               S02:00001020:  C9 A0
F02:0023                           bcs L102e
               S02:00001022:  B0 0A
F02:0024                           sta $2a
               S02:00001024:  85 2A
F02:0025                           jsr $001f
               S02:00001026:  20 1F 00
F02:0026                           sta $29
               S02:00001029:  85 29
F02:0027                           jmp L1076
               S02:0000102B:  4C 76 10
F02:0028                           
F02:0029       L102e               sec
               S02:0000102E:  38
F02:0030                           sbc #$9f
               S02:0000102F:  E9 9F
F02:0031                           sta $03
               S02:00001031:  85 03
F02:0032       L1033               dec $03
               S02:00001033:  C6 03
F02:0033                           jmp L1076
               S02:00001035:  4C 76 10
F02:0034                           
F02:0035       L1038               jsr $001f
               S02:00001038:  20 1F 00
F02:0036                           cmp #$fd
               S02:0000103B:  C9 FD
F02:0037                           beq L106b
               S02:0000103D:  F0 2C
F02:0038                           cmp #$fe
               S02:0000103F:  C9 FE
F02:0039                           beq L1060
               S02:00001041:  F0 1D
F02:0040                           cmp #$ff
               S02:00001043:  C9 FF
F02:0041                           beq L104a
               S02:00001045:  F0 03
F02:0042                           sta $02
               S02:00001047:  85 02
F02:0043                           rts
               S02:00001049:  60
F02:0044                           
F02:0045       L104a               lda #$00
               S02:0000104A:  A9 00
F02:0046                           sta d404_sVoc1Control
               S02:0000104C:  8D 04 B8
F02:0047                           sta d40b_sVoc2Control
               S02:0000104F:  8D 0B B8
F02:0048                           sta d412_sVoc3Control
               S02:00001052:  8D 12 B8
F02:0049                           lda #$5e
               S02:00001055:  A9 5E
F02:0050                           sta $26
               S02:00001057:  85 26
F02:0051                           lda #$10
               S02:00001059:  A9 10
F02:0052                           sta $27
               S02:0000105B:  85 27
F02:0053                           rts
               S02:0000105D:  60
F02:0054                           
F02:0055                             .byte $ff, $00 
               S02:0000105E:  FF
               S02:0000105F:  00
F02:0056       L1060               lda $1d
               S02:00001060:  A5 1D
F02:0057                           sta $26
               S02:00001062:  85 26
F02:0058                           lda $1e
               S02:00001064:  A5 1E
F02:0059                           sta $27
               S02:00001066:  85 27
F02:0060                           jmp L1015
               S02:00001068:  4C 15 10
F02:0061                           
F02:0062       L106b               lda $26
               S02:0000106B:  A5 26
F02:0063                           sta $1d
               S02:0000106D:  85 1D
F02:0064                           lda $27
               S02:0000106F:  A5 27
F02:0065                           sta $1e
               S02:00001071:  85 1E
F02:0066                           jmp L1015
               S02:00001073:  4C 15 10
F02:0067                           
F02:0068       L1076               jsr S10a1
               S02:00001076:  20 A1 10
F02:0069                           lda #$f8
               S02:00001079:  A9 F8
F02:0070       L107b               clc
               S02:0000107B:  18
F02:0071                           adc #$07
               S02:0000107C:  69 07
F02:0072                           pha
               S02:0000107E:  48
F02:0073                           tax
               S02:0000107F:  AA
F02:0074                           jsr $001f
               S02:00001080:  20 1F 00
F02:0075                           lsr a
               S02:00001083:  4A
F02:0076                           php
               S02:00001084:  08
F02:0077       L1085               inx
               S02:00001085:  E8
F02:0078                           lsr a
               S02:00001086:  4A
F02:0079                           bcs L1093
               S02:00001087:  B0 0A
F02:0080                           bne L1085
               S02:00001089:  D0 FA
F02:0081                           plp
               S02:0000108B:  28
F02:0082                           pla
               S02:0000108C:  68
F02:0083                           bcs L107b
               S02:0000108D:  B0 EC
F02:0084                           jsr S10a1
               S02:0000108F:  20 A1 10
F02:0085                           rts
               S02:00001092:  60
F02:0086                           
F02:0087       L1093               pha
               S02:00001093:  48
F02:0088                           ldy $ffff,x
               S02:00001094:  BC FF FF
F02:0089                           jsr $001f
               S02:00001097:  20 1F 00
F02:0090                           sta $0004,y
               S02:0000109A:  99 04 00
F02:0091                           pla
               S02:0000109D:  68
F02:0092                           jmp L1085
               S02:0000109E:  4C 85 10
F02:0093                           
F02:0094       S10a1               ldy $26
               S02:000010A1:  A4 26
F02:0095                           ldx $29
               S02:000010A3:  A6 29
F02:0096                           sty $29
               S02:000010A5:  84 29
F02:0097                           stx $26
               S02:000010A7:  86 26
F02:0098                           ldy $27
               S02:000010A9:  A4 27
F02:0099                           ldx $2a
               S02:000010AB:  A6 2A
F02:0100                           sty $2a
               S02:000010AD:  84 2A
F02:0101                           stx $27
               S02:000010AF:  86 27
F02:0102                           rts
               S02:000010B1:  60
F02:0103                           
F02:0104       L10b2               sty $26
               S02:000010B2:  84 26
F02:0105                           stx $27
               S02:000010B4:  86 27
F02:0106                           ldx #$06
               S02:000010B6:  A2 06
F02:0107       L10b8               lda $10c6,x
               S02:000010B8:  BD C6 10
F02:0108                           sta $1f,x
               S02:000010BB:  95 1F
F02:0109                           dex
               S02:000010BD:  CA
F02:0110                           bpl L10b8
               S02:000010BE:  10 F8
F02:0111                           lda #$60
               S02:000010C0:  A9 60
F02:0112                           sta $28
               S02:000010C2:  85 28
F02:0113                           bne L10d0
               S02:000010C4:  D0 0A
F02:0114                           inc $26
               S02:000010C6:  E6 26
F02:0115                           bne L10cc
               S02:000010C8:  D0 02
F02:0116                           inc $27
               S02:000010CA:  E6 27
F02:0117       L10cc               lda $ffff
               S02:000010CC:  AD FF FF
F02:0118                           rts
               S02:000010CF:  60
F02:0119                           
F02:0120       L10d0               jsr $001f
               S02:000010D0:  20 1F 00
F02:0121                           sta $dc04
               S02:000010D3:  8D 04 DC
F02:0122                           jsr $001f
               S02:000010D6:  20 1F 00
F02:0123                           sta $dc05
               S02:000010D9:  8D 05 DC
F02:0124                           jsr $001f
               S02:000010DC:  20 1F 00
F02:0125                           sta $29
               S02:000010DF:  85 29
F02:0126                           jsr $001f
               S02:000010E1:  20 1F 00
F02:0127                           sta $2a
               S02:000010E4:  85 2A
F02:0128                           inc $26
               S02:000010E6:  E6 26
F02:0129                           bne L10ec
               S02:000010E8:  D0 02
F02:0130                           inc $27
               S02:000010EA:  E6 27
F02:0131       L10ec               lda $26
               S02:000010EC:  A5 26
F02:0132                           sta $1095
               S02:000010EE:  8D 95 10
F02:0133                           lda $27
               S02:000010F1:  A5 27
F02:0134                           sta $1096
               S02:000010F3:  8D 96 10
F02:0135                           ldx #$1c
               S02:000010F6:  A2 1C
F02:0136                           lda #$00
               S02:000010F8:  A9 00
F02:0137       L10fa               sta $02,x
               S02:000010FA:  95 02
F02:0138                           dex
               S02:000010FC:  CA
F02:0139                           bpl L10fa
               S02:000010FD:  10 FB
F02:0140                           jsr S10a1
               S02:000010FF:  20 A1 10
F02:0141                           rts
               S02:00001102:  60
F02:0142                           
F02:0143       InitSid2            ldy #$09
               S02:00001103:  A0 09
F02:0144                           ldx #$11
               S02:00001105:  A2 11
F02:0145                           jmp L10b2
               S02:00001107:  4C B2 10
F02:0146       
F02:0147         .binary "errorsound.bin"
               S02:0000110A:  F0 0F 77 11 01 00 12 0D 04 05 0B 14 08 09 07 06
               S02:0000111A:  0C 03 0E 0F 10 11 17 13 0A 15 16 18 02 00 B6 00
F02:0148       ;          ^^^^^^^^^^^
F02:0149       ; put your data file here.
F02:0150       
F02:0151       
F01:0049       
F01:0050       startupsoundloop:	
F01:0051         lda donefact		; loop only if the sound is not done
               S02:0000122F:  A5 01
F01:0052         bne startupsoundloop
               S02:00001231:  D0 FC
F01:0053         stz $b00e		; if done disable irqs
               S02:00001233:  9C 0E B0
F01:0054         stz $b00d
               S02:00001236:  9C 0D B0
F01:0055         sei
               S02:00001239:  78
F01:0056         lda $c0		; clear irq vectors
               S02:0000123A:  A5 C0
F01:0057         sta $7fff
               S02:0000123C:  8D FF 7F
F01:0058         stz $7ffe
               S02:0000123F:  9C FE 7F
F01:0059         jsr clear_sid
               S02:00001242:  20 49 12
F01:0060         rts
               S02:00001245:  60
F01:0061         rts
               S02:00001246:  60
F01:0062         rts
               S02:00001247:  60
F01:0063         rts
               S02:00001248:  60
F01:0064       
F01:0065       clear_sid
F01:0066         ldx #$17 ; 17 cuz no pop
               S02:00001249:  A2 17
F01:0067       csid
F01:0068         stz $b800,x
               S02:0000124B:  9E 00 B8
F01:0069         dex
               S02:0000124E:  CA
F01:0070         bne csid
               S02:0000124F:  D0 FA
F01:0071         rts
               S02:00001251:  60
F01:0072       
F01:0073       
F00:0102         .include "hwconfig.s"
F03:0001       PORTB = $b000
F03:0002       PORTA = $b001
F03:0003       DDRB = $b002
F03:0004       DDRA = $b003
F03:0005       
F03:0006       LCD_E  = %10000000
F03:0007       LCD_RW = %01000000
F03:0008       LCD_RS = %00100000
F03:0009       
F03:0010       SD_CS   = %00010000
F03:0011       SD_SCK  = %00001000
F03:0012       SD_MOSI = %00000100
F03:0013       SD_MISO = %00000010
F03:0014       
F03:0015       PORTA_OUTPUTPINS = LCD_E | LCD_RW | LCD_RS | SD_CS | SD_SCK | SD_MOSI
F03:0016       
F03:0017       via_init:
F03:0018         lda #%11111111          ; Set all pins on port B to output
               S02:00001252:  A9 FF
F03:0019         sta DDRB
               S02:00001254:  8D 02 B0
F03:0020         lda #PORTA_OUTPUTPINS   ; Set various pins on port A to output
               S02:00001257:  A9 FC
F03:0021         sta DDRA
               S02:00001259:  8D 03 B0
F03:0022         rts
               S02:0000125C:  60
F03:0023       
F03:0024       
F00:0103         .include "libacia.s"
F04:0001       ;       ------------------ 6551 ACIA Subroutine Library -------------------
F04:0002       ; Includes:
F04:0003       ; acia_init       - Initializes the ACIA
F04:0004       ; print_hex_acia  - Prints a hex value in A
F04:0005       ; crlf		  - Prints <CR> followed by <LF>
F04:0006       ; clear_display   - Sends a <CLS> command
F04:0007       ; txpoll          - Polls the TX bit to see if the ACIA is ready
F04:0008       ; print_chara     - Prints a Character that is stored in A
F04:0009       ; print_char_acia - Same as print_chara
F04:0010       ; ascii_home      - Home the cursor
F04:0011       ; w_acia_full     - Print a NULL-Termintated String with >HIGH in Y and <LOW in X
F04:0012       
F04:0013       acia_init:
F04:0014         pha
               S02:0000125D:  48
F04:0015         lda #%00001011          ; No parity, no echo, no interrupt
               S02:0000125E:  A9 0B
F04:0016         sta $8002
               S02:00001260:  8D 02 80
F04:0017         lda #%00011111          ; 1 stop bit, 8 data bits, 19200 baud
               S02:00001263:  A9 1F
F04:0018         sta $8003
               S02:00001265:  8D 03 80
F04:0019         pla
               S02:00001268:  68
F04:0020         rts
               S02:00001269:  60
F04:0021       
F04:0022       print_hex_acia:
F04:0023         pha
               S02:0000126A:  48
F04:0024         ror
               S02:0000126B:  6A
F04:0025         ror
               S02:0000126C:  6A
F04:0026         ror
               S02:0000126D:  6A
F04:0027         ror
               S02:0000126E:  6A
F04:0028         jsr print_nybble   ; This is just som usful hex cod
               S02:0000126F:  20 73 12
F04:0029         pla
               S02:00001272:  68
F04:0030       print_nybble:
F04:0031         and #15
               S02:00001273:  29 0F
F04:0032         cmp #10
               S02:00001275:  C9 0A
F04:0033         bmi cskipletter
               S02:00001277:  30 02
F04:0034         adc #6
               S02:00001279:  69 06
F04:0035       cskipletter:
F04:0036         adc #48
               S02:0000127B:  69 30
F04:0037        ; jsr print_char
F04:0038         jsr print_chara
               S02:0000127D:  20 B1 12
F04:0039         rts
               S02:00001280:  60
F04:0040       
F04:0041       crlf:
F04:0042         pha
               S02:00001281:  48
F04:0043         txa
               S02:00001282:  8A
F04:0044         pha
               S02:00001283:  48
F04:0045         tya
               S02:00001284:  98
F04:0046         pha
               S02:00001285:  48
F04:0047         lda #$0d
               S02:00001286:  A9 0D
F04:0048         jsr print_chara
               S02:00001288:  20 B1 12
F04:0049         lda #$0a
               S02:0000128B:  A9 0A
F04:0050         jsr print_chara
               S02:0000128D:  20 B1 12
F04:0051         pla
               S02:00001290:  68
F04:0052         tay
               S02:00001291:  A8
F04:0053         pla
               S02:00001292:  68
F04:0054         tax
               S02:00001293:  AA
F04:0055         pla
               S02:00001294:  68
F04:0056         rts
               S02:00001295:  60
F04:0057       
F04:0058       cleardisplay:
F04:0059         pha
               S02:00001296:  48
F04:0060         jsr txpoll  ; Poll the TX bit
               S02:00001297:  20 A1 12
F04:0061         lda #12     ; Print decimal 12 (CLS)
               S02:0000129A:  A9 0C
F04:0062         sta $8000
               S02:0000129C:  8D 00 80
F04:0063         pla
               S02:0000129F:  68
F04:0064         rts
               S02:000012A0:  60
F04:0065       
F04:0066       txpoll:
F04:0067         lda $8001
               S02:000012A1:  AD 01 80
F04:0068         and #$10    ; Poll the TX bit
               S02:000012A4:  29 10
F04:0069         beq txpoll
               S02:000012A6:  F0 F9
F04:0070         rts
               S02:000012A8:  60
F04:0071       
F04:0072       rxpoll:
F04:0073         lda $8001
               S02:000012A9:  AD 01 80
F04:0074         and #$08    ; Poll the RX bit
               S02:000012AC:  29 08
F04:0075         beq rxpoll
               S02:000012AE:  F0 F9
F04:0076         rts
               S02:000012B0:  60
F04:0077       
F04:0078       
F04:0079       print_chara:
F04:0080         pha
               S02:000012B1:  48
F04:0081         jsr txpoll  ; Poll the TX bit
               S02:000012B2:  20 A1 12
F04:0082         pla
               S02:000012B5:  68
F04:0083         sta $8000   ; Print character from A
               S02:000012B6:  8D 00 80
F04:0084         rts
               S02:000012B9:  60
F04:0085       
F04:0086       print_char_acia:
F04:0087         jmp print_chara  ; Same as "print_chara"
               S02:000012BA:  4C B1 12
F04:0088       
F04:0089       ascii_home:
F04:0090         pha
               S02:000012BD:  48
F04:0091         lda #1
               S02:000012BE:  A9 01
F04:0092         jsr print_chara  ; Print 1 (HOME)
               S02:000012C0:  20 B1 12
F04:0093         pla
               S02:000012C3:  68
F04:0094         rts
               S02:000012C4:  60
F04:0095       
F04:0096       w_acia_full:
F04:0097         pha
               S02:000012C5:  48
F04:0098         lda $ff
               S02:000012C6:  A5 FF
F04:0099         pha        ; Push Previous States onto the stack
               S02:000012C8:  48
F04:0100         lda $fe
               S02:000012C9:  A5 FE
F04:0101         pha
               S02:000012CB:  48
F04:0102         sty $ff    ; Set Y as the Upper Address (8-15)
               S02:000012CC:  84 FF
F04:0103         stx $fe    ; Set X as the Lower Adderss (0-7)
               S02:000012CE:  86 FE
F04:0104         ldy #0
               S02:000012D0:  A0 00
F04:0105       acia_man:
F04:0106         jsr txpoll   ; Poll TX
               S02:000012D2:  20 A1 12
F04:0107         lda ($fe),y  ; Load the Address
               S02:000012D5:  B1 FE
F04:0108         sta $8000    ; Print what is at the address
               S02:000012D7:  8D 00 80
F04:0109         beq endwacia ; If Done, End
               S02:000012DA:  F0 04
F04:0110         iny          ; Next Character
               S02:000012DC:  C8
F04:0111         jmp acia_man ; Back to the top
               S02:000012DD:  4C D2 12
F04:0112       endwacia:
F04:0113         pla
               S02:000012E0:  68
F04:0114         sta $fe
               S02:000012E1:  85 FE
F04:0115         pla          ; Restore Variables
               S02:000012E3:  68
F04:0116         sta $ff
               S02:000012E4:  85 FF
F04:0117         pla
               S02:000012E6:  68
F04:0118         rts
               S02:000012E7:  60
F04:0119       
F00:0104         .include "libsd.s"
F05:0001       ; SD card interface module
F05:0002       ;
F05:0003       ; Requires zero-page variable storage:
F05:0004       ;   zp_sd_address - 2 bytes
F05:0005       ;   zp_sd_currentsector - 4 bytes
F05:0006       
F05:0007       
F05:0008       sd_init:
F05:0009         ; Let the SD card boot up, by pumping the clock with SD CS disabled
F05:0010       
F05:0011         ; We need to apply around 80 clock pulses with CS and MOSI high.
F05:0012         ; Normally MOSI doesn't matter when CS is high, but the card is
F05:0013         ; not yet is SPI mode, and in this non-SPI state it does care.
F05:0014       
F05:0015         lda #SD_CS | SD_MOSI
               S02:000012E8:  A9 14
F05:0016         ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
               S02:000012EA:  A2 A0
F05:0017       .preinitloop:
F05:0018         eor #SD_SCK
               S02:000012EC:  49 08
F05:0019         sta PORTA
               S02:000012EE:  8D 01 B0
F05:0020         dex
               S02:000012F1:  CA
F05:0021         bne .preinitloop
               S02:000012F2:  D0 F8
F05:0022         
F05:0023       
F05:0024       .cmd0 ; GO_IDLE_STATE - resets card to idle state, and SPI mode
F05:0025         lda #<sd_cmd0_bytes
               S02:000012F4:  A9 5B
F05:0026         sta zp_sd_address
               S02:000012F6:  85 48
F05:0027         lda #>sd_cmd0_bytes
               S02:000012F8:  A9 13
F05:0028         sta zp_sd_address+1
               S02:000012FA:  85 49
F05:0029       
F05:0030         jsr sd_sendcommand
               S02:000012FC:  20 AD 13
F05:0031       
F05:0032         ; Expect status response $01 (not initialized)
F05:0033         cmp #$01
               S02:000012FF:  C9 01
F05:0034         bne .initfailed
               S02:00001301:  D0 50
F05:0035       
F05:0036       .cmd8 ; SEND_IF_COND - tell the card how we want it to operate (3.3V, etc)
F05:0037         lda #<sd_cmd8_bytes
               S02:00001303:  A9 61
F05:0038         sta zp_sd_address
               S02:00001305:  85 48
F05:0039         lda #>sd_cmd8_bytes
               S02:00001307:  A9 13
F05:0040         sta zp_sd_address+1
               S02:00001309:  85 49
F05:0041       
F05:0042         jsr sd_sendcommand
               S02:0000130B:  20 AD 13
F05:0043       
F05:0044         ; Expect status response $01 (not initialized)
F05:0045         cmp #$01
               S02:0000130E:  C9 01
F05:0046         bne .initfailed
               S02:00001310:  D0 41
F05:0047       
F05:0048         ; Read 32-bit return value, but ignore it
F05:0049         jsr sd_readbyte
               S02:00001312:  20 73 13
F05:0050         jsr sd_readbyte
               S02:00001315:  20 73 13
F05:0051         jsr sd_readbyte
               S02:00001318:  20 73 13
F05:0052         jsr sd_readbyte
               S02:0000131B:  20 73 13
F05:0053       
F05:0054       .cmd55 ; APP_CMD - required prefix for ACMD commands
F05:0055         lda #<sd_cmd55_bytes
               S02:0000131E:  A9 67
F05:0056         sta zp_sd_address
               S02:00001320:  85 48
F05:0057         lda #>sd_cmd55_bytes
               S02:00001322:  A9 13
F05:0058         sta zp_sd_address+1
               S02:00001324:  85 49
F05:0059       
F05:0060         jsr sd_sendcommand
               S02:00001326:  20 AD 13
F05:0061       
F05:0062         ; Expect status response $01 (not initialized)
F05:0063         cmp #$01
               S02:00001329:  C9 01
F05:0064         bne .initfailed
               S02:0000132B:  D0 26
F05:0065       
F05:0066       .cmd41 ; APP_SEND_OP_COND - send operating conditions, initialize card
F05:0067         lda #<sd_cmd41_bytes
               S02:0000132D:  A9 6D
F05:0068         sta zp_sd_address
               S02:0000132F:  85 48
F05:0069         lda #>sd_cmd41_bytes
               S02:00001331:  A9 13
F05:0070         sta zp_sd_address+1
               S02:00001333:  85 49
F05:0071       
F05:0072         jsr sd_sendcommand
               S02:00001335:  20 AD 13
F05:0073       
F05:0074         ; Status response $00 means initialised
F05:0075         cmp #$00
               S02:00001338:  C9 00
F05:0076         beq .initialized
               S02:0000133A:  F0 11
F05:0077       
F05:0078         ; Otherwise expect status response $01 (not initialized)
F05:0079         cmp #$01
               S02:0000133C:  C9 01
F05:0080         bne .initfailed
               S02:0000133E:  D0 13
F05:0081       
F05:0082         ; Not initialized yet, so wait a while then try again.
F05:0083          	; This retry is important, to give the card time to initialize.
F05:0084       
F05:0085         ldx #0
               S02:00001340:  A2 00
F05:0086         ldy #0
               S02:00001342:  A0 00
F05:0087       .delayloop
F05:0088         dey
               S02:00001344:  88
F05:0089         bne .delayloop
               S02:00001345:  D0 FD
F05:0090         dex
               S02:00001347:  CA
F05:0091         bne .delayloop
               S02:00001348:  D0 FA
F05:0092       
F05:0093         jmp .cmd55
               S02:0000134A:  4C 1E 13
F05:0094       
F05:0095       
F05:0096       .initialized
F05:0097         lda #'Y'
               S02:0000134D:  A9 59
F05:0098         jsr print_chara
               S02:0000134F:  20 B1 12
F05:0099         rts
               S02:00001352:  60
F05:0100       
F05:0101       .initfailed
F05:0102         lda #'X'
               S02:00001353:  A9 58
F05:0103         jsr print_chara
               S02:00001355:  20 B1 12
F05:0104       .loop
F05:0105         jmp .loop
               S02:00001358:  4C 58 13
F05:0106       
F05:0107       
F05:0108       sd_cmd0_bytes
F05:0109         .byte $40, $00, $00, $00, $00, $95
               S02:0000135B:  40
               S02:0000135C:  00
               S02:0000135D:  00
               S02:0000135E:  00
               S02:0000135F:  00
               S02:00001360:  95
F05:0110       sd_cmd8_bytes
F05:0111         .byte $48, $00, $00, $01, $aa, $87
               S02:00001361:  48
               S02:00001362:  00
               S02:00001363:  00
               S02:00001364:  01
               S02:00001365:  AA
               S02:00001366:  87
F05:0112       sd_cmd55_bytes
F05:0113         .byte $77, $00, $00, $00, $00, $01
               S02:00001367:  77
               S02:00001368:  00
               S02:00001369:  00
               S02:0000136A:  00
               S02:0000136B:  00
               S02:0000136C:  01
F05:0114       sd_cmd41_bytes
F05:0115         .byte $69, $40, $00, $00, $00, $01
               S02:0000136D:  69
               S02:0000136E:  40
               S02:0000136F:  00
               S02:00001370:  00
               S02:00001371:  00
               S02:00001372:  01
F05:0116       
F05:0117       
F05:0118       
F05:0119       sd_readbyte:
F05:0120         ; Enable the card and tick the clock 8 times with MOSI high, 
F05:0121         ; capturing bits from MISO and returning them
F05:0122       
F05:0123         ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
               S02:00001373:  A2 FE
F05:0124       
F05:0125       .loop:
F05:0126       
F05:0127         lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
               S02:00001375:  A9 04
F05:0128         sta PORTA
               S02:00001377:  8D 01 B0
F05:0129       
F05:0130         lda #SD_MOSI | SD_SCK       ; toggle the clock high
               S02:0000137A:  A9 0C
F05:0131         sta PORTA
               S02:0000137C:  8D 01 B0
F05:0132       
F05:0133         lda PORTA                   ; read next bit
               S02:0000137F:  AD 01 B0
F05:0134         and #SD_MISO
               S02:00001382:  29 02
F05:0135       
F05:0136         clc                         ; default to clearing the bottom bit
               S02:00001384:  18
F05:0137         beq .bitnotset              ; unless MISO was set
               S02:00001385:  F0 01
F05:0138         sec                         ; in which case get ready to set the bottom bit
               S02:00001387:  38
F05:0139       .bitnotset:
F05:0140       
F05:0141         txa                         ; transfer partial result from X
               S02:00001388:  8A
F05:0142         rol                         ; rotate carry bit into read result, and loop bit into carry
               S02:00001389:  2A
F05:0143         tax                         ; save partial result back to X
               S02:0000138A:  AA
F05:0144         
F05:0145         bcs .loop                   ; loop if we need to read more bits
               S02:0000138B:  B0 E8
F05:0146       
F05:0147         rts
               S02:0000138D:  60
F05:0148       
F05:0149       
F05:0150       sd_writebyte:
F05:0151         ; Tick the clock 8 times with descending bits on MOSI
F05:0152         ; SD communication is mostly half-duplex so we ignore anything it sends back here
F05:0153       
F05:0154         ldx #8                      ; send 8 bits
               S02:0000138E:  A2 08
F05:0155       
F05:0156       .loop:
F05:0157         asl                         ; shift next bit into carry
               S02:00001390:  0A
F05:0158         tay                         ; save remaining bits for later
               S02:00001391:  A8
F05:0159       
F05:0160         lda #0
               S02:00001392:  A9 00
F05:0161         bcc .sendbit                ; if carry clear, don't set MOSI for this bit
               S02:00001394:  90 02
F05:0162         ora #SD_MOSI
               S02:00001396:  09 04
F05:0163       
F05:0164       .sendbit:
F05:0165         sta PORTA                   ; set MOSI (or not) first with SCK low
               S02:00001398:  8D 01 B0
F05:0166         eor #SD_SCK
               S02:0000139B:  49 08
F05:0167         sta PORTA                   ; raise SCK keeping MOSI the same, to send the bit
               S02:0000139D:  8D 01 B0
F05:0168       
F05:0169         tya                         ; restore remaining bits to send
               S02:000013A0:  98
F05:0170       
F05:0171         dex
               S02:000013A1:  CA
F05:0172         bne .loop                   ; loop if there are more bits to send
               S02:000013A2:  D0 EC
F05:0173       
F05:0174         rts
               S02:000013A4:  60
F05:0175       
F05:0176       
F05:0177       sd_waitresult:
F05:0178         ; Wait for the SD card to return something other than $ff
F05:0179         jsr sd_readbyte
               S02:000013A5:  20 73 13
F05:0180         cmp #$ff
               S02:000013A8:  C9 FF
F05:0181         beq sd_waitresult
               S02:000013AA:  F0 F9
F05:0182         rts
               S02:000013AC:  60
F05:0183       
F05:0184       
F05:0185       sd_sendcommand:
F05:0186         ; Debug print which command is being executed
F05:0187         ;jsr cleardisplay
F05:0188       
F05:0189         lda #'c'
               S02:000013AD:  A9 63
F05:0190         jsr print_chara
               S02:000013AF:  20 B1 12
F05:0191         ldx #0
               S02:000013B2:  A2 00
F05:0192         lda (zp_sd_address,x)
               S02:000013B4:  A1 48
F05:0193         jsr print_hex_acia
               S02:000013B6:  20 6A 12
F05:0194       
F05:0195         lda #SD_MOSI           ; pull CS low to begin command
               S02:000013B9:  A9 04
F05:0196         sta PORTA
               S02:000013BB:  8D 01 B0
F05:0197       
F05:0198         ldy #0
               S02:000013BE:  A0 00
F05:0199         lda (zp_sd_address),y    ; command byte
               S02:000013C0:  B1 48
F05:0200         jsr sd_writebyte
               S02:000013C2:  20 8E 13
F05:0201         ldy #1
               S02:000013C5:  A0 01
F05:0202         lda (zp_sd_address),y    ; data 1
               S02:000013C7:  B1 48
F05:0203         jsr sd_writebyte
               S02:000013C9:  20 8E 13
F05:0204         ldy #2
               S02:000013CC:  A0 02
F05:0205         lda (zp_sd_address),y    ; data 2
               S02:000013CE:  B1 48
F05:0206         jsr sd_writebyte
               S02:000013D0:  20 8E 13
F05:0207         ldy #3
               S02:000013D3:  A0 03
F05:0208         lda (zp_sd_address),y    ; data 3
               S02:000013D5:  B1 48
F05:0209         jsr sd_writebyte
               S02:000013D7:  20 8E 13
F05:0210         ldy #4
               S02:000013DA:  A0 04
F05:0211         lda (zp_sd_address),y    ; data 4
               S02:000013DC:  B1 48
F05:0212         jsr sd_writebyte
               S02:000013DE:  20 8E 13
F05:0213         ldy #5
               S02:000013E1:  A0 05
F05:0214         lda (zp_sd_address),y    ; crc
               S02:000013E3:  B1 48
F05:0215         jsr sd_writebyte
               S02:000013E5:  20 8E 13
F05:0216       
F05:0217         jsr sd_waitresult
               S02:000013E8:  20 A5 13
F05:0218         pha
               S02:000013EB:  48
F05:0219       
F05:0220         ; Debug print the result code
F05:0221         jsr print_hex_acia
               S02:000013EC:  20 6A 12
F05:0222       
F05:0223         ; End command
F05:0224         lda #SD_CS | SD_MOSI   ; set CS high again
               S02:000013EF:  A9 14
F05:0225         sta PORTA
               S02:000013F1:  8D 01 B0
F05:0226       
F05:0227         pla   ; restore result code
               S02:000013F4:  68
F05:0228         rts
               S02:000013F5:  60
F05:0229       
F05:0230       
F05:0231       sd_readsector:
F05:0232         ; Read a sector from the SD card.  A sector is 512 bytes.
F05:0233         ;
F05:0234         ; Parameters:
F05:0235         ;    zp_sd_currentsector   32-bit sector number
F05:0236         ;    zp_sd_address     address of buffer to receive data
F05:0237         
F05:0238         lda #SD_MOSI
               S02:000013F6:  A9 04
F05:0239         sta PORTA
               S02:000013F8:  8D 01 B0
F05:0240       
F05:0241         ; Command 17, arg is sector number, crc not checked
F05:0242         lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S02:000013FB:  A9 51
F05:0243         jsr sd_writebyte
               S02:000013FD:  20 8E 13
F05:0244         lda zp_sd_currentsector+3   ; sector 24:31
               S02:00001400:  A5 4D
F05:0245         jsr sd_writebyte
               S02:00001402:  20 8E 13
F05:0246         lda zp_sd_currentsector+2   ; sector 16:23
               S02:00001405:  A5 4C
F05:0247         jsr sd_writebyte
               S02:00001407:  20 8E 13
F05:0248         lda zp_sd_currentsector+1   ; sector 8:15
               S02:0000140A:  A5 4B
F05:0249         jsr sd_writebyte
               S02:0000140C:  20 8E 13
F05:0250         lda zp_sd_currentsector     ; sector 0:7
               S02:0000140F:  A5 4A
F05:0251         jsr sd_writebyte
               S02:00001411:  20 8E 13
F05:0252         lda #$01                    ; crc (not checked)
               S02:00001414:  A9 01
F05:0253         jsr sd_writebyte
               S02:00001416:  20 8E 13
F05:0254       
F05:0255         jsr sd_waitresult
               S02:00001419:  20 A5 13
F05:0256         cmp #$00
               S02:0000141C:  C9 00
F05:0257         bne sd_fail
               S02:0000141E:  D0 22
F05:0258       
F05:0259         ; wait for data
F05:0260         jsr sd_waitresult
               S02:00001420:  20 A5 13
F05:0261         cmp #$fe
               S02:00001423:  C9 FE
F05:0262         bne sd_fail
               S02:00001425:  D0 1B
F05:0263       
F05:0264         ; Need to read 512 bytes - two pages of 256 bytes each
F05:0265         jsr .readpage
               S02:00001427:  20 37 14
F05:0266         inc zp_sd_address+1
               S02:0000142A:  E6 49
F05:0267         jsr .readpage
               S02:0000142C:  20 37 14
F05:0268         dec zp_sd_address+1
               S02:0000142F:  C6 49
F05:0269       
F05:0270         ; End command
F05:0271         lda #SD_CS | SD_MOSI
               S02:00001431:  A9 14
F05:0272         sta PORTA
               S02:00001433:  8D 01 B0
F05:0273       
F05:0274         rts
               S02:00001436:  60
F05:0275       
F05:0276       .readpage
F05:0277         ; Read 256 bytes to the address at zp_sd_address
F05:0278         ldy #0
               S02:00001437:  A0 00
F05:0279       .readloop
F05:0280         jsr sd_readbyte
               S02:00001439:  20 73 13
F05:0281         sta (zp_sd_address),y
               S02:0000143C:  91 48
F05:0282         iny
               S02:0000143E:  C8
F05:0283         bne .readloop
               S02:0000143F:  D0 F8
F05:0284         rts
               S02:00001441:  60
F05:0285       
F05:0286       sd_fail:
F05:0287         lda #'s'
               S02:00001442:  A9 73
F05:0288         jsr print_chara
               S02:00001444:  20 B1 12
F05:0289         lda #':'
               S02:00001447:  A9 3A
F05:0290         jsr print_chara
               S02:00001449:  20 B1 12
F05:0291         lda #'f'
               S02:0000144C:  A9 66
F05:0292         jsr print_chara
               S02:0000144E:  20 B1 12
F05:0293       .failloop
F05:0294         jmp .failloop
               S02:00001451:  4C 51 14
F05:0295       
F05:0296       
F05:0297       sd_writesector:
F05:0298         ; Write a sector to the SD card.  A sector is 512 bytes.
F05:0299         ;
F05:0300         ; Parameters:
F05:0301         ;    zp_sd_currentsector   32-bit sector number
F05:0302         ;    zp_sd_address     address of buffer to take data from
F05:0303         
F05:0304         lda #SD_MOSI
               S02:00001454:  A9 04
F05:0305         sta PORTA
               S02:00001456:  8D 01 B0
F05:0306       
F05:0307         ; Command 24, arg is sector number, crc not checked
F05:0308         lda #$58                    ; CMD24 - WRITE_BLOCK
               S02:00001459:  A9 58
F05:0309         jsr sd_writebyte
               S02:0000145B:  20 8E 13
F05:0310         lda zp_sd_currentsector+3   ; sector 24:31
               S02:0000145E:  A5 4D
F05:0311         jsr sd_writebyte
               S02:00001460:  20 8E 13
F05:0312         lda zp_sd_currentsector+2   ; sector 16:23
               S02:00001463:  A5 4C
F05:0313         jsr sd_writebyte
               S02:00001465:  20 8E 13
F05:0314         lda zp_sd_currentsector+1   ; sector 8:15
               S02:00001468:  A5 4B
F05:0315         jsr sd_writebyte
               S02:0000146A:  20 8E 13
F05:0316         lda zp_sd_currentsector     ; sector 0:7
               S02:0000146D:  A5 4A
F05:0317         jsr sd_writebyte
               S02:0000146F:  20 8E 13
F05:0318         lda #$01                    ; crc (not checked)
               S02:00001472:  A9 01
F05:0319         jsr sd_writebyte
               S02:00001474:  20 8E 13
F05:0320       
F05:0321         jsr sd_waitresult
               S02:00001477:  20 A5 13
F05:0322         cmp #$00
               S02:0000147A:  C9 00
F05:0323         bne sd_fail
               S02:0000147C:  D0 C4
F05:0324       
F05:0325         ; Send start token
F05:0326         lda #$fe
               S02:0000147E:  A9 FE
F05:0327         jsr sd_writebyte
               S02:00001480:  20 8E 13
F05:0328       
F05:0329         ; Need to write 512 bytes - two pages of 256 bytes each
F05:0330         jsr .writepage
               S02:00001483:  20 A3 14
F05:0331         inc zp_sd_address+1
               S02:00001486:  E6 49
F05:0332         jsr .writepage
               S02:00001488:  20 A3 14
F05:0333         dec zp_sd_address+1
               S02:0000148B:  C6 49
F05:0334       
F05:0335         ; wait for data response
F05:0336         jsr sd_waitresult
               S02:0000148D:  20 A5 13
F05:0337         and #$1f
               S02:00001490:  29 1F
F05:0338         cmp #$05
               S02:00001492:  C9 05
F05:0339         bne sd_fail
               S02:00001494:  D0 AC
F05:0340       
F05:0341       .waitidle
F05:0342         jsr sd_readbyte
               S02:00001496:  20 73 13
F05:0343         cmp #$ff
               S02:00001499:  C9 FF
F05:0344         bne .waitidle
               S02:0000149B:  D0 F9
F05:0345       
F05:0346         ; End command
F05:0347         lda #SD_CS | SD_MOSI ; set cs and mosi high (disconnected)
               S02:0000149D:  A9 14
F05:0348         sta PORTA
               S02:0000149F:  8D 01 B0
F05:0349       
F05:0350         rts
               S02:000014A2:  60
F05:0351       
F05:0352       .writepage:
F05:0353         ; Write 256 bytes fom zp_sd_address
F05:0354         ldy #0
               S02:000014A3:  A0 00
F05:0355       .writeloop:
F05:0356         lda (zp_sd_address),y
               S02:000014A5:  B1 48
F05:0357         phy
               S02:000014A7:  5A
F05:0358         jsr sd_writebyte
               S02:000014A8:  20 8E 13
F05:0359         ply
               S02:000014AB:  7A
F05:0360         iny
               S02:000014AC:  C8
F05:0361         bne .writeloop
               S02:000014AD:  D0 F6
F05:0362         rts
               S02:000014AF:  60
F05:0363       
F05:0364       
F05:0365       
F05:0366       
F00:0105         .include "libfat32.s"
F06:0001       ; FAT32/SD interface library
F06:0002       ;
F06:0003       ; This module requires some RAM workspace to be defined elsewhere:
F06:0004       ; 
F06:0005       ; fat32_workspace    - a large page-aligned 512-byte workspace
F06:0006       ; zp_fat32_variables - 24 bytes of zero-page storage for variables etc
F06:0007       
F06:0008       ; FIXME once we have more flags, please incorporate all of them into one byte! (flags have two states)
F06:0009       
F06:0010       fat32_readbuffer = fat32_workspace
F06:0011       
F06:0012       fat32_fatstart          	= zp_fat32_variables + $00  ; 4 bytes
F06:0013       fat32_datastart         	= zp_fat32_variables + $04  ; 4 bytes
F06:0014       fat32_rootcluster       	= zp_fat32_variables + $08  ; 4 bytes
F06:0015       fat32_sectorspercluster 	= zp_fat32_variables + $0c  ; 1 byte
F06:0016       fat32_pendingsectors    	= zp_fat32_variables + $0d  ; 1 byte
F06:0017       fat32_address           	= zp_fat32_variables + $0e  ; 2 bytes
F06:0018       fat32_nextcluster       	= zp_fat32_variables + $10  ; 4 bytes
F06:0019       fat32_bytesremaining    	= zp_fat32_variables + $14  ; 4 bytes   	
F06:0020       fat32_lastfoundfreecluster	= zp_fat32_variables + $18  ; 4 bytes
F06:0021       fat32_sectorsperfat		= zp_fat32_variables + $1c  ; 2 bytes
F06:0022       ;fat32_fsinfosector		= zp_fat32_variables + $1e  ; 2 bytes
F06:0023       fat32_lastcluster		= zp_fat32_variables + $1e  ; 4 bytes
F06:0024       fat32_lastsector		= zp_fat32_variables + $23  ; 4 bytes
F06:0025       fat32_newfatsector		= zp_fat32_variables + $28  ; 1 byte FLAG
F06:0026       
F06:0027       fat32_errorstage            = fat32_bytesremaining  ; only used during initialization
F06:0028       fat32_filenamepointer       = fat32_bytesremaining  ; only used when searching for a file
F06:0029       
F06:0030       ; TODO add cluster chain creation (saving the next cluster at the previous cluster, and adding a end-of-chain marker.)
F06:0031       
F06:0032       fat32_init:
F06:0033         ; Initialize the module - read the MBR etc, find the partition,
F06:0034         ; and set up the variables ready for navigating the filesystem
F06:0035       
F06:0036         ; Read the MBR and extract pertinent information
F06:0037       
F06:0038         lda #0
               S02:000014B0:  A9 00
F06:0039         sta fat32_errorstage
               S02:000014B2:  85 63
F06:0040       
F06:0041         ; Sector 0
F06:0042         lda #0
               S02:000014B4:  A9 00
F06:0043         sta zp_sd_currentsector
               S02:000014B6:  85 4A
F06:0044         sta zp_sd_currentsector+1
               S02:000014B8:  85 4B
F06:0045         sta zp_sd_currentsector+2
               S02:000014BA:  85 4C
F06:0046         sta zp_sd_currentsector+3
               S02:000014BC:  85 4D
F06:0047       
F06:0048         ; Target buffer
F06:0049         lda #<fat32_readbuffer
               S02:000014BE:  A9 00
F06:0050         sta zp_sd_address
               S02:000014C0:  85 48
F06:0051         lda #>fat32_readbuffer
               S02:000014C2:  A9 05
F06:0052         sta zp_sd_address+1
               S02:000014C4:  85 49
F06:0053       
F06:0054         ; Do the read
F06:0055         jsr sd_readsector
               S02:000014C6:  20 F6 13
F06:0056       
F06:0057       
F06:0058         inc fat32_errorstage ; stage 1 = boot sector signature check
               S02:000014C9:  E6 63
F06:0059       
F06:0060         ; Check some things
F06:0061         lda fat32_readbuffer+510 ; Boot sector signature 55
               S02:000014CB:  AD FE 06
F06:0062         cmp #$55
               S02:000014CE:  C9 55
F06:0063         bne .fail
               S02:000014D0:  D0 2D
F06:0064         lda fat32_readbuffer+511 ; Boot sector signature aa
               S02:000014D2:  AD FF 06
F06:0065         cmp #$aa
               S02:000014D5:  C9 AA
F06:0066         bne .fail
               S02:000014D7:  D0 26
F06:0067       
F06:0068       
F06:0069         inc fat32_errorstage ; stage 2 = finding partition
               S02:000014D9:  E6 63
F06:0070       
F06:0071         ; Find a FAT32 partition
F06:0072       .FSTYPE_FAT32 = 12
F06:0073         ldx #0
               S02:000014DB:  A2 00
F06:0074         lda fat32_readbuffer+$1c2,x
               S02:000014DD:  BD C2 06
F06:0075         cmp #.FSTYPE_FAT32
               S02:000014E0:  C9 0C
F06:0076         beq .foundpart
               S02:000014E2:  F0 1E
F06:0077         ldx #16
               S02:000014E4:  A2 10
F06:0078         lda fat32_readbuffer+$1c2,x
               S02:000014E6:  BD C2 06
F06:0079         cmp #.FSTYPE_FAT32
               S02:000014E9:  C9 0C
F06:0080         beq .foundpart
               S02:000014EB:  F0 15
F06:0081         ldx #32
               S02:000014ED:  A2 20
F06:0082         lda fat32_readbuffer+$1c2,x
               S02:000014EF:  BD C2 06
F06:0083         cmp #.FSTYPE_FAT32
               S02:000014F2:  C9 0C
F06:0084         beq .foundpart
               S02:000014F4:  F0 0C
F06:0085         ldx #48
               S02:000014F6:  A2 30
F06:0086         lda fat32_readbuffer+$1c2,x
               S02:000014F8:  BD C2 06
F06:0087         cmp #.FSTYPE_FAT32
               S02:000014FB:  C9 0C
F06:0088         beq .foundpart
               S02:000014FD:  F0 03
F06:0089       
F06:0090       .fail:
F06:0091         jmp .error
               S02:000014FF:  4C C0 15
F06:0092       
F06:0093       .foundpart:
F06:0094       
F06:0095         ; Read the FAT32 BPB
F06:0096         lda fat32_readbuffer+$1c6,x
               S02:00001502:  BD C6 06
F06:0097         sta zp_sd_currentsector
               S02:00001505:  85 4A
F06:0098         lda fat32_readbuffer+$1c7,x
               S02:00001507:  BD C7 06
F06:0099         sta zp_sd_currentsector+1
               S02:0000150A:  85 4B
F06:0100         lda fat32_readbuffer+$1c8,x
               S02:0000150C:  BD C8 06
F06:0101         sta zp_sd_currentsector+2
               S02:0000150F:  85 4C
F06:0102         lda fat32_readbuffer+$1c9,x
               S02:00001511:  BD C9 06
F06:0103         sta zp_sd_currentsector+3
               S02:00001514:  85 4D
F06:0104       
F06:0105         jsr sd_readsector
               S02:00001516:  20 F6 13
F06:0106       
F06:0107       
F06:0108         inc fat32_errorstage ; stage 3 = BPB signature check
               S02:00001519:  E6 63
F06:0109       
F06:0110         ; Check some things
F06:0111         lda fat32_readbuffer+510 ; BPB sector signature 55
               S02:0000151B:  AD FE 06
F06:0112         cmp #$55
               S02:0000151E:  C9 55
F06:0113         bne .fail
               S02:00001520:  D0 DD
F06:0114         lda fat32_readbuffer+511 ; BPB sector signature aa
               S02:00001522:  AD FF 06
F06:0115         cmp #$aa
               S02:00001525:  C9 AA
F06:0116         bne .fail
               S02:00001527:  D0 D6
F06:0117       
F06:0118         inc fat32_errorstage ; stage 4 = RootEntCnt check
               S02:00001529:  E6 63
F06:0119       
F06:0120         lda fat32_readbuffer+17 ; RootEntCnt should be 0 for FAT32
               S02:0000152B:  AD 11 05
F06:0121         ora fat32_readbuffer+18
               S02:0000152E:  0D 12 05
F06:0122         bne .fail
               S02:00001531:  D0 CC
F06:0123       
F06:0124         inc fat32_errorstage ; stage 5 = TotSec16 check
               S02:00001533:  E6 63
F06:0125       
F06:0126         lda fat32_readbuffer+19 ; TotSec16 should be 0 for FAT32
               S02:00001535:  AD 13 05
F06:0127         ora fat32_readbuffer+20
               S02:00001538:  0D 14 05
F06:0128         bne .fail
               S02:0000153B:  D0 C2
F06:0129       
F06:0130         inc fat32_errorstage ; stage 6 = SectorsPerCluster check
               S02:0000153D:  E6 63
F06:0131       
F06:0132         ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
F06:0133         lda fat32_readbuffer+11 ; low byte should be zero
               S02:0000153F:  AD 0B 05
F06:0134         bne .fail
               S02:00001542:  D0 BB
F06:0135         lda fat32_readbuffer+12 ; high byte is 2 (512), 4, 8, or 16
               S02:00001544:  AD 0C 05
F06:0136         cmp #2
               S02:00001547:  C9 02
F06:0137         bne .fail
               S02:00001549:  D0 B4
F06:0138       
F06:0139         ; Save sectors per FAT
F06:0140       
F06:0141         lda fat32_readbuffer+22
               S02:0000154B:  AD 16 05
F06:0142         sta fat32_sectorsperfat
               S02:0000154E:  85 6B
F06:0143         lda fat32_readbuffer+23
               S02:00001550:  AD 17 05
F06:0144         sta fat32_sectorsperfat+1
               S02:00001553:  85 6C
F06:0145       
F06:0146         ; Calculate the starting sector of the FAT
F06:0147         clc
               S02:00001555:  18
F06:0148         lda zp_sd_currentsector
               S02:00001556:  A5 4A
F06:0149         adc fat32_readbuffer+14    ; reserved sectors lo
               S02:00001558:  6D 0E 05
F06:0150         sta fat32_fatstart
               S02:0000155B:  85 4F
F06:0151         sta fat32_datastart
               S02:0000155D:  85 53
F06:0152         lda zp_sd_currentsector+1
               S02:0000155F:  A5 4B
F06:0153         adc fat32_readbuffer+15    ; reserved sectors hi
               S02:00001561:  6D 0F 05
F06:0154         sta fat32_fatstart+1
               S02:00001564:  85 50
F06:0155         sta fat32_datastart+1
               S02:00001566:  85 54
F06:0156         lda zp_sd_currentsector+2
               S02:00001568:  A5 4C
F06:0157         adc #0
               S02:0000156A:  69 00
F06:0158         sta fat32_fatstart+2
               S02:0000156C:  85 51
F06:0159         sta fat32_datastart+2
               S02:0000156E:  85 55
F06:0160         lda zp_sd_currentsector+3
               S02:00001570:  A5 4D
F06:0161         adc #0
               S02:00001572:  69 00
F06:0162         sta fat32_fatstart+3
               S02:00001574:  85 52
F06:0163         sta fat32_datastart+3
               S02:00001576:  85 56
F06:0164       
F06:0165         ; Calculate the starting sector of the data area
F06:0166         ldx fat32_readbuffer+16   ; number of FATs
               S02:00001578:  AE 10 05
F06:0167       .skipfatsloop:
F06:0168         clc
               S02:0000157B:  18
F06:0169         lda fat32_datastart
               S02:0000157C:  A5 53
F06:0170         adc fat32_readbuffer+36 ; fatsize 0
               S02:0000157E:  6D 24 05
F06:0171         sta fat32_datastart
               S02:00001581:  85 53
F06:0172         lda fat32_datastart+1
               S02:00001583:  A5 54
F06:0173         adc fat32_readbuffer+37 ; fatsize 1
               S02:00001585:  6D 25 05
F06:0174         sta fat32_datastart+1
               S02:00001588:  85 54
F06:0175         lda fat32_datastart+2
               S02:0000158A:  A5 55
F06:0176         adc fat32_readbuffer+38 ; fatsize 2
               S02:0000158C:  6D 26 05
F06:0177         sta fat32_datastart+2
               S02:0000158F:  85 55
F06:0178         lda fat32_datastart+3
               S02:00001591:  A5 56
F06:0179         adc fat32_readbuffer+39 ; fatsize 3
               S02:00001593:  6D 27 05
F06:0180         sta fat32_datastart+3
               S02:00001596:  85 56
F06:0181         dex
               S02:00001598:  CA
F06:0182         bne .skipfatsloop
               S02:00001599:  D0 E0
F06:0183       
F06:0184         ; Sectors-per-cluster is a power of two from 1 to 128
F06:0185         lda fat32_readbuffer+13
               S02:0000159B:  AD 0D 05
F06:0186         sta fat32_sectorspercluster
               S02:0000159E:  85 5B
F06:0187       
F06:0188         ; Remember FSInfo sector
F06:0189         ;lda fat32_readbuffer+38
F06:0190         ;sta fat32_fsinfosector
F06:0191         ;lda fat32_readbuffer+39
F06:0192         ;sta fat32_fsinfosector+1
F06:0193       
F06:0194         ; Remember the root cluster
F06:0195         lda fat32_readbuffer+44
               S02:000015A0:  AD 2C 05
F06:0196         sta fat32_rootcluster
               S02:000015A3:  85 57
F06:0197         lda fat32_readbuffer+45
               S02:000015A5:  AD 2D 05
F06:0198         sta fat32_rootcluster+1
               S02:000015A8:  85 58
F06:0199         lda fat32_readbuffer+46
               S02:000015AA:  AD 2E 05
F06:0200         sta fat32_rootcluster+2
               S02:000015AD:  85 59
F06:0201         lda fat32_readbuffer+47
               S02:000015AF:  AD 2F 05
F06:0202         sta fat32_rootcluster+3
               S02:000015B2:  85 5A
F06:0203       
F06:0204         ; Set the last found free cluster to 0.
F06:0205         lda #0
               S02:000015B4:  A9 00
F06:0206         sta fat32_lastfoundfreecluster
               S02:000015B6:  85 67
F06:0207         sta fat32_lastfoundfreecluster+1
               S02:000015B8:  85 68
F06:0208         sta fat32_lastfoundfreecluster+2
               S02:000015BA:  85 69
F06:0209         sta fat32_lastfoundfreecluster+3
               S02:000015BC:  85 6A
F06:0210       
F06:0211         clc
               S02:000015BE:  18
F06:0212         rts
               S02:000015BF:  60
F06:0213       
F06:0214       .error:
F06:0215         sec
               S02:000015C0:  38
F06:0216         rts
               S02:000015C1:  60
F06:0217       
F06:0218       
F06:0219       fat32_seekcluster:
F06:0220         ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
F06:0221         
F06:0222         ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
F06:0223         lda fat32_nextcluster
               S02:000015C2:  A5 5F
F06:0224         asl
               S02:000015C4:  0A
F06:0225         lda fat32_nextcluster+1
               S02:000015C5:  A5 60
F06:0226         rol
               S02:000015C7:  2A
F06:0227         sta zp_sd_currentsector
               S02:000015C8:  85 4A
F06:0228         lda fat32_nextcluster+2
               S02:000015CA:  A5 61
F06:0229         rol
               S02:000015CC:  2A
F06:0230         sta zp_sd_currentsector+1
               S02:000015CD:  85 4B
F06:0231         lda fat32_nextcluster+3
               S02:000015CF:  A5 62
F06:0232         rol
               S02:000015D1:  2A
F06:0233         sta zp_sd_currentsector+2
               S02:000015D2:  85 4C
F06:0234         ; note: cluster numbers never have the top bit set, so no carry can occur
F06:0235       
F06:0236         ; Add FAT starting sector
F06:0237         lda zp_sd_currentsector
               S02:000015D4:  A5 4A
F06:0238         adc fat32_fatstart
               S02:000015D6:  65 4F
F06:0239         sta zp_sd_currentsector
               S02:000015D8:  85 4A
F06:0240         lda zp_sd_currentsector+1
               S02:000015DA:  A5 4B
F06:0241         adc fat32_fatstart+1
               S02:000015DC:  65 50
F06:0242         sta zp_sd_currentsector+1
               S02:000015DE:  85 4B
F06:0243         lda zp_sd_currentsector+2
               S02:000015E0:  A5 4C
F06:0244         adc fat32_fatstart+2
               S02:000015E2:  65 51
F06:0245         sta zp_sd_currentsector+2
               S02:000015E4:  85 4C
F06:0246         lda #0
               S02:000015E6:  A9 00
F06:0247         adc fat32_fatstart+3
               S02:000015E8:  65 52
F06:0248         sta zp_sd_currentsector+3
               S02:000015EA:  85 4D
F06:0249       
F06:0250         ; Check if this sector is the same as the last one
F06:0251         lda fat32_lastsector
               S02:000015EC:  A5 72
F06:0252         cmp zp_sd_currentsector
               S02:000015EE:  C5 4A
F06:0253         bne .newsector
               S02:000015F0:  D0 12
F06:0254         lda fat32_lastsector+1
               S02:000015F2:  A5 73
F06:0255         cmp zp_sd_currentsector+1
               S02:000015F4:  C5 4B
F06:0256         bne .newsector
               S02:000015F6:  D0 0C
F06:0257         lda fat32_lastsector+2
               S02:000015F8:  A5 74
F06:0258         cmp zp_sd_currentsector+2
               S02:000015FA:  C5 4C
F06:0259         bne .newsector
               S02:000015FC:  D0 06
F06:0260         lda fat32_lastsector+3
               S02:000015FE:  A5 75
F06:0261         cmp zp_sd_currentsector+3
               S02:00001600:  C5 4D
F06:0262         beq .notnew
               S02:00001602:  F0 1F
F06:0263       
F06:0264       .newsector
F06:0265       
F06:0266         lda #$ff
               S02:00001604:  A9 FF
F06:0267         sta fat32_newfatsector
               S02:00001606:  85 77
F06:0268       
F06:0269         ; Target buffer
F06:0270         lda #<fat32_readbuffer
               S02:00001608:  A9 00
F06:0271         sta zp_sd_address
               S02:0000160A:  85 48
F06:0272         lda #>fat32_readbuffer
               S02:0000160C:  A9 05
F06:0273         sta zp_sd_address+1
               S02:0000160E:  85 49
F06:0274       
F06:0275         ; Read the sector from the FAT
F06:0276         jsr sd_readsector
               S02:00001610:  20 F6 13
F06:0277       
F06:0278         ; Update fat32_lastsector
F06:0279       
F06:0280         lda zp_sd_currentsector
               S02:00001613:  A5 4A
F06:0281         sta fat32_lastsector
               S02:00001615:  85 72
F06:0282         lda zp_sd_currentsector+1
               S02:00001617:  A5 4B
F06:0283         sta fat32_lastsector+1
               S02:00001619:  85 73
F06:0284         lda zp_sd_currentsector+2
               S02:0000161B:  A5 4C
F06:0285         sta fat32_lastsector+2
               S02:0000161D:  85 74
F06:0286         lda zp_sd_currentsector+3
               S02:0000161F:  A5 4D
F06:0287         sta fat32_lastsector+3
               S02:00001621:  85 75
F06:0288       
F06:0289       .notnew
F06:0290       
F06:0291         stz fat32_newfatsector
               S02:00001623:  64 77
F06:0292       
F06:0293         ; Before using this FAT data, set currentsector ready to read the cluster itself
F06:0294         ; We need to multiply the cluster number minus two by the number of sectors per 
F06:0295         ; cluster, then add the data region start sector
F06:0296       
F06:0297         ; Subtract two from cluster number
F06:0298         sec
               S02:00001625:  38
F06:0299         lda fat32_nextcluster
               S02:00001626:  A5 5F
F06:0300         sbc #2
               S02:00001628:  E9 02
F06:0301         sta zp_sd_currentsector
               S02:0000162A:  85 4A
F06:0302         lda fat32_nextcluster+1
               S02:0000162C:  A5 60
F06:0303         sbc #0
               S02:0000162E:  E9 00
F06:0304         sta zp_sd_currentsector+1
               S02:00001630:  85 4B
F06:0305         lda fat32_nextcluster+2
               S02:00001632:  A5 61
F06:0306         sbc #0
               S02:00001634:  E9 00
F06:0307         sta zp_sd_currentsector+2
               S02:00001636:  85 4C
F06:0308         lda fat32_nextcluster+3
               S02:00001638:  A5 62
F06:0309         sbc #0
               S02:0000163A:  E9 00
F06:0310         sta zp_sd_currentsector+3
               S02:0000163C:  85 4D
F06:0311         
F06:0312         ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
F06:0313         lda fat32_sectorspercluster
               S02:0000163E:  A5 5B
F06:0314       .spcshiftloop:
F06:0315         lsr
               S02:00001640:  4A
F06:0316         bcs .spcshiftloopdone
               S02:00001641:  B0 0B
F06:0317         asl zp_sd_currentsector
               S02:00001643:  06 4A
F06:0318         rol zp_sd_currentsector+1
               S02:00001645:  26 4B
F06:0319         rol zp_sd_currentsector+2
               S02:00001647:  26 4C
F06:0320         rol zp_sd_currentsector+3
               S02:00001649:  26 4D
F06:0321         jmp .spcshiftloop
               S02:0000164B:  4C 40 16
F06:0322       .spcshiftloopdone:
F06:0323       
F06:0324         ; Add the data region start sector
F06:0325         clc
               S02:0000164E:  18
F06:0326         lda zp_sd_currentsector
               S02:0000164F:  A5 4A
F06:0327         adc fat32_datastart
               S02:00001651:  65 53
F06:0328         sta zp_sd_currentsector
               S02:00001653:  85 4A
F06:0329         lda zp_sd_currentsector+1
               S02:00001655:  A5 4B
F06:0330         adc fat32_datastart+1
               S02:00001657:  65 54
F06:0331         sta zp_sd_currentsector+1
               S02:00001659:  85 4B
F06:0332         lda zp_sd_currentsector+2
               S02:0000165B:  A5 4C
F06:0333         adc fat32_datastart+2
               S02:0000165D:  65 55
F06:0334         sta zp_sd_currentsector+2
               S02:0000165F:  85 4C
F06:0335         lda zp_sd_currentsector+3
               S02:00001661:  A5 4D
F06:0336         adc fat32_datastart+3
               S02:00001663:  65 56
F06:0337         sta zp_sd_currentsector+3
               S02:00001665:  85 4D
F06:0338       
F06:0339         ; That's now ready for later code to read this sector in - tell it how many consecutive
F06:0340         ; sectors it can now read
F06:0341         lda fat32_sectorspercluster
               S02:00001667:  A5 5B
F06:0342         sta fat32_pendingsectors
               S02:00001669:  85 5C
F06:0343       
F06:0344         ; Now go back to looking up the next cluster in the chain
F06:0345         ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
F06:0346       
F06:0347         ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
F06:0348         lda fat32_nextcluster
               S02:0000166B:  A5 5F
F06:0349         and #$7f
               S02:0000166D:  29 7F
F06:0350         asl
               S02:0000166F:  0A
F06:0351         asl
               S02:00001670:  0A
F06:0352         tay ; Y = low byte of offset
               S02:00001671:  A8
F06:0353       
F06:0354         ; Add the potentially carried bit to the high byte of the address
F06:0355         lda zp_sd_address+1
               S02:00001672:  A5 49
F06:0356         adc #0
               S02:00001674:  69 00
F06:0357         sta zp_sd_address+1
               S02:00001676:  85 49
F06:0358       
F06:0359         ; Copy out the next cluster in the chain for later use
F06:0360         lda (zp_sd_address),y
               S02:00001678:  B1 48
F06:0361         sta fat32_nextcluster
               S02:0000167A:  85 5F
F06:0362         iny
               S02:0000167C:  C8
F06:0363         lda (zp_sd_address),y
               S02:0000167D:  B1 48
F06:0364         sta fat32_nextcluster+1
               S02:0000167F:  85 60
F06:0365         iny
               S02:00001681:  C8
F06:0366         lda (zp_sd_address),y
               S02:00001682:  B1 48
F06:0367         sta fat32_nextcluster+2
               S02:00001684:  85 61
F06:0368         iny
               S02:00001686:  C8
F06:0369         lda (zp_sd_address),y
               S02:00001687:  B1 48
F06:0370         and #$0f
               S02:00001689:  29 0F
F06:0371         sta fat32_nextcluster+3
               S02:0000168B:  85 62
F06:0372       
F06:0373         ; See if it's the end of the chain
F06:0374         ora #$f0
               S02:0000168D:  09 F0
F06:0375         and fat32_nextcluster+2
               S02:0000168F:  25 61
F06:0376         and fat32_nextcluster+1
               S02:00001691:  25 60
F06:0377         cmp #$ff
               S02:00001693:  C9 FF
F06:0378         bne .notendofchain
               S02:00001695:  D0 08
F06:0379         lda fat32_nextcluster
               S02:00001697:  A5 5F
F06:0380         cmp #$f8
               S02:00001699:  C9 F8
F06:0381         bcc .notendofchain
               S02:0000169B:  90 02
F06:0382       
F06:0383         ; It's the end of the chain, set the top bits so that we can tell this later on
F06:0384         sta fat32_nextcluster+3
               S02:0000169D:  85 62
F06:0385       .notendofchain:
F06:0386         rts
               S02:0000169F:  60
F06:0387       
F06:0388       
F06:0389       fat32_readnextsector:
F06:0390         ; Reads the next sector from a cluster chain into the buffer at fat32_address.
F06:0391         ;
F06:0392         ; Advances the current sector ready for the next read and looks up the next cluster
F06:0393         ; in the chain when necessary.
F06:0394         ;
F06:0395         ; On return, carry is clear if data was read, or set if the cluster chain has ended.
F06:0396       
F06:0397         ; Maybe there are pending sectors in the current cluster
F06:0398         lda fat32_pendingsectors
               S02:000016A0:  A5 5C
F06:0399         bne .readsector
               S02:000016A2:  D0 07
F06:0400       
F06:0401         ; No pending sectors, check for end of cluster chain
F06:0402         lda fat32_nextcluster+3
               S02:000016A4:  A5 62
F06:0403         bmi .endofchain
               S02:000016A6:  30 20
F06:0404       
F06:0405         ; Prepare to read the next cluster
F06:0406         jsr fat32_seekcluster
               S02:000016A8:  20 C2 15
F06:0407       
F06:0408       .readsector:
F06:0409         dec fat32_pendingsectors
               S02:000016AB:  C6 5C
F06:0410       
F06:0411         ; Set up target address  
F06:0412         lda fat32_address
               S02:000016AD:  A5 5D
F06:0413         sta zp_sd_address
               S02:000016AF:  85 48
F06:0414         lda fat32_address+1
               S02:000016B1:  A5 5E
F06:0415         sta zp_sd_address+1
               S02:000016B3:  85 49
F06:0416       
F06:0417         ; Read the sector
F06:0418         jsr sd_readsector
               S02:000016B5:  20 F6 13
F06:0419       
F06:0420         ; Advance to next sector
F06:0421         inc zp_sd_currentsector
               S02:000016B8:  E6 4A
F06:0422         bne .sectorincrementdone
               S02:000016BA:  D0 0A
F06:0423         inc zp_sd_currentsector+1
               S02:000016BC:  E6 4B
F06:0424         bne .sectorincrementdone
               S02:000016BE:  D0 06
F06:0425         inc zp_sd_currentsector+2
               S02:000016C0:  E6 4C
F06:0426         bne .sectorincrementdone
               S02:000016C2:  D0 02
F06:0427         inc zp_sd_currentsector+3
               S02:000016C4:  E6 4D
F06:0428       .sectorincrementdone:
F06:0429       
F06:0430         ; Success - clear carry and return
F06:0431         clc
               S02:000016C6:  18
F06:0432         rts
               S02:000016C7:  60
F06:0433       
F06:0434       .endofchain:
F06:0435         ; End of chain - set carry and return
F06:0436         sec
               S02:000016C8:  38
F06:0437         rts
               S02:000016C9:  60
F06:0438       
F06:0439       fat32_writenextsector:
F06:0440         ; TODO Writes the next sector into the buffer at fat32_address.
F06:0441         ; 
F06:0442         ; Also looks for new clusters and stores them in the FAT.
F06:0443         ;
F06:0444         ; On return, carry is set if its the end of the chain.
F06:0445       
F06:0446         ; Maybe there are pending sectors in the current cluster
F06:0447         lda fat32_pendingsectors
               S02:000016CA:  A5 5C
F06:0448         bne .writesector
               S02:000016CC:  D0 61
F06:0449       
F06:0450         ; No pending sectors, check if this is the last cluster in the chain
F06:0451         cmp fat32_sectorspercluster
               S02:000016CE:  C5 5B
F06:0452         bcs .notlastcluster	 ; pendingsectors >= sectorspercluster?
               S02:000016D0:  B0 27
F06:0453       
F06:0454         ; It is the last one.
F06:0455       
F06:0456       .lastcluster
F06:0457       
F06:0458       ; go back the previous one
F06:0459         lda fat32_lastcluster
               S02:000016D2:  A5 6D
F06:0460         sta fat32_nextcluster
               S02:000016D4:  85 5F
F06:0461         lda fat32_lastcluster+1
               S02:000016D6:  A5 6E
F06:0462         sta fat32_nextcluster+1
               S02:000016D8:  85 60
F06:0463         lda fat32_lastcluster+2
               S02:000016DA:  A5 6F
F06:0464         sta fat32_nextcluster+2
               S02:000016DC:  85 61
F06:0465         lda fat32_lastcluster+3
               S02:000016DE:  A5 70
F06:0466         sta fat32_nextcluster+3
               S02:000016E0:  85 62
F06:0467       
F06:0468         jsr fat32_seekcluster
               S02:000016E2:  20 C2 15
F06:0469       
F06:0470         ; Write 0x0FFFFFFF (EOC)
F06:0471         lda #$0f
               S02:000016E5:  A9 0F
F06:0472         sta (zp_sd_address),y
               S02:000016E7:  91 48
F06:0473         dey
               S02:000016E9:  88
F06:0474         lda #$ff
               S02:000016EA:  A9 FF
F06:0475         sta (zp_sd_address),y
               S02:000016EC:  91 48
F06:0476         dey
               S02:000016EE:  88
F06:0477         sta (zp_sd_address),y
               S02:000016EF:  91 48
F06:0478         dey
               S02:000016F1:  88
F06:0479         sta (zp_sd_address),y
               S02:000016F2:  91 48
F06:0480       
F06:0481         ; Update the FAT, if needed.
F06:0482         jsr .sectorbounds
               S02:000016F4:  20 4C 17
F06:0483       
F06:0484         ; End of chain - set carry and return
F06:0485         sec
               S02:000016F7:  38
F06:0486         rts
               S02:000016F8:  60
F06:0487       
F06:0488       .notlastcluster
F06:0489         ; Wait! Are there enough sectors left to fit exactly in one cluster?
F06:0490         beq .lastcluster
               S02:000016F9:  F0 D7
F06:0491       
F06:0492         ; Find the next cluster
F06:0493         jsr fat32_findnextfreecluster
               S02:000016FB:  20 B4 17
F06:0494       
F06:0495         ; Seek to the previous cluster
F06:0496         lda fat32_lastcluster
               S02:000016FE:  A5 6D
F06:0497         sta fat32_nextcluster
               S02:00001700:  85 5F
F06:0498         lda fat32_lastcluster+1
               S02:00001702:  A5 6E
F06:0499         sta fat32_nextcluster+1
               S02:00001704:  85 60
F06:0500         lda fat32_lastcluster+2
               S02:00001706:  A5 6F
F06:0501         sta fat32_nextcluster+2
               S02:00001708:  85 61
F06:0502         lda fat32_lastcluster+3
               S02:0000170A:  A5 70
F06:0503         sta fat32_nextcluster+3
               S02:0000170C:  85 62
F06:0504       
F06:0505         jsr fat32_seekcluster
               S02:0000170E:  20 C2 15
F06:0506       
F06:0507         ; Enter the address of the next one into the FAT
F06:0508         lda fat32_lastfoundfreecluster+3
               S02:00001711:  A5 6A
F06:0509         sta fat32_lastcluster+3
               S02:00001713:  85 70
F06:0510         sta (zp_sd_address),y
               S02:00001715:  91 48
F06:0511         dey
               S02:00001717:  88
F06:0512         lda fat32_lastfoundfreecluster+2
               S02:00001718:  A5 69
F06:0513         sta fat32_lastcluster+2
               S02:0000171A:  85 6F
F06:0514         sta (zp_sd_address),y
               S02:0000171C:  91 48
F06:0515         dey
               S02:0000171E:  88
F06:0516         lda fat32_lastfoundfreecluster+1
               S02:0000171F:  A5 68
F06:0517         sta fat32_lastcluster+1
               S02:00001721:  85 6E
F06:0518         sta (zp_sd_address),y
               S02:00001723:  91 48
F06:0519         dey
               S02:00001725:  88
F06:0520         lda fat32_lastfoundfreecluster
               S02:00001726:  A5 67
F06:0521         sta fat32_lastcluster
               S02:00001728:  85 6D
F06:0522         sta (zp_sd_address),y
               S02:0000172A:  91 48
F06:0523       
F06:0524         ; Update the FAT, if needed.
F06:0525         jsr .sectorbounds
               S02:0000172C:  20 4C 17
F06:0526         
F06:0527       .writesector:
F06:0528         dec fat32_pendingsectors
               S02:0000172F:  C6 5C
F06:0529       
F06:0530         ; Set up target address
F06:0531         lda fat32_address
               S02:00001731:  A5 5D
F06:0532         sta zp_sd_address
               S02:00001733:  85 48
F06:0533         lda fat32_address+1
               S02:00001735:  A5 5E
F06:0534         sta zp_sd_address+1
               S02:00001737:  85 49
F06:0535       
F06:0536         ; Write the sector
F06:0537         jsr sd_writesector
               S02:00001739:  20 54 14
F06:0538       
F06:0539         ; Advance to next sector
F06:0540         inc zp_sd_currentsector
               S02:0000173C:  E6 4A
F06:0541         bne .nextsectorincrementdone
               S02:0000173E:  D0 0A
F06:0542         inc zp_sd_currentsector+1
               S02:00001740:  E6 4B
F06:0543         bne .nextsectorincrementdone
               S02:00001742:  D0 06
F06:0544         inc zp_sd_currentsector+2
               S02:00001744:  E6 4C
F06:0545         bne .nextsectorincrementdone
               S02:00001746:  D0 02
F06:0546         inc zp_sd_currentsector+3
               S02:00001748:  E6 4D
F06:0547       .nextsectorincrementdone:
F06:0548       
F06:0549         ; Success - clear carry and return
F06:0550         clc
               S02:0000174A:  18
F06:0551         rts
               S02:0000174B:  60
F06:0552       
F06:0553       .sectorbounds
F06:0554         ; Have we passed over a sector while modifying the FAT?
F06:0555         lda fat32_newfatsector
               S02:0000174C:  A5 77
F06:0556         beq .nopass
               S02:0000174E:  F0 33
F06:0557       
F06:0558         ; Yes, preserve the current sector
F06:0559         lda zp_sd_currentsector
               S02:00001750:  A5 4A
F06:0560         pha 
               S02:00001752:  48
F06:0561         lda zp_sd_currentsector+1
               S02:00001753:  A5 4B
F06:0562         pha 
               S02:00001755:  48
F06:0563         lda zp_sd_currentsector+2
               S02:00001756:  A5 4C
F06:0564         pha 
               S02:00001758:  48
F06:0565         lda zp_sd_currentsector+3
               S02:00001759:  A5 4D
F06:0566         pha 
               S02:0000175B:  48
F06:0567       
F06:0568         ; Write the sector
F06:0569         lda fat32_lastsector
               S02:0000175C:  A5 72
F06:0570         sta zp_sd_currentsector
               S02:0000175E:  85 4A
F06:0571         lda fat32_lastsector+1
               S02:00001760:  A5 73
F06:0572         sta zp_sd_currentsector+1
               S02:00001762:  85 4B
F06:0573         lda fat32_lastsector+2
               S02:00001764:  A5 74
F06:0574         sta zp_sd_currentsector+2
               S02:00001766:  85 4C
F06:0575         lda fat32_lastsector+3
               S02:00001768:  A5 75
F06:0576         sta zp_sd_currentsector+3
               S02:0000176A:  85 4D
F06:0577       
F06:0578         ; Target buffer
F06:0579         lda #<fat32_readbuffer
               S02:0000176C:  A9 00
F06:0580         sta zp_sd_address
               S02:0000176E:  85 48
F06:0581         lda #>fat32_readbuffer
               S02:00001770:  A9 05
F06:0582         sta zp_sd_address+1
               S02:00001772:  85 49
F06:0583       
F06:0584         ; Write the FAT sector
F06:0585         jsr sd_writesector
               S02:00001774:  20 54 14
F06:0586       
F06:0587         pla
               S02:00001777:  68
F06:0588         sta zp_sd_currentsector+3
               S02:00001778:  85 4D
F06:0589         pla
               S02:0000177A:  68
F06:0590         sta zp_sd_currentsector+2
               S02:0000177B:  85 4C
F06:0591         pla
               S02:0000177D:  68
F06:0592         sta zp_sd_currentsector+1
               S02:0000177E:  85 4B
F06:0593         pla
               S02:00001780:  68
F06:0594         sta zp_sd_currentsector
               S02:00001781:  85 4A
F06:0595       
F06:0596       .nopass
F06:0597         ; We did not, return.
F06:0598         rts
               S02:00001783:  60
F06:0599       
F06:0600       
F06:0601       fat32_openroot:
F06:0602         ; Prepare to read the root directory
F06:0603       
F06:0604         lda fat32_rootcluster
               S02:00001784:  A5 57
F06:0605         sta fat32_nextcluster
               S02:00001786:  85 5F
F06:0606         lda fat32_rootcluster+1
               S02:00001788:  A5 58
F06:0607         sta fat32_nextcluster+1
               S02:0000178A:  85 60
F06:0608         lda fat32_rootcluster+2
               S02:0000178C:  A5 59
F06:0609         sta fat32_nextcluster+2
               S02:0000178E:  85 61
F06:0610         lda fat32_rootcluster+3
               S02:00001790:  A5 5A
F06:0611         sta fat32_nextcluster+3
               S02:00001792:  85 62
F06:0612       
F06:0613         jsr fat32_seekcluster
               S02:00001794:  20 C2 15
F06:0614       
F06:0615         ; Set the pointer to a large value so we always read a sector the first time through
F06:0616         lda #$ff
               S02:00001797:  A9 FF
F06:0617         sta zp_sd_address+1
               S02:00001799:  85 49
F06:0618       
F06:0619         rts
               S02:0000179B:  60
F06:0620       
F06:0621       fat32_allocatecluster:
F06:0622         ; Allocate a cluster to store a file at.
F06:0623         ; Must be done BEFORE running fat32_opendirent.
F06:0624       
F06:0625         ; Find a free cluster
F06:0626         jsr fat32_findnextfreecluster
               S02:0000179C:  20 B4 17
F06:0627       
F06:0628         ; Cache the value so we can add the address of the next one later, if any
F06:0629         lda fat32_lastfoundfreecluster
               S02:0000179F:  A5 67
F06:0630         sta fat32_lastcluster
               S02:000017A1:  85 6D
F06:0631         lda fat32_lastfoundfreecluster+1
               S02:000017A3:  A5 68
F06:0632         sta fat32_lastcluster+1
               S02:000017A5:  85 6E
F06:0633         lda fat32_lastfoundfreecluster+2
               S02:000017A7:  A5 69
F06:0634         sta fat32_lastcluster+2
               S02:000017A9:  85 6F
F06:0635         lda fat32_lastfoundfreecluster+3
               S02:000017AB:  A5 6A
F06:0636         sta fat32_lastcluster+3
               S02:000017AD:  85 70
F06:0637       
F06:0638         ; Add marker for new routines, so we don't think this is free.
F06:0639         lda #$0f
               S02:000017AF:  A9 0F
F06:0640         sta (zp_sd_address),y
               S02:000017B1:  91 48
F06:0641       
F06:0642         rts
               S02:000017B3:  60
F06:0643       
F06:0644       fat32_findnextfreecluster:
F06:0645       ; Find next free cluster
F06:0646       ; 
F06:0647       ; This program will search the FAT for an empty entry, and
F06:0648       ; save the 32-bit cluster number at fat32_lastfoundfreecluter.
F06:0649       ;
F06:0650       ; Also sets the carry bit if the SD card is full.
F06:0651       ;
F06:0652       ; TODO CHECK FOR BUGS
F06:0653       
F06:0654         ; Find a free cluster and store it's location in fat32_lastfoundfreecluster
F06:0655       
F06:0656         lda #0
               S02:000017B4:  A9 00
F06:0657         sta fat32_nextcluster
               S02:000017B6:  85 5F
F06:0658         sta fat32_lastfoundfreecluster
               S02:000017B8:  85 67
F06:0659         sta fat32_nextcluster+1
               S02:000017BA:  85 60
F06:0660         sta fat32_lastfoundfreecluster+1
               S02:000017BC:  85 68
F06:0661         sta fat32_nextcluster+2
               S02:000017BE:  85 61
F06:0662         sta fat32_lastfoundfreecluster+2
               S02:000017C0:  85 69
F06:0663         sta fat32_nextcluster+3
               S02:000017C2:  85 62
F06:0664         sta fat32_lastfoundfreecluster+3
               S02:000017C4:  85 6A
F06:0665       
F06:0666       .searchclusters
F06:0667       
F06:0668         ; Seek cluster
F06:0669         jsr fat32_seekcluster
               S02:000017C6:  20 C2 15
F06:0670       
F06:0671         ; Is the cluster free?
F06:0672         lda fat32_nextcluster
               S02:000017C9:  A5 5F
F06:0673         and #$0f
               S02:000017CB:  29 0F
F06:0674         ora fat32_nextcluster+1
               S02:000017CD:  05 60
F06:0675         ora fat32_nextcluster+2
               S02:000017CF:  05 61
F06:0676         ora fat32_nextcluster+3
               S02:000017D1:  05 62
F06:0677         beq .foundcluster
               S02:000017D3:  F0 21
F06:0678       
F06:0679         ; No, increment the cluster count
F06:0680         inc fat32_lastfoundfreecluster
               S02:000017D5:  E6 67
F06:0681         bne .copycluster
               S02:000017D7:  D0 0A
F06:0682         inc fat32_lastfoundfreecluster+1
               S02:000017D9:  E6 68
F06:0683         bne .copycluster
               S02:000017DB:  D0 06
F06:0684         inc fat32_lastfoundfreecluster+2
               S02:000017DD:  E6 69
F06:0685         bne .copycluster
               S02:000017DF:  D0 02
F06:0686         inc fat32_lastfoundfreecluster+3
               S02:000017E1:  E6 6A
F06:0687       
F06:0688       .copycluster
F06:0689       
F06:0690         ; Copy the cluster count to the next cluster
F06:0691         lda fat32_lastfoundfreecluster
               S02:000017E3:  A5 67
F06:0692         sta fat32_nextcluster
               S02:000017E5:  85 5F
F06:0693         lda fat32_lastfoundfreecluster+1
               S02:000017E7:  A5 68
F06:0694         sta fat32_nextcluster+1
               S02:000017E9:  85 60
F06:0695         lda fat32_lastfoundfreecluster+2
               S02:000017EB:  A5 69
F06:0696         sta fat32_nextcluster+2
               S02:000017ED:  85 61
F06:0697         lda fat32_lastfoundfreecluster+3
               S02:000017EF:  A5 6A
F06:0698         sta fat32_nextcluster+3
               S02:000017F1:  85 62
F06:0699         
F06:0700         ; Go again for another pass
F06:0701         jmp .searchclusters
               S02:000017F3:  4C C6 17
F06:0702       
F06:0703       .foundcluster
F06:0704         ; done.
F06:0705         rts
               S02:000017F6:  60
F06:0706       
F06:0707       fat32_opendirent:
F06:0708         ; Prepare to read/write a file or directory based on a dirent
F06:0709         ;
F06:0710         ; Point zp_sd_address at the dirent
F06:0711       
F06:0712         ; Remember file size in bytes remaining
F06:0713         ldy #28
               S02:000017F7:  A0 1C
F06:0714         lda (zp_sd_address),y
               S02:000017F9:  B1 48
F06:0715         sta fat32_bytesremaining
               S02:000017FB:  85 63
F06:0716         iny
               S02:000017FD:  C8
F06:0717         lda (zp_sd_address),y
               S02:000017FE:  B1 48
F06:0718         sta fat32_bytesremaining+1
               S02:00001800:  85 64
F06:0719         iny
               S02:00001802:  C8
F06:0720         lda (zp_sd_address),y
               S02:00001803:  B1 48
F06:0721         sta fat32_bytesremaining+2
               S02:00001805:  85 65
F06:0722         iny
               S02:00001807:  C8
F06:0723         lda (zp_sd_address),y
               S02:00001808:  B1 48
F06:0724         sta fat32_bytesremaining+3
               S02:0000180A:  85 66
F06:0725       
F06:0726         ; Seek to first cluster
F06:0727         ldy #26
               S02:0000180C:  A0 1A
F06:0728         lda (zp_sd_address),y
               S02:0000180E:  B1 48
F06:0729         sta fat32_nextcluster
               S02:00001810:  85 5F
F06:0730         iny
               S02:00001812:  C8
F06:0731         lda (zp_sd_address),y
               S02:00001813:  B1 48
F06:0732         sta fat32_nextcluster+1
               S02:00001815:  85 60
F06:0733         ldy #20
               S02:00001817:  A0 14
F06:0734         lda (zp_sd_address),y
               S02:00001819:  B1 48
F06:0735         sta fat32_nextcluster+2
               S02:0000181B:  85 61
F06:0736         iny
               S02:0000181D:  C8
F06:0737         lda (zp_sd_address),y
               S02:0000181E:  B1 48
F06:0738         sta fat32_nextcluster+3
               S02:00001820:  85 62
F06:0739       
F06:0740         jsr fat32_seekcluster
               S02:00001822:  20 C2 15
F06:0741       
F06:0742         ; Set the pointer to a large value so we always read a sector the first time through
F06:0743         lda #$ff
               S02:00001825:  A9 FF
F06:0744         sta zp_sd_address+1
               S02:00001827:  85 49
F06:0745       
F06:0746         rts
               S02:00001829:  60
F06:0747       
F06:0748       fat32_writedirent:
F06:0749         ; TODO Write a directory entry from the open directory
F06:0750         ; requires:
F06:0751         ;   fat32bytesremaining (2 bytes) = file size in bytes (little endian)
F06:0752         ;   and the processes of:
F06:0753         ;     fat32_finddirent
F06:0754         ;     fat32_findnextfreecluster
F06:0755       
F06:0756         ; Increment pointer by 32 to point to next entry
F06:0757         clc
               S02:0000182A:  18
F06:0758         lda zp_sd_address
               S02:0000182B:  A5 48
F06:0759         adc #32
               S02:0000182D:  69 20
F06:0760         sta zp_sd_address
               S02:0000182F:  85 48
F06:0761         lda zp_sd_address+1
               S02:00001831:  A5 49
F06:0762         adc #0
               S02:00001833:  69 00
F06:0763         sta zp_sd_address+1
               S02:00001835:  85 49
F06:0764       
F06:0765         ; If it's not at the end of the buffer, we have data already
F06:0766         cmp #>(fat32_readbuffer+$200)
               S02:00001837:  C9 07
F06:0767         bcc .gotdirrent
               S02:00001839:  90 0F
F06:0768       
F06:0769         ; Read another sector
F06:0770         lda #<fat32_readbuffer
               S02:0000183B:  A9 00
F06:0771         sta fat32_address
               S02:0000183D:  85 5D
F06:0772         lda #>fat32_readbuffer
               S02:0000183F:  A9 05
F06:0773         sta fat32_address+1
               S02:00001841:  85 5E
F06:0774       
F06:0775         jsr fat32_readnextsector
               S02:00001843:  20 A0 16
F06:0776         bcc .gotdirrent
               S02:00001846:  90 02
F06:0777       
F06:0778       .endofdirectorywrite:
F06:0779         sec
               S02:00001848:  38
F06:0780         rts
               S02:00001849:  60
F06:0781       
F06:0782       .gotdirrent:
F06:0783         ; Check first character
F06:0784         clc
               S02:0000184A:  18
F06:0785         ldy #0
               S02:0000184B:  A0 00
F06:0786         lda (zp_sd_address),y
               S02:0000184D:  B1 48
F06:0787         bne fat32_writedirent ; go again
               S02:0000184F:  D0 D9
F06:0788         ; End of directory. Now make a new entry.
F06:0789       .dloop:
F06:0790         lda (fat32_filenamepointer),y	; copy filename
               S02:00001851:  B1 63
F06:0791         sta (zp_sd_address),y
               S02:00001853:  91 48
F06:0792         iny
               S02:00001855:  C8
F06:0793         cpy #$0b
               S02:00001856:  C0 0B
F06:0794         bne .dloop
               S02:00001858:  D0 F7
F06:0795         ; The full Short filename is #11 bytes long so,
F06:0796         ; this start at 0x0b - File type
F06:0797         ; BUG assumes that we are making a file, not a folder...
F06:0798         lda #$20		; File Type: ARCHIVE
               S02:0000185A:  A9 20
F06:0799         sta (zp_sd_address),y
               S02:0000185C:  91 48
F06:0800         iny   ; 0x0c - Checksum/File accsess password
               S02:0000185E:  C8
F06:0801         lda #$10		            ; No checksum or password
               S02:0000185F:  A9 10
F06:0802         sta (zp_sd_address),y
               S02:00001861:  91 48
F06:0803         iny   ; 0x0d - Does not matter now (first char of deleted file)
               S02:00001863:  C8
F06:0804         lda #0
               S02:00001864:  A9 00
F06:0805         sta (zp_sd_address),y
               S02:00001866:  91 48
F06:0806         iny	; 0x0e-0x11 - File creation time/date
               S02:00001868:  C8
F06:0807       .empty
F06:0808         sta (zp_sd_address),y	; No time/date because I don't have an RTC
               S02:00001869:  91 48
F06:0809         iny
               S02:0000186B:  C8
F06:0810         cpy #$14 ; also empty the user ID (0x12-0x13)
               S02:0000186C:  C0 14
F06:0811         bne .empty
               S02:0000186E:  D0 F9
F06:0812         ;sta (zp_sd_address),y
F06:0813         ;iny
F06:0814         ;sta (zp_sd_address),y
F06:0815         ;iny
F06:0816         ;sta (zp_sd_address),y
F06:0817         ; if you have an RTC, refer to https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#Directory_entry 
F06:0818         ; show the "Directory entry" table and look at at 0x0E onward.
F06:0819         ;iny   ; 0x12-0x13 - User ID
F06:0820         ;lda #0
F06:0821         ;sta (zp_sd_address),y	; No ID
F06:0822         ;iny
F06:0823         ;sta (zp_sd_address),y
F06:0824         ;iny 
F06:0825         ; 0x14-0x15 - File start cluster (high word)
F06:0826         lda fat32_lastfoundfreecluster+2
               S02:00001870:  A5 69
F06:0827         sta (zp_sd_address),y
               S02:00001872:  91 48
F06:0828         iny
               S02:00001874:  C8
F06:0829         lda fat32_lastfoundfreecluster+3
               S02:00001875:  A5 6A
F06:0830         sta (zp_sd_address),y
               S02:00001877:  91 48
F06:0831         iny ; 0x16-0x19 - File modifiaction date
               S02:00001879:  C8
F06:0832         lda #0
               S02:0000187A:  A9 00
F06:0833         sta (zp_sd_address),y
               S02:0000187C:  91 48
F06:0834         iny
               S02:0000187E:  C8
F06:0835         sta (zp_sd_address),y   ; no rtc
               S02:0000187F:  91 48
F06:0836         iny
               S02:00001881:  C8
F06:0837         sta (zp_sd_address),y
               S02:00001882:  91 48
F06:0838         iny
               S02:00001884:  C8
F06:0839         sta (zp_sd_address),y
               S02:00001885:  91 48
F06:0840         iny ; 0x1a-0x1b - File start cluster (low word)
               S02:00001887:  C8
F06:0841         lda fat32_lastfoundfreecluster
               S02:00001888:  A5 67
F06:0842         sta (zp_sd_address),y
               S02:0000188A:  91 48
F06:0843         iny
               S02:0000188C:  C8
F06:0844         lda fat32_lastfoundfreecluster+1
               S02:0000188D:  A5 68
F06:0845         sta (zp_sd_address),y
               S02:0000188F:  91 48
F06:0846         iny ; 0x1c-0x1f File size in bytes
               S02:00001891:  C8
F06:0847         lda fat32_bytesremaining
               S02:00001892:  A5 63
F06:0848         sta (zp_sd_address),y
               S02:00001894:  91 48
F06:0849         iny
               S02:00001896:  C8
F06:0850         lda fat32_bytesremaining+1
               S02:00001897:  A5 64
F06:0851         sta (zp_sd_address),y
               S02:00001899:  91 48
F06:0852         iny
               S02:0000189B:  C8
F06:0853         lda #0
               S02:0000189C:  A9 00
F06:0854         sta (zp_sd_address),y ; Not bigger that 64k
               S02:0000189E:  91 48
F06:0855         iny
               S02:000018A0:  C8
F06:0856         sta (zp_sd_address),y
               S02:000018A1:  91 48
F06:0857         iny
               S02:000018A3:  C8
F06:0858         ; are we over the buffer?
F06:0859         lda zp_sd_address+1
               S02:000018A4:  A5 49
F06:0860         cmp #>(fat32_readbuffer+$200)
               S02:000018A6:  C9 07
F06:0861         bcc .overbuffer
               S02:000018A8:  90 12
F06:0862         jsr fat32_writenextsector ; if so, write the current sector
               S02:000018AA:  20 CA 16
F06:0863         jsr fat32_readnextsector  ; then read the next one.
               S02:000018AD:  20 A0 16
F06:0864         bcs .dfail
               S02:000018B0:  B0 13
F06:0865         ldy #0
               S02:000018B2:  A0 00
F06:0866         lda #<fat32_readbuffer
               S02:000018B4:  A9 00
F06:0867         sta zp_sd_address
               S02:000018B6:  85 48
F06:0868         lda #>fat32_readbuffer
               S02:000018B8:  A9 05
F06:0869         sta zp_sd_address+1
               S02:000018BA:  85 49
F06:0870       .overbuffer:
F06:0871         ; next entry is 0 (end of dir)
F06:0872         lda #0
               S02:000018BC:  A9 00
F06:0873         sta (zp_sd_address),y
               S02:000018BE:  91 48
F06:0874         jsr fat32_writenextsector ; write all the data...
               S02:000018C0:  20 CA 16
F06:0875         clc
               S02:000018C3:  18
F06:0876         rts
               S02:000018C4:  60
F06:0877       
F06:0878       .dfail:
F06:0879         ; Card Full
F06:0880         sec
               S02:000018C5:  38
F06:0881         rts
               S02:000018C6:  60
F06:0882       
F06:0883       fat32_readdirent:
F06:0884         ; Read a directory entry from the open directory
F06:0885         ;
F06:0886         ; On exit the carry is set if there were no more directory entries.
F06:0887         ;
F06:0888         ; Otherwise, A is set to the file's attribute byte and
F06:0889         ; zp_sd_address points at the returned directory entry.
F06:0890         ; LFNs and empty entries are ignored automatically.
F06:0891       
F06:0892         ; Increment pointer by 32 to point to next entry
F06:0893         clc
               S02:000018C7:  18
F06:0894         lda zp_sd_address
               S02:000018C8:  A5 48
F06:0895         adc #32
               S02:000018CA:  69 20
F06:0896         sta zp_sd_address
               S02:000018CC:  85 48
F06:0897         lda zp_sd_address+1
               S02:000018CE:  A5 49
F06:0898         adc #0
               S02:000018D0:  69 00
F06:0899         sta zp_sd_address+1
               S02:000018D2:  85 49
F06:0900       
F06:0901         ; If it's not at the end of the buffer, we have data already
F06:0902         cmp #>(fat32_readbuffer+$200)
               S02:000018D4:  C9 07
F06:0903         bcc .gotdata
               S02:000018D6:  90 0F
F06:0904       
F06:0905         ; Read another sector
F06:0906         lda #<fat32_readbuffer
               S02:000018D8:  A9 00
F06:0907         sta fat32_address
               S02:000018DA:  85 5D
F06:0908         lda #>fat32_readbuffer
               S02:000018DC:  A9 05
F06:0909         sta fat32_address+1
               S02:000018DE:  85 5E
F06:0910       
F06:0911         jsr fat32_readnextsector
               S02:000018E0:  20 A0 16
F06:0912         bcc .gotdata
               S02:000018E3:  90 02
F06:0913       
F06:0914       .endofdirectory:
F06:0915         sec
               S02:000018E5:  38
F06:0916         rts
               S02:000018E6:  60
F06:0917       
F06:0918       .gotdata:
F06:0919         ; Check first character
F06:0920         ldy #0
               S02:000018E7:  A0 00
F06:0921         lda (zp_sd_address),y
               S02:000018E9:  B1 48
F06:0922       
F06:0923         ; End of directory => abort
F06:0924         beq .endofdirectory
               S02:000018EB:  F0 F8
F06:0925       
F06:0926         ; Empty entry => start again
F06:0927         cmp #$e5
               S02:000018ED:  C9 E5
F06:0928         beq fat32_readdirent
               S02:000018EF:  F0 D6
F06:0929       
F06:0930         ; Check attributes
F06:0931         ldy #11
               S02:000018F1:  A0 0B
F06:0932         lda (zp_sd_address),y
               S02:000018F3:  B1 48
F06:0933         and #$3f
               S02:000018F5:  29 3F
F06:0934         cmp #$0f ; LFN => start again
               S02:000018F7:  C9 0F
F06:0935         beq fat32_readdirent
               S02:000018F9:  F0 CC
F06:0936       
F06:0937         ; Yield this result
F06:0938         clc
               S02:000018FB:  18
F06:0939         rts
               S02:000018FC:  60
F06:0940       
F06:0941       
F06:0942       fat32_finddirent:
F06:0943         ; Finds a particular directory entry. X,Y point to the 11-character filename to seek.
F06:0944         ; The directory should already be open for iteration.
F06:0945       
F06:0946         ; Form ZP pointer to user's filename
F06:0947         stx fat32_filenamepointer
               S02:000018FD:  86 63
F06:0948         sty fat32_filenamepointer+1
               S02:000018FF:  84 64
F06:0949         
F06:0950         ; Iterate until name is found or end of directory
F06:0951       .direntloop:
F06:0952         jsr fat32_readdirent
               S02:00001901:  20 C7 18
F06:0953         ldy #10
               S02:00001904:  A0 0A
F06:0954         bcc .comparenameloop
               S02:00001906:  90 01
F06:0955         rts ; with carry set
               S02:00001908:  60
F06:0956       
F06:0957       .comparenameloop:
F06:0958         lda (zp_sd_address),y
               S02:00001909:  B1 48
F06:0959         cmp (fat32_filenamepointer),y
               S02:0000190B:  D1 63
F06:0960         bne .direntloop ; no match
               S02:0000190D:  D0 F2
F06:0961         dey
               S02:0000190F:  88
F06:0962         bpl .comparenameloop
               S02:00001910:  10 F7
F06:0963       
F06:0964         ; Found it
F06:0965         clc
               S02:00001912:  18
F06:0966         rts
               S02:00001913:  60
F06:0967       
F06:0968       
F06:0969       fat32_file_readbyte:
F06:0970         ; Read a byte from an open file
F06:0971         ;
F06:0972         ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
F06:0973       
F06:0974         sec
               S02:00001914:  38
F06:0975       
F06:0976         ; Is there any data to read at all?
F06:0977         lda fat32_bytesremaining
               S02:00001915:  A5 63
F06:0978         ora fat32_bytesremaining+1
               S02:00001917:  05 64
F06:0979         ora fat32_bytesremaining+2
               S02:00001919:  05 65
F06:0980         ora fat32_bytesremaining+3
               S02:0000191B:  05 66
F06:0981         beq .rts
               S02:0000191D:  F0 3D
F06:0982       
F06:0983         ; Decrement the remaining byte count
F06:0984         lda fat32_bytesremaining
               S02:0000191F:  A5 63
F06:0985         sbc #1
               S02:00001921:  E9 01
F06:0986         sta fat32_bytesremaining
               S02:00001923:  85 63
F06:0987         lda fat32_bytesremaining+1
               S02:00001925:  A5 64
F06:0988         sbc #0
               S02:00001927:  E9 00
F06:0989         sta fat32_bytesremaining+1
               S02:00001929:  85 64
F06:0990         lda fat32_bytesremaining+2
               S02:0000192B:  A5 65
F06:0991         sbc #0
               S02:0000192D:  E9 00
F06:0992         sta fat32_bytesremaining+2
               S02:0000192F:  85 65
F06:0993         lda fat32_bytesremaining+3
               S02:00001931:  A5 66
F06:0994         sbc #0
               S02:00001933:  E9 00
F06:0995         sta fat32_bytesremaining+3
               S02:00001935:  85 66
F06:0996         
F06:0997         ; Need to read a new sector?
F06:0998         lda zp_sd_address+1
               S02:00001937:  A5 49
F06:0999         cmp #>(fat32_readbuffer+$200)
               S02:00001939:  C9 07
F06:1000         bcc .gotdata
               S02:0000193B:  90 0D
F06:1001       
F06:1002         ; Read another sector
F06:1003         lda #<fat32_readbuffer
               S02:0000193D:  A9 00
F06:1004         sta fat32_address
               S02:0000193F:  85 5D
F06:1005         lda #>fat32_readbuffer
               S02:00001941:  A9 05
F06:1006         sta fat32_address+1
               S02:00001943:  85 5E
F06:1007       
F06:1008         jsr fat32_readnextsector
               S02:00001945:  20 A0 16
F06:1009         bcs .rts                    ; this shouldn't happen
               S02:00001948:  B0 12
F06:1010       
F06:1011       .gotdata:
F06:1012         ldy #0
               S02:0000194A:  A0 00
F06:1013         lda (zp_sd_address),y
               S02:0000194C:  B1 48
F06:1014       
F06:1015         inc zp_sd_address
               S02:0000194E:  E6 48
F06:1016         bne .rts
               S02:00001950:  D0 0A
F06:1017         inc zp_sd_address+1
               S02:00001952:  E6 49
F06:1018         bne .rts
               S02:00001954:  D0 06
F06:1019         inc zp_sd_address+2
               S02:00001956:  E6 4A
F06:1020         bne .rts
               S02:00001958:  D0 02
F06:1021         inc zp_sd_address+3
               S02:0000195A:  E6 4B
F06:1022       
F06:1023       .rts:
F06:1024         rts
               S02:0000195C:  60
F06:1025       
F06:1026       
F06:1027       fat32_file_read:
F06:1028         ; Read a whole file into memory.  It's assumed the file has just been opened 
F06:1029         ; and no data has been read yet.
F06:1030         ;
F06:1031         ; Also we read whole sectors, so data in the target region beyond the end of the 
F06:1032         ; file may get overwritten, up to the next 512-byte boundary.
F06:1033         ;
F06:1034         ; And we don't properly support 64k+ files, as it's unnecessary complication given
F06:1035         ; the 6502's small address space
F06:1036       
F06:1037         ; Round the size up to the next whole sector
F06:1038         lda fat32_bytesremaining
               S02:0000195D:  A5 63
F06:1039         cmp #1                      ; set carry if bottom 8 bits not zero
               S02:0000195F:  C9 01
F06:1040         lda fat32_bytesremaining+1
               S02:00001961:  A5 64
F06:1041         adc #0                      ; add carry, if any
               S02:00001963:  69 00
F06:1042         lsr                         ; divide by 2
               S02:00001965:  4A
F06:1043         adc #0                      ; round up
               S02:00001966:  69 00
F06:1044       
F06:1045         ; No data?
F06:1046         beq .done
               S02:00001968:  F0 12
F06:1047       
F06:1048         ; Store sector count - not a byte count any more
F06:1049         sta fat32_bytesremaining
               S02:0000196A:  85 63
F06:1050       
F06:1051         ; Read entire sectors to the user-supplied buffer
F06:1052       .wholesectorreadloop:
F06:1053         ; Read a sector to fat32_address
F06:1054         jsr fat32_readnextsector
               S02:0000196C:  20 A0 16
F06:1055       
F06:1056         ; Advance fat32_address by 512 bytes
F06:1057         lda fat32_address+1
               S02:0000196F:  A5 5E
F06:1058         adc #2                      ; carry already clear
               S02:00001971:  69 02
F06:1059         sta fat32_address+1
               S02:00001973:  85 5E
F06:1060       
F06:1061         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
               S02:00001975:  A6 63
F06:1062         dex
               S02:00001977:  CA
F06:1063         stx fat32_bytesremaining    ; note - actually stores sectors remaining
               S02:00001978:  86 63
F06:1064       
F06:1065         bne .wholesectorreadloop
               S02:0000197A:  D0 F0
F06:1066       
F06:1067       .done:
F06:1068         rts
               S02:0000197C:  60
F06:1069       
F06:1070       fat32_file_write:
F06:1071         ; Write a whole file from memory.  It's assumed the file has just been opened 
F06:1072         ; and no data has been written yet.
F06:1073         ;
F06:1074         ; Also we write whole sectors, so data in the target region beyond the end of the 
F06:1075         ; file may get overwritten, up to the next 512-byte boundary.
F06:1076         ;
F06:1077         ; And we don't properly support 64k+ files, as it's unnecessary complication given
F06:1078         ; the 6502's small address space
F06:1079       
F06:1080         ; Round the size up to the next whole sector
F06:1081         lda fat32_bytesremaining
               S02:0000197D:  A5 63
F06:1082         cmp #1                      ; set carry if bottom 8 bits not zero
               S02:0000197F:  C9 01
F06:1083         lda fat32_bytesremaining+1
               S02:00001981:  A5 64
F06:1084         adc #0                      ; add carry, if any
               S02:00001983:  69 00
F06:1085         lsr                         ; divide by 2
               S02:00001985:  4A
F06:1086         adc #0                      ; round up
               S02:00001986:  69 00
F06:1087       
F06:1088         ; No data?
F06:1089         beq .fail
               S02:00001988:  F0 33
F06:1090       
F06:1091         ; Store sector count - not a byte count anymore.
F06:1092         sta fat32_bytesremaining
               S02:0000198A:  85 63
F06:1093       
F06:1094         ; Write entire sectors from the user-supplied buffer
F06:1095       .wholesectorwriteloop:
F06:1096         ; Write a sector from fat32_address
F06:1097         jsr fat32_writenextsector
               S02:0000198C:  20 CA 16
F06:1098         bcs .fail	; this shouldn't happen
               S02:0000198F:  B0 2C
F06:1099       
F06:1100         ; Advance fat32_address by 512 bytes
F06:1101         lda fat32_address+1
               S02:00001991:  A5 5E
F06:1102         adc #2                      ; carry already clear
               S02:00001993:  69 02
F06:1103         sta fat32_address+1
               S02:00001995:  85 5E
F06:1104       
F06:1105         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
               S02:00001997:  A6 63
F06:1106         dex
               S02:00001999:  CA
F06:1107         stx fat32_bytesremaining    ; note - actually stores sectors remaining
               S02:0000199A:  86 63
F06:1108       
F06:1109         bne .wholesectorwriteloop
               S02:0000199C:  D0 EE
F06:1110       
F06:1111         ; Has fat32_writenextsector written the FAT table?
F06:1112         lda fat32_newfatsector
               S02:0000199E:  A5 77
F06:1113         bne .fail  ; not a fail, just means its done.
               S02:000019A0:  D0 1B
F06:1114       
F06:1115         ; No, write it here.
F06:1116         lda fat32_lastsector
               S02:000019A2:  A5 72
F06:1117         sta zp_sd_currentsector
               S02:000019A4:  85 4A
F06:1118         lda fat32_lastsector+1
               S02:000019A6:  A5 73
F06:1119         sta zp_sd_currentsector+1
               S02:000019A8:  85 4B
F06:1120         lda fat32_lastsector+2
               S02:000019AA:  A5 74
F06:1121         sta zp_sd_currentsector+2
               S02:000019AC:  85 4C
F06:1122         lda fat32_lastsector+3
               S02:000019AE:  A5 75
F06:1123         sta zp_sd_currentsector+3
               S02:000019B0:  85 4D
F06:1124       
F06:1125         ; Target buffer
F06:1126         lda #<fat32_readbuffer
               S02:000019B2:  A9 00
F06:1127         sta zp_sd_address
               S02:000019B4:  85 48
F06:1128         lda #>fat32_readbuffer
               S02:000019B6:  A9 05
F06:1129         sta zp_sd_address+1
               S02:000019B8:  85 49
F06:1130       
F06:1131         ; Write the FAT sector
F06:1132         jsr sd_writesector
               S02:000019BA:  20 54 14
F06:1133       
F06:1134       .fail
F06:1135         rts
               S02:000019BD:  60
F06:1136       
F00:0106       
F00:0107       failedmsg:
F00:0108         .byte "Failed!",CR,LF,$00
               S02:000019BE:  46 61 69 6C 65 64 21
               S02:000019C5:  0D
               S02:000019C6:  0A
               S02:000019C7:  00
F00:0109       
F00:0110       


Sections:
S01  segf00
S02  seg1006


Sources:
F00  writetest.s
F01  errors.s
F02  errorsound.s
F03  hwconfig.s
F04  libacia.s
F05  libsd.s
F06  libfat32.s


Symbols:
failedmsg EXPR(6590=0x19be) UNUSED ABS 
 fat32_file_write wholesectorwriteloop EXPR(6540=0x198c) ABS 
 fat32_file_write fail EXPR(6589=0x19bd) ABS 
fat32_file_write EXPR(6525=0x197d) UNUSED ABS 
 fat32_file_read wholesectorreadloop EXPR(6508=0x196c) ABS 
 fat32_file_read done EXPR(6524=0x197c) ABS 
fat32_file_read EXPR(6493=0x195d) UNUSED ABS 
 fat32_file_readbyte gotdata EXPR(6474=0x194a) ABS 
 fat32_file_readbyte rts EXPR(6492=0x195c) ABS 
fat32_file_readbyte EXPR(6420=0x1914) UNUSED ABS 
 fat32_finddirent comparenameloop EXPR(6409=0x1909) ABS 
 fat32_finddirent direntloop EXPR(6401=0x1901) ABS 
fat32_finddirent EXPR(6397=0x18fd) UNUSED ABS 
 fat32_readdirent endofdirectory EXPR(6373=0x18e5) ABS 
 fat32_readdirent gotdata EXPR(6375=0x18e7) ABS 
fat32_readdirent EXPR(6343=0x18c7) ABS 
 fat32_writedirent dfail EXPR(6341=0x18c5) ABS 
 fat32_writedirent overbuffer EXPR(6332=0x18bc) ABS 
 fat32_writedirent empty EXPR(6249=0x1869) ABS 
 fat32_writedirent dloop EXPR(6225=0x1851) ABS 
 fat32_writedirent endofdirectorywrite EXPR(6216=0x1848) UNUSED ABS 
 fat32_writedirent gotdirrent EXPR(6218=0x184a) ABS 
fat32_writedirent EXPR(6186=0x182a) ABS 
fat32_opendirent EXPR(6135=0x17f7) UNUSED ABS 
 fat32_findnextfreecluster copycluster EXPR(6115=0x17e3) ABS 
 fat32_findnextfreecluster foundcluster EXPR(6134=0x17f6) ABS 
 fat32_findnextfreecluster searchclusters EXPR(6086=0x17c6) ABS 
fat32_allocatecluster EXPR(6044=0x179c) UNUSED ABS 
fat32_openroot EXPR(6020=0x1784) UNUSED ABS 
 fat32_writenextsector nopass EXPR(6019=0x1783) ABS 
 fat32_writenextsector nextsectorincrementdone EXPR(5962=0x174a) ABS 
fat32_findnextfreecluster EXPR(6068=0x17b4) ABS 
 fat32_writenextsector sectorbounds EXPR(5964=0x174c) ABS 
 fat32_writenextsector lastcluster EXPR(5842=0x16d2) ABS 
 fat32_writenextsector notlastcluster EXPR(5881=0x16f9) ABS 
 fat32_writenextsector writesector EXPR(5935=0x172f) ABS 
fat32_writenextsector EXPR(5834=0x16ca) ABS 
 fat32_readnextsector sectorincrementdone EXPR(5830=0x16c6) ABS 
 fat32_readnextsector endofchain EXPR(5832=0x16c8) ABS 
 fat32_readnextsector readsector EXPR(5803=0x16ab) ABS 
fat32_readnextsector EXPR(5792=0x16a0) ABS 
 fat32_seekcluster notendofchain EXPR(5791=0x169f) ABS 
 fat32_seekcluster spcshiftloopdone EXPR(5710=0x164e) ABS 
 fat32_seekcluster spcshiftloop EXPR(5696=0x1640) ABS 
 fat32_seekcluster notnew EXPR(5667=0x1623) ABS 
 fat32_seekcluster newsector EXPR(5636=0x1604) ABS 
fat32_seekcluster EXPR(5570=0x15c2) ABS 
 fat32_init skipfatsloop EXPR(5499=0x157b) ABS 
 fat32_init error EXPR(5568=0x15c0) ABS 
 fat32_init foundpart EXPR(5378=0x1502) ABS 
 fat32_init FSTYPE_FAT32 EXPR(12=0xc) EQU 
 fat32_init fail EXPR(5375=0x14ff) ABS 
fat32_init EXPR(5296=0x14b0) UNUSED ABS 
fat32_filenamepointer EXPR(99=0x63) EQU 
fat32_errorstage EXPR(99=0x63) EQU 
fat32_newfatsector EXPR(119=0x77) EQU 
fat32_lastsector EXPR(114=0x72) EQU 
fat32_lastcluster EXPR(109=0x6d) EQU 
fat32_sectorsperfat EXPR(107=0x6b) EQU 
fat32_lastfoundfreecluster EXPR(103=0x67) EQU 
fat32_bytesremaining EXPR(99=0x63) EQU 
fat32_nextcluster EXPR(95=0x5f) EQU 
fat32_address EXPR(93=0x5d) EQU 
fat32_pendingsectors EXPR(92=0x5c) EQU 
fat32_sectorspercluster EXPR(91=0x5b) EQU 
fat32_rootcluster EXPR(87=0x57) EQU 
fat32_datastart EXPR(83=0x53) EQU 
fat32_fatstart EXPR(79=0x4f) EQU 
fat32_readbuffer EXPR(1280=0x500) EQU 
 sd_writesector writeloop EXPR(5285=0x14a5) ABS 
 sd_writesector waitidle EXPR(5270=0x1496) ABS 
 sd_writesector writepage EXPR(5283=0x14a3) ABS 
 sd_fail failloop EXPR(5201=0x1451) ABS 
 sd_readsector readloop EXPR(5177=0x1439) ABS 
 sd_readsector readpage EXPR(5175=0x1437) ABS 
sd_fail EXPR(5186=0x1442) ABS 
sd_waitresult EXPR(5029=0x13a5) ABS 
 sd_writebyte sendbit EXPR(5016=0x1398) ABS 
 sd_writebyte loop EXPR(5008=0x1390) ABS 
sd_writebyte EXPR(5006=0x138e) ABS 
 sd_readbyte bitnotset EXPR(5000=0x1388) ABS 
 sd_readbyte loop EXPR(4981=0x1375) ABS 
 sd_init loop EXPR(4952=0x1358) ABS 
 sd_init delayloop EXPR(4932=0x1344) ABS 
 sd_init initialized EXPR(4941=0x134d) ABS 
sd_cmd41_bytes EXPR(4973=0x136d) ABS 
 sd_init cmd41 EXPR(4909=0x132d) UNUSED ABS 
sd_cmd55_bytes EXPR(4967=0x1367) ABS 
 sd_init cmd55 EXPR(4894=0x131e) ABS 
sd_readbyte EXPR(4979=0x1373) ABS 
sd_cmd8_bytes EXPR(4961=0x1361) ABS 
 sd_init cmd8 EXPR(4867=0x1303) UNUSED ABS 
 sd_init initfailed EXPR(4947=0x1353) ABS 
sd_sendcommand EXPR(5037=0x13ad) ABS 
sd_cmd0_bytes EXPR(4955=0x135b) ABS 
 sd_init cmd0 EXPR(4852=0x12f4) UNUSED ABS 
 sd_init preinitloop EXPR(4844=0x12ec) ABS 
sd_init EXPR(4840=0x12e8) UNUSED ABS 
endwacia EXPR(4832=0x12e0) ABS 
acia_man EXPR(4818=0x12d2) ABS 
ascii_home EXPR(4797=0x12bd) UNUSED ABS 
print_char_acia EXPR(4794=0x12ba) UNUSED ABS 
txpoll EXPR(4769=0x12a1) ABS 
cleardisplay EXPR(4758=0x1296) UNUSED ABS 
crlf EXPR(4737=0x1281) UNUSED ABS 
print_chara EXPR(4785=0x12b1) ABS 
cskipletter EXPR(4731=0x127b) ABS 
print_nybble EXPR(4723=0x1273) ABS 
print_hex_acia EXPR(4714=0x126a) ABS 
acia_init EXPR(4701=0x125d) UNUSED ABS 
via_init EXPR(4690=0x1252) UNUSED ABS 
PORTA_OUTPUTPINS EXPR(252=0xfc) EQU 
SD_MISO EXPR(2=0x2) EQU 
SD_MOSI EXPR(4=0x4) EQU 
SD_SCK EXPR(8=0x8) EQU 
SD_CS EXPR(16=0x10) EQU 
LCD_RS EXPR(32=0x20) EQU 
LCD_RW EXPR(64=0x40) EQU 
LCD_E EXPR(128=0x80) EQU 
DDRA EXPR(45059=0xb003) EQU 
DDRB EXPR(45058=0xb002) EQU 
PORTA EXPR(45057=0xb001) EQU 
PORTB EXPR(45056=0xb000) UNUSED EQU 
csid EXPR(4683=0x124b) ABS 
clear_sid EXPR(4681=0x1249) ABS 
InitSid2 EXPR(4355=0x1103) UNUSED ABS 
L10fa EXPR(4346=0x10fa) ABS 
L10ec EXPR(4332=0x10ec) ABS 
L10cc EXPR(4300=0x10cc) ABS 
L10d0 EXPR(4304=0x10d0) ABS 
L10b8 EXPR(4280=0x10b8) ABS 
L10b2 EXPR(4274=0x10b2) ABS 
L1093 EXPR(4243=0x1093) ABS 
L1085 EXPR(4229=0x1085) ABS 
L107b EXPR(4219=0x107b) ABS 
S10a1 EXPR(4257=0x10a1) ABS 
L104a EXPR(4170=0x104a) ABS 
L1060 EXPR(4192=0x1060) ABS 
L106b EXPR(4203=0x106b) ABS 
L1076 EXPR(4214=0x1076) ABS 
L102e EXPR(4142=0x102e) ABS 
L1038 EXPR(4152=0x1038) ABS 
L1033 EXPR(4147=0x1033) ABS 
L1015 EXPR(4117=0x1015) ABS 
L1008 EXPR(4104=0x1008) ABS 
PlaySid EXPR(4102=0x1006) UNUSED ABS 
d412_sVoc3Control EXPR(47122=0xb812) EQU 
d40b_sVoc2Control EXPR(47115=0xb80b) EQU 
d404_sVoc1Control EXPR(47108=0xb804) EQU 
d400_sVoc1FreqLo EXPR(47104=0xb800) EQU 
continue24542 EXPR(4009=0xfa9) ABS 
putbut EXPR(4013=0xfad) ABS 
startupsoundloop EXPR(4655=0x122f) ABS 
InitSid EXPR(4030=0xfbe) ABS 
irq EXPR(3991=0xf97) ABS 
runthesound EXPR(3961=0xf79) UNUSED ABS 
error_sound EXPR(3955=0xf73) UNUSED ABS 
ded EXPR(3947=0xf6b) ABS 
sd_writesector EXPR(5204=0x1454) ABS 
dummyloop EXPR(3882=0xf2a) ABS 
sd_readsector EXPR(5110=0x13f6) ABS 
goin EXPR(3936=0xf60) ABS 
rxpoll EXPR(4777=0x12a9) ABS 
w_acia_full EXPR(4805=0x12c5) ABS 
hehe EXPR(3903=0xf3f) ABS 
reset EXPR(3840=0xf00) UNUSED ABS 
LF EXPR(10=0xa) EQU 
CR EXPR(13=0xd) EQU 
endbuf EXPR(2304=0x900) UNUSED EQU 
buffer EXPR(1792=0x700) EQU 
fat32_workspace EXPR(1280=0x500) EQU 
path EXPR(1024=0x400) UNUSED EQU 
zp_fat32_variables EXPR(79=0x4f) EQU 
zp_sd_currentsector EXPR(74=0x4a) EQU 
zp_sd_address EXPR(72=0x48) EQU 
donefact EXPR(1=0x1) EQU 
irqcount EXPR(0=0x0) EQU 
ACIAData EXPR(32768=0x8000) UNUSED EQU 
ACIAStatus EXPR(32769=0x8001) UNUSED EQU 
ACIACommand EXPR(32770=0x8002) UNUSED EQU 
ACIAControl EXPR(32771=0x8003) UNUSED EQU 
ACIA EXPR(32768=0x8000) EQU 
__RPTCNT EXPR(-1=0xffff) INTERNAL 
__VASM EXPR(0=0x0) INTERNAL 

There have been no errors.
