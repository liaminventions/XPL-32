F00:0001       ; Save test
F00:0002       ; 
F00:0003       ; this code is just for debugging the sd card saving system.
F00:0004       ; i will use ben eater's debugger for this.
F00:0005       
F00:0006       ACIA = $8000
F00:0007       ACIAControl = ACIA+3
F00:0008       ACIACommand = ACIA+2
F00:0009       ACIAStatus = ACIA+1
F00:0010       ACIAData = ACIA
F00:0011       
F00:0012       irqcount = $00
F00:0013       donefact = $01
F00:0014       
F00:0015       ; sd card:
F00:0016       zp_sd_address = $48         ; 2 bytes
F00:0017       zp_sd_currentsector = $4a   ; 4 bytes
F00:0018       zp_fat32_variables = $4f    ; 24 bytes
F00:0019       ; only used during fat32 processing
F00:0020       path = $400		    ; page
F00:0021       fat32_workspace = $500      ; two pages
F00:0022       buffer = $700		    ; two pages
F00:0023       endbuf = $900
F00:0024       
F00:0025       XYLODSAV2 = $64 ; 2
F00:0026       
F00:0027       CR=13
F00:0028       LF=10
F00:0029       
F00:0030         .org $0f00
F00:0031       
F00:0032       reset:
F00:0033         ;jsr sd_init
F00:0034         ;bcs sd_fail
F00:0035         ; sd init done
F00:0036         ;lda #'S'
F00:0037         ;sta ACIAData
F00:0038         ;jsr fat32_init
F00:0039         ;bcs faterror
F00:0040         ; fat32 init done
F00:0041         ;jsr txpoll
F00:0042         ;lda #'F'
F00:0043         ;sta ACIAData
F00:0044       ; Set the last found free cluster to 0.
F00:0045         lda #0
               S01:00000F00:  A9 00
F00:0046         sta fat32_lastfoundfreecluster
               S01:00000F02:  85 67
F00:0047         sta fat32_lastfoundfreecluster+1
               S01:00000F04:  85 68
F00:0048         sta fat32_lastfoundfreecluster+2
               S01:00000F06:  85 69
F00:0049         sta fat32_lastfoundfreecluster+3
               S01:00000F08:  85 6A
F00:0050         ; init done
F00:0051       ;initdone:
F00:0052         ; now make a dummy file.
F00:0053         ;ldx #0
F00:0054       ;dummyloop:
F00:0055         ;txa
F00:0056         ;sta $0900,x
F00:0057         ;sta $0a00,x
F00:0058         ;inx
F00:0059         ;bne dummyloop
F00:0060         ; add an EOF
F00:0061         ;lda #0
F00:0062         ;sta $0b00
F00:0063         ;sta $0701
F00:0064         ;sta $0702
F00:0065       
F00:0066         jmp MEMORY_SAVE ; OK, here we go.
               S01:00000F0A:  4C FD 19
F00:0067       
F00:0068       ;faterror:
F00:0069       ;  lda #'f'
F00:0070       ;  jsr print_chara
F00:0071       ;  jmp doneloop
F00:0072       ;sd_fail:
F00:0073       ;  lda #'s'
F00:0074       ;  jsr print_chara
F00:0075       ;  jmp doneloop
F00:0076       
F00:0077         .include "errors.s"
F01:0001       error_sound:
F01:0002         lda #$55
               S01:00000F0D:  A9 55
F01:0003         sta donefact
               S01:00000F0F:  85 01
F01:0004         stz irqcount	; reset irq count
               S01:00000F11:  64 00
F01:0005       
F01:0006       runthesound:
F01:0007         sei		; turn off irqs
               S01:00000F13:  78
F01:0008         lda #<irq
               S01:00000F14:  A9 31
F01:0009         sta $7ffe
               S01:00000F16:  8D FE 7F
F01:0010         lda #>irq
               S01:00000F19:  A9 0F
F01:0011         sta $7fff	; store vectors
               S01:00000F1B:  8D FF 7F
F01:0012         lda #$c0
               S01:00000F1E:  A9 C0
F01:0013         sta $b00e	
               S01:00000F20:  8D 0E B0
F01:0014         lda #0 ; Song Number
               S01:00000F23:  A9 00
F01:0015         jsr InitSid
               S01:00000F25:  20 58 0F
F01:0016         lda #$40
               S01:00000F28:  A9 40
F01:0017         sta $b00d
               S01:00000F2A:  8D 0D B0
F01:0018         cli
               S01:00000F2D:  58
F01:0019         jmp startupsoundloop
               S01:00000F2E:  4C 2F 12
F01:0020       
F01:0021       irq:
F01:0022         lda #$40
               S01:00000F31:  A9 40
F01:0023         sta $b00d
               S01:00000F33:  8D 0D B0
F01:0024         jsr putbut		; refresh timers
               S01:00000F36:  20 47 0F
F01:0025         inc irqcount		; a irq has occurred
               S01:00000F39:  E6 00
F01:0026         lda irqcount
               S01:00000F3B:  A5 00
F01:0027         cmp #$40		; if $32 irqs (end of the error sound)
               S01:00000F3D:  C9 40
F01:0028         bne continue24542 	; end the stream
               S01:00000F3F:  D0 02
F01:0029         stz donefact		; its done, tell the loop
               S01:00000F41:  64 01
F01:0030       continue24542:
F01:0031         jsr $1006
               S01:00000F43:  20 06 10
F01:0032         rti			; exit
               S01:00000F46:  40
F01:0033       
F01:0034       putbut:
F01:0035         ldx #$9e
               S01:00000F47:  A2 9E
F01:0036         stx $b004
               S01:00000F49:  8E 04 B0
F01:0037         stx $b006
               S01:00000F4C:  8E 06 B0
F01:0038         ldx #$0f  ; 250Hz IRQ
               S01:00000F4F:  A2 0F
F01:0039         stx $b005
               S01:00000F51:  8E 05 B0
F01:0040         stx $b007
               S01:00000F54:  8E 07 B0
F01:0041         rts
               S01:00000F57:  60
F01:0042       InitSid:
F01:0043         jsr putbut
               S01:00000F58:  20 47 0F
F01:0044         jmp $1103
               S01:00000F5B:  4C 03 11
F01:0045       
F01:0046         .org $1006
F01:0047       
F01:0048         .include "errorsound.s"
F02:0001       d400_sVoc1FreqLo = $b800
F02:0002       d404_sVoc1Control = $b804
F02:0003       d40b_sVoc2Control = $b80b
F02:0004       d412_sVoc3Control = $b812
F02:0005       
F02:0006         .org $1006
F02:0007       
F02:0008       PlaySid             ldx #$18
               S02:00001006:  A2 18
F02:0009       L1008               lda $04,x
               S02:00001008:  B5 04
F02:0010                           sta d400_sVoc1FreqLo,x
               S02:0000100A:  9D 00 B8
F02:0011                           dex
               S02:0000100D:  CA
F02:0012                           bpl L1008
               S02:0000100E:  10 F8
F02:0013                           dec $02
               S02:00001010:  C6 02
F02:0014                           bmi L1015
               S02:00001012:  30 01
F02:0015                           rts
               S02:00001014:  60
F02:0016                           
F02:0017       L1015               stx $02
               S02:00001015:  86 02
F02:0018                           lda $03
               S02:00001017:  A5 03
F02:0019                           bne L1033
               S02:00001019:  D0 18
F02:0020                           jsr $001f
               S02:0000101B:  20 1F 00
F02:0021                           beq L1038
               S02:0000101E:  F0 18
F02:0022                           cmp #$a0
               S02:00001020:  C9 A0
F02:0023                           bcs L102e
               S02:00001022:  B0 0A
F02:0024                           sta $2a
               S02:00001024:  85 2A
F02:0025                           jsr $001f
               S02:00001026:  20 1F 00
F02:0026                           sta $29
               S02:00001029:  85 29
F02:0027                           jmp L1076
               S02:0000102B:  4C 76 10
F02:0028                           
F02:0029       L102e               sec
               S02:0000102E:  38
F02:0030                           sbc #$9f
               S02:0000102F:  E9 9F
F02:0031                           sta $03
               S02:00001031:  85 03
F02:0032       L1033               dec $03
               S02:00001033:  C6 03
F02:0033                           jmp L1076
               S02:00001035:  4C 76 10
F02:0034                           
F02:0035       L1038               jsr $001f
               S02:00001038:  20 1F 00
F02:0036                           cmp #$fd
               S02:0000103B:  C9 FD
F02:0037                           beq L106b
               S02:0000103D:  F0 2C
F02:0038                           cmp #$fe
               S02:0000103F:  C9 FE
F02:0039                           beq L1060
               S02:00001041:  F0 1D
F02:0040                           cmp #$ff
               S02:00001043:  C9 FF
F02:0041                           beq L104a
               S02:00001045:  F0 03
F02:0042                           sta $02
               S02:00001047:  85 02
F02:0043                           rts
               S02:00001049:  60
F02:0044                           
F02:0045       L104a               lda #$00
               S02:0000104A:  A9 00
F02:0046                           sta d404_sVoc1Control
               S02:0000104C:  8D 04 B8
F02:0047                           sta d40b_sVoc2Control
               S02:0000104F:  8D 0B B8
F02:0048                           sta d412_sVoc3Control
               S02:00001052:  8D 12 B8
F02:0049                           lda #$5e
               S02:00001055:  A9 5E
F02:0050                           sta $26
               S02:00001057:  85 26
F02:0051                           lda #$10
               S02:00001059:  A9 10
F02:0052                           sta $27
               S02:0000105B:  85 27
F02:0053                           rts
               S02:0000105D:  60
F02:0054                           
F02:0055                             .byte $ff, $00 
               S02:0000105E:  FF
               S02:0000105F:  00
F02:0056       L1060               lda $1d
               S02:00001060:  A5 1D
F02:0057                           sta $26
               S02:00001062:  85 26
F02:0058                           lda $1e
               S02:00001064:  A5 1E
F02:0059                           sta $27
               S02:00001066:  85 27
F02:0060                           jmp L1015
               S02:00001068:  4C 15 10
F02:0061                           
F02:0062       L106b               lda $26
               S02:0000106B:  A5 26
F02:0063                           sta $1d
               S02:0000106D:  85 1D
F02:0064                           lda $27
               S02:0000106F:  A5 27
F02:0065                           sta $1e
               S02:00001071:  85 1E
F02:0066                           jmp L1015
               S02:00001073:  4C 15 10
F02:0067                           
F02:0068       L1076               jsr S10a1
               S02:00001076:  20 A1 10
F02:0069                           lda #$f8
               S02:00001079:  A9 F8
F02:0070       L107b               clc
               S02:0000107B:  18
F02:0071                           adc #$07
               S02:0000107C:  69 07
F02:0072                           pha
               S02:0000107E:  48
F02:0073                           tax
               S02:0000107F:  AA
F02:0074                           jsr $001f
               S02:00001080:  20 1F 00
F02:0075                           lsr a
               S02:00001083:  4A
F02:0076                           php
               S02:00001084:  08
F02:0077       L1085               inx
               S02:00001085:  E8
F02:0078                           lsr a
               S02:00001086:  4A
F02:0079                           bcs L1093
               S02:00001087:  B0 0A
F02:0080                           bne L1085
               S02:00001089:  D0 FA
F02:0081                           plp
               S02:0000108B:  28
F02:0082                           pla
               S02:0000108C:  68
F02:0083                           bcs L107b
               S02:0000108D:  B0 EC
F02:0084                           jsr S10a1
               S02:0000108F:  20 A1 10
F02:0085                           rts
               S02:00001092:  60
F02:0086                           
F02:0087       L1093               pha
               S02:00001093:  48
F02:0088                           ldy $ffff,x
               S02:00001094:  BC FF FF
F02:0089                           jsr $001f
               S02:00001097:  20 1F 00
F02:0090                           sta $0004,y
               S02:0000109A:  99 04 00
F02:0091                           pla
               S02:0000109D:  68
F02:0092                           jmp L1085
               S02:0000109E:  4C 85 10
F02:0093                           
F02:0094       S10a1               ldy $26
               S02:000010A1:  A4 26
F02:0095                           ldx $29
               S02:000010A3:  A6 29
F02:0096                           sty $29
               S02:000010A5:  84 29
F02:0097                           stx $26
               S02:000010A7:  86 26
F02:0098                           ldy $27
               S02:000010A9:  A4 27
F02:0099                           ldx $2a
               S02:000010AB:  A6 2A
F02:0100                           sty $2a
               S02:000010AD:  84 2A
F02:0101                           stx $27
               S02:000010AF:  86 27
F02:0102                           rts
               S02:000010B1:  60
F02:0103                           
F02:0104       L10b2               sty $26
               S02:000010B2:  84 26
F02:0105                           stx $27
               S02:000010B4:  86 27
F02:0106                           ldx #$06
               S02:000010B6:  A2 06
F02:0107       L10b8               lda $10c6,x
               S02:000010B8:  BD C6 10
F02:0108                           sta $1f,x
               S02:000010BB:  95 1F
F02:0109                           dex
               S02:000010BD:  CA
F02:0110                           bpl L10b8
               S02:000010BE:  10 F8
F02:0111                           lda #$60
               S02:000010C0:  A9 60
F02:0112                           sta $28
               S02:000010C2:  85 28
F02:0113                           bne L10d0
               S02:000010C4:  D0 0A
F02:0114                           inc $26
               S02:000010C6:  E6 26
F02:0115                           bne L10cc
               S02:000010C8:  D0 02
F02:0116                           inc $27
               S02:000010CA:  E6 27
F02:0117       L10cc               lda $ffff
               S02:000010CC:  AD FF FF
F02:0118                           rts
               S02:000010CF:  60
F02:0119                           
F02:0120       L10d0               jsr $001f
               S02:000010D0:  20 1F 00
F02:0121                           sta $dc04
               S02:000010D3:  8D 04 DC
F02:0122                           jsr $001f
               S02:000010D6:  20 1F 00
F02:0123                           sta $dc05
               S02:000010D9:  8D 05 DC
F02:0124                           jsr $001f
               S02:000010DC:  20 1F 00
F02:0125                           sta $29
               S02:000010DF:  85 29
F02:0126                           jsr $001f
               S02:000010E1:  20 1F 00
F02:0127                           sta $2a
               S02:000010E4:  85 2A
F02:0128                           inc $26
               S02:000010E6:  E6 26
F02:0129                           bne L10ec
               S02:000010E8:  D0 02
F02:0130                           inc $27
               S02:000010EA:  E6 27
F02:0131       L10ec               lda $26
               S02:000010EC:  A5 26
F02:0132                           sta $1095
               S02:000010EE:  8D 95 10
F02:0133                           lda $27
               S02:000010F1:  A5 27
F02:0134                           sta $1096
               S02:000010F3:  8D 96 10
F02:0135                           ldx #$1c
               S02:000010F6:  A2 1C
F02:0136                           lda #$00
               S02:000010F8:  A9 00
F02:0137       L10fa               sta $02,x
               S02:000010FA:  95 02
F02:0138                           dex
               S02:000010FC:  CA
F02:0139                           bpl L10fa
               S02:000010FD:  10 FB
F02:0140                           jsr S10a1
               S02:000010FF:  20 A1 10
F02:0141                           rts
               S02:00001102:  60
F02:0142                           
F02:0143       InitSid2            ldy #$09
               S02:00001103:  A0 09
F02:0144                           ldx #$11
               S02:00001105:  A2 11
F02:0145                           jmp L10b2
               S02:00001107:  4C B2 10
F02:0146       
F02:0147         .binary "errorsound.bin"
               S02:0000110A:  F0 0F 77 11 01 00 12 0D 04 05 0B 14 08 09 07 06
               S02:0000111A:  0C 03 0E 0F 10 11 17 13 0A 15 16 18 02 00 B6 00
F02:0148       ;          ^^^^^^^^^^^
F02:0149       ; put your data file here.
F02:0150       
F02:0151       
F01:0049       
F01:0050       startupsoundloop:	
F01:0051         lda donefact		; loop only if the sound is not done
               S02:0000122F:  A5 01
F01:0052         bne startupsoundloop
               S02:00001231:  D0 FC
F01:0053         stz $b00e		; if done disable irqs
               S02:00001233:  9C 0E B0
F01:0054         stz $b00d
               S02:00001236:  9C 0D B0
F01:0055         sei
               S02:00001239:  78
F01:0056         lda $c0		; clear irq vectors
               S02:0000123A:  A5 C0
F01:0057         sta $7fff
               S02:0000123C:  8D FF 7F
F01:0058         stz $7ffe
               S02:0000123F:  9C FE 7F
F01:0059         jsr clear_sid
               S02:00001242:  20 49 12
F01:0060         rts
               S02:00001245:  60
F01:0061         rts
               S02:00001246:  60
F01:0062         rts
               S02:00001247:  60
F01:0063         rts
               S02:00001248:  60
F01:0064       
F01:0065       clear_sid
F01:0066         ldx #$17 ; 17 cuz no pop
               S02:00001249:  A2 17
F01:0067       csid
F01:0068         stz $b800,x
               S02:0000124B:  9E 00 B8
F01:0069         dex
               S02:0000124E:  CA
F01:0070         bne csid
               S02:0000124F:  D0 FA
F01:0071         rts
               S02:00001251:  60
F01:0072       
F01:0073       
F00:0078         .include "hwconfig.s"
F03:0001       PORTB = $b000
F03:0002       PORTA = $b001
F03:0003       DDRB = $b002
F03:0004       DDRA = $b003
F03:0005       
F03:0006       LCD_E  = %10000000
F03:0007       LCD_RW = %01000000
F03:0008       LCD_RS = %00100000
F03:0009       
F03:0010       SD_CS   = %00010000
F03:0011       SD_SCK  = %00001000
F03:0012       SD_MOSI = %00000100
F03:0013       SD_MISO = %00000010
F03:0014       
F03:0015       PORTA_OUTPUTPINS = LCD_E | LCD_RW | LCD_RS | SD_CS | SD_SCK | SD_MOSI
F03:0016       
F03:0017       via_init:
F03:0018         lda #%11111111          ; Set all pins on port B to output
               S02:00001252:  A9 FF
F03:0019         sta DDRB
               S02:00001254:  8D 02 B0
F03:0020         lda #PORTA_OUTPUTPINS   ; Set various pins on port A to output
               S02:00001257:  A9 FC
F03:0021         sta DDRA
               S02:00001259:  8D 03 B0
F03:0022         rts
               S02:0000125C:  60
F03:0023       
F03:0024       
F00:0079         .include "libacia.s"
F04:0001       ;       ------------------ 6551 ACIA Subroutine Library -------------------
F04:0002       ; Includes:
F04:0003       ; acia_init       - Initializes the ACIA
F04:0004       ; print_hex_acia  - Prints a hex value in A
F04:0005       ; crlf		  - Prints <CR> followed by <LF>
F04:0006       ; clear_display   - Sends a <CLS> command
F04:0007       ; txpoll          - Polls the TX bit to see if the ACIA is ready
F04:0008       ; print_chara     - Prints a Character that is stored in A
F04:0009       ; print_char_acia - Same as print_chara
F04:0010       ; ascii_home      - Home the cursor
F04:0011       ; w_acia_full     - Print a NULL-Termintated String with >HIGH in Y and <LOW in X
F04:0012       
F04:0013       acia_init:
F04:0014         pha
               S02:0000125D:  48
F04:0015         lda #%00001011          ; No parity, no echo, no interrupt
               S02:0000125E:  A9 0B
F04:0016         sta $8002
               S02:00001260:  8D 02 80
F04:0017         lda #%00011111          ; 1 stop bit, 8 data bits, 19200 baud
               S02:00001263:  A9 1F
F04:0018         sta $8003
               S02:00001265:  8D 03 80
F04:0019         pla
               S02:00001268:  68
F04:0020         rts
               S02:00001269:  60
F04:0021       
F04:0022       print_hex_acia:
F04:0023         pha
               S02:0000126A:  48
F04:0024         ror
               S02:0000126B:  6A
F04:0025         ror
               S02:0000126C:  6A
F04:0026         ror
               S02:0000126D:  6A
F04:0027         ror
               S02:0000126E:  6A
F04:0028         jsr print_nybble   ; This is just som usful hex cod
               S02:0000126F:  20 73 12
F04:0029         pla
               S02:00001272:  68
F04:0030       print_nybble:
F04:0031         and #15
               S02:00001273:  29 0F
F04:0032         cmp #10
               S02:00001275:  C9 0A
F04:0033         bmi cskipletter
               S02:00001277:  30 02
F04:0034         adc #6
               S02:00001279:  69 06
F04:0035       cskipletter:
F04:0036         adc #48
               S02:0000127B:  69 30
F04:0037        ; jsr print_char
F04:0038         jsr print_chara
               S02:0000127D:  20 B1 12
F04:0039         rts
               S02:00001280:  60
F04:0040       
F04:0041       crlf:
F04:0042         pha
               S02:00001281:  48
F04:0043         txa
               S02:00001282:  8A
F04:0044         pha
               S02:00001283:  48
F04:0045         tya
               S02:00001284:  98
F04:0046         pha
               S02:00001285:  48
F04:0047         lda #$0d
               S02:00001286:  A9 0D
F04:0048         jsr print_chara
               S02:00001288:  20 B1 12
F04:0049         lda #$0a
               S02:0000128B:  A9 0A
F04:0050         jsr print_chara
               S02:0000128D:  20 B1 12
F04:0051         pla
               S02:00001290:  68
F04:0052         tay
               S02:00001291:  A8
F04:0053         pla
               S02:00001292:  68
F04:0054         tax
               S02:00001293:  AA
F04:0055         pla
               S02:00001294:  68
F04:0056         rts
               S02:00001295:  60
F04:0057       
F04:0058       cleardisplay:
F04:0059         pha
               S02:00001296:  48
F04:0060         jsr txpoll  ; Poll the TX bit
               S02:00001297:  20 A1 12
F04:0061         lda #12     ; Print decimal 12 (CLS)
               S02:0000129A:  A9 0C
F04:0062         sta $8000
               S02:0000129C:  8D 00 80
F04:0063         pla
               S02:0000129F:  68
F04:0064         rts
               S02:000012A0:  60
F04:0065       
F04:0066       txpoll:
F04:0067         lda $8001
               S02:000012A1:  AD 01 80
F04:0068         and #$10    ; Poll the TX bit
               S02:000012A4:  29 10
F04:0069         beq txpoll
               S02:000012A6:  F0 F9
F04:0070         rts
               S02:000012A8:  60
F04:0071       
F04:0072       rxpoll:
F04:0073         lda $8001
               S02:000012A9:  AD 01 80
F04:0074         and #$08    ; Poll the RX bit
               S02:000012AC:  29 08
F04:0075         beq rxpoll
               S02:000012AE:  F0 F9
F04:0076         rts
               S02:000012B0:  60
F04:0077       
F04:0078       
F04:0079       print_chara:
F04:0080         pha
               S02:000012B1:  48
F04:0081         jsr txpoll  ; Poll the TX bit
               S02:000012B2:  20 A1 12
F04:0082         pla
               S02:000012B5:  68
F04:0083         sta $8000   ; Print character from A
               S02:000012B6:  8D 00 80
F04:0084         rts
               S02:000012B9:  60
F04:0085       
F04:0086       print_char_acia:
F04:0087         jmp print_chara  ; Same as "print_chara"
               S02:000012BA:  4C B1 12
F04:0088       
F04:0089       ascii_home:
F04:0090         pha
               S02:000012BD:  48
F04:0091         lda #1
               S02:000012BE:  A9 01
F04:0092         jsr print_chara  ; Print 1 (HOME)
               S02:000012C0:  20 B1 12
F04:0093         pla
               S02:000012C3:  68
F04:0094         rts
               S02:000012C4:  60
F04:0095       
F04:0096       w_acia_full:
F04:0097         pha
               S02:000012C5:  48
F04:0098         lda $ff
               S02:000012C6:  A5 FF
F04:0099         pha        ; Push Previous States onto the stack
               S02:000012C8:  48
F04:0100         lda $fe
               S02:000012C9:  A5 FE
F04:0101         pha
               S02:000012CB:  48
F04:0102         sty $ff    ; Set Y as the Upper Address (8-15)
               S02:000012CC:  84 FF
F04:0103         stx $fe    ; Set X as the Lower Adderss (0-7)
               S02:000012CE:  86 FE
F04:0104         ldy #0
               S02:000012D0:  A0 00
F04:0105       acia_man:
F04:0106         jsr txpoll   ; Poll TX
               S02:000012D2:  20 A1 12
F04:0107         lda ($fe),y  ; Load the Address
               S02:000012D5:  B1 FE
F04:0108         sta $8000    ; Print what is at the address
               S02:000012D7:  8D 00 80
F04:0109         beq endwacia ; If Done, End
               S02:000012DA:  F0 04
F04:0110         iny          ; Next Character
               S02:000012DC:  C8
F04:0111         jmp acia_man ; Back to the top
               S02:000012DD:  4C D2 12
F04:0112       endwacia:
F04:0113         pla
               S02:000012E0:  68
F04:0114         sta $fe
               S02:000012E1:  85 FE
F04:0115         pla          ; Restore Variables
               S02:000012E3:  68
F04:0116         sta $ff
               S02:000012E4:  85 FF
F04:0117         pla
               S02:000012E6:  68
F04:0118         rts
               S02:000012E7:  60
F04:0119       
F00:0080         .include "libsd.s"
F05:0001       ; SD card interface module
F05:0002       ;
F05:0003       ; Requires zero-page variable storage:
F05:0004       ;   zp_sd_address - 2 bytes
F05:0005       ;   zp_sd_currentsector - 4 bytes
F05:0006       
F05:0007       
F05:0008       sd_init:
F05:0009         ; Let the SD card boot up, by pumping the clock with SD CS disabled
F05:0010       
F05:0011         ; We need to apply around 80 clock pulses with CS and MOSI high.
F05:0012         ; Normally MOSI doesn't matter when CS is high, but the card is
F05:0013         ; not yet is SPI mode, and in this non-SPI state it does care.
F05:0014       
F05:0015         lda #SD_CS | SD_MOSI
               S02:000012E8:  A9 14
F05:0016         ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
               S02:000012EA:  A2 A0
F05:0017       .preinitloop:
F05:0018         eor #SD_SCK
               S02:000012EC:  49 08
F05:0019         sta PORTA
               S02:000012EE:  8D 01 B0
F05:0020         dex
               S02:000012F1:  CA
F05:0021         bne .preinitloop
               S02:000012F2:  D0 F8
F05:0022         
F05:0023       
F05:0024       .cmd0 ; GO_IDLE_STATE - resets card to idle state, and SPI mode
F05:0025         lda #<sd_cmd0_bytes
               S02:000012F4:  A9 5B
F05:0026         sta zp_sd_address
               S02:000012F6:  85 48
F05:0027         lda #>sd_cmd0_bytes
               S02:000012F8:  A9 13
F05:0028         sta zp_sd_address+1
               S02:000012FA:  85 49
F05:0029       
F05:0030         jsr sd_sendcommand
               S02:000012FC:  20 AD 13
F05:0031       
F05:0032         ; Expect status response $01 (not initialized)
F05:0033         cmp #$01
               S02:000012FF:  C9 01
F05:0034         bne .initfailed
               S02:00001301:  D0 50
F05:0035       
F05:0036       .cmd8 ; SEND_IF_COND - tell the card how we want it to operate (3.3V, etc)
F05:0037         lda #<sd_cmd8_bytes
               S02:00001303:  A9 61
F05:0038         sta zp_sd_address
               S02:00001305:  85 48
F05:0039         lda #>sd_cmd8_bytes
               S02:00001307:  A9 13
F05:0040         sta zp_sd_address+1
               S02:00001309:  85 49
F05:0041       
F05:0042         jsr sd_sendcommand
               S02:0000130B:  20 AD 13
F05:0043       
F05:0044         ; Expect status response $01 (not initialized)
F05:0045         cmp #$01
               S02:0000130E:  C9 01
F05:0046         bne .initfailed
               S02:00001310:  D0 41
F05:0047       
F05:0048         ; Read 32-bit return value, but ignore it
F05:0049         jsr sd_readbyte
               S02:00001312:  20 73 13
F05:0050         jsr sd_readbyte
               S02:00001315:  20 73 13
F05:0051         jsr sd_readbyte
               S02:00001318:  20 73 13
F05:0052         jsr sd_readbyte
               S02:0000131B:  20 73 13
F05:0053       
F05:0054       .cmd55 ; APP_CMD - required prefix for ACMD commands
F05:0055         lda #<sd_cmd55_bytes
               S02:0000131E:  A9 67
F05:0056         sta zp_sd_address
               S02:00001320:  85 48
F05:0057         lda #>sd_cmd55_bytes
               S02:00001322:  A9 13
F05:0058         sta zp_sd_address+1
               S02:00001324:  85 49
F05:0059       
F05:0060         jsr sd_sendcommand
               S02:00001326:  20 AD 13
F05:0061       
F05:0062         ; Expect status response $01 (not initialized)
F05:0063         cmp #$01
               S02:00001329:  C9 01
F05:0064         bne .initfailed
               S02:0000132B:  D0 26
F05:0065       
F05:0066       .cmd41 ; APP_SEND_OP_COND - send operating conditions, initialize card
F05:0067         lda #<sd_cmd41_bytes
               S02:0000132D:  A9 6D
F05:0068         sta zp_sd_address
               S02:0000132F:  85 48
F05:0069         lda #>sd_cmd41_bytes
               S02:00001331:  A9 13
F05:0070         sta zp_sd_address+1
               S02:00001333:  85 49
F05:0071       
F05:0072         jsr sd_sendcommand
               S02:00001335:  20 AD 13
F05:0073       
F05:0074         ; Status response $00 means initialised
F05:0075         cmp #$00
               S02:00001338:  C9 00
F05:0076         beq .initialized
               S02:0000133A:  F0 11
F05:0077       
F05:0078         ; Otherwise expect status response $01 (not initialized)
F05:0079         cmp #$01
               S02:0000133C:  C9 01
F05:0080         bne .initfailed
               S02:0000133E:  D0 13
F05:0081       
F05:0082         ; Not initialized yet, so wait a while then try again.
F05:0083          	; This retry is important, to give the card time to initialize.
F05:0084       
F05:0085         ldx #0
               S02:00001340:  A2 00
F05:0086         ldy #0
               S02:00001342:  A0 00
F05:0087       .delayloop
F05:0088         dey
               S02:00001344:  88
F05:0089         bne .delayloop
               S02:00001345:  D0 FD
F05:0090         dex
               S02:00001347:  CA
F05:0091         bne .delayloop
               S02:00001348:  D0 FA
F05:0092       
F05:0093         jmp .cmd55
               S02:0000134A:  4C 1E 13
F05:0094       
F05:0095       
F05:0096       .initialized
F05:0097         lda #'Y'
               S02:0000134D:  A9 59
F05:0098         jsr print_chara
               S02:0000134F:  20 B1 12
F05:0099         rts
               S02:00001352:  60
F05:0100       
F05:0101       .initfailed
F05:0102         lda #'X'
               S02:00001353:  A9 58
F05:0103         jsr print_chara
               S02:00001355:  20 B1 12
F05:0104       .loop
F05:0105         jmp .loop
               S02:00001358:  4C 58 13
F05:0106       
F05:0107       
F05:0108       sd_cmd0_bytes
F05:0109         .byte $40, $00, $00, $00, $00, $95
               S02:0000135B:  40
               S02:0000135C:  00
               S02:0000135D:  00
               S02:0000135E:  00
               S02:0000135F:  00
               S02:00001360:  95
F05:0110       sd_cmd8_bytes
F05:0111         .byte $48, $00, $00, $01, $aa, $87
               S02:00001361:  48
               S02:00001362:  00
               S02:00001363:  00
               S02:00001364:  01
               S02:00001365:  AA
               S02:00001366:  87
F05:0112       sd_cmd55_bytes
F05:0113         .byte $77, $00, $00, $00, $00, $01
               S02:00001367:  77
               S02:00001368:  00
               S02:00001369:  00
               S02:0000136A:  00
               S02:0000136B:  00
               S02:0000136C:  01
F05:0114       sd_cmd41_bytes
F05:0115         .byte $69, $40, $00, $00, $00, $01
               S02:0000136D:  69
               S02:0000136E:  40
               S02:0000136F:  00
               S02:00001370:  00
               S02:00001371:  00
               S02:00001372:  01
F05:0116       
F05:0117       
F05:0118       
F05:0119       sd_readbyte:
F05:0120         ; Enable the card and tick the clock 8 times with MOSI high, 
F05:0121         ; capturing bits from MISO and returning them
F05:0122       
F05:0123         ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
               S02:00001373:  A2 FE
F05:0124       
F05:0125       .loop:
F05:0126       
F05:0127         lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
               S02:00001375:  A9 04
F05:0128         sta PORTA
               S02:00001377:  8D 01 B0
F05:0129       
F05:0130         lda #SD_MOSI | SD_SCK       ; toggle the clock high
               S02:0000137A:  A9 0C
F05:0131         sta PORTA
               S02:0000137C:  8D 01 B0
F05:0132       
F05:0133         lda PORTA                   ; read next bit
               S02:0000137F:  AD 01 B0
F05:0134         and #SD_MISO
               S02:00001382:  29 02
F05:0135       
F05:0136         clc                         ; default to clearing the bottom bit
               S02:00001384:  18
F05:0137         beq .bitnotset              ; unless MISO was set
               S02:00001385:  F0 01
F05:0138         sec                         ; in which case get ready to set the bottom bit
               S02:00001387:  38
F05:0139       .bitnotset:
F05:0140       
F05:0141         txa                         ; transfer partial result from X
               S02:00001388:  8A
F05:0142         rol                         ; rotate carry bit into read result, and loop bit into carry
               S02:00001389:  2A
F05:0143         tax                         ; save partial result back to X
               S02:0000138A:  AA
F05:0144         
F05:0145         bcs .loop                   ; loop if we need to read more bits
               S02:0000138B:  B0 E8
F05:0146       
F05:0147         rts
               S02:0000138D:  60
F05:0148       
F05:0149       
F05:0150       sd_writebyte:
F05:0151         ; Tick the clock 8 times with descending bits on MOSI
F05:0152         ; SD communication is mostly half-duplex so we ignore anything it sends back here
F05:0153       
F05:0154         ldx #8                      ; send 8 bits
               S02:0000138E:  A2 08
F05:0155       
F05:0156       .loop:
F05:0157         asl                         ; shift next bit into carry
               S02:00001390:  0A
F05:0158         tay                         ; save remaining bits for later
               S02:00001391:  A8
F05:0159       
F05:0160         lda #0
               S02:00001392:  A9 00
F05:0161         bcc .sendbit                ; if carry clear, don't set MOSI for this bit
               S02:00001394:  90 02
F05:0162         ora #SD_MOSI
               S02:00001396:  09 04
F05:0163       
F05:0164       .sendbit:
F05:0165         sta PORTA                   ; set MOSI (or not) first with SCK low
               S02:00001398:  8D 01 B0
F05:0166         eor #SD_SCK
               S02:0000139B:  49 08
F05:0167         sta PORTA                   ; raise SCK keeping MOSI the same, to send the bit
               S02:0000139D:  8D 01 B0
F05:0168       
F05:0169         tya                         ; restore remaining bits to send
               S02:000013A0:  98
F05:0170       
F05:0171         dex
               S02:000013A1:  CA
F05:0172         bne .loop                   ; loop if there are more bits to send
               S02:000013A2:  D0 EC
F05:0173       
F05:0174         rts
               S02:000013A4:  60
F05:0175       
F05:0176       
F05:0177       sd_waitresult:
F05:0178         ; Wait for the SD card to return something other than $ff
F05:0179         jsr sd_readbyte
               S02:000013A5:  20 73 13
F05:0180         cmp #$ff
               S02:000013A8:  C9 FF
F05:0181         beq sd_waitresult
               S02:000013AA:  F0 F9
F05:0182         rts
               S02:000013AC:  60
F05:0183       
F05:0184       
F05:0185       sd_sendcommand:
F05:0186         ; Debug print which command is being executed
F05:0187         ;jsr cleardisplay
F05:0188       
F05:0189         lda #'c'
               S02:000013AD:  A9 63
F05:0190         jsr print_chara
               S02:000013AF:  20 B1 12
F05:0191         ldx #0
               S02:000013B2:  A2 00
F05:0192         lda (zp_sd_address,x)
               S02:000013B4:  A1 48
F05:0193         jsr print_hex_acia
               S02:000013B6:  20 6A 12
F05:0194       
F05:0195         lda #SD_MOSI           ; pull CS low to begin command
               S02:000013B9:  A9 04
F05:0196         sta PORTA
               S02:000013BB:  8D 01 B0
F05:0197       
F05:0198         ldy #0
               S02:000013BE:  A0 00
F05:0199         lda (zp_sd_address),y    ; command byte
               S02:000013C0:  B1 48
F05:0200         jsr sd_writebyte
               S02:000013C2:  20 8E 13
F05:0201         ldy #1
               S02:000013C5:  A0 01
F05:0202         lda (zp_sd_address),y    ; data 1
               S02:000013C7:  B1 48
F05:0203         jsr sd_writebyte
               S02:000013C9:  20 8E 13
F05:0204         ldy #2
               S02:000013CC:  A0 02
F05:0205         lda (zp_sd_address),y    ; data 2
               S02:000013CE:  B1 48
F05:0206         jsr sd_writebyte
               S02:000013D0:  20 8E 13
F05:0207         ldy #3
               S02:000013D3:  A0 03
F05:0208         lda (zp_sd_address),y    ; data 3
               S02:000013D5:  B1 48
F05:0209         jsr sd_writebyte
               S02:000013D7:  20 8E 13
F05:0210         ldy #4
               S02:000013DA:  A0 04
F05:0211         lda (zp_sd_address),y    ; data 4
               S02:000013DC:  B1 48
F05:0212         jsr sd_writebyte
               S02:000013DE:  20 8E 13
F05:0213         ldy #5
               S02:000013E1:  A0 05
F05:0214         lda (zp_sd_address),y    ; crc
               S02:000013E3:  B1 48
F05:0215         jsr sd_writebyte
               S02:000013E5:  20 8E 13
F05:0216       
F05:0217         jsr sd_waitresult
               S02:000013E8:  20 A5 13
F05:0218         pha
               S02:000013EB:  48
F05:0219       
F05:0220         ; Debug print the result code
F05:0221         jsr print_hex_acia
               S02:000013EC:  20 6A 12
F05:0222       
F05:0223         ; End command
F05:0224         lda #SD_CS | SD_MOSI   ; set CS high again
               S02:000013EF:  A9 14
F05:0225         sta PORTA
               S02:000013F1:  8D 01 B0
F05:0226       
F05:0227         pla   ; restore result code
               S02:000013F4:  68
F05:0228         rts
               S02:000013F5:  60
F05:0229       
F05:0230       
F05:0231       sd_readsector:
F05:0232         ; Read a sector from the SD card.  A sector is 512 bytes.
F05:0233         ;
F05:0234         ; Parameters:
F05:0235         ;    zp_sd_currentsector   32-bit sector number
F05:0236         ;    zp_sd_address     address of buffer to receive data
F05:0237         
F05:0238         lda #SD_MOSI
               S02:000013F6:  A9 04
F05:0239         sta PORTA
               S02:000013F8:  8D 01 B0
F05:0240       
F05:0241         ; Command 17, arg is sector number, crc not checked
F05:0242         lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S02:000013FB:  A9 51
F05:0243         jsr sd_writebyte
               S02:000013FD:  20 8E 13
F05:0244         lda zp_sd_currentsector+3   ; sector 24:31
               S02:00001400:  A5 4D
F05:0245         jsr sd_writebyte
               S02:00001402:  20 8E 13
F05:0246         lda zp_sd_currentsector+2   ; sector 16:23
               S02:00001405:  A5 4C
F05:0247         jsr sd_writebyte
               S02:00001407:  20 8E 13
F05:0248         lda zp_sd_currentsector+1   ; sector 8:15
               S02:0000140A:  A5 4B
F05:0249         jsr sd_writebyte
               S02:0000140C:  20 8E 13
F05:0250         lda zp_sd_currentsector     ; sector 0:7
               S02:0000140F:  A5 4A
F05:0251         jsr sd_writebyte
               S02:00001411:  20 8E 13
F05:0252         lda #$01                    ; crc (not checked)
               S02:00001414:  A9 01
F05:0253         jsr sd_writebyte
               S02:00001416:  20 8E 13
F05:0254       
F05:0255         jsr sd_waitresult
               S02:00001419:  20 A5 13
F05:0256         cmp #$00
               S02:0000141C:  C9 00
F05:0257         bne sd_fail
               S02:0000141E:  D0 22
F05:0258       
F05:0259         ; wait for data
F05:0260         jsr sd_waitresult
               S02:00001420:  20 A5 13
F05:0261         cmp #$fe
               S02:00001423:  C9 FE
F05:0262         bne sd_fail
               S02:00001425:  D0 1B
F05:0263       
F05:0264         ; Need to read 512 bytes - two pages of 256 bytes each
F05:0265         jsr .readpage
               S02:00001427:  20 37 14
F05:0266         inc zp_sd_address+1
               S02:0000142A:  E6 49
F05:0267         jsr .readpage
               S02:0000142C:  20 37 14
F05:0268         dec zp_sd_address+1
               S02:0000142F:  C6 49
F05:0269       
F05:0270         ; End command
F05:0271         lda #SD_CS | SD_MOSI
               S02:00001431:  A9 14
F05:0272         sta PORTA
               S02:00001433:  8D 01 B0
F05:0273       
F05:0274         rts
               S02:00001436:  60
F05:0275       
F05:0276       .readpage
F05:0277         ; Read 256 bytes to the address at zp_sd_address
F05:0278         ldy #0
               S02:00001437:  A0 00
F05:0279       .readloop
F05:0280         jsr sd_readbyte
               S02:00001439:  20 73 13
F05:0281         sta (zp_sd_address),y
               S02:0000143C:  91 48
F05:0282         iny
               S02:0000143E:  C8
F05:0283         bne .readloop
               S02:0000143F:  D0 F8
F05:0284         rts
               S02:00001441:  60
F05:0285       
F05:0286       sd_fail:
F05:0287         lda #'s'
               S02:00001442:  A9 73
F05:0288         jsr print_chara
               S02:00001444:  20 B1 12
F05:0289         lda #':'
               S02:00001447:  A9 3A
F05:0290         jsr print_chara
               S02:00001449:  20 B1 12
F05:0291         lda #'f'
               S02:0000144C:  A9 66
F05:0292         jsr print_chara
               S02:0000144E:  20 B1 12
F05:0293       .failloop
F05:0294         jmp .failloop
               S02:00001451:  4C 51 14
F05:0295       
F05:0296       
F05:0297       sd_writesector:
F05:0298         ; Write a sector to the SD card.  A sector is 512 bytes.
F05:0299         ;
F05:0300         ; Parameters:
F05:0301         ;    zp_sd_currentsector   32-bit sector number
F05:0302         ;    zp_sd_address     address of buffer to take data from
F05:0303         
F05:0304         lda #SD_MOSI
               S02:00001454:  A9 04
F05:0305         sta PORTA
               S02:00001456:  8D 01 B0
F05:0306       
F05:0307         ; Command 24, arg is sector number, crc not checked
F05:0308         lda #$58                    ; CMD24 - WRITE_BLOCK
               S02:00001459:  A9 58
F05:0309         jsr sd_writebyte
               S02:0000145B:  20 8E 13
F05:0310         lda zp_sd_currentsector+3   ; sector 24:31
               S02:0000145E:  A5 4D
F05:0311         jsr sd_writebyte
               S02:00001460:  20 8E 13
F05:0312         lda zp_sd_currentsector+2   ; sector 16:23
               S02:00001463:  A5 4C
F05:0313         jsr sd_writebyte
               S02:00001465:  20 8E 13
F05:0314         lda zp_sd_currentsector+1   ; sector 8:15
               S02:00001468:  A5 4B
F05:0315         jsr sd_writebyte
               S02:0000146A:  20 8E 13
F05:0316         lda zp_sd_currentsector     ; sector 0:7
               S02:0000146D:  A5 4A
F05:0317         jsr sd_writebyte
               S02:0000146F:  20 8E 13
F05:0318         lda #$01                    ; crc (not checked)
               S02:00001472:  A9 01
F05:0319         jsr sd_writebyte
               S02:00001474:  20 8E 13
F05:0320       
F05:0321         jsr sd_waitresult
               S02:00001477:  20 A5 13
F05:0322         cmp #$00
               S02:0000147A:  C9 00
F05:0323         bne sd_fail
               S02:0000147C:  D0 C4
F05:0324       
F05:0325         ; Send start token
F05:0326         lda #$fe
               S02:0000147E:  A9 FE
F05:0327         jsr sd_writebyte
               S02:00001480:  20 8E 13
F05:0328       
F05:0329         ; Need to write 512 bytes - two pages of 256 bytes each
F05:0330         jsr .writepage
               S02:00001483:  20 A3 14
F05:0331         inc zp_sd_address+1
               S02:00001486:  E6 49
F05:0332         jsr .writepage
               S02:00001488:  20 A3 14
F05:0333         dec zp_sd_address+1
               S02:0000148B:  C6 49
F05:0334       
F05:0335         ; wait for data response
F05:0336         jsr sd_waitresult
               S02:0000148D:  20 A5 13
F05:0337         and #$1f
               S02:00001490:  29 1F
F05:0338         cmp #$05
               S02:00001492:  C9 05
F05:0339         bne sd_fail
               S02:00001494:  D0 AC
F05:0340       
F05:0341       .waitidle
F05:0342         jsr sd_readbyte
               S02:00001496:  20 73 13
F05:0343         cmp #$ff
               S02:00001499:  C9 FF
F05:0344         bne .waitidle
               S02:0000149B:  D0 F9
F05:0345       
F05:0346         ; End command
F05:0347         lda #SD_CS | SD_MOSI ; set cs and mosi high (disconnected)
               S02:0000149D:  A9 14
F05:0348         sta PORTA
               S02:0000149F:  8D 01 B0
F05:0349       
F05:0350         rts
               S02:000014A2:  60
F05:0351       
F05:0352       .writepage:
F05:0353         ; Write 256 bytes fom zp_sd_address
F05:0354         ldy #0
               S02:000014A3:  A0 00
F05:0355       .writeloop:
F05:0356         lda (zp_sd_address),y
               S02:000014A5:  B1 48
F05:0357         phy
               S02:000014A7:  5A
F05:0358         jsr sd_writebyte
               S02:000014A8:  20 8E 13
F05:0359         ply
               S02:000014AB:  7A
F05:0360         iny
               S02:000014AC:  C8
F05:0361         bne .writeloop
               S02:000014AD:  D0 F6
F05:0362         rts
               S02:000014AF:  60
F05:0363       
F05:0364       
F05:0365       
F05:0366       
F00:0081         .include "libfat32.s"
F06:0001       ; FAT32/SD interface library
F06:0002       ;
F06:0003       ; This module requires some RAM workspace to be defined elsewhere:
F06:0004       ; 
F06:0005       ; fat32_workspace    - a large page-aligned 512-byte workspace
F06:0006       ; zp_fat32_variables - 24 bytes of zero-page storage for variables etc
F06:0007       
F06:0008       ; FIXME once we have more flags, please incorporate all of them into one byte! (flags have two states)
F06:0009       
F06:0010       fat32_readbuffer = fat32_workspace
F06:0011       fat32_fatbuffer = buffer
F06:0012       
F06:0013       fat32_fatstart          	= zp_fat32_variables + $00  ; 4 bytes
F06:0014       fat32_datastart         	= zp_fat32_variables + $04  ; 4 bytes
F06:0015       fat32_rootcluster       	= zp_fat32_variables + $08  ; 4 bytes
F06:0016       fat32_sectorspercluster 	= zp_fat32_variables + $0c  ; 1 byte
F06:0017       fat32_pendingsectors    	= zp_fat32_variables + $0d  ; 1 byte
F06:0018       fat32_address           	= zp_fat32_variables + $0e  ; 2 bytes
F06:0019       fat32_nextcluster       	= zp_fat32_variables + $10  ; 4 bytes
F06:0020       fat32_bytesremaining    	= zp_fat32_variables + $14  ; 4 bytes   	
F06:0021       fat32_lastfoundfreecluster	= zp_fat32_variables + $18  ; 4 bytes
F06:0022       fat32_sectorsperfat		= zp_fat32_variables + $1c  ; 2 bytes
F06:0023       ;fat32_fsinfosector		= zp_fat32_variables + $1e  ; 2 bytes
F06:0024       fat32_lastcluster		= zp_fat32_variables + $1e  ; 4 bytes
F06:0025       fat32_lastsector		= zp_fat32_variables + $23  ; 4 bytes
F06:0026       fat32_newfatsector		= zp_fat32_variables + $28  ; 1 byte FLAG
F06:0027       fat32_filenamepointer       	= zp_fat32_variables + $29  ; 2 bytes
F06:0028       
F06:0029       fat32_errorstage            = fat32_bytesremaining  ; only used during initialization
F06:0030       
F06:0031       ; TODO fix filesize stuff, saved files seem too long and pick up garbage from the RAM... (BUG)
F06:0032       
F06:0033       fat32_init:
F06:0034         ; Initialize the module - read the MBR etc, find the partition,
F06:0035         ; and set up the variables ready for navigating the filesystem
F06:0036       
F06:0037         ; Read the MBR and extract pertinent information
F06:0038       
F06:0039         lda #0
               S02:000014B0:  A9 00
F06:0040         sta fat32_errorstage
               S02:000014B2:  85 63
F06:0041       
F06:0042         ; Sector 0
F06:0043         lda #0
               S02:000014B4:  A9 00
F06:0044         sta zp_sd_currentsector
               S02:000014B6:  85 4A
F06:0045         sta zp_sd_currentsector+1
               S02:000014B8:  85 4B
F06:0046         sta zp_sd_currentsector+2
               S02:000014BA:  85 4C
F06:0047         sta zp_sd_currentsector+3
               S02:000014BC:  85 4D
F06:0048       
F06:0049         ; Target buffer
F06:0050         lda #<fat32_readbuffer
               S02:000014BE:  A9 00
F06:0051         sta zp_sd_address
               S02:000014C0:  85 48
F06:0052         lda #>fat32_readbuffer
               S02:000014C2:  A9 05
F06:0053         sta zp_sd_address+1
               S02:000014C4:  85 49
F06:0054       
F06:0055         ; Do the read
F06:0056         jsr sd_readsector
               S02:000014C6:  20 F6 13
F06:0057       
F06:0058       
F06:0059         inc fat32_errorstage ; stage 1 = boot sector signature check
               S02:000014C9:  E6 63
F06:0060       
F06:0061         ; Check some things
F06:0062         lda fat32_readbuffer+510 ; Boot sector signature 55
               S02:000014CB:  AD FE 06
F06:0063         cmp #$55
               S02:000014CE:  C9 55
F06:0064         bne .fail
               S02:000014D0:  D0 2D
F06:0065         lda fat32_readbuffer+511 ; Boot sector signature aa
               S02:000014D2:  AD FF 06
F06:0066         cmp #$aa
               S02:000014D5:  C9 AA
F06:0067         bne .fail
               S02:000014D7:  D0 26
F06:0068       
F06:0069       
F06:0070         inc fat32_errorstage ; stage 2 = finding partition
               S02:000014D9:  E6 63
F06:0071       
F06:0072         ; Find a FAT32 partition
F06:0073       .FSTYPE_FAT32 = 12
F06:0074         ldx #0
               S02:000014DB:  A2 00
F06:0075         lda fat32_readbuffer+$1c2,x
               S02:000014DD:  BD C2 06
F06:0076         cmp #.FSTYPE_FAT32
               S02:000014E0:  C9 0C
F06:0077         beq .foundpart
               S02:000014E2:  F0 1E
F06:0078         ldx #16
               S02:000014E4:  A2 10
F06:0079         lda fat32_readbuffer+$1c2,x
               S02:000014E6:  BD C2 06
F06:0080         cmp #.FSTYPE_FAT32
               S02:000014E9:  C9 0C
F06:0081         beq .foundpart
               S02:000014EB:  F0 15
F06:0082         ldx #32
               S02:000014ED:  A2 20
F06:0083         lda fat32_readbuffer+$1c2,x
               S02:000014EF:  BD C2 06
F06:0084         cmp #.FSTYPE_FAT32
               S02:000014F2:  C9 0C
F06:0085         beq .foundpart
               S02:000014F4:  F0 0C
F06:0086         ldx #48
               S02:000014F6:  A2 30
F06:0087         lda fat32_readbuffer+$1c2,x
               S02:000014F8:  BD C2 06
F06:0088         cmp #.FSTYPE_FAT32
               S02:000014FB:  C9 0C
F06:0089         beq .foundpart
               S02:000014FD:  F0 03
F06:0090       
F06:0091       .fail:
F06:0092         jmp .error
               S02:000014FF:  4C C0 15
F06:0093       
F06:0094       .foundpart:
F06:0095       
F06:0096         ; Read the FAT32 BPB
F06:0097         lda fat32_readbuffer+$1c6,x
               S02:00001502:  BD C6 06
F06:0098         sta zp_sd_currentsector
               S02:00001505:  85 4A
F06:0099         lda fat32_readbuffer+$1c7,x
               S02:00001507:  BD C7 06
F06:0100         sta zp_sd_currentsector+1
               S02:0000150A:  85 4B
F06:0101         lda fat32_readbuffer+$1c8,x
               S02:0000150C:  BD C8 06
F06:0102         sta zp_sd_currentsector+2
               S02:0000150F:  85 4C
F06:0103         lda fat32_readbuffer+$1c9,x
               S02:00001511:  BD C9 06
F06:0104         sta zp_sd_currentsector+3
               S02:00001514:  85 4D
F06:0105       
F06:0106         jsr sd_readsector
               S02:00001516:  20 F6 13
F06:0107       
F06:0108       
F06:0109         inc fat32_errorstage ; stage 3 = BPB signature check
               S02:00001519:  E6 63
F06:0110       
F06:0111         ; Check some things
F06:0112         lda fat32_readbuffer+510 ; BPB sector signature 55
               S02:0000151B:  AD FE 06
F06:0113         cmp #$55
               S02:0000151E:  C9 55
F06:0114         bne .fail
               S02:00001520:  D0 DD
F06:0115         lda fat32_readbuffer+511 ; BPB sector signature aa
               S02:00001522:  AD FF 06
F06:0116         cmp #$aa
               S02:00001525:  C9 AA
F06:0117         bne .fail
               S02:00001527:  D0 D6
F06:0118       
F06:0119         inc fat32_errorstage ; stage 4 = RootEntCnt check
               S02:00001529:  E6 63
F06:0120       
F06:0121         lda fat32_readbuffer+17 ; RootEntCnt should be 0 for FAT32
               S02:0000152B:  AD 11 05
F06:0122         ora fat32_readbuffer+18
               S02:0000152E:  0D 12 05
F06:0123         bne .fail
               S02:00001531:  D0 CC
F06:0124       
F06:0125         inc fat32_errorstage ; stage 5 = TotSec16 check
               S02:00001533:  E6 63
F06:0126       
F06:0127         lda fat32_readbuffer+19 ; TotSec16 should be 0 for FAT32
               S02:00001535:  AD 13 05
F06:0128         ora fat32_readbuffer+20
               S02:00001538:  0D 14 05
F06:0129         bne .fail
               S02:0000153B:  D0 C2
F06:0130       
F06:0131         inc fat32_errorstage ; stage 6 = SectorsPerCluster check
               S02:0000153D:  E6 63
F06:0132       
F06:0133         ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
F06:0134         lda fat32_readbuffer+11 ; low byte should be zero
               S02:0000153F:  AD 0B 05
F06:0135         bne .fail
               S02:00001542:  D0 BB
F06:0136         lda fat32_readbuffer+12 ; high byte is 2 (512), 4, 8, or 16
               S02:00001544:  AD 0C 05
F06:0137         cmp #2
               S02:00001547:  C9 02
F06:0138         bne .fail
               S02:00001549:  D0 B4
F06:0139       
F06:0140         ; Save sectors per FAT
F06:0141       
F06:0142         lda fat32_readbuffer+22
               S02:0000154B:  AD 16 05
F06:0143         sta fat32_sectorsperfat
               S02:0000154E:  85 6B
F06:0144         lda fat32_readbuffer+23
               S02:00001550:  AD 17 05
F06:0145         sta fat32_sectorsperfat+1
               S02:00001553:  85 6C
F06:0146       
F06:0147         ; Calculate the starting sector of the FAT
F06:0148         clc
               S02:00001555:  18
F06:0149         lda zp_sd_currentsector
               S02:00001556:  A5 4A
F06:0150         adc fat32_readbuffer+14    ; reserved sectors lo
               S02:00001558:  6D 0E 05
F06:0151         sta fat32_fatstart
               S02:0000155B:  85 4F
F06:0152         sta fat32_datastart
               S02:0000155D:  85 53
F06:0153         lda zp_sd_currentsector+1
               S02:0000155F:  A5 4B
F06:0154         adc fat32_readbuffer+15    ; reserved sectors hi
               S02:00001561:  6D 0F 05
F06:0155         sta fat32_fatstart+1
               S02:00001564:  85 50
F06:0156         sta fat32_datastart+1
               S02:00001566:  85 54
F06:0157         lda zp_sd_currentsector+2
               S02:00001568:  A5 4C
F06:0158         adc #0
               S02:0000156A:  69 00
F06:0159         sta fat32_fatstart+2
               S02:0000156C:  85 51
F06:0160         sta fat32_datastart+2
               S02:0000156E:  85 55
F06:0161         lda zp_sd_currentsector+3
               S02:00001570:  A5 4D
F06:0162         adc #0
               S02:00001572:  69 00
F06:0163         sta fat32_fatstart+3
               S02:00001574:  85 52
F06:0164         sta fat32_datastart+3
               S02:00001576:  85 56
F06:0165       
F06:0166         ; Calculate the starting sector of the data area
F06:0167         ldx fat32_readbuffer+16   ; number of FATs
               S02:00001578:  AE 10 05
F06:0168       .skipfatsloop:
F06:0169         clc
               S02:0000157B:  18
F06:0170         lda fat32_datastart
               S02:0000157C:  A5 53
F06:0171         adc fat32_readbuffer+36 ; fatsize 0
               S02:0000157E:  6D 24 05
F06:0172         sta fat32_datastart
               S02:00001581:  85 53
F06:0173         lda fat32_datastart+1
               S02:00001583:  A5 54
F06:0174         adc fat32_readbuffer+37 ; fatsize 1
               S02:00001585:  6D 25 05
F06:0175         sta fat32_datastart+1
               S02:00001588:  85 54
F06:0176         lda fat32_datastart+2
               S02:0000158A:  A5 55
F06:0177         adc fat32_readbuffer+38 ; fatsize 2
               S02:0000158C:  6D 26 05
F06:0178         sta fat32_datastart+2
               S02:0000158F:  85 55
F06:0179         lda fat32_datastart+3
               S02:00001591:  A5 56
F06:0180         adc fat32_readbuffer+39 ; fatsize 3
               S02:00001593:  6D 27 05
F06:0181         sta fat32_datastart+3
               S02:00001596:  85 56
F06:0182         dex
               S02:00001598:  CA
F06:0183         bne .skipfatsloop
               S02:00001599:  D0 E0
F06:0184       
F06:0185         ; Sectors-per-cluster is a power of two from 1 to 128
F06:0186         lda fat32_readbuffer+13
               S02:0000159B:  AD 0D 05
F06:0187         sta fat32_sectorspercluster
               S02:0000159E:  85 5B
F06:0188       
F06:0189         ; Remember FSInfo sector
F06:0190         ;lda fat32_readbuffer+38
F06:0191         ;sta fat32_fsinfosector
F06:0192         ;lda fat32_readbuffer+39
F06:0193         ;sta fat32_fsinfosector+1
F06:0194       
F06:0195         ; Remember the root cluster
F06:0196         lda fat32_readbuffer+44
               S02:000015A0:  AD 2C 05
F06:0197         sta fat32_rootcluster
               S02:000015A3:  85 57
F06:0198         lda fat32_readbuffer+45
               S02:000015A5:  AD 2D 05
F06:0199         sta fat32_rootcluster+1
               S02:000015A8:  85 58
F06:0200         lda fat32_readbuffer+46
               S02:000015AA:  AD 2E 05
F06:0201         sta fat32_rootcluster+2
               S02:000015AD:  85 59
F06:0202         lda fat32_readbuffer+47
               S02:000015AF:  AD 2F 05
F06:0203         sta fat32_rootcluster+3
               S02:000015B2:  85 5A
F06:0204       
F06:0205         ; Set the last found free cluster to 0.
F06:0206         lda #0
               S02:000015B4:  A9 00
F06:0207         sta fat32_lastfoundfreecluster
               S02:000015B6:  85 67
F06:0208         sta fat32_lastfoundfreecluster+1
               S02:000015B8:  85 68
F06:0209         sta fat32_lastfoundfreecluster+2
               S02:000015BA:  85 69
F06:0210         sta fat32_lastfoundfreecluster+3
               S02:000015BC:  85 6A
F06:0211       
F06:0212         clc
               S02:000015BE:  18
F06:0213         rts
               S02:000015BF:  60
F06:0214       
F06:0215       .error:
F06:0216         sec
               S02:000015C0:  38
F06:0217         rts
               S02:000015C1:  60
F06:0218       
F06:0219       
F06:0220       fat32_seekcluster:
F06:0221         ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
F06:0222       
F06:0223         ; Target buffer
F06:0224         lda #<fat32_fatbuffer
               S02:000015C2:  A9 00
F06:0225         sta zp_sd_address
               S02:000015C4:  85 48
F06:0226         lda #>fat32_fatbuffer
               S02:000015C6:  A9 07
F06:0227         sta zp_sd_address+1
               S02:000015C8:  85 49
F06:0228         
F06:0229         ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
F06:0230         lda fat32_nextcluster
               S02:000015CA:  A5 5F
F06:0231         asl
               S02:000015CC:  0A
F06:0232         lda fat32_nextcluster+1
               S02:000015CD:  A5 60
F06:0233         rol
               S02:000015CF:  2A
F06:0234         sta zp_sd_currentsector
               S02:000015D0:  85 4A
F06:0235         lda fat32_nextcluster+2
               S02:000015D2:  A5 61
F06:0236         rol
               S02:000015D4:  2A
F06:0237         sta zp_sd_currentsector+1
               S02:000015D5:  85 4B
F06:0238         lda fat32_nextcluster+3
               S02:000015D7:  A5 62
F06:0239         rol
               S02:000015D9:  2A
F06:0240         sta zp_sd_currentsector+2
               S02:000015DA:  85 4C
F06:0241         ; note: cluster numbers never have the top bit set, so no carry can occur
F06:0242       
F06:0243         ; Add FAT starting sector
F06:0244         lda zp_sd_currentsector
               S02:000015DC:  A5 4A
F06:0245         adc fat32_fatstart
               S02:000015DE:  65 4F
F06:0246         sta zp_sd_currentsector
               S02:000015E0:  85 4A
F06:0247         lda zp_sd_currentsector+1
               S02:000015E2:  A5 4B
F06:0248         adc fat32_fatstart+1
               S02:000015E4:  65 50
F06:0249         sta zp_sd_currentsector+1
               S02:000015E6:  85 4B
F06:0250         lda zp_sd_currentsector+2
               S02:000015E8:  A5 4C
F06:0251         adc fat32_fatstart+2
               S02:000015EA:  65 51
F06:0252         sta zp_sd_currentsector+2
               S02:000015EC:  85 4C
F06:0253         lda #0
               S02:000015EE:  A9 00
F06:0254         adc fat32_fatstart+3
               S02:000015F0:  65 52
F06:0255         sta zp_sd_currentsector+3
               S02:000015F2:  85 4D
F06:0256       
F06:0257         ; Check if this sector is the same as the last one
F06:0258         lda fat32_lastsector
               S02:000015F4:  A5 72
F06:0259         cmp zp_sd_currentsector
               S02:000015F6:  C5 4A
F06:0260         bne .newsector
               S02:000015F8:  D0 12
F06:0261         lda fat32_lastsector+1
               S02:000015FA:  A5 73
F06:0262         cmp zp_sd_currentsector+1
               S02:000015FC:  C5 4B
F06:0263         bne .newsector
               S02:000015FE:  D0 0C
F06:0264         lda fat32_lastsector+2
               S02:00001600:  A5 74
F06:0265         cmp zp_sd_currentsector+2
               S02:00001602:  C5 4C
F06:0266         bne .newsector
               S02:00001604:  D0 06
F06:0267         lda fat32_lastsector+3
               S02:00001606:  A5 75
F06:0268         cmp zp_sd_currentsector+3
               S02:00001608:  C5 4D
F06:0269         beq .notnew
               S02:0000160A:  F0 13
F06:0270       
F06:0271       .newsector
F06:0272       
F06:0273       ;  lda #$ff
F06:0274       ;  sta fat32_newfatsector
F06:0275       
F06:0276         ; Read the sector from the FAT
F06:0277         jsr sd_readsector
               S02:0000160C:  20 F6 13
F06:0278       
F06:0279         ; Update fat32_lastsector
F06:0280       
F06:0281         lda zp_sd_currentsector
               S02:0000160F:  A5 4A
F06:0282         sta fat32_lastsector
               S02:00001611:  85 72
F06:0283         lda zp_sd_currentsector+1
               S02:00001613:  A5 4B
F06:0284         sta fat32_lastsector+1
               S02:00001615:  85 73
F06:0285         lda zp_sd_currentsector+2
               S02:00001617:  A5 4C
F06:0286         sta fat32_lastsector+2
               S02:00001619:  85 74
F06:0287         lda zp_sd_currentsector+3
               S02:0000161B:  A5 4D
F06:0288         sta fat32_lastsector+3
               S02:0000161D:  85 75
F06:0289       
F06:0290       ;  jmp .newc
F06:0291       
F06:0292       .notnew
F06:0293       
F06:0294       ; stz fat32_newfatsector
F06:0295       
F06:0296       ;.newc
F06:0297       
F06:0298         ; Before using this FAT data, set currentsector ready to read the cluster itself
F06:0299         ; We need to multiply the cluster number minus two by the number of sectors per 
F06:0300         ; cluster, then add the data region start sector
F06:0301       
F06:0302         ; Subtract two from cluster number
F06:0303         sec
               S02:0000161F:  38
F06:0304         lda fat32_nextcluster
               S02:00001620:  A5 5F
F06:0305         sbc #2
               S02:00001622:  E9 02
F06:0306         sta zp_sd_currentsector
               S02:00001624:  85 4A
F06:0307         lda fat32_nextcluster+1
               S02:00001626:  A5 60
F06:0308         sbc #0
               S02:00001628:  E9 00
F06:0309         sta zp_sd_currentsector+1
               S02:0000162A:  85 4B
F06:0310         lda fat32_nextcluster+2
               S02:0000162C:  A5 61
F06:0311         sbc #0
               S02:0000162E:  E9 00
F06:0312         sta zp_sd_currentsector+2
               S02:00001630:  85 4C
F06:0313         lda fat32_nextcluster+3
               S02:00001632:  A5 62
F06:0314         sbc #0
               S02:00001634:  E9 00
F06:0315         sta zp_sd_currentsector+3
               S02:00001636:  85 4D
F06:0316         
F06:0317         ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
F06:0318         lda fat32_sectorspercluster
               S02:00001638:  A5 5B
F06:0319       .spcshiftloop:
F06:0320         lsr
               S02:0000163A:  4A
F06:0321         bcs .spcshiftloopdone
               S02:0000163B:  B0 0B
F06:0322         asl zp_sd_currentsector
               S02:0000163D:  06 4A
F06:0323         rol zp_sd_currentsector+1
               S02:0000163F:  26 4B
F06:0324         rol zp_sd_currentsector+2
               S02:00001641:  26 4C
F06:0325         rol zp_sd_currentsector+3
               S02:00001643:  26 4D
F06:0326         jmp .spcshiftloop
               S02:00001645:  4C 3A 16
F06:0327       .spcshiftloopdone:
F06:0328       
F06:0329         ; Add the data region start sector
F06:0330         clc
               S02:00001648:  18
F06:0331         lda zp_sd_currentsector
               S02:00001649:  A5 4A
F06:0332         adc fat32_datastart
               S02:0000164B:  65 53
F06:0333         sta zp_sd_currentsector
               S02:0000164D:  85 4A
F06:0334         lda zp_sd_currentsector+1
               S02:0000164F:  A5 4B
F06:0335         adc fat32_datastart+1
               S02:00001651:  65 54
F06:0336         sta zp_sd_currentsector+1
               S02:00001653:  85 4B
F06:0337         lda zp_sd_currentsector+2
               S02:00001655:  A5 4C
F06:0338         adc fat32_datastart+2
               S02:00001657:  65 55
F06:0339         sta zp_sd_currentsector+2
               S02:00001659:  85 4C
F06:0340         lda zp_sd_currentsector+3
               S02:0000165B:  A5 4D
F06:0341         adc fat32_datastart+3
               S02:0000165D:  65 56
F06:0342         sta zp_sd_currentsector+3
               S02:0000165F:  85 4D
F06:0343       
F06:0344         ; That's now ready for later code to read this sector in - tell it how many consecutive
F06:0345         ; sectors it can now read
F06:0346         lda fat32_sectorspercluster
               S02:00001661:  A5 5B
F06:0347         sta fat32_pendingsectors
               S02:00001663:  85 5C
F06:0348       
F06:0349         ; Now go back to looking up the next cluster in the chain
F06:0350         ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
F06:0351       
F06:0352         ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
F06:0353         lda fat32_nextcluster
               S02:00001665:  A5 5F
F06:0354         and #$7f
               S02:00001667:  29 7F
F06:0355         asl
               S02:00001669:  0A
F06:0356         asl
               S02:0000166A:  0A
F06:0357         tay ; Y = low byte of offset
               S02:0000166B:  A8
F06:0358       
F06:0359         ; Add the potentially carried bit to the high byte of the address
F06:0360         lda zp_sd_address+1
               S02:0000166C:  A5 49
F06:0361         adc #0
               S02:0000166E:  69 00
F06:0362         sta zp_sd_address+1
               S02:00001670:  85 49
F06:0363       
F06:0364         ; Copy out the next cluster in the chain for later use
F06:0365         lda (zp_sd_address),y
               S02:00001672:  B1 48
F06:0366         sta fat32_nextcluster
               S02:00001674:  85 5F
F06:0367         iny
               S02:00001676:  C8
F06:0368         lda (zp_sd_address),y
               S02:00001677:  B1 48
F06:0369         sta fat32_nextcluster+1
               S02:00001679:  85 60
F06:0370         iny
               S02:0000167B:  C8
F06:0371         lda (zp_sd_address),y
               S02:0000167C:  B1 48
F06:0372         sta fat32_nextcluster+2
               S02:0000167E:  85 61
F06:0373         iny
               S02:00001680:  C8
F06:0374         lda (zp_sd_address),y
               S02:00001681:  B1 48
F06:0375         and #$0f
               S02:00001683:  29 0F
F06:0376         sta fat32_nextcluster+3
               S02:00001685:  85 62
F06:0377       
F06:0378         ; See if it's the end of the chain
F06:0379         ora #$f0
               S02:00001687:  09 F0
F06:0380         and fat32_nextcluster+2
               S02:00001689:  25 61
F06:0381         and fat32_nextcluster+1
               S02:0000168B:  25 60
F06:0382         cmp #$ff
               S02:0000168D:  C9 FF
F06:0383         bne .notendofchain
               S02:0000168F:  D0 08
F06:0384         lda fat32_nextcluster
               S02:00001691:  A5 5F
F06:0385         cmp #$f8
               S02:00001693:  C9 F8
F06:0386         bcc .notendofchain
               S02:00001695:  90 02
F06:0387       
F06:0388         ; It's the end of the chain, set the top bits so that we can tell this later on
F06:0389         sta fat32_nextcluster+3
               S02:00001697:  85 62
F06:0390       .notendofchain:
F06:0391         rts
               S02:00001699:  60
F06:0392       
F06:0393       
F06:0394       fat32_readnextsector:
F06:0395         ; Reads the next sector from a cluster chain into the buffer at fat32_address.
F06:0396         ;
F06:0397         ; Advances the current sector ready for the next read and looks up the next cluster
F06:0398         ; in the chain when necessary.
F06:0399         ;
F06:0400         ; On return, carry is clear if data was read, or set if the cluster chain has ended.
F06:0401       
F06:0402         ; Maybe there are pending sectors in the current cluster
F06:0403         lda fat32_pendingsectors
               S02:0000169A:  A5 5C
F06:0404         bne .readsector
               S02:0000169C:  D0 07
F06:0405       
F06:0406         ; No pending sectors, check for end of cluster chain
F06:0407         lda fat32_nextcluster+3
               S02:0000169E:  A5 62
F06:0408         bmi .endofchain
               S02:000016A0:  30 20
F06:0409       
F06:0410         ; Prepare to read the next cluster
F06:0411         jsr fat32_seekcluster
               S02:000016A2:  20 C2 15
F06:0412       
F06:0413       .readsector:
F06:0414         dec fat32_pendingsectors
               S02:000016A5:  C6 5C
F06:0415       
F06:0416         ; Set up target address  
F06:0417         lda fat32_address
               S02:000016A7:  A5 5D
F06:0418         sta zp_sd_address
               S02:000016A9:  85 48
F06:0419         lda fat32_address+1
               S02:000016AB:  A5 5E
F06:0420         sta zp_sd_address+1
               S02:000016AD:  85 49
F06:0421       
F06:0422         ; Read the sector
F06:0423         jsr sd_readsector
               S02:000016AF:  20 F6 13
F06:0424       
F06:0425         ; Advance to next sector
F06:0426         inc zp_sd_currentsector
               S02:000016B2:  E6 4A
F06:0427         bne .sectorincrementdone
               S02:000016B4:  D0 0A
F06:0428         inc zp_sd_currentsector+1
               S02:000016B6:  E6 4B
F06:0429         bne .sectorincrementdone
               S02:000016B8:  D0 06
F06:0430         inc zp_sd_currentsector+2
               S02:000016BA:  E6 4C
F06:0431         bne .sectorincrementdone
               S02:000016BC:  D0 02
F06:0432         inc zp_sd_currentsector+3
               S02:000016BE:  E6 4D
F06:0433       .sectorincrementdone:
F06:0434       
F06:0435         ; Success - clear carry and return
F06:0436         clc
               S02:000016C0:  18
F06:0437         rts
               S02:000016C1:  60
F06:0438       
F06:0439       .endofchain:
F06:0440         ; End of chain - set carry and return
F06:0441         sec
               S02:000016C2:  38
F06:0442         rts
               S02:000016C3:  60
F06:0443       
F06:0444       fat32_writenextsector:
F06:0445         ; Writes the next sector into the buffer at fat32_address.
F06:0446         ; 
F06:0447         ; Also looks for new clusters and stores them in the FAT.
F06:0448         ;
F06:0449         ; On return, carry is set if its the end of the chain.
F06:0450       
F06:0451         ; Are there any pending sectors in the current cluster
F06:0452         lda fat32_pendingsectors
               S02:000016C4:  A5 5C
F06:0453         beq .newcluster
               S02:000016C6:  F0 03
F06:0454         jmp .writesector
               S02:000016C8:  4C 5F 17
F06:0455       
F06:0456       .newcluster
F06:0457       
F06:0458         ; No, make a new cluster
F06:0459       
F06:0460         ; Check if it's the last cluster in the chain 
F06:0461         lda fat32_bytesremaining
               S02:000016CB:  A5 63
F06:0462         cmp fat32_sectorspercluster
               S02:000016CD:  C5 5B
F06:0463         bcs .notlastcluster	 ; sectorsremaining >= sectorspercluster?
               S02:000016CF:  B0 40
F06:0464       
F06:0465         ; It is the last one.
F06:0466       
F06:0467       .lastcluster
F06:0468       
F06:0469       ; go back the previous one
F06:0470         lda fat32_lastcluster
               S02:000016D1:  A5 6D
F06:0471         sta fat32_nextcluster
               S02:000016D3:  85 5F
F06:0472         lda fat32_lastcluster+1
               S02:000016D5:  A5 6E
F06:0473         sta fat32_nextcluster+1
               S02:000016D7:  85 60
F06:0474         lda fat32_lastcluster+2
               S02:000016D9:  A5 6F
F06:0475         sta fat32_nextcluster+2
               S02:000016DB:  85 61
F06:0476         lda fat32_lastcluster+3
               S02:000016DD:  A5 70
F06:0477         sta fat32_nextcluster+3
               S02:000016DF:  85 62
F06:0478       
F06:0479         jsr fat32_seekcluster
               S02:000016E1:  20 C2 15
F06:0480       
F06:0481         ; Write 0x0FFFFFFF (EOC)
F06:0482         lda #$0f
               S02:000016E4:  A9 0F
F06:0483         sta (zp_sd_address),y
               S02:000016E6:  91 48
F06:0484         dey
               S02:000016E8:  88
F06:0485         lda #$ff
               S02:000016E9:  A9 FF
F06:0486         sta (zp_sd_address),y
               S02:000016EB:  91 48
F06:0487         dey
               S02:000016ED:  88
F06:0488         sta (zp_sd_address),y
               S02:000016EE:  91 48
F06:0489         dey
               S02:000016F0:  88
F06:0490         sta (zp_sd_address),y
               S02:000016F1:  91 48
F06:0491       
F06:0492         ; Preserve the current sector
F06:0493         lda zp_sd_currentsector
               S02:000016F3:  A5 4A
F06:0494         pha 
               S02:000016F5:  48
F06:0495         lda zp_sd_currentsector+1
               S02:000016F6:  A5 4B
F06:0496         pha 
               S02:000016F8:  48
F06:0497         lda zp_sd_currentsector+2
               S02:000016F9:  A5 4C
F06:0498         pha 
               S02:000016FB:  48
F06:0499         lda zp_sd_currentsector+3
               S02:000016FC:  A5 4D
F06:0500         pha
               S02:000016FE:  48
F06:0501       
F06:0502         ; Update the FAT, if needed.
F06:0503         jsr .sectorbounds
               S02:000016FF:  20 7C 17
F06:0504       
F06:0505         ; End of chain - finish up the remaining sectors
F06:0506       
F06:0507         ; Pull back the current sector
F06:0508         pla
               S02:00001702:  68
F06:0509         sta zp_sd_currentsector+3
               S02:00001703:  85 4D
F06:0510         pla
               S02:00001705:  68
F06:0511         sta zp_sd_currentsector+2
               S02:00001706:  85 4C
F06:0512         pla
               S02:00001708:  68
F06:0513         sta zp_sd_currentsector+1
               S02:00001709:  85 4B
F06:0514         pla
               S02:0000170B:  68
F06:0515         sta zp_sd_currentsector
               S02:0000170C:  85 4A
F06:0516       
F06:0517         jmp .writesector
               S02:0000170E:  4C 5F 17
F06:0518       
F06:0519       .notlastcluster
F06:0520         ; Wait! Are there enough sectors left to fit exactly in one cluster?
F06:0521         beq .lastcluster
               S02:00001711:  F0 BE
F06:0522       
F06:0523         ; Find the next cluster
F06:0524         jsr fat32_findnextfreecluster
               S02:00001713:  20 C4 17
F06:0525       
F06:0526         ; Preserve the current sector
F06:0527         lda zp_sd_currentsector
               S02:00001716:  A5 4A
F06:0528         pha 
               S02:00001718:  48
F06:0529         lda zp_sd_currentsector+1
               S02:00001719:  A5 4B
F06:0530         pha 
               S02:0000171B:  48
F06:0531         lda zp_sd_currentsector+2
               S02:0000171C:  A5 4C
F06:0532         pha 
               S02:0000171E:  48
F06:0533         lda zp_sd_currentsector+3
               S02:0000171F:  A5 4D
F06:0534         pha
               S02:00001721:  48
F06:0535       
F06:0536         ; Seek to the previous cluster
F06:0537         lda fat32_lastcluster
               S02:00001722:  A5 6D
F06:0538         sta fat32_nextcluster
               S02:00001724:  85 5F
F06:0539         lda fat32_lastcluster+1
               S02:00001726:  A5 6E
F06:0540         sta fat32_nextcluster+1
               S02:00001728:  85 60
F06:0541         lda fat32_lastcluster+2
               S02:0000172A:  A5 6F
F06:0542         sta fat32_nextcluster+2
               S02:0000172C:  85 61
F06:0543         lda fat32_lastcluster+3
               S02:0000172E:  A5 70
F06:0544         sta fat32_nextcluster+3
               S02:00001730:  85 62
F06:0545       
F06:0546         jsr fat32_seekcluster
               S02:00001732:  20 C2 15
F06:0547       
F06:0548         ; Enter the address of the next one into the FAT
F06:0549         lda fat32_lastfoundfreecluster+3
               S02:00001735:  A5 6A
F06:0550         sta fat32_lastcluster+3
               S02:00001737:  85 70
F06:0551         sta (zp_sd_address),y
               S02:00001739:  91 48
F06:0552         dey
               S02:0000173B:  88
F06:0553         lda fat32_lastfoundfreecluster+2
               S02:0000173C:  A5 69
F06:0554         sta fat32_lastcluster+2
               S02:0000173E:  85 6F
F06:0555         sta (zp_sd_address),y
               S02:00001740:  91 48
F06:0556         dey
               S02:00001742:  88
F06:0557         lda fat32_lastfoundfreecluster+1
               S02:00001743:  A5 68
F06:0558         sta fat32_lastcluster+1
               S02:00001745:  85 6E
F06:0559         sta (zp_sd_address),y
               S02:00001747:  91 48
F06:0560         dey
               S02:00001749:  88
F06:0561         lda fat32_lastfoundfreecluster
               S02:0000174A:  A5 67
F06:0562         sta fat32_lastcluster
               S02:0000174C:  85 6D
F06:0563         sta (zp_sd_address),y
               S02:0000174E:  91 48
F06:0564       
F06:0565         ; Update the FAT, if needed.
F06:0566         jsr .sectorbounds
               S02:00001750:  20 7C 17
F06:0567       
F06:0568         ; Pull back the current sector
F06:0569         pla
               S02:00001753:  68
F06:0570         sta zp_sd_currentsector+3
               S02:00001754:  85 4D
F06:0571         pla
               S02:00001756:  68
F06:0572         sta zp_sd_currentsector+2
               S02:00001757:  85 4C
F06:0573         pla
               S02:00001759:  68
F06:0574         sta zp_sd_currentsector+1
               S02:0000175A:  85 4B
F06:0575         pla
               S02:0000175C:  68
F06:0576         sta zp_sd_currentsector
               S02:0000175D:  85 4A
F06:0577         
F06:0578       .writesector:
F06:0579         dec fat32_pendingsectors
               S02:0000175F:  C6 5C
F06:0580       
F06:0581         ; Set up target address
F06:0582         lda fat32_address
               S02:00001761:  A5 5D
F06:0583         sta zp_sd_address
               S02:00001763:  85 48
F06:0584         lda fat32_address+1
               S02:00001765:  A5 5E
F06:0585         sta zp_sd_address+1
               S02:00001767:  85 49
F06:0586       
F06:0587         ; Write the sector
F06:0588         jsr sd_writesector
               S02:00001769:  20 54 14
F06:0589       
F06:0590         ; Advance to next sector
F06:0591         inc zp_sd_currentsector
               S02:0000176C:  E6 4A
F06:0592         bne .nextsectorincrementdone
               S02:0000176E:  D0 0A
F06:0593         inc zp_sd_currentsector+1
               S02:00001770:  E6 4B
F06:0594         bne .nextsectorincrementdone
               S02:00001772:  D0 06
F06:0595         inc zp_sd_currentsector+2
               S02:00001774:  E6 4C
F06:0596         bne .nextsectorincrementdone
               S02:00001776:  D0 02
F06:0597         inc zp_sd_currentsector+3
               S02:00001778:  E6 4D
F06:0598       .nextsectorincrementdone:
F06:0599       
F06:0600         ; Success - clear carry and return
F06:0601         clc
               S02:0000177A:  18
F06:0602         rts
               S02:0000177B:  60
F06:0603       
F06:0604       .sectorbounds:
F06:0605         ; Have we passed over a sector while modifying the FAT?
F06:0606         ;lda fat32_newfatsector
F06:0607         ;beq .nopass
F06:0608       
F06:0609         ; Write the sector
F06:0610         lda fat32_lastsector
               S02:0000177C:  A5 72
F06:0611         sta zp_sd_currentsector
               S02:0000177E:  85 4A
F06:0612         lda fat32_lastsector+1
               S02:00001780:  A5 73
F06:0613         sta zp_sd_currentsector+1
               S02:00001782:  85 4B
F06:0614         lda fat32_lastsector+2
               S02:00001784:  A5 74
F06:0615         sta zp_sd_currentsector+2
               S02:00001786:  85 4C
F06:0616         lda fat32_lastsector+3
               S02:00001788:  A5 75
F06:0617         sta zp_sd_currentsector+3
               S02:0000178A:  85 4D
F06:0618       
F06:0619         ; Target buffer
F06:0620         lda #<fat32_fatbuffer
               S02:0000178C:  A9 00
F06:0621         sta zp_sd_address
               S02:0000178E:  85 48
F06:0622         lda #>fat32_fatbuffer
               S02:00001790:  A9 07
F06:0623         sta zp_sd_address+1
               S02:00001792:  85 49
F06:0624       
F06:0625         ; Write the FAT sector
F06:0626         jsr sd_writesector
               S02:00001794:  20 54 14
F06:0627       
F06:0628       .nopass
F06:0629         ; We did not, return.
F06:0630         rts
               S02:00001797:  60
F06:0631       
F06:0632       
F06:0633       fat32_openroot:
F06:0634         ; Prepare to read the root directory
F06:0635       
F06:0636         lda fat32_rootcluster
               S02:00001798:  A5 57
F06:0637         sta fat32_nextcluster
               S02:0000179A:  85 5F
F06:0638         lda fat32_rootcluster+1
               S02:0000179C:  A5 58
F06:0639         sta fat32_nextcluster+1
               S02:0000179E:  85 60
F06:0640         lda fat32_rootcluster+2
               S02:000017A0:  A5 59
F06:0641         sta fat32_nextcluster+2
               S02:000017A2:  85 61
F06:0642         lda fat32_rootcluster+3
               S02:000017A4:  A5 5A
F06:0643         sta fat32_nextcluster+3
               S02:000017A6:  85 62
F06:0644       
F06:0645         jsr fat32_seekcluster
               S02:000017A8:  20 C2 15
F06:0646       
F06:0647         ; Set the pointer to a large value so we always read a sector the first time through
F06:0648         lda #$ff
               S02:000017AB:  A9 FF
F06:0649         sta zp_sd_address+1
               S02:000017AD:  85 49
F06:0650       
F06:0651         rts
               S02:000017AF:  60
F06:0652       
F06:0653       fat32_allocatecluster:
F06:0654         ; Allocate a cluster to store a file at.
F06:0655         ; Must be done BEFORE running fat32_opendirent.
F06:0656       
F06:0657         ; Find a free cluster
F06:0658         jsr fat32_findnextfreecluster
               S02:000017B0:  20 C4 17
F06:0659       
F06:0660         ; Cache the value so we can add the address of the next one later, if any
F06:0661         lda fat32_lastfoundfreecluster
               S02:000017B3:  A5 67
F06:0662         sta fat32_lastcluster
               S02:000017B5:  85 6D
F06:0663         lda fat32_lastfoundfreecluster+1
               S02:000017B7:  A5 68
F06:0664         sta fat32_lastcluster+1
               S02:000017B9:  85 6E
F06:0665         lda fat32_lastfoundfreecluster+2
               S02:000017BB:  A5 69
F06:0666         sta fat32_lastcluster+2
               S02:000017BD:  85 6F
F06:0667         lda fat32_lastfoundfreecluster+3
               S02:000017BF:  A5 6A
F06:0668         sta fat32_lastcluster+3
               S02:000017C1:  85 70
F06:0669       
F06:0670         ; Add marker for new routines, so we don't think this is free.
F06:0671         ;lda #$0f
F06:0672         ;sta (zp_sd_address),y
F06:0673       
F06:0674         rts
               S02:000017C3:  60
F06:0675       
F06:0676       fat32_findnextfreecluster:
F06:0677       ; Find next free cluster
F06:0678       ; 
F06:0679       ; This program will search the FAT for an empty entry, and
F06:0680       ; save the 32-bit cluster number at fat32_lastfoundfreecluter.
F06:0681       ;
F06:0682       ; Also sets the carry bit if the SD card is full.
F06:0683       ;
F06:0684       
F06:0685         ; Find a free cluster and store it's location in fat32_lastfoundfreecluster
F06:0686       
F06:0687         lda #0
               S02:000017C4:  A9 00
F06:0688         sta fat32_nextcluster
               S02:000017C6:  85 5F
F06:0689         sta fat32_lastfoundfreecluster
               S02:000017C8:  85 67
F06:0690         sta fat32_nextcluster+1
               S02:000017CA:  85 60
F06:0691         sta fat32_lastfoundfreecluster+1
               S02:000017CC:  85 68
F06:0692         sta fat32_nextcluster+2
               S02:000017CE:  85 61
F06:0693         sta fat32_lastfoundfreecluster+2
               S02:000017D0:  85 69
F06:0694         sta fat32_nextcluster+3
               S02:000017D2:  85 62
F06:0695         sta fat32_lastfoundfreecluster+3
               S02:000017D4:  85 6A
F06:0696       
F06:0697       .searchclusters
F06:0698       
F06:0699         ; Seek cluster
F06:0700         jsr fat32_seekcluster
               S02:000017D6:  20 C2 15
F06:0701       
F06:0702         ; Is the cluster free?
F06:0703         lda fat32_nextcluster
               S02:000017D9:  A5 5F
F06:0704         and #$0f
               S02:000017DB:  29 0F
F06:0705         ora fat32_nextcluster+1
               S02:000017DD:  05 60
F06:0706         ora fat32_nextcluster+2
               S02:000017DF:  05 61
F06:0707         ora fat32_nextcluster+3
               S02:000017E1:  05 62
F06:0708         beq .foundcluster
               S02:000017E3:  F0 21
F06:0709       
F06:0710         ; No, increment the cluster count
F06:0711         inc fat32_lastfoundfreecluster
               S02:000017E5:  E6 67
F06:0712         bne .copycluster
               S02:000017E7:  D0 0A
F06:0713         inc fat32_lastfoundfreecluster+1
               S02:000017E9:  E6 68
F06:0714         bne .copycluster
               S02:000017EB:  D0 06
F06:0715         inc fat32_lastfoundfreecluster+2
               S02:000017ED:  E6 69
F06:0716         bne .copycluster
               S02:000017EF:  D0 02
F06:0717         inc fat32_lastfoundfreecluster+3
               S02:000017F1:  E6 6A
F06:0718       
F06:0719       .copycluster
F06:0720       
F06:0721         ; Copy the cluster count to the next cluster
F06:0722         lda fat32_lastfoundfreecluster
               S02:000017F3:  A5 67
F06:0723         sta fat32_nextcluster
               S02:000017F5:  85 5F
F06:0724         lda fat32_lastfoundfreecluster+1
               S02:000017F7:  A5 68
F06:0725         sta fat32_nextcluster+1
               S02:000017F9:  85 60
F06:0726         lda fat32_lastfoundfreecluster+2
               S02:000017FB:  A5 69
F06:0727         sta fat32_nextcluster+2
               S02:000017FD:  85 61
F06:0728         lda fat32_lastfoundfreecluster+3
               S02:000017FF:  A5 6A
F06:0729         sta fat32_nextcluster+3
               S02:00001801:  85 62
F06:0730         
F06:0731         ; Go again for another pass
F06:0732         jmp .searchclusters
               S02:00001803:  4C D6 17
F06:0733       
F06:0734       .foundcluster
F06:0735         ; done.
F06:0736         rts
               S02:00001806:  60
F06:0737       
F06:0738       fat32_opendirent:
F06:0739         ; Prepare to read/write a file or directory based on a dirent
F06:0740         ;
F06:0741         ; Point zp_sd_address at the dirent
F06:0742       
F06:0743         ; Remember file size in bytes remaining
F06:0744         ldy #28
               S02:00001807:  A0 1C
F06:0745         lda (zp_sd_address),y
               S02:00001809:  B1 48
F06:0746         sta fat32_bytesremaining
               S02:0000180B:  85 63
F06:0747         iny
               S02:0000180D:  C8
F06:0748         lda (zp_sd_address),y
               S02:0000180E:  B1 48
F06:0749         sta fat32_bytesremaining+1
               S02:00001810:  85 64
F06:0750         iny
               S02:00001812:  C8
F06:0751         lda (zp_sd_address),y
               S02:00001813:  B1 48
F06:0752         sta fat32_bytesremaining+2
               S02:00001815:  85 65
F06:0753         iny
               S02:00001817:  C8
F06:0754         lda (zp_sd_address),y
               S02:00001818:  B1 48
F06:0755         sta fat32_bytesremaining+3
               S02:0000181A:  85 66
F06:0756       
F06:0757         ; Seek to first cluster
F06:0758         ldy #26
               S02:0000181C:  A0 1A
F06:0759         lda (zp_sd_address),y
               S02:0000181E:  B1 48
F06:0760         sta fat32_nextcluster
               S02:00001820:  85 5F
F06:0761         iny
               S02:00001822:  C8
F06:0762         lda (zp_sd_address),y
               S02:00001823:  B1 48
F06:0763         sta fat32_nextcluster+1
               S02:00001825:  85 60
F06:0764         ldy #20
               S02:00001827:  A0 14
F06:0765         lda (zp_sd_address),y
               S02:00001829:  B1 48
F06:0766         sta fat32_nextcluster+2
               S02:0000182B:  85 61
F06:0767         iny
               S02:0000182D:  C8
F06:0768         lda (zp_sd_address),y
               S02:0000182E:  B1 48
F06:0769         sta fat32_nextcluster+3
               S02:00001830:  85 62
F06:0770       
F06:0771         jsr fat32_seekcluster
               S02:00001832:  20 C2 15
F06:0772       
F06:0773         ; Set the pointer to a large value so we always read a sector the first time through
F06:0774         lda #$ff
               S02:00001835:  A9 FF
F06:0775         sta zp_sd_address+1
               S02:00001837:  85 49
F06:0776       
F06:0777         rts
               S02:00001839:  60
F06:0778       
F06:0779       fat32_writedirent:
F06:0780         ; Write a directory entry from the open directory
F06:0781         ; requires:
F06:0782         ;   fat32bytesremaining (2 bytes) = file size in bytes (little endian)
F06:0783         ;   and the processes of:
F06:0784         ;     fat32_finddirent
F06:0785         ;     fat32_findnextfreecluster
F06:0786         ; BUG fix windows-specific stuff so i can read a written file on my pc
F06:0787       
F06:0788         ; Increment pointer by 32 to point to next entry
F06:0789         clc
               S02:0000183A:  18
F06:0790         lda zp_sd_address
               S02:0000183B:  A5 48
F06:0791         adc #32
               S02:0000183D:  69 20
F06:0792         sta zp_sd_address
               S02:0000183F:  85 48
F06:0793         lda zp_sd_address+1
               S02:00001841:  A5 49
F06:0794         adc #0
               S02:00001843:  69 00
F06:0795         sta zp_sd_address+1
               S02:00001845:  85 49
F06:0796       
F06:0797         ; If it's not at the end of the buffer, we have data already
F06:0798         cmp #>(fat32_readbuffer+$200)
               S02:00001847:  C9 07
F06:0799         bcc .gotdirrent
               S02:00001849:  90 0F
F06:0800       
F06:0801         ; Read another sector
F06:0802         lda #<fat32_readbuffer
               S02:0000184B:  A9 00
F06:0803         sta fat32_address
               S02:0000184D:  85 5D
F06:0804         lda #>fat32_readbuffer
               S02:0000184F:  A9 05
F06:0805         sta fat32_address+1
               S02:00001851:  85 5E
F06:0806       
F06:0807         jsr fat32_readnextsector
               S02:00001853:  20 9A 16
F06:0808         bcc .gotdirrent
               S02:00001856:  90 02
F06:0809       
F06:0810       .endofdirectorywrite:
F06:0811         sec
               S02:00001858:  38
F06:0812         rts
               S02:00001859:  60
F06:0813       
F06:0814       .gotdirrent:
F06:0815         ; Check first character
F06:0816         clc
               S02:0000185A:  18
F06:0817         ldy #0
               S02:0000185B:  A0 00
F06:0818         lda (zp_sd_address),y
               S02:0000185D:  B1 48
F06:0819         bne fat32_writedirent ; go again
               S02:0000185F:  D0 D9
F06:0820         ; End of directory. Now make a new entry.
F06:0821       .dloop:
F06:0822         lda (fat32_filenamepointer),y	; copy filename
               S02:00001861:  B1 78
F06:0823         sta (zp_sd_address),y
               S02:00001863:  91 48
F06:0824         iny
               S02:00001865:  C8
F06:0825         cpy #$0b
               S02:00001866:  C0 0B
F06:0826         bne .dloop
               S02:00001868:  D0 F7
F06:0827         ; The full Short filename is #11 bytes long so,
F06:0828         ; this start at 0x0b - File type
F06:0829         ; BUG assumes that we are making a file, not a folder...
F06:0830         lda #$20		; File Type: ARCHIVE
               S02:0000186A:  A9 20
F06:0831         sta (zp_sd_address),y
               S02:0000186C:  91 48
F06:0832         iny   ; 0x0c - Checksum/File accsess password
               S02:0000186E:  C8
F06:0833         lda #$10		            ; No checksum or password
               S02:0000186F:  A9 10
F06:0834         sta (zp_sd_address),y
               S02:00001871:  91 48
F06:0835         iny   ; 0x0d - first char of deleted file - 0x7d for nothing
               S02:00001873:  C8
F06:0836         lda #$7D
               S02:00001874:  A9 7D
F06:0837         sta (zp_sd_address),y
               S02:00001876:  91 48
F06:0838         iny	; 0x0e-0x11 - File creation time/date
               S02:00001878:  C8
F06:0839         lda #0
               S02:00001879:  A9 00
F06:0840       .empty
F06:0841         sta (zp_sd_address),y	; No time/date because I don't have an RTC
               S02:0000187B:  91 48
F06:0842         iny
               S02:0000187D:  C8
F06:0843         cpy #$14 ; also empty the user ID (0x12-0x13)
               S02:0000187E:  C0 14
F06:0844         bne .empty
               S02:00001880:  D0 F9
F06:0845         ;sta (zp_sd_address),y
F06:0846         ;iny
F06:0847         ;sta (zp_sd_address),y
F06:0848         ;iny
F06:0849         ;sta (zp_sd_address),y
F06:0850         ; if you have an RTC, refer to https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#Directory_entry 
F06:0851         ; show the "Directory entry" table and look at at 0x0E onward.
F06:0852         ;iny   ; 0x12-0x13 - User ID
F06:0853         ;lda #0
F06:0854         ;sta (zp_sd_address),y	; No ID
F06:0855         ;iny
F06:0856         ;sta (zp_sd_address),y
F06:0857         ;iny 
F06:0858         ; 0x14-0x15 - File start cluster (high word)
F06:0859         lda fat32_lastfoundfreecluster+2
               S02:00001882:  A5 69
F06:0860         sta (zp_sd_address),y
               S02:00001884:  91 48
F06:0861         iny
               S02:00001886:  C8
F06:0862         lda fat32_lastfoundfreecluster+3
               S02:00001887:  A5 6A
F06:0863         sta (zp_sd_address),y
               S02:00001889:  91 48
F06:0864         iny ; 0x16-0x19 - File modifiaction date
               S02:0000188B:  C8
F06:0865         lda #0
               S02:0000188C:  A9 00
F06:0866         sta (zp_sd_address),y
               S02:0000188E:  91 48
F06:0867         iny
               S02:00001890:  C8
F06:0868         sta (zp_sd_address),y   ; no rtc
               S02:00001891:  91 48
F06:0869         iny
               S02:00001893:  C8
F06:0870         sta (zp_sd_address),y
               S02:00001894:  91 48
F06:0871         iny
               S02:00001896:  C8
F06:0872         sta (zp_sd_address),y
               S02:00001897:  91 48
F06:0873         iny ; 0x1a-0x1b - File start cluster (low word)
               S02:00001899:  C8
F06:0874         lda fat32_lastfoundfreecluster
               S02:0000189A:  A5 67
F06:0875         sta (zp_sd_address),y
               S02:0000189C:  91 48
F06:0876         iny
               S02:0000189E:  C8
F06:0877         lda fat32_lastfoundfreecluster+1
               S02:0000189F:  A5 68
F06:0878         sta (zp_sd_address),y
               S02:000018A1:  91 48
F06:0879         iny ; 0x1c-0x1f File size in bytes
               S02:000018A3:  C8
F06:0880         lda fat32_bytesremaining
               S02:000018A4:  A5 63
F06:0881         sta (zp_sd_address),y
               S02:000018A6:  91 48
F06:0882         iny
               S02:000018A8:  C8
F06:0883         lda fat32_bytesremaining+1
               S02:000018A9:  A5 64
F06:0884         sta (zp_sd_address),y
               S02:000018AB:  91 48
F06:0885         iny
               S02:000018AD:  C8
F06:0886         lda #0
               S02:000018AE:  A9 00
F06:0887         sta (zp_sd_address),y ; Not bigger that 64k
               S02:000018B0:  91 48
F06:0888         iny
               S02:000018B2:  C8
F06:0889         sta (zp_sd_address),y
               S02:000018B3:  91 48
F06:0890         iny
               S02:000018B5:  C8
F06:0891         ; are we over the buffer?
F06:0892         lda zp_sd_address+1
               S02:000018B6:  A5 49
F06:0893         cmp #>(fat32_readbuffer+$200)
               S02:000018B8:  C9 07
F06:0894         bcc .notoverbuffer
               S02:000018BA:  90 12
F06:0895         jsr .wr ; if so, write the current sector
               S02:000018BC:  20 D9 18
F06:0896         jsr fat32_readnextsector  ; then read the next one.
               S02:000018BF:  20 9A 16
F06:0897         bcs .dfail
               S02:000018C2:  B0 13
F06:0898         ldy #0
               S02:000018C4:  A0 00
F06:0899         lda #<fat32_readbuffer
               S02:000018C6:  A9 00
F06:0900         sta zp_sd_address
               S02:000018C8:  85 48
F06:0901         lda #>fat32_readbuffer
               S02:000018CA:  A9 05
F06:0902         sta zp_sd_address+1
               S02:000018CC:  85 49
F06:0903       .notoverbuffer
F06:0904         ; next entry is 0 (end of dir)
F06:0905         lda #0
               S02:000018CE:  A9 00
F06:0906         sta (zp_sd_address),y
               S02:000018D0:  91 48
F06:0907         ;jsr fat32_writenextsector ; write all the data...
F06:0908         jsr .wr
               S02:000018D2:  20 D9 18
F06:0909         clc
               S02:000018D5:  18
F06:0910         rts
               S02:000018D6:  60
F06:0911       
F06:0912       .dfail:
F06:0913         ; Card Full
F06:0914         sec
               S02:000018D7:  38
F06:0915         rts
               S02:000018D8:  60
F06:0916       
F06:0917       .wr
F06:0918       
F06:0919         ; fix thingy
F06:0920         lda zp_sd_currentsector
               S02:000018D9:  A5 4A
F06:0921         bne .skip
               S02:000018DB:  D0 0A
F06:0922         dec zp_sd_currentsector+1
               S02:000018DD:  C6 4B
F06:0923         bne .skip
               S02:000018DF:  D0 06
F06:0924         dec zp_sd_currentsector+2
               S02:000018E1:  C6 4C
F06:0925         bne .skip
               S02:000018E3:  D0 02
F06:0926         dec zp_sd_currentsector+3
               S02:000018E5:  C6 4D
F06:0927       
F06:0928       .skip
F06:0929         dec zp_sd_currentsector
               S02:000018E7:  C6 4A
F06:0930       
F06:0931       .nodec
F06:0932       
F06:0933         lda fat32_address
               S02:000018E9:  A5 5D
F06:0934         sta zp_sd_address
               S02:000018EB:  85 48
F06:0935         lda fat32_address+1
               S02:000018ED:  A5 5E
F06:0936         sta zp_sd_address+1
               S02:000018EF:  85 49
F06:0937       
F06:0938         ; Read the sector
F06:0939         jsr sd_writesector
               S02:000018F1:  20 54 14
F06:0940       
F06:0941         ; Advance to next sector
F06:0942         inc zp_sd_currentsector
               S02:000018F4:  E6 4A
F06:0943         bne .sectorincrementdone
               S02:000018F6:  D0 0A
F06:0944         inc zp_sd_currentsector+1
               S02:000018F8:  E6 4B
F06:0945         bne .sectorincrementdone
               S02:000018FA:  D0 06
F06:0946         inc zp_sd_currentsector+2
               S02:000018FC:  E6 4C
F06:0947         bne .sectorincrementdone
               S02:000018FE:  D0 02
F06:0948         inc zp_sd_currentsector+3
               S02:00001900:  E6 4D
F06:0949       
F06:0950       .sectorincrementdone
F06:0951         rts
               S02:00001902:  60
F06:0952       
F06:0953       fat32_readdirent:
F06:0954         ; Read a directory entry from the open directory
F06:0955         ;
F06:0956         ; On exit the carry is set if there were no more directory entries.
F06:0957         ;
F06:0958         ; Otherwise, A is set to the file's attribute byte and
F06:0959         ; zp_sd_address points at the returned directory entry.
F06:0960         ; LFNs and empty entries are ignored automatically.
F06:0961       
F06:0962         ; Increment pointer by 32 to point to next entry
F06:0963         clc
               S02:00001903:  18
F06:0964         lda zp_sd_address
               S02:00001904:  A5 48
F06:0965         adc #32
               S02:00001906:  69 20
F06:0966         sta zp_sd_address
               S02:00001908:  85 48
F06:0967         lda zp_sd_address+1
               S02:0000190A:  A5 49
F06:0968         adc #0
               S02:0000190C:  69 00
F06:0969         sta zp_sd_address+1
               S02:0000190E:  85 49
F06:0970       
F06:0971         ; If it's not at the end of the buffer, we have data already
F06:0972         cmp #>(fat32_readbuffer+$200)
               S02:00001910:  C9 07
F06:0973         bcc .gotdata
               S02:00001912:  90 0F
F06:0974       
F06:0975         ; Read another sector
F06:0976         lda #<fat32_readbuffer
               S02:00001914:  A9 00
F06:0977         sta fat32_address
               S02:00001916:  85 5D
F06:0978         lda #>fat32_readbuffer
               S02:00001918:  A9 05
F06:0979         sta fat32_address+1
               S02:0000191A:  85 5E
F06:0980       
F06:0981         jsr fat32_readnextsector
               S02:0000191C:  20 9A 16
F06:0982         bcc .gotdata
               S02:0000191F:  90 02
F06:0983       
F06:0984       .endofdirectory:
F06:0985         sec
               S02:00001921:  38
F06:0986         rts
               S02:00001922:  60
F06:0987       
F06:0988       .gotdata:
F06:0989         ; Check first character
F06:0990         ldy #0
               S02:00001923:  A0 00
F06:0991         lda (zp_sd_address),y
               S02:00001925:  B1 48
F06:0992       
F06:0993         ; End of directory => abort
F06:0994         beq .endofdirectory
               S02:00001927:  F0 F8
F06:0995       
F06:0996         ; Empty entry => start again
F06:0997         cmp #$e5
               S02:00001929:  C9 E5
F06:0998         beq fat32_readdirent
               S02:0000192B:  F0 D6
F06:0999       
F06:1000         ; Check attributes
F06:1001         ldy #11
               S02:0000192D:  A0 0B
F06:1002         lda (zp_sd_address),y
               S02:0000192F:  B1 48
F06:1003         and #$3f
               S02:00001931:  29 3F
F06:1004         cmp #$0f ; LFN => start again
               S02:00001933:  C9 0F
F06:1005         beq fat32_readdirent
               S02:00001935:  F0 CC
F06:1006       
F06:1007         ; Yield this result
F06:1008         clc
               S02:00001937:  18
F06:1009         rts
               S02:00001938:  60
F06:1010       
F06:1011       
F06:1012       fat32_finddirent:
F06:1013         ; Finds a particular directory entry. X,Y point to the 11-character filename to seek.
F06:1014         ; The directory should already be open for iteration.
F06:1015       
F06:1016         ; Form ZP pointer to user's filename
F06:1017         stx fat32_filenamepointer
               S02:00001939:  86 78
F06:1018         sty fat32_filenamepointer+1
               S02:0000193B:  84 79
F06:1019         
F06:1020         ; Iterate until name is found or end of directory
F06:1021       .direntloop:
F06:1022         jsr fat32_readdirent
               S02:0000193D:  20 03 19
F06:1023         ldy #10
               S02:00001940:  A0 0A
F06:1024         bcc .comparenameloop
               S02:00001942:  90 01
F06:1025         rts ; with carry set
               S02:00001944:  60
F06:1026       
F06:1027       .comparenameloop:
F06:1028         lda (zp_sd_address),y
               S02:00001945:  B1 48
F06:1029         cmp (fat32_filenamepointer),y
               S02:00001947:  D1 78
F06:1030         bne .direntloop ; no match
               S02:00001949:  D0 F2
F06:1031         dey
               S02:0000194B:  88
F06:1032         bpl .comparenameloop
               S02:0000194C:  10 F7
F06:1033       
F06:1034         ; Found it
F06:1035         clc
               S02:0000194E:  18
F06:1036         rts
               S02:0000194F:  60
F06:1037       
F06:1038       
F06:1039       fat32_file_readbyte:
F06:1040         ; Read a byte from an open file
F06:1041         ;
F06:1042         ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
F06:1043       
F06:1044         sec
               S02:00001950:  38
F06:1045       
F06:1046         ; Is there any data to read at all?
F06:1047         lda fat32_bytesremaining
               S02:00001951:  A5 63
F06:1048         ora fat32_bytesremaining+1
               S02:00001953:  05 64
F06:1049         ora fat32_bytesremaining+2
               S02:00001955:  05 65
F06:1050         ora fat32_bytesremaining+3
               S02:00001957:  05 66
F06:1051         beq .rts
               S02:00001959:  F0 3D
F06:1052       
F06:1053         ; Decrement the remaining byte count
F06:1054         lda fat32_bytesremaining
               S02:0000195B:  A5 63
F06:1055         sbc #1
               S02:0000195D:  E9 01
F06:1056         sta fat32_bytesremaining
               S02:0000195F:  85 63
F06:1057         lda fat32_bytesremaining+1
               S02:00001961:  A5 64
F06:1058         sbc #0
               S02:00001963:  E9 00
F06:1059         sta fat32_bytesremaining+1
               S02:00001965:  85 64
F06:1060         lda fat32_bytesremaining+2
               S02:00001967:  A5 65
F06:1061         sbc #0
               S02:00001969:  E9 00
F06:1062         sta fat32_bytesremaining+2
               S02:0000196B:  85 65
F06:1063         lda fat32_bytesremaining+3
               S02:0000196D:  A5 66
F06:1064         sbc #0
               S02:0000196F:  E9 00
F06:1065         sta fat32_bytesremaining+3
               S02:00001971:  85 66
F06:1066         
F06:1067         ; Need to read a new sector?
F06:1068         lda zp_sd_address+1
               S02:00001973:  A5 49
F06:1069         cmp #>(fat32_readbuffer+$200)
               S02:00001975:  C9 07
F06:1070         bcc .gotdata
               S02:00001977:  90 0D
F06:1071       
F06:1072         ; Read another sector
F06:1073         lda #<fat32_readbuffer
               S02:00001979:  A9 00
F06:1074         sta fat32_address
               S02:0000197B:  85 5D
F06:1075         lda #>fat32_readbuffer
               S02:0000197D:  A9 05
F06:1076         sta fat32_address+1
               S02:0000197F:  85 5E
F06:1077       
F06:1078         jsr fat32_readnextsector
               S02:00001981:  20 9A 16
F06:1079         bcs .rts                    ; this shouldn't happen
               S02:00001984:  B0 12
F06:1080       
F06:1081       .gotdata:
F06:1082         ldy #0
               S02:00001986:  A0 00
F06:1083         lda (zp_sd_address),y
               S02:00001988:  B1 48
F06:1084       
F06:1085         inc zp_sd_address
               S02:0000198A:  E6 48
F06:1086         bne .rts
               S02:0000198C:  D0 0A
F06:1087         inc zp_sd_address+1
               S02:0000198E:  E6 49
F06:1088         bne .rts
               S02:00001990:  D0 06
F06:1089         inc zp_sd_address+2
               S02:00001992:  E6 4A
F06:1090         bne .rts
               S02:00001994:  D0 02
F06:1091         inc zp_sd_address+3
               S02:00001996:  E6 4B
F06:1092       
F06:1093       .rts:
F06:1094         rts
               S02:00001998:  60
F06:1095       
F06:1096       
F06:1097       fat32_file_read:
F06:1098         ; Read a whole file into memory.  It's assumed the file has just been opened 
F06:1099         ; and no data has been read yet.
F06:1100         ;
F06:1101         ; Also we read whole sectors, so data in the target region beyond the end of the 
F06:1102         ; file may get overwritten, up to the next 512-byte boundary.
F06:1103         ;
F06:1104         ; And we don't properly support 64k+ files, as it's unnecessary complication given
F06:1105         ; the 6502's small address space
F06:1106       
F06:1107         ; Round the size up to the next whole sector
F06:1108         lda fat32_bytesremaining
               S02:00001999:  A5 63
F06:1109         cmp #1                      ; set carry if bottom 8 bits not zero
               S02:0000199B:  C9 01
F06:1110         lda fat32_bytesremaining+1
               S02:0000199D:  A5 64
F06:1111         adc #0                      ; add carry, if any
               S02:0000199F:  69 00
F06:1112         lsr                         ; divide by 2
               S02:000019A1:  4A
F06:1113         adc #0                      ; round up
               S02:000019A2:  69 00
F06:1114       
F06:1115         ; No data?
F06:1116         beq .done
               S02:000019A4:  F0 12
F06:1117       
F06:1118         ; Store sector count - not a byte count any more
F06:1119         sta fat32_bytesremaining
               S02:000019A6:  85 63
F06:1120       
F06:1121         ; Read entire sectors to the user-supplied buffer
F06:1122       .wholesectorreadloop:
F06:1123         ; Read a sector to fat32_address
F06:1124         jsr fat32_readnextsector
               S02:000019A8:  20 9A 16
F06:1125       
F06:1126         ; Advance fat32_address by 512 bytes
F06:1127         lda fat32_address+1
               S02:000019AB:  A5 5E
F06:1128         adc #2                      ; carry already clear
               S02:000019AD:  69 02
F06:1129         sta fat32_address+1
               S02:000019AF:  85 5E
F06:1130       
F06:1131         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
               S02:000019B1:  A6 63
F06:1132         dex
               S02:000019B3:  CA
F06:1133         stx fat32_bytesremaining    ; note - actually stores sectors remaining
               S02:000019B4:  86 63
F06:1134       
F06:1135         bne .wholesectorreadloop
               S02:000019B6:  D0 F0
F06:1136       
F06:1137       .done:
F06:1138         rts
               S02:000019B8:  60
F06:1139       
F06:1140       fat32_file_write:
F06:1141         ; Write a whole file from memory.  It's assumed the file has just been opened 
F06:1142         ; and no data has been written yet.
F06:1143         ;
F06:1144         ; Also we write whole sectors, so data in the target region beyond the end of the 
F06:1145         ; file may get overwritten, up to the next 512-byte boundary.
F06:1146         ;
F06:1147         ; And we don't properly support 64k+ files, as it's unnecessary complication given
F06:1148         ; the 6502's small address space
F06:1149       
F06:1150         ; Round the size up to the next whole sector
F06:1151         lda fat32_bytesremaining
               S02:000019B9:  A5 63
F06:1152         cmp #1                      ; set carry if bottom 8 bits not zero
               S02:000019BB:  C9 01
F06:1153         lda fat32_bytesremaining+1
               S02:000019BD:  A5 64
F06:1154         adc #0                      ; add carry, if any
               S02:000019BF:  69 00
F06:1155         lsr                         ; divide by 2
               S02:000019C1:  4A
F06:1156         adc #0                      ; round up
               S02:000019C2:  69 00
F06:1157       
F06:1158         ; No data?
F06:1159         beq .fail
               S02:000019C4:  F0 16
F06:1160       
F06:1161         ; Store sector count - not a byte count anymore.
F06:1162         sta fat32_bytesremaining
               S02:000019C6:  85 63
F06:1163       
F06:1164         ; We will be making a new cluster the first time around
F06:1165         stz fat32_pendingsectors
               S02:000019C8:  64 5C
F06:1166       
F06:1167         ; Write entire sectors from the user-supplied buffer
F06:1168       .wholesectorwriteloop:
F06:1169         ; Write a sector from fat32_address
F06:1170         jsr fat32_writenextsector
               S02:000019CA:  20 C4 16
F06:1171         bcs .fail	; this shouldn't happen
               S02:000019CD:  B0 0D
F06:1172       
F06:1173         ; Advance fat32_address by 512 bytes
F06:1174         lda fat32_address+1
               S02:000019CF:  A5 5E
F06:1175         adc #2                      ; carry already clear
               S02:000019D1:  69 02
F06:1176         sta fat32_address+1
               S02:000019D3:  85 5E
F06:1177       
F06:1178         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
               S02:000019D5:  A6 63
F06:1179         dex
               S02:000019D7:  CA
F06:1180         stx fat32_bytesremaining    ; note - actually stores sectors remaining
               S02:000019D8:  86 63
F06:1181       
F06:1182         bne .wholesectorwriteloop
               S02:000019DA:  D0 EE
F06:1183       
F06:1184         ; Has fat32_writenextsector written the FAT table?
F06:1185         ;lda fat32_newfatsector
F06:1186         ;bne .fail  ; not a fail, just means its done.
F06:1187       
F06:1188         ; No, write it here.
F06:1189         ;lda fat32_lastsector
F06:1190         ;sta zp_sd_currentsector
F06:1191         ;lda fat32_lastsector+1
F06:1192         ;sta zp_sd_currentsector+1
F06:1193         ;lda fat32_lastsector+2
F06:1194         ;sta zp_sd_currentsector+2
F06:1195         ;lda fat32_lastsector+3
F06:1196         ;sta zp_sd_currentsector+3
F06:1197       
F06:1198         ; Target buffer
F06:1199         ;lda #<fat32_readbuffer
F06:1200         ;sta zp_sd_address
F06:1201         ;lda #>fat32_readbuffer
F06:1202         ;sta zp_sd_address+1
F06:1203       
F06:1204         ; Write the FAT sector
F06:1205         ;jsr sd_writesector
F06:1206       
F06:1207       .fail
F06:1208         rts
               S02:000019DC:  60
F06:1209       
F00:0082       
F00:0083       rootsetup:		; setup <ROOT>
F00:0084       
F00:0085         ; Open root directory
F00:0086         jsr fat32_openroot
               S02:000019DD:  20 98 17
F00:0087       
F00:0088         ; Find the subdirectory by name
F00:0089         ldx #<dirname
               S02:000019E0:  A2 36
F00:0090         ldy #>dirname
               S02:000019E2:  A0 1A
F00:0091         jsr fat32_finddirent
               S02:000019E4:  20 39 19
F00:0092         bcc foundsub
               S02:000019E7:  90 03
F00:0093       
F00:0094         ; Subdirectory not found
F00:0095         jmp transfer_error
               S02:000019E9:  4C F0 19
F00:0096       
F00:0097       foundsub:
F00:0098       
F00:0099         ; Open subdirectory
F00:0100         jsr fat32_opendirent	; open folder
               S02:000019EC:  20 07 18
F00:0101       	
F00:0102         rts			; done
               S02:000019EF:  60
F00:0103       
F00:0104       transfer_error:
F00:0105         ldy #>errormsg
               S02:000019F0:  A0 1A
F00:0106         ldx #<errormsg
               S02:000019F2:  A2 42
F00:0107         jsr w_acia_full
               S02:000019F4:  20 C5 12
F00:0108         jsr error_sound
               S02:000019F7:  20 0D 0F
F00:0109         jmp doneloop
               S02:000019FA:  4C 33 1A
F00:0110       
F00:0111       ;msincremaining:
F00:0112       ;  inc fat32_bytesremaining
F00:0113       ;  bne msinca
F00:0114       ;  inc fat32_bytesremaining+1
F00:0115       ;msinca:
F00:0116       ;  inc XYLODSAV2
F00:0117       ;  bne msincb
F00:0118       ;  inc XYLODSAV2+1
F00:0119       ;msincb:
F00:0120       ;  rts
F00:0121       
F00:0122       MEMORY_SAVE:
F00:0123       ; finally. this is what we need to debug.
F00:0124         ldx #<savmsg
               S02:000019FD:  A2 8B
F00:0125         ldy #>savmsg
               S02:000019FF:  A0 1A
F00:0126         jsr w_acia_full
               S02:00001A01:  20 C5 12
F00:0127         ; Allocate the first cluster for the data
F00:0128         jsr fat32_allocatecluster
               S02:00001A04:  20 B0 17
F00:0129         ; Open the folder
F00:0130         jsr rootsetup
               S02:00001A07:  20 DD 19
F00:0131         
F00:0132         ;ldy #>sdbuffer
F00:0133         ;ldx #<sdbuffer
F00:0134         ;jsr fat32_finddirent
F00:0135         ;bcs saveok
F00:0136         ;jsr file_exists
F00:0137         ;bcs doneloop
F00:0138       saveok:
F00:0139       ; Now calculate file size and store it in fat32_bytesremaining.
F00:0140       ; For now, just write it.
F00:0141         lda #$80
               S02:00001A0A:  A9 80
F00:0142         sta fat32_bytesremaining+1
               S02:00001A0C:  85 64
F00:0143         lda #$00
               S02:00001A0E:  A9 00
F00:0144         sta fat32_bytesremaining
               S02:00001A10:  85 63
F00:0145         sta fat32_bytesremaining+2
               S02:00001A12:  85 65
F00:0146         sta fat32_bytesremaining+3
               S02:00001A14:  85 66
F00:0147       
F00:0148       ;  lda #$00
F00:0149       ;  sta XYLODSAV2
F00:0150       ;  lda #$07
F00:0151       ;  sta XYLODSAV2+1
F00:0152       ;  lda #0
F00:0153       ;  sta fat32_bytesremaining
F00:0154       ;  sta fat32_bytesremaining+1
F00:0155       ;  ldy #0
F00:0156       ;savecalclp:
F00:0157       ;  lda (XYLODSAV2),y
F00:0158       ;  beq mszero
F00:0159       ;  jsr msincremaining
F00:0160       ;  jmp savecalclp
F00:0161       ;mszero:
F00:0162       ;  jsr msincremaining
F00:0163       
F00:0164         ;lda (XYLODSAV2),y
F00:0165         ;bne savecalclp
F00:0166         ;jsr msincremaining
F00:0167         ;lda (XYLODSAV2),y
F00:0168         ;bne savecalclp
F00:0169       
F00:0170         ; Save filename pointer
F00:0171         lda #<sdbuffer
               S02:00001A16:  A9 4D
F00:0172         sta fat32_filenamepointer
               S02:00001A18:  85 78
F00:0173         lda #>sdbuffer
               S02:00001A1A:  A9 1A
F00:0174         sta fat32_filenamepointer+1
               S02:00001A1C:  85 79
F00:0175       
F00:0176         ; Great, now make a directory entry for this new file.
F00:0177         jsr fat32_writedirent
               S02:00001A1E:  20 3A 18
F00:0178       
F00:0179         ; Now, let's write the file...
F00:0180         lda #$00
               S02:00001A21:  A9 00
F00:0181         sta fat32_address
               S02:00001A23:  85 5D
F00:0182         lda #$c0
               S02:00001A25:  A9 C0
F00:0183         sta fat32_address+1
               S02:00001A27:  85 5E
F00:0184         jsr fat32_file_write  ; Yes. It is finally time to save the file.
               S02:00001A29:  20 B9 19
F00:0185         
F00:0186         ; All done!
F00:0187         ldx #<SAVE_DONE
               S02:00001A2C:  A2 78
F00:0188         ldy #>SAVE_DONE
               S02:00001A2E:  A0 1A
F00:0189         jsr w_acia_full
               S02:00001A30:  20 C5 12
F00:0190       doneloop:
F00:0191         ;jmp doneloop
F00:0192         rts
               S02:00001A33:  60
F00:0193         rts
               S02:00001A34:  60
F00:0194         rts
               S02:00001A35:  60
F00:0195       ;file_exists:
F00:0196         ; clc if 'y'
F00:0197         ; sec if 'n'
F00:0198       ;  ldx #<EXIST_MSG
F00:0199       ;  ldy #>EXIST_MSG
F00:0200       ;  jsr w_acia_full
F00:0201       ;fexlp:
F00:0202       ;  jsr rxpoll
F00:0203       ;  lda ACIAData
F00:0204       ;  pha
F00:0205       ;  cmp #'y'
F00:0206       ;  beq exy
F00:0207       ;  cmp #'n'
F00:0208       ;  beq exn
F00:0209       ;  pla
F00:0210       ;  jmp fexlp
F00:0211       ;exy:
F00:0212       ;  jsr crlf
F00:0213       ;  clc
F00:0214       ;  rts
F00:0215       ;exn:
F00:0216       ;  jsr crlf
F00:0217       ;  sec
F00:0218       ;  rts
F00:0219       
F00:0220       dirname:
F00:0221         .asciiz "FOLDER     "
               S02:00001A36:  46 4F 4C 44 45 52 20 20 20 20 20
F00:0222       errormsg:
F00:0223         .byte CR,LF,"ERROR!",CR,LF
               S02:00001A42:  0D
               S02:00001A43:  0A
               S02:00001A44:  45 52 52 4F 52 21
               S02:00001A4A:  0D
               S02:00001A4B:  0A
F00:0224         .byte 0
               S02:00001A4C:  00
F00:0225       sdbuffer:
F00:0226         .byte "SAVE    BAS" ; save.bas
               S02:00001A4D:  53 41 56 45 20 20 20 20 42 41 53
F00:0227       EXIST_MSG:
F00:0228         .byte "File Exists. Overwrite? (y/n): ",$00
               S02:00001A58:  46 69 6C 65 20 45 78 69 73 74 73 2E 20 4F 76 65
               S02:00001A68:  72 77 72 69 74 65 3F 20 28 79 2F 6E 29 3A 20
               S02:00001A77:  00
F00:0229       SAVE_DONE:
F00:0230         .byte	CR,LF,"Save Complete.",CR,LF,$00
               S02:00001A78:  0D
               S02:00001A79:  0A
               S02:00001A7A:  53 61 76 65 20 43 6F 6D 70 6C 65 74 65 2E
               S02:00001A88:  0D
               S02:00001A89:  0A
               S02:00001A8A:  00
F00:0231       savmsg:
F00:0232         .byte $0d, $0a, "Saving...", $0d, $0a, $00
               S02:00001A8B:  0D
               S02:00001A8C:  0A
               S02:00001A8D:  53 61 76 69 6E 67 2E 2E 2E
               S02:00001A96:  0D
               S02:00001A97:  0A
               S02:00001A98:  00
F00:0233       failedmsg:
F00:0234         .byte "Failed!",CR,LF,$00
               S02:00001A99:  46 61 69 6C 65 64 21
               S02:00001AA0:  0D
               S02:00001AA1:  0A
               S02:00001AA2:  00
F00:0235       


Sections:
S01  segf00
S02  seg1006


Sources:
F00  savetest.s
F01  errors.s
F02  errorsound.s
F03  hwconfig.s
F04  libacia.s
F05  libsd.s
F06  libfat32.s


Symbols:
failedmsg EXPR(6809=0x1a99) UNUSED ABS 
EXIST_MSG EXPR(6744=0x1a58) UNUSED ABS 
SAVE_DONE EXPR(6776=0x1a78) ABS 
sdbuffer EXPR(6733=0x1a4d) ABS 
saveok EXPR(6666=0x1a0a) UNUSED ABS 
savmsg EXPR(6795=0x1a8b) ABS 
doneloop EXPR(6707=0x1a33) ABS 
errormsg EXPR(6722=0x1a42) ABS 
transfer_error EXPR(6640=0x19f0) ABS 
foundsub EXPR(6636=0x19ec) ABS 
dirname EXPR(6710=0x1a36) ABS 
rootsetup EXPR(6621=0x19dd) ABS 
 fat32_file_write wholesectorwriteloop EXPR(6602=0x19ca) ABS 
 fat32_file_write fail EXPR(6620=0x19dc) ABS 
fat32_file_write EXPR(6585=0x19b9) ABS 
 fat32_file_read wholesectorreadloop EXPR(6568=0x19a8) ABS 
 fat32_file_read done EXPR(6584=0x19b8) ABS 
fat32_file_read EXPR(6553=0x1999) UNUSED ABS 
 fat32_file_readbyte gotdata EXPR(6534=0x1986) ABS 
 fat32_file_readbyte rts EXPR(6552=0x1998) ABS 
fat32_file_readbyte EXPR(6480=0x1950) UNUSED ABS 
 fat32_finddirent comparenameloop EXPR(6469=0x1945) ABS 
 fat32_finddirent direntloop EXPR(6461=0x193d) ABS 
fat32_finddirent EXPR(6457=0x1939) ABS 
 fat32_readdirent endofdirectory EXPR(6433=0x1921) ABS 
 fat32_readdirent gotdata EXPR(6435=0x1923) ABS 
fat32_readdirent EXPR(6403=0x1903) ABS 
 fat32_writedirent sectorincrementdone EXPR(6402=0x1902) ABS 
 fat32_writedirent nodec EXPR(6377=0x18e9) UNUSED ABS 
 fat32_writedirent skip EXPR(6375=0x18e7) ABS 
 fat32_writedirent dfail EXPR(6359=0x18d7) ABS 
 fat32_writedirent wr EXPR(6361=0x18d9) ABS 
 fat32_writedirent notoverbuffer EXPR(6350=0x18ce) ABS 
 fat32_writedirent empty EXPR(6267=0x187b) ABS 
 fat32_writedirent dloop EXPR(6241=0x1861) ABS 
 fat32_writedirent endofdirectorywrite EXPR(6232=0x1858) UNUSED ABS 
 fat32_writedirent gotdirrent EXPR(6234=0x185a) ABS 
fat32_writedirent EXPR(6202=0x183a) ABS 
fat32_opendirent EXPR(6151=0x1807) ABS 
 fat32_findnextfreecluster copycluster EXPR(6131=0x17f3) ABS 
 fat32_findnextfreecluster foundcluster EXPR(6150=0x1806) ABS 
 fat32_findnextfreecluster searchclusters EXPR(6102=0x17d6) ABS 
fat32_allocatecluster EXPR(6064=0x17b0) ABS 
fat32_openroot EXPR(6040=0x1798) ABS 
 fat32_writenextsector nopass EXPR(6039=0x1797) UNUSED ABS 
 fat32_writenextsector nextsectorincrementdone EXPR(6010=0x177a) ABS 
fat32_findnextfreecluster EXPR(6084=0x17c4) ABS 
 fat32_writenextsector sectorbounds EXPR(6012=0x177c) ABS 
 fat32_writenextsector lastcluster EXPR(5841=0x16d1) ABS 
 fat32_writenextsector notlastcluster EXPR(5905=0x1711) ABS 
 fat32_writenextsector writesector EXPR(5983=0x175f) ABS 
 fat32_writenextsector newcluster EXPR(5835=0x16cb) ABS 
fat32_writenextsector EXPR(5828=0x16c4) ABS 
 fat32_readnextsector sectorincrementdone EXPR(5824=0x16c0) ABS 
 fat32_readnextsector endofchain EXPR(5826=0x16c2) ABS 
 fat32_readnextsector readsector EXPR(5797=0x16a5) ABS 
fat32_readnextsector EXPR(5786=0x169a) ABS 
 fat32_seekcluster notendofchain EXPR(5785=0x1699) ABS 
 fat32_seekcluster spcshiftloopdone EXPR(5704=0x1648) ABS 
 fat32_seekcluster spcshiftloop EXPR(5690=0x163a) ABS 
 fat32_seekcluster notnew EXPR(5663=0x161f) ABS 
 fat32_seekcluster newsector EXPR(5644=0x160c) ABS 
fat32_seekcluster EXPR(5570=0x15c2) ABS 
 fat32_init skipfatsloop EXPR(5499=0x157b) ABS 
 fat32_init error EXPR(5568=0x15c0) ABS 
 fat32_init foundpart EXPR(5378=0x1502) ABS 
 fat32_init FSTYPE_FAT32 EXPR(12=0xc) EQU 
 fat32_init fail EXPR(5375=0x14ff) ABS 
fat32_init EXPR(5296=0x14b0) UNUSED ABS 
fat32_errorstage EXPR(99=0x63) EQU 
fat32_filenamepointer EXPR(120=0x78) EQU 
fat32_newfatsector EXPR(119=0x77) UNUSED EQU 
fat32_lastsector EXPR(114=0x72) EQU 
fat32_lastcluster EXPR(109=0x6d) EQU 
fat32_sectorsperfat EXPR(107=0x6b) EQU 
fat32_bytesremaining EXPR(99=0x63) EQU 
fat32_nextcluster EXPR(95=0x5f) EQU 
fat32_address EXPR(93=0x5d) EQU 
fat32_pendingsectors EXPR(92=0x5c) EQU 
fat32_sectorspercluster EXPR(91=0x5b) EQU 
fat32_rootcluster EXPR(87=0x57) EQU 
fat32_datastart EXPR(83=0x53) EQU 
fat32_fatstart EXPR(79=0x4f) EQU 
fat32_fatbuffer EXPR(1792=0x700) EQU 
fat32_readbuffer EXPR(1280=0x500) EQU 
 sd_writesector writeloop EXPR(5285=0x14a5) ABS 
 sd_writesector waitidle EXPR(5270=0x1496) ABS 
 sd_writesector writepage EXPR(5283=0x14a3) ABS 
sd_writesector EXPR(5204=0x1454) ABS 
 sd_fail failloop EXPR(5201=0x1451) ABS 
 sd_readsector readloop EXPR(5177=0x1439) ABS 
 sd_readsector readpage EXPR(5175=0x1437) ABS 
sd_fail EXPR(5186=0x1442) ABS 
sd_readsector EXPR(5110=0x13f6) ABS 
sd_waitresult EXPR(5029=0x13a5) ABS 
 sd_writebyte sendbit EXPR(5016=0x1398) ABS 
 sd_writebyte loop EXPR(5008=0x1390) ABS 
sd_writebyte EXPR(5006=0x138e) ABS 
 sd_readbyte bitnotset EXPR(5000=0x1388) ABS 
 sd_readbyte loop EXPR(4981=0x1375) ABS 
 sd_init loop EXPR(4952=0x1358) ABS 
 sd_init delayloop EXPR(4932=0x1344) ABS 
 sd_init initialized EXPR(4941=0x134d) ABS 
sd_cmd41_bytes EXPR(4973=0x136d) ABS 
 sd_init cmd41 EXPR(4909=0x132d) UNUSED ABS 
sd_cmd55_bytes EXPR(4967=0x1367) ABS 
 sd_init cmd55 EXPR(4894=0x131e) ABS 
sd_readbyte EXPR(4979=0x1373) ABS 
sd_cmd8_bytes EXPR(4961=0x1361) ABS 
 sd_init cmd8 EXPR(4867=0x1303) UNUSED ABS 
 sd_init initfailed EXPR(4947=0x1353) ABS 
sd_sendcommand EXPR(5037=0x13ad) ABS 
sd_cmd0_bytes EXPR(4955=0x135b) ABS 
 sd_init cmd0 EXPR(4852=0x12f4) UNUSED ABS 
 sd_init preinitloop EXPR(4844=0x12ec) ABS 
sd_init EXPR(4840=0x12e8) UNUSED ABS 
endwacia EXPR(4832=0x12e0) ABS 
acia_man EXPR(4818=0x12d2) ABS 
w_acia_full EXPR(4805=0x12c5) ABS 
ascii_home EXPR(4797=0x12bd) UNUSED ABS 
print_char_acia EXPR(4794=0x12ba) UNUSED ABS 
rxpoll EXPR(4777=0x12a9) ABS 
txpoll EXPR(4769=0x12a1) ABS 
cleardisplay EXPR(4758=0x1296) UNUSED ABS 
crlf EXPR(4737=0x1281) UNUSED ABS 
print_chara EXPR(4785=0x12b1) ABS 
cskipletter EXPR(4731=0x127b) ABS 
print_nybble EXPR(4723=0x1273) ABS 
print_hex_acia EXPR(4714=0x126a) ABS 
acia_init EXPR(4701=0x125d) UNUSED ABS 
via_init EXPR(4690=0x1252) UNUSED ABS 
PORTA_OUTPUTPINS EXPR(252=0xfc) EQU 
SD_MISO EXPR(2=0x2) EQU 
SD_MOSI EXPR(4=0x4) EQU 
SD_SCK EXPR(8=0x8) EQU 
SD_CS EXPR(16=0x10) EQU 
LCD_RS EXPR(32=0x20) EQU 
LCD_RW EXPR(64=0x40) EQU 
LCD_E EXPR(128=0x80) EQU 
DDRA EXPR(45059=0xb003) EQU 
DDRB EXPR(45058=0xb002) EQU 
PORTA EXPR(45057=0xb001) EQU 
PORTB EXPR(45056=0xb000) UNUSED EQU 
csid EXPR(4683=0x124b) ABS 
clear_sid EXPR(4681=0x1249) ABS 
InitSid2 EXPR(4355=0x1103) UNUSED ABS 
L10fa EXPR(4346=0x10fa) ABS 
L10ec EXPR(4332=0x10ec) ABS 
L10cc EXPR(4300=0x10cc) ABS 
L10d0 EXPR(4304=0x10d0) ABS 
L10b8 EXPR(4280=0x10b8) ABS 
L10b2 EXPR(4274=0x10b2) ABS 
L1093 EXPR(4243=0x1093) ABS 
L1085 EXPR(4229=0x1085) ABS 
L107b EXPR(4219=0x107b) ABS 
S10a1 EXPR(4257=0x10a1) ABS 
L104a EXPR(4170=0x104a) ABS 
L1060 EXPR(4192=0x1060) ABS 
L106b EXPR(4203=0x106b) ABS 
L1076 EXPR(4214=0x1076) ABS 
L102e EXPR(4142=0x102e) ABS 
L1038 EXPR(4152=0x1038) ABS 
L1033 EXPR(4147=0x1033) ABS 
L1015 EXPR(4117=0x1015) ABS 
L1008 EXPR(4104=0x1008) ABS 
PlaySid EXPR(4102=0x1006) UNUSED ABS 
d412_sVoc3Control EXPR(47122=0xb812) EQU 
d40b_sVoc2Control EXPR(47115=0xb80b) EQU 
d404_sVoc1Control EXPR(47108=0xb804) EQU 
d400_sVoc1FreqLo EXPR(47104=0xb800) EQU 
continue24542 EXPR(3907=0xf43) ABS 
putbut EXPR(3911=0xf47) ABS 
startupsoundloop EXPR(4655=0x122f) ABS 
InitSid EXPR(3928=0xf58) ABS 
irq EXPR(3889=0xf31) ABS 
runthesound EXPR(3859=0xf13) UNUSED ABS 
error_sound EXPR(3853=0xf0d) ABS 
MEMORY_SAVE EXPR(6653=0x19fd) ABS 
fat32_lastfoundfreecluster EXPR(103=0x67) EQU 
reset EXPR(3840=0xf00) UNUSED ABS 
LF EXPR(10=0xa) EQU 
CR EXPR(13=0xd) EQU 
XYLODSAV2 EXPR(100=0x64) UNUSED EQU 
endbuf EXPR(2304=0x900) UNUSED EQU 
buffer EXPR(1792=0x700) EQU 
fat32_workspace EXPR(1280=0x500) EQU 
path EXPR(1024=0x400) UNUSED EQU 
zp_fat32_variables EXPR(79=0x4f) EQU 
zp_sd_currentsector EXPR(74=0x4a) EQU 
zp_sd_address EXPR(72=0x48) EQU 
donefact EXPR(1=0x1) EQU 
irqcount EXPR(0=0x0) EQU 
ACIAData EXPR(32768=0x8000) UNUSED EQU 
ACIAStatus EXPR(32769=0x8001) UNUSED EQU 
ACIACommand EXPR(32770=0x8002) UNUSED EQU 
ACIAControl EXPR(32771=0x8003) UNUSED EQU 
ACIA EXPR(32768=0x8000) EQU 
__RPTCNT EXPR(-1=0xffff) INTERNAL 
__VASM EXPR(0=0x0) INTERNAL 

There have been no errors.
