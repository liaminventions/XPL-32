F00:0001       done = $00
F00:0002       sample = $01
F00:0003       flag = $02
F00:0004       zp_sd_address = $40         ; 2 bytes
F00:0005       zp_sd_currentsector = $42   ; 4 bytes
F00:0006       zp_fat32_variables = $46    ; 32 bytes
F00:0007       
F00:0008       bytepointer = $66	    ; 4 bytes
F00:0009       
F00:0010       buffer = $400               ; 512 bytes
F00:0011       endbuf = $600
F00:0012       
F00:0013       SID = $b800
F00:0014       
F00:0015       flagSeed = $55           ; flag seed, 8kHz
F00:0016       freq     = $80           ; CIA NMI timer delay, 8kHz
F00:0017       ;flagSeed = $00          ; flag seed, 4Hz
F00:0018       ;freq    = $100          ; CIA NMI timer delay, 4kHz
F00:0019       
F00:0020       	.org $0f00
F00:0021       darn
F00:0022       	jmp ebutrocks
               S01:00000F00:  4C 70 12
F00:0023       
F00:0024       ;datname:
F00:0025       ;  .asciiz "FASTCMC RAW"  ; music file on SD card
F00:0026       ;dirname:
F00:0027       ;  .asciiz "FOLDER     "  ; folder
F00:0028       
F00:0029       	.org $1000
F00:0030       
F00:0031       	.include "hwconfig.s"
F01:0001       PORTB = $b000
F01:0002       PORTA = $b001
F01:0003       DDRB = $b002
F01:0004       DDRA = $b003
F01:0005       
F01:0006       LCD_E  = %10000000
F01:0007       LCD_RW = %01000000
F01:0008       LCD_RS = %00100000
F01:0009       
F01:0010       SD_CS   = %00010000
F01:0011       SD_SCK  = %00001000
F01:0012       SD_MOSI = %00000100
F01:0013       SD_MISO = %00000010
F01:0014       
F01:0015       PORTA_OUTPUTPINS = LCD_E | LCD_RW | LCD_RS | SD_CS | SD_SCK | SD_MOSI
F01:0016       
F01:0017       via_init:
F01:0018         lda #%11111111          ; Set all pins on port B to output
               S02:00001000:  A9 FF
F01:0019         sta DDRB
               S02:00001002:  8D 02 B0
F01:0020         lda #PORTA_OUTPUTPINS   ; Set various pins on port A to output
               S02:00001005:  A9 FC
F01:0021         sta DDRA
               S02:00001007:  8D 03 B0
F01:0022         rts
               S02:0000100A:  60
F01:0023       
F01:0024       
F00:0032               .include "libacia.s"
F02:0001       ;       ------------------ 6551 ACIA Subroutine Library -------------------
F02:0002       ; Includes:
F02:0003       ; acia_init       - Initializes the ACIA
F02:0004       ; print_hex_acia  - Prints a hex value in A
F02:0005       ; crlf		  - Prints <CR> followed by <LF>
F02:0006       ; clear_display   - Sends a <CLS> command
F02:0007       ; txpoll          - Polls the TX bit to see if the ACIA is ready
F02:0008       ; print_chara     - Prints a Character that is stored in A
F02:0009       ; print_char_acia - Same as print_chara
F02:0010       ; ascii_home      - Home the cursor
F02:0011       ; w_acia_full     - Print a NULL-Termintated String with >HIGH in Y and <LOW in X
F02:0012       
F02:0013       acia_init:
F02:0014         pha
               S02:0000100B:  48
F02:0015         lda #%00001011          ; No parity, no echo, no interrupt
               S02:0000100C:  A9 0B
F02:0016         sta $8002
               S02:0000100E:  8D 02 80
F02:0017         lda #%00011111          ; 1 stop bit, 8 data bits, 19200 baud
               S02:00001011:  A9 1F
F02:0018         sta $8003
               S02:00001013:  8D 03 80
F02:0019         pla
               S02:00001016:  68
F02:0020         rts
               S02:00001017:  60
F02:0021       
F02:0022       print_hex_acia:
F02:0023         pha
               S02:00001018:  48
F02:0024         ror
               S02:00001019:  6A
F02:0025         ror
               S02:0000101A:  6A
F02:0026         ror
               S02:0000101B:  6A
F02:0027         ror
               S02:0000101C:  6A
F02:0028         jsr print_nybble   ; This is just som usful hex cod
               S02:0000101D:  20 21 10
F02:0029         pla
               S02:00001020:  68
F02:0030       print_nybble:
F02:0031         and #15
               S02:00001021:  29 0F
F02:0032         cmp #10
               S02:00001023:  C9 0A
F02:0033         bmi cskipletter
               S02:00001025:  30 02
F02:0034         adc #6
               S02:00001027:  69 06
F02:0035       cskipletter:
F02:0036         adc #48
               S02:00001029:  69 30
F02:0037        ; jsr print_char
F02:0038         jsr print_chara
               S02:0000102B:  20 5F 10
F02:0039         rts
               S02:0000102E:  60
F02:0040       
F02:0041       crlf:
F02:0042         pha
               S02:0000102F:  48
F02:0043         txa
               S02:00001030:  8A
F02:0044         pha
               S02:00001031:  48
F02:0045         tya
               S02:00001032:  98
F02:0046         pha
               S02:00001033:  48
F02:0047         lda #$0d
               S02:00001034:  A9 0D
F02:0048         jsr print_chara
               S02:00001036:  20 5F 10
F02:0049         lda #$0a
               S02:00001039:  A9 0A
F02:0050         jsr print_chara
               S02:0000103B:  20 5F 10
F02:0051         pla
               S02:0000103E:  68
F02:0052         tay
               S02:0000103F:  A8
F02:0053         pla
               S02:00001040:  68
F02:0054         tax
               S02:00001041:  AA
F02:0055         pla
               S02:00001042:  68
F02:0056         rts
               S02:00001043:  60
F02:0057       
F02:0058       cleardisplay:
F02:0059         pha
               S02:00001044:  48
F02:0060         jsr txpoll  ; Poll the TX bit
               S02:00001045:  20 4F 10
F02:0061         lda #12     ; Print decimal 12 (CLS)
               S02:00001048:  A9 0C
F02:0062         sta $8000
               S02:0000104A:  8D 00 80
F02:0063         pla
               S02:0000104D:  68
F02:0064         rts
               S02:0000104E:  60
F02:0065       
F02:0066       txpoll:
F02:0067         lda $8001
               S02:0000104F:  AD 01 80
F02:0068         and #$10    ; Poll the TX bit
               S02:00001052:  29 10
F02:0069         beq txpoll
               S02:00001054:  F0 F9
F02:0070         rts
               S02:00001056:  60
F02:0071       
F02:0072       rxpoll:
F02:0073         lda $8001
               S02:00001057:  AD 01 80
F02:0074         and #$08    ; Poll the RX bit
               S02:0000105A:  29 08
F02:0075         beq rxpoll
               S02:0000105C:  F0 F9
F02:0076         rts
               S02:0000105E:  60
F02:0077       
F02:0078       
F02:0079       print_chara:
F02:0080         pha
               S02:0000105F:  48
F02:0081         jsr txpoll  ; Poll the TX bit
               S02:00001060:  20 4F 10
F02:0082         pla
               S02:00001063:  68
F02:0083         sta $8000   ; Print character from A
               S02:00001064:  8D 00 80
F02:0084         rts
               S02:00001067:  60
F02:0085       
F02:0086       print_char_acia:
F02:0087         jmp print_chara  ; Same as "print_chara"
               S02:00001068:  4C 5F 10
F02:0088       
F02:0089       ascii_home:
F02:0090         pha
               S02:0000106B:  48
F02:0091         lda #1
               S02:0000106C:  A9 01
F02:0092         jsr print_chara  ; Print 1 (HOME)
               S02:0000106E:  20 5F 10
F02:0093         pla
               S02:00001071:  68
F02:0094         rts
               S02:00001072:  60
F02:0095       
F02:0096       w_acia_full:
F02:0097         pha
               S02:00001073:  48
F02:0098         lda $ff
               S02:00001074:  A5 FF
F02:0099         pha        ; Push Previous States onto the stack
               S02:00001076:  48
F02:0100         lda $fe
               S02:00001077:  A5 FE
F02:0101         pha
               S02:00001079:  48
F02:0102         sty $ff    ; Set Y as the Upper Address (8-15)
               S02:0000107A:  84 FF
F02:0103         stx $fe    ; Set X as the Lower Adderss (0-7)
               S02:0000107C:  86 FE
F02:0104         ldy #0
               S02:0000107E:  A0 00
F02:0105       acia_man:
F02:0106         jsr txpoll   ; Poll TX
               S02:00001080:  20 4F 10
F02:0107         lda ($fe),y  ; Load the Address
               S02:00001083:  B1 FE
F02:0108         sta $8000    ; Print what is at the address
               S02:00001085:  8D 00 80
F02:0109         beq endwacia ; If Done, End
               S02:00001088:  F0 04
F02:0110         iny          ; Next Character
               S02:0000108A:  C8
F02:0111         jmp acia_man ; Back to the top
               S02:0000108B:  4C 80 10
F02:0112       endwacia:
F02:0113         pla
               S02:0000108E:  68
F02:0114         sta $fe
               S02:0000108F:  85 FE
F02:0115         pla          ; Restore Variables
               S02:00001091:  68
F02:0116         sta $ff
               S02:00001092:  85 FF
F02:0117         pla
               S02:00001094:  68
F02:0118         rts
               S02:00001095:  60
F02:0119       
F00:0033       	.include "libsd.s" ; ah ye sd tim
F03:0001       ; SD card interface module
F03:0002       ;
F03:0003       ; Requires zero-page variable storage:
F03:0004       ;   zp_sd_address - a bytes
F03:0005       ;   zp_sd_currentsector - 4 bytes
F03:0006       
F03:0007       cmsg:
F03:0008         .byte "Command: ", $00
               S02:00001096:  43 6F 6D 6D 61 6E 64 3A 20
               S02:0000109F:  00
F03:0009       
F03:0010       sd_init:
F03:0011         ; Let the SD card boot up, by pumping the clock with SD CS disabled
F03:0012       
F03:0013         ; We need to apply around 80 clock pulses with CS and MOSI higha
F03:0014         ; Normally MOSI doesn't matter when CS is high, but the card is
F03:0015         ; not yet is SPI mode, and in this non-SPI state it does carea
F03:0016       
F03:0017         lda #SD_CS | SD_MOSI
               S02:000010A0:  A9 14
F03:0018         ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
               S02:000010A2:  A2 A0
F03:0019       apreinitloop:
F03:0020         eor #SD_SCK
               S02:000010A4:  49 08
F03:0021         sta PORTA
               S02:000010A6:  8D 01 B0
F03:0022         dex
               S02:000010A9:  CA
F03:0023         bne apreinitloop
               S02:000010AA:  D0 F8
F03:0024         
F03:0025       
F03:0026       acmd0: ; GO_IDLE_STATE - resets card to idle state, and SPI mode
F03:0027         lda #<sd_cmd0_bytes
               S02:000010AC:  A9 13
F03:0028         sta zp_sd_address
               S02:000010AE:  85 40
F03:0029         lda #>sd_cmd0_bytes
               S02:000010B0:  A9 11
F03:0030         sta zp_sd_address+1
               S02:000010B2:  85 41
F03:0031       
F03:0032         jsr sd_sendcommand
               S02:000010B4:  20 65 11
F03:0033       
F03:0034         ; Expect status response $01 (not initialized)
F03:0035        ; cmp #$01
F03:0036        ; bne ainitfailed
F03:0037       
F03:0038       acmd8: ; SEND_IF_COND - tell the card how we want it to operate (3a3V, etc)
F03:0039         lda #<sd_cmd8_bytes
               S02:000010B7:  A9 19
F03:0040         sta zp_sd_address
               S02:000010B9:  85 40
F03:0041         lda #>sd_cmd8_bytes
               S02:000010BB:  A9 11
F03:0042         sta zp_sd_address+1
               S02:000010BD:  85 41
F03:0043       
F03:0044         jsr sd_sendcommand
               S02:000010BF:  20 65 11
F03:0045       
F03:0046         ; Expect status response $01 (not initialized)
F03:0047         cmp #$01
               S02:000010C2:  C9 01
F03:0048         bne ainitfailed
               S02:000010C4:  D0 44
F03:0049       
F03:0050         ; Read 3a-bit return value, but ignore it
F03:0051         jsr sd_readbyte
               S02:000010C6:  20 2B 11
F03:0052         jsr sd_readbyte
               S02:000010C9:  20 2B 11
F03:0053         jsr sd_readbyte
               S02:000010CC:  20 2B 11
F03:0054         jsr sd_readbyte
               S02:000010CF:  20 2B 11
F03:0055       
F03:0056       acmd55: ; APP_CMD - required prefix for ACMD commands
F03:0057         lda #<sd_cmd55_bytes
               S02:000010D2:  A9 1F
F03:0058         sta zp_sd_address
               S02:000010D4:  85 40
F03:0059         lda #>sd_cmd55_bytes
               S02:000010D6:  A9 11
F03:0060         sta zp_sd_address+1
               S02:000010D8:  85 41
F03:0061       
F03:0062         jsr sd_sendcommand
               S02:000010DA:  20 65 11
F03:0063       
F03:0064         ; Expect status response $01 (not initialized)
F03:0065         cmp #$01
               S02:000010DD:  C9 01
F03:0066         bne ainitfailed
               S02:000010DF:  D0 29
F03:0067       
F03:0068       acmd41: ; APP_SEND_OP_COND - send operating conditions, initialize card
F03:0069         lda #<sd_cmd41_bytes
               S02:000010E1:  A9 25
F03:0070         sta zp_sd_address
               S02:000010E3:  85 40
F03:0071         lda #>sd_cmd41_bytes
               S02:000010E5:  A9 11
F03:0072         sta zp_sd_address+1
               S02:000010E7:  85 41
F03:0073       
F03:0074         jsr sd_sendcommand
               S02:000010E9:  20 65 11
F03:0075       
F03:0076         ; Status response $00 means initialised
F03:0077         cmp #$00
               S02:000010EC:  C9 00
F03:0078         beq ainitialized
               S02:000010EE:  F0 11
F03:0079       
F03:0080         ; Otherwise expect status response $01 (not initialized)
F03:0081         cmp #$01
               S02:000010F0:  C9 01
F03:0082         bne ainitfailed
               S02:000010F2:  D0 16
F03:0083       
F03:0084         ; Not initialized yet, so wait a while then try againa
F03:0085         ; This retry is important, to give the card time to initializea
F03:0086       
F03:0087         ldx #0
               S02:000010F4:  A2 00
F03:0088         ldy #0
               S02:000010F6:  A0 00
F03:0089       adelayloop:
F03:0090         dey
               S02:000010F8:  88
F03:0091         bne adelayloop
               S02:000010F9:  D0 FD
F03:0092         dex
               S02:000010FB:  CA
F03:0093         bne adelayloop
               S02:000010FC:  D0 FA
F03:0094       
F03:0095         jmp acmd55
               S02:000010FE:  4C D2 10
F03:0096       
F03:0097       
F03:0098       ainitialized:
F03:0099         ldy #>initmsg
               S02:00001101:  A0 12
F03:0100         ldx #<initmsg
               S02:00001103:  A2 5E
F03:0101         jsr w_acia_full
               S02:00001105:  20 73 10
F03:0102         clc
               S02:00001108:  18
F03:0103         rts
               S02:00001109:  60
F03:0104       
F03:0105       ainitfailed:
F03:0106         ldy #>initfailedmsg
               S02:0000110A:  A0 12
F03:0107         ldx #<initfailedmsg
               S02:0000110C:  A2 44
F03:0108         jsr w_acia_full
               S02:0000110E:  20 73 10
F03:0109       aloop:
F03:0110         sec
               S02:00001111:  38
F03:0111         rts
               S02:00001112:  60
F03:0112       
F03:0113       sd_cmd0_bytes:
F03:0114         .byte $40, $00, $00, $00, $00, $95
               S02:00001113:  40
               S02:00001114:  00
               S02:00001115:  00
               S02:00001116:  00
               S02:00001117:  00
               S02:00001118:  95
F03:0115       sd_cmd8_bytes:
F03:0116         .byte $48, $00, $00, $01, $aa, $87
               S02:00001119:  48
               S02:0000111A:  00
               S02:0000111B:  00
               S02:0000111C:  01
               S02:0000111D:  AA
               S02:0000111E:  87
F03:0117       sd_cmd55_bytes:
F03:0118         .byte $77, $00, $00, $00, $00, $01
               S02:0000111F:  77
               S02:00001120:  00
               S02:00001121:  00
               S02:00001122:  00
               S02:00001123:  00
               S02:00001124:  01
F03:0119       sd_cmd41_bytes:
F03:0120         .byte $69, $40, $00, $00, $00, $01
               S02:00001125:  69
               S02:00001126:  40
               S02:00001127:  00
               S02:00001128:  00
               S02:00001129:  00
               S02:0000112A:  01
F03:0121       
F03:0122       
F03:0123       
F03:0124       sd_readbyte:
F03:0125         ; Enable the card and tick the clock 8 times with MOSI high, 
F03:0126         ; capturing bits from MISO and returning them
F03:0127       
F03:0128         ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
               S02:0000112B:  A2 FE
F03:0129       
F03:0130       baloop:
F03:0131       
F03:0132         lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
               S02:0000112D:  A9 04
F03:0133         sta PORTA
               S02:0000112F:  8D 01 B0
F03:0134       
F03:0135         lda #SD_MOSI | SD_SCK       ; toggle the clock high
               S02:00001132:  A9 0C
F03:0136         sta PORTA
               S02:00001134:  8D 01 B0
F03:0137       
F03:0138         lda PORTA                   ; read next bit
               S02:00001137:  AD 01 B0
F03:0139         and #SD_MISO
               S02:0000113A:  29 02
F03:0140       
F03:0141         clc                         ; default to clearing the bottom bit
               S02:0000113C:  18
F03:0142         beq abitnotset              ; unless MISO was set
               S02:0000113D:  F0 01
F03:0143         sec                         ; in which case get ready to set the bottom bit
               S02:0000113F:  38
F03:0144       abitnotset:
F03:0145       
F03:0146         txa                         ; transfer partial result from X
               S02:00001140:  8A
F03:0147         rol                         ; rotate carry bit into read result, and loop bit into carry
               S02:00001141:  2A
F03:0148         tax                         ; save partial result back to X
               S02:00001142:  AA
F03:0149         
F03:0150         bcs baloop                   ; loop if we need to read more bits
               S02:00001143:  B0 E8
F03:0151       
F03:0152         rts
               S02:00001145:  60
F03:0153       
F03:0154       
F03:0155       sd_writebyte:
F03:0156         ; Tick the clock 8 times with descending bits on MOSI
F03:0157         ; SD communication is mostly half-duplex so we ignore anything it sends back here
F03:0158       
F03:0159         ldx #8                      ; send 8 bits
               S02:00001146:  A2 08
F03:0160       
F03:0161       arloop:
F03:0162         asl                         ; shift next bit into carry
               S02:00001148:  0A
F03:0163         tay                         ; save remaining bits for later
               S02:00001149:  A8
F03:0164       
F03:0165         lda #0
               S02:0000114A:  A9 00
F03:0166         bcc asendbit                ; if carry clear, don't set MOSI for this bit
               S02:0000114C:  90 02
F03:0167         ora #SD_MOSI
               S02:0000114E:  09 04
F03:0168       
F03:0169       asendbit:
F03:0170         sta PORTA                   ; set MOSI (or not) first with SCK low
               S02:00001150:  8D 01 B0
F03:0171         eor #SD_SCK
               S02:00001153:  49 08
F03:0172         sta PORTA                   ; raise SCK keeping MOSI the same, to send the bit
               S02:00001155:  8D 01 B0
F03:0173       
F03:0174         tya                         ; restore remaining bits to send
               S02:00001158:  98
F03:0175       
F03:0176         dex
               S02:00001159:  CA
F03:0177         bne arloop                   ; loop if there are more bits to send
               S02:0000115A:  D0 EC
F03:0178       
F03:0179         rts
               S02:0000115C:  60
F03:0180       
F03:0181       
F03:0182       sd_waitresult:
F03:0183         ; Wait for the SD card to return something other than $ff
F03:0184         jsr sd_readbyte
               S02:0000115D:  20 2B 11
F03:0185         cmp #$ff
               S02:00001160:  C9 FF
F03:0186         beq sd_waitresult
               S02:00001162:  F0 F9
F03:0187         rts
               S02:00001164:  60
F03:0188       
F03:0189       
F03:0190       sd_sendcommand:
F03:0191         ; Debug print which command is being executed
F03:0192        ; jsr lcd_cleardisplay
F03:0193        ; jsr cleardisplay
F03:0194       
F03:0195       ;  phx
F03:0196       ;  phy
F03:0197       ;  ldx #<cmsg
F03:0198       ;  ldy #>cmsg
F03:0199       ;  jsr w_acia_full
F03:0200       ;  ply
F03:0201       ;  plx
F03:0202       
F03:0203       ;  ldx #0
F03:0204       ;  lda (zp_sd_address,x)
F03:0205       ;  jsr print_hex_acia
F03:0206       
F03:0207       ;  lda #$a0
F03:0208       ;  jsr print_chara
F03:0209       ;  
F03:0210       ;  lda #$a0
F03:0211       ;  jsr print_chara
F03:0212       
F03:0213         lda #SD_MOSI           ; pull CS low to begin command
               S02:00001165:  A9 04
F03:0214         sta PORTA
               S02:00001167:  8D 01 B0
F03:0215       
F03:0216         ldy #0
               S02:0000116A:  A0 00
F03:0217         lda (zp_sd_address),y    ; command byte
               S02:0000116C:  B1 40
F03:0218         jsr sd_writebyte
               S02:0000116E:  20 46 11
F03:0219         ldy #1
               S02:00001171:  A0 01
F03:0220         lda (zp_sd_address),y    ; data 1
               S02:00001173:  B1 40
F03:0221         jsr sd_writebyte
               S02:00001175:  20 46 11
F03:0222         ldy #2
               S02:00001178:  A0 02
F03:0223         lda (zp_sd_address),y    ; data 2
               S02:0000117A:  B1 40
F03:0224         jsr sd_writebyte
               S02:0000117C:  20 46 11
F03:0225         ldy #3
               S02:0000117F:  A0 03
F03:0226         lda (zp_sd_address),y    ; data 3
               S02:00001181:  B1 40
F03:0227         jsr sd_writebyte
               S02:00001183:  20 46 11
F03:0228         ldy #4
               S02:00001186:  A0 04
F03:0229         lda (zp_sd_address),y    ; data 4
               S02:00001188:  B1 40
F03:0230         jsr sd_writebyte
               S02:0000118A:  20 46 11
F03:0231         ldy #5
               S02:0000118D:  A0 05
F03:0232         lda (zp_sd_address),y    ; crc
               S02:0000118F:  B1 40
F03:0233         jsr sd_writebyte
               S02:00001191:  20 46 11
F03:0234       
F03:0235         jsr sd_waitresult
               S02:00001194:  20 5D 11
F03:0236         pha
               S02:00001197:  48
F03:0237       
F03:0238       ;  phy
F03:0239       ;  phx
F03:0240       ;  ldy #>respmsg
F03:0241       ;  ldx #<respmsg
F03:0242       ;  jsr w_acia_full
F03:0243       ;  ply
F03:0244       ;  plx
F03:0245       
F03:0246         ; Debug print the result code
F03:0247       ;  jsr print_hex_acia
F03:0248       
F03:0249       ;  lda #$0d
F03:0250       ;  jsr print_chara
F03:0251       ;  
F03:0252       ;  lda #$0a
F03:0253       ;  jsr print_chara
F03:0254       
F03:0255         ; End command
F03:0256         lda #SD_CS | SD_MOSI   ; set CS high again
               S02:00001198:  A9 14
F03:0257         sta PORTA
               S02:0000119A:  8D 01 B0
F03:0258       
F03:0259         pla   ; restore result code
               S02:0000119D:  68
F03:0260         rts
               S02:0000119E:  60
F03:0261       
F03:0262       
F03:0263       sd_readsector:
F03:0264         ; Read a sector from the SD carda  A sector is 512 bytes.
F03:0265         ;
F03:0266         ; Parameters:
F03:0267         ;    zp_sd_currentsector   3a-bit sector number
F03:0268         ;    zp_sd_address     address of buffer to receive data
F03:0269         
F03:0270         lda #SD_MOSI
               S02:0000119F:  A9 04
F03:0271         sta PORTA
               S02:000011A1:  8D 01 B0
F03:0272       
F03:0273         ; Command 17, arg is sector number, crc not checked
F03:0274         lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S02:000011A4:  A9 51
F03:0275         jsr sd_writebyte
               S02:000011A6:  20 46 11
F03:0276         lda zp_sd_currentsector+3   ; sector 24:31
               S02:000011A9:  A5 45
F03:0277         jsr sd_writebyte
               S02:000011AB:  20 46 11
F03:0278         lda zp_sd_currentsector+2   ; sector 16:23
               S02:000011AE:  A5 44
F03:0279         jsr sd_writebyte
               S02:000011B0:  20 46 11
F03:0280         lda zp_sd_currentsector+1   ; sector 8:15
               S02:000011B3:  A5 43
F03:0281         jsr sd_writebyte
               S02:000011B5:  20 46 11
F03:0282         lda zp_sd_currentsector     ; sector 0:7
               S02:000011B8:  A5 42
F03:0283         jsr sd_writebyte
               S02:000011BA:  20 46 11
F03:0284         lda #$01                    ; crc (not checked)
               S02:000011BD:  A9 01
F03:0285         jsr sd_writebyte
               S02:000011BF:  20 46 11
F03:0286       
F03:0287         jsr sd_waitresult
               S02:000011C2:  20 5D 11
F03:0288         cmp #$00
               S02:000011C5:  C9 00
F03:0289         bne afail
               S02:000011C7:  D0 53
F03:0290       
F03:0291         ; wait for data
F03:0292         jsr sd_waitresult
               S02:000011C9:  20 5D 11
F03:0293         cmp #$fe
               S02:000011CC:  C9 FE
F03:0294         bne afail
               S02:000011CE:  D0 4C
F03:0295       
F03:0296         ; Need to read 512 bytes - two pages of 256 bytes each
F03:0297         jsr areadpage
               S02:000011D0:  20 25 12
F03:0298         inc zp_sd_address+1
               S02:000011D3:  E6 41
F03:0299         jsr areadpage
               S02:000011D5:  20 25 12
F03:0300         dec zp_sd_address+1
               S02:000011D8:  C6 41
F03:0301       
F03:0302         ; End command
F03:0303         lda #SD_CS | SD_MOSI
               S02:000011DA:  A9 14
F03:0304         sta PORTA
               S02:000011DC:  8D 01 B0
F03:0305         
F03:0306         sec
               S02:000011DF:  38
F03:0307         rts
               S02:000011E0:  60
F03:0308       
F03:0309       sd_writesector:
F03:0310         ; Write a sector to the SD card.  A sector is 512 bytes.
F03:0311         ;
F03:0312         ; Parameters:
F03:0313         ;    zp_sd_currentsector   32-bit sector number
F03:0314         ;    zp_sd_address     address of buffer to take data from
F03:0315         
F03:0316         lda #SD_MISO
               S02:000011E1:  A9 02
F03:0317         sta PORTA
               S02:000011E3:  8D 01 B0
F03:0318       
F03:0319         ; Command 24, arg is sector number, crc not checked
F03:0320         lda #$58                    ; CMD24 - WRITE_BLOCK
               S02:000011E6:  A9 58
F03:0321         jsr sd_writebyte
               S02:000011E8:  20 46 11
F03:0322         lda zp_sd_currentsector+3   ; sector 24:31
               S02:000011EB:  A5 45
F03:0323         jsr sd_writebyte
               S02:000011ED:  20 46 11
F03:0324         lda zp_sd_currentsector+2   ; sector 16:23
               S02:000011F0:  A5 44
F03:0325         jsr sd_writebyte
               S02:000011F2:  20 46 11
F03:0326         lda zp_sd_currentsector+1   ; sector 8:15
               S02:000011F5:  A5 43
F03:0327         jsr sd_writebyte
               S02:000011F7:  20 46 11
F03:0328         lda zp_sd_currentsector     ; sector 0:7
               S02:000011FA:  A5 42
F03:0329         jsr sd_writebyte
               S02:000011FC:  20 46 11
F03:0330         lda #$01                    ; crc (not checked)
               S02:000011FF:  A9 01
F03:0331         jsr sd_writebyte
               S02:00001201:  20 46 11
F03:0332       
F03:0333         jsr sd_waitresult
               S02:00001204:  20 5D 11
F03:0334         cmp #$00
               S02:00001207:  C9 00
F03:0335         bne afail
               S02:00001209:  D0 11
F03:0336       
F03:0337         ; wait for data
F03:0338         ;jsr sd_waitresult
F03:0339         ;cmp #$fe
F03:0340         ;bne afail
F03:0341         ; BUG I don't think it need to wait for any more data, but I gotta check the datasheet more... (hard to read)
F03:0342       
F03:0343         ; Need to write 512 bytes - two pages of 256 bytes each
F03:0344         jsr awritepage
               S02:0000120B:  20 30 12
F03:0345         inc zp_sd_address+1
               S02:0000120E:  E6 41
F03:0346         jsr awritepage
               S02:00001210:  20 30 12
F03:0347         dec zp_sd_address+1
               S02:00001213:  C6 41
F03:0348       
F03:0349         ; End command
F03:0350         lda #SD_CS | SD_MOSI ; set cs and mosi high (disconnected)
               S02:00001215:  A9 14
F03:0351         sta PORTA
               S02:00001217:  8D 01 B0
F03:0352       
F03:0353         sec
               S02:0000121A:  38
F03:0354         rts
               S02:0000121B:  60
F03:0355       
F03:0356       afail:
F03:0357         ldx #<failedmsg
               S02:0000121C:  A2 49
F03:0358         ldy #>failedmsg  ;Failed!
               S02:0000121E:  A0 12
F03:0359         jsr w_acia_full
               S02:00001220:  20 73 10
F03:0360       afailloop:
F03:0361         clc
               S02:00001223:  18
F03:0362         rts
               S02:00001224:  60
F03:0363       
F03:0364       areadpage:
F03:0365         ; Read 256 bytes to the address at zp_sd_address
F03:0366         ldy #0
               S02:00001225:  A0 00
F03:0367       areadloop:
F03:0368         jsr sd_readbyte
               S02:00001227:  20 2B 11
F03:0369         sta (zp_sd_address),y
               S02:0000122A:  91 40
F03:0370         iny
               S02:0000122C:  C8
F03:0371         bne areadloop
               S02:0000122D:  D0 F8
F03:0372         rts
               S02:0000122F:  60
F03:0373       
F03:0374       awritepage:
F03:0375         ; Write 256 bytes to the sd card
F03:0376         ldy #0
               S02:00001230:  A0 00
F03:0377       awriteloop:
F03:0378         lda (zp_sd_address),y
               S02:00001232:  B1 40
F03:0379         jsr sd_writebyte
               S02:00001234:  20 46 11
F03:0380         iny
               S02:00001237:  C8
F03:0381         bne awriteloop
               S02:00001238:  D0 F8
F03:0382         rts
               S02:0000123A:  60
F03:0383       
F03:0384       statusmsg:
F03:0385         .byte "Status: ", $00
               S02:0000123B:  53 74 61 74 75 73 3A 20
               S02:00001243:  00
F03:0386       initfailedmsg:
F03:0387         .byte "Init "
               S02:00001244:  49 6E 69 74 20
F03:0388       failedmsg:
F03:0389         .byte "Failed!", $0d, $0a, $00
               S02:00001249:  46 61 69 6C 65 64 21
               S02:00001250:  0D
               S02:00001251:  0A
               S02:00001252:  00
F03:0390       respmsg:
F03:0391         .byte "Response: ", $00
               S02:00001253:  52 65 73 70 6F 6E 73 65 3A 20
               S02:0000125D:  00
F03:0392       initmsg:
F03:0393         .byte "Initialized!", $0d, $0a, $00
               S02:0000125E:  49 6E 69 74 69 61 6C 69 7A 65 64 21
               S02:0000126A:  0D
               S02:0000126B:  0A
               S02:0000126C:  00
F03:0394       
F00:0034       	;.include "libfat32.s"
F00:0035       	; no filesystem
F00:0036       
F00:0037       jmpfailed:
F00:0038       	jmp failed
               S02:0000126D:  4C 65 13
F00:0039       
F00:0040       ebutrocks:
F00:0041       ; init sd card (it was just plugged in)
F00:0042       	jsr sd_init
               S02:00001270:  20 A0 10
F00:0043               bcs jmpfailed
               S02:00001273:  B0 F8
F00:0044       
F00:0045       	lda #0
               S02:00001275:  A9 00
F00:0046       	sta bytepointer
               S02:00001277:  85 66
F00:0047       	sta bytepointer+1
               S02:00001279:  85 67
F00:0048       	sta bytepointer+2
               S02:0000127B:  85 68
F00:0049       	sta bytepointer+3
               S02:0000127D:  85 69
F00:0050       ;-------------------------------------------------------------------------------
F00:0051       ; Initialize DIGI_Player
F00:0052       
F00:0053               PHA                     ; We need to save both A
               S02:0000127F:  48
F00:0054               phx                     ; and X as we use them
               S02:00001280:  DA
F00:0055       
F00:0056               ; disable interrupts
F00:0057               LDA #$00                ; was $7f in the_c64_digi.txt
               S02:00001281:  A9 00
F00:0058               STA $B00D               ; ICR CIA #2
               S02:00001283:  8D 0D B0
F00:0059                      ; read acks any pending interrupt
F00:0060               LDA $B00D
               S02:00001286:  AD 0D B0
F00:0061               SEI                     ; disables maskable interrupts
               S02:00001289:  78
F00:0062       
F00:0063       				; hold on les fix da sd
F00:0064         lda #SD_MOSI
               S02:0000128A:  A9 04
F00:0065         sta PORTA
               S02:0000128C:  8D 01 B0
F00:0066         ; Command 16, arg is size in bytes, crc not checked
F00:0067         lda #$50                    ; CMD16 - SET_BLOCKLEN
               S02:0000128F:  A9 50
F00:0068         jsr sd_writebyte
               S02:00001291:  20 46 11
F00:0069         lda #0		      ; byte 24:31
               S02:00001294:  A9 00
F00:0070         jsr sd_writebyte
               S02:00001296:  20 46 11
F00:0071         lda #0		      ; byte 16:23
               S02:00001299:  A9 00
F00:0072         jsr sd_writebyte
               S02:0000129B:  20 46 11
F00:0073         lda #0		      ; byte 8:15
               S02:0000129E:  A9 00
F00:0074         jsr sd_writebyte
               S02:000012A0:  20 46 11
F00:0075         lda #1                      ; byte 0:7
               S02:000012A3:  A9 01
F00:0076         jsr sd_writebyte
               S02:000012A5:  20 46 11
F00:0077         lda #$01                    ; crc (not checked)
               S02:000012A8:  A9 01
F00:0078         jsr sd_writebyte
               S02:000012AA:  20 46 11
F00:0079       
F00:0080         jsr sd_waitresult
               S02:000012AD:  20 5D 11
F00:0081         cmp #$00
               S02:000012B0:  C9 00
F00:0082         bne jmpfailed
               S02:000012B2:  D0 B9
F00:0083         
F00:0084       ;  ; Open root directory
F00:0085       ;  jsr fat32_openroot
F00:0086       ;
F00:0087       ;  ; Find subdirectory by name
F00:0088       ;  ldx #<dirname
F00:0089       ;  ldy #>dirname
F00:0090       ;  jsr fat32_finddirent
F00:0091       ;  bcc foundsubdir
F00:0092       ;
F00:0093       ;error:
F00:0094       ;  plx
F00:0095       ;  pla
F00:0096       ;  rts
F00:0097       ;  rts
F00:0098       ;  rts
F00:0099       ;  rts
F00:0100       ;
F00:0101       ;foundsubdir
F00:0102       ;
F00:0103       ;  ; Open subdirectory
F00:0104       ;  jsr fat32_opendirent
F00:0105       ;				; ok dats don
F00:0106       
F00:0107       
F00:0108               ; initialize SID
F00:0109               LDA #$00                ; zeros out all SID registers
               S02:000012B4:  A9 00
F00:0110               LDX #$00                ;
               S02:000012B6:  A2 00
F00:0111       SIDCLR                          
F00:0112               STA SID,x               ; 
               S02:000012B8:  9D 00 B8
F00:0113               INX                     ;
               S02:000012BB:  E8
F00:0114               BNE SIDCLR             
               S02:000012BC:  D0 FA
F00:0115       
F00:0116               ; SID voices modulated too, increases volume on 8580 SIDs
F00:0117               LDA #$00                ; 
               S02:000012BE:  A9 00
F00:0118               STA SID+$05             ; voice 1 Attach/Decay 
               S02:000012C0:  8D 05 B8
F00:0119               LDA #$F0                ;
               S02:000012C3:  A9 F0
F00:0120               STA SID+$06             ;         Systain/Release 
               S02:000012C5:  8D 06 B8
F00:0121               LDA #$01                ;
               S02:000012C8:  A9 01
F00:0122               STA SID+$04             ;         ctrl 
               S02:000012CA:  8D 04 B8
F00:0123               LDA #$00 
               S02:000012CD:  A9 00
F00:0124               STA SID+$0C             ; voice 2 Attach/Decay 
               S02:000012CF:  8D 0C B8
F00:0125               LDA #$F0                ;
               S02:000012D2:  A9 F0
F00:0126               STA SID+$0D             ;         Systain/Release 
               S02:000012D4:  8D 0D B8
F00:0127               LDA #$01                ;
               S02:000012D7:  A9 01
F00:0128               STA SID+$0B             ;         ctrl 
               S02:000012D9:  8D 0B B8
F00:0129               LDA #$00        
               S02:000012DC:  A9 00
F00:0130               STA SID+$13             ; voice 3 Attach/Decay 
               S02:000012DE:  8D 13 B8
F00:0131               LDA #$F0                ;
               S02:000012E1:  A9 F0
F00:0132               STA SID+$14             ;         Systain/Release 
               S02:000012E3:  8D 14 B8
F00:0133               LDA #$01                ;
               S02:000012E6:  A9 01
F00:0134               STA SID+$12             ;         ctrl 
               S02:000012E8:  8D 12 B8
F00:0135               LDA #$00 
               S02:000012EB:  A9 00
F00:0136               STA SID+$15             ; filter  lo 
               S02:000012ED:  8D 15 B8
F00:0137               LDA #$10                ;
               S02:000012F0:  A9 10
F00:0138               STA SID+$16             ; filter  hi 
               S02:000012F2:  8D 16 B8
F00:0139               LDA #$F7                ;
               S02:000012F5:  A9 F7
F00:0140               STA SID+$17             ; filter  voices+reso 
               S02:000012F7:  8D 17 B8
F00:0141       
F00:0142               ; point to our player routine
F00:0143               LDA #<NMI_HANDLER       ; set NMI handler address low byte
               S02:000012FA:  A9 6B
F00:0144               STA $7FFF               ;
               S02:000012FC:  8D FF 7F
F00:0145               LDA #>NMI_HANDLER       ; set NMI handler address hi byte
               S02:000012FF:  A9 13
F00:0146               STA $7FFE               ;
               S02:00001301:  8D FE 7F
F00:0147       
F00:0148               ;LDA #<DATASTART         ; low byte
F00:0149       	;STA fat32_address
F00:0150               ;LDA #>DATASTART         ; high byte
F00:0151       	;STA fat32_address+1
F00:0152       
F00:0153               LDA #flagSeed           ; initialize flag used for
               S02:00001304:  A9 55
F00:0154               STA flag                ; indicating which nibble to play
               S02:00001306:  85 02
F00:0155       	
F00:0156       	;; get the missle
F00:0157       	;LDX #<datname		; low byte
F00:0158       	;LDY #>datname		; high byte
F00:0159       	;JSR fat32_finddirent	; do it
F00:0160       	;JSR fat32_opendirent	; ignore errors >:)
F00:0161       	;JSR fat32_file_readbyte ; one. yes just one bomb for now.
F00:0162       
F00:0163       	; Command 17, arg is sector number, crc not checked
F00:0164         	lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S02:00001308:  A9 51
F00:0165         	jsr sd_writebyte
               S02:0000130A:  20 46 11
F00:0166         	lda bytepointer+3	    ; sector 24:31
               S02:0000130D:  A5 69
F00:0167         	jsr sd_writebyte
               S02:0000130F:  20 46 11
F00:0168         	lda bytepointer+2	    ; sector 16:23
               S02:00001312:  A5 68
F00:0169         	jsr sd_writebyte
               S02:00001314:  20 46 11
F00:0170         	lda bytepointer+1	    ; sector 8:15
               S02:00001317:  A5 67
F00:0171        	jsr sd_writebyte
               S02:00001319:  20 46 11
F00:0172        	lda bytepointer+0           ; sector 0:7
               S02:0000131C:  A5 66
F00:0173        	jsr sd_writebyte
               S02:0000131E:  20 46 11
F00:0174        	lda #$01                    ; crc (not checked)
               S02:00001321:  A9 01
F00:0175        	jsr sd_writebyte
               S02:00001323:  20 46 11
F00:0176       
F00:0177       	jsr sd_waitresult
               S02:00001326:  20 5D 11
F00:0178       	cmp #$00
               S02:00001329:  C9 00
F00:0179       	bne failed
               S02:0000132B:  D0 38
F00:0180       
F00:0181       	jsr sd_readbyte
               S02:0000132D:  20 2B 11
F00:0182       
F00:0183       	STA DATASTART		; load the missle
               S02:00001330:  8D E7 13
F00:0184       	STA sample		; all right.
               S02:00001333:  85 01
F00:0185       	JSR wee			; prepare the cannons.
               S02:00001335:  20 50 13
F00:0186       
F00:0187               LDA #$40                ; ICR set to TMR A underflow
               S02:00001338:  A9 40
F00:0188               STA $B00D               ; ICR CIA #2
               S02:0000133A:  8D 0D B0
F00:0189               LDA #$c0                ;
               S02:0000133D:  A9 C0
F00:0190               STA $B00E               ; CRA interrupt enable
               S02:0000133F:  8D 0E B0
F00:0191       
F00:0192       	cli
               S02:00001342:  58
F00:0193       
F00:0194               LDA #$00                ;
               S02:00001343:  A9 00
F00:0195               STA done                ; reset player done flag
               S02:00001345:  85 00
F00:0196       
F00:0197       pause
F00:0198               LDA done                ; player sets'done' flag when finished, pause
               S02:00001347:  A5 00
F00:0199               BEQ pause               ; until then for clean return to BASIC
               S02:00001349:  F0 FC
F00:0200       
F00:0201               PLA                     ; Let's get our saved
               S02:0000134B:  68
F00:0202               TAX                     ; X register and
               S02:0000134C:  AA
F00:0203               PLA                     ; A register back
               S02:0000134D:  68
F00:0204               SEI                     ; set interuppts again
               S02:0000134E:  78
F00:0205               RTS                     ; and return
               S02:0000134F:  60
F00:0206       wee
F00:0207               ; setup VIA, watch out as it will lunch da cannon!!
F00:0208               LDA #<freq              ; interrupt freq
               S02:00001350:  A9 80
F00:0209               STA $B004               ; TA LO
               S02:00001352:  8D 04 B0
F00:0210               LDA #>freq              ;
               S02:00001355:  A9 00
F00:0211               STA $B005               ; TA HI
               S02:00001357:  8D 05 B0
F00:0212               LDA #<freq              ; interrupt freq
               S02:0000135A:  A9 80
F00:0213               STA $B006               ; TA LO
               S02:0000135C:  8D 06 B0
F00:0214               LDA #>freq              ;
               S02:0000135F:  A9 00
F00:0215               STA $B007               ; TA HI
               S02:00001361:  8D 07 B0
F00:0216       	RTS
               S02:00001364:  60
F00:0217       
F00:0218       failed:
F00:0219         plx
               S02:00001365:  FA
F00:0220         pla
               S02:00001366:  68
F00:0221         rts
               S02:00001367:  60
F00:0222         rts
               S02:00001368:  60
F00:0223         rts
               S02:00001369:  60
F00:0224         rts
               S02:0000136A:  60
F00:0225       
F00:0226       ;-------------------------------------------------------------------------------
F00:0227       ; NMI handler routine, plays one 4bit sample per pass
F00:0228       ; Path A -> Play Lower, shift upper down. 3+19+13+23=58 cycles
F00:0229       ; Path B -> Play upper, load new sample. 3+19+8+25=55 cycles
F00:0230       ; Path C -> Play upper. load sample, new page. 3+19+8+14+21=65 cycles
F00:0231       ; Sample's lower nybble holds the 4-bit sample to played on the "even" NMIs
F00:0232       ; The upper nybble holds the next nybble to be played on "odd" NMIs
F00:0233       NMI_HANDLER        
F00:0234               ; start with saving state       
F00:0235               PHA                     ; 3- (3) will restore when returning
               S02:0000136B:  48
F00:0236       
F00:0237       	lda #$40
               S02:0000136C:  A9 40
F00:0238       	sta $b00d		; ack
               S02:0000136E:  8D 0D B0
F00:0239       
F00:0240       	JSR wee			; prepare next missle
               S02:00001371:  20 50 13
F00:0241       
F00:0242               ; play 4-bit sample, first sample byte saved during Init
F00:0243               LDA sample              ; 3- load sample byte
               S02:00001374:  A5 01
F00:0244               ORA #$10                ; 2- make sure wee no ded filter settings
               S02:00001376:  09 10
F00:0245               AND #$1F                ; 2- git rid of any put bits
               S02:00001378:  29 1F
F00:0246               STA SID+$18             ; 4- save to ta regsiter
               S02:0000137A:  8D 18 B8
F00:0247               LDA $B00D               ; 4- (19)clear gobut
               S02:0000137D:  AD 0D B0
F00:0248       
F00:0249               ; flag init to $AA or $55, We shift alternating pattern though flag byte
F00:0250               ASL flag                ; 5- shift patten left thru flag byte
               S02:00001380:  06 02
F00:0251               BCC loadnew             ; 2-3 
               S02:00001382:  90 0C
F00:0252               INC flag                ; 5 (8-13) so skip ahead to load new byte
               S02:00001384:  E6 02
F00:0253          
F00:0254       shftupr
F00:0255               LDA sample              ; 3- *1 shift upper nibble down
               S02:00001386:  A5 01
F00:0256               LSR a                   ; 2-
               S02:00001388:  4A
F00:0257               LSR a                   ; 2-
               S02:00001389:  4A
F00:0258               LSR a                   ; 2-
               S02:0000138A:  4A
F00:0259               LSR a                   ; 2-
               S02:0000138B:  4A
F00:0260               STA sample              ; 3- store it back to play next pass
               S02:0000138C:  85 01
F00:0261       
F00:0262               PLA                     ; 3- local exit code is smaller and 
               S02:0000138E:  68
F00:0263               RTI                     ; 6- (23) faster than jumps/branches
               S02:0000138F:  40
F00:0264       
F00:0265               ; loadnew+1,+2 is self-modifying ptr to sample, gets set in init
F00:0266       loadnew
F00:0267       	; manny! read da bite.
F00:0268        	lda #SD_MOSI
               S02:00001390:  A9 04
F00:0269         	sta PORTA
               S02:00001392:  8D 01 B0
F00:0270       
F00:0271       	inc bytepointer
               S02:00001395:  E6 66
F00:0272       	bne newcontinue
               S02:00001397:  D0 0A
F00:0273       	inc bytepointer+1
               S02:00001399:  E6 67
F00:0274       	bne newcontinue
               S02:0000139B:  D0 06
F00:0275       	inc bytepointer+2
               S02:0000139D:  E6 68
F00:0276       	bne newcontinue
               S02:0000139F:  D0 02
F00:0277       	inc bytepointer+3
               S02:000013A1:  E6 69
F00:0278       
F00:0279       newcontinue:
F00:0280       
F00:0281         	; Command 17, arg is sector number, crc not checked
F00:0282         	lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S02:000013A3:  A9 51
F00:0283         	jsr sd_writebyte
               S02:000013A5:  20 46 11
F00:0284         	lda bytepointer+3	    ; sector 24:31
               S02:000013A8:  A5 69
F00:0285         	jsr sd_writebyte
               S02:000013AA:  20 46 11
F00:0286         	lda bytepointer+2	    ; sector 16:23
               S02:000013AD:  A5 68
F00:0287         	jsr sd_writebyte
               S02:000013AF:  20 46 11
F00:0288         	lda bytepointer+1	    ; sector 8:15
               S02:000013B2:  A5 67
F00:0289        	jsr sd_writebyte
               S02:000013B4:  20 46 11
F00:0290        	lda bytepointer+0           ; sector 0:7
               S02:000013B7:  A5 66
F00:0291        	jsr sd_writebyte
               S02:000013B9:  20 46 11
F00:0292        	lda #$01                    ; crc (not checked)
               S02:000013BC:  A9 01
F00:0293        	jsr sd_writebyte
               S02:000013BE:  20 46 11
F00:0294       
F00:0295       	jsr sd_waitresult
               S02:000013C1:  20 5D 11
F00:0296       	cmp #$00
               S02:000013C4:  C9 00
F00:0297       	bne stop
               S02:000013C6:  D0 0A
F00:0298       
F00:0299       	jsr sd_readbyte
               S02:000013C8:  20 2B 11
F00:0300               STA sample              ; 3- save to temp location
               S02:000013CB:  85 01
F00:0301       	STA DATASTART
               S02:000013CD:  8D E7 13
F00:0302               ;BCS stop               ; 2-3- if thats it then stop
F00:0303       	; BUG cannot stop sample when reading sd RAW
F00:0304               PLA                     ; 3- local exit code is smaller and
               S02:000013D0:  68
F00:0305               RTI                     ; 6- (14-25)faster than jumps/branches
               S02:000013D1:  40
F00:0306       
F00:0307       
F00:0308       stop
F00:0309               LDA #$08                ; 2- turn off NMI (IRQ AAAAAA)
               S02:000013D2:  A9 08
F00:0310               STA $B00E               ; 4- timer A stop-CRA, CIA #1 DC0E
               S02:000013D4:  8D 0E B0
F00:0311               LDA #$4F                ; 2- disable all CIA-2 NMIs 
               S02:000013D7:  A9 4F
F00:0312               STA $B00D               ; 4- ICR - interrupt control / status
               S02:000013D9:  8D 0D B0
F00:0313               LDA $B00D               ; 4- (16) sta/lda to ack any pending int
               S02:000013DC:  AD 0D B0
F00:0314       
F00:0315               LDA #$37                ; 2- reset kernal banking
               S02:000013DF:  A9 37
F00:0316               STA $01                 ; 3- (5)
               S02:000013E1:  85 01
F00:0317       
F00:0318               INC done                ; set player done flag
               S02:000013E3:  E6 00
F00:0319               
F00:0320               PLA                     ; 3- local exit code is smaller and
               S02:000013E5:  68
F00:0321               RTI                     ; 6- faster than jumps/branches
               S02:000013E6:  40
F00:0322       
F00:0323       DATASTART 
F00:0324       	.byte $00		; smol... ah ye its actually many MB. haha
               S02:000013E7:  00
F00:0325       DATASTOP  
F00:0326       


Sections:
S01  segf00
S02  seg1000


Sources:
F00  stream.s
F01  hwconfig.s
F02  libacia.s
F03  libsd.s


Symbols:
DATASTOP EXPR(5096=0x13e8) UNUSED ABS 
stop EXPR(5074=0x13d2) ABS 
newcontinue EXPR(5027=0x13a3) ABS 
shftupr EXPR(4998=0x1386) UNUSED ABS 
loadnew EXPR(5008=0x1390) ABS 
pause EXPR(4935=0x1347) ABS 
wee EXPR(4944=0x1350) ABS 
DATASTART EXPR(5095=0x13e7) ABS 
NMI_HANDLER EXPR(4971=0x136b) ABS 
SIDCLR EXPR(4792=0x12b8) ABS 
failed EXPR(4965=0x1365) ABS 
jmpfailed EXPR(4717=0x126d) ABS 
respmsg EXPR(4691=0x1253) UNUSED ABS 
statusmsg EXPR(4667=0x123b) UNUSED ABS 
awriteloop EXPR(4658=0x1232) ABS 
areadloop EXPR(4647=0x1227) ABS 
afailloop EXPR(4643=0x1223) UNUSED ABS 
failedmsg EXPR(4681=0x1249) ABS 
awritepage EXPR(4656=0x1230) ABS 
sd_writesector EXPR(4577=0x11e1) UNUSED ABS 
areadpage EXPR(4645=0x1225) ABS 
afail EXPR(4636=0x121c) ABS 
sd_readsector EXPR(4511=0x119f) UNUSED ABS 
sd_waitresult EXPR(4445=0x115d) ABS 
asendbit EXPR(4432=0x1150) ABS 
arloop EXPR(4424=0x1148) ABS 
sd_writebyte EXPR(4422=0x1146) ABS 
abitnotset EXPR(4416=0x1140) ABS 
baloop EXPR(4397=0x112d) ABS 
aloop EXPR(4369=0x1111) UNUSED ABS 
initfailedmsg EXPR(4676=0x1244) ABS 
initmsg EXPR(4702=0x125e) ABS 
adelayloop EXPR(4344=0x10f8) ABS 
ainitialized EXPR(4353=0x1101) ABS 
sd_cmd41_bytes EXPR(4389=0x1125) ABS 
acmd41 EXPR(4321=0x10e1) UNUSED ABS 
sd_cmd55_bytes EXPR(4383=0x111f) ABS 
acmd55 EXPR(4306=0x10d2) ABS 
sd_readbyte EXPR(4395=0x112b) ABS 
ainitfailed EXPR(4362=0x110a) ABS 
sd_cmd8_bytes EXPR(4377=0x1119) ABS 
acmd8 EXPR(4279=0x10b7) UNUSED ABS 
sd_sendcommand EXPR(4453=0x1165) ABS 
sd_cmd0_bytes EXPR(4371=0x1113) ABS 
acmd0 EXPR(4268=0x10ac) UNUSED ABS 
apreinitloop EXPR(4260=0x10a4) ABS 
sd_init EXPR(4256=0x10a0) ABS 
cmsg EXPR(4246=0x1096) UNUSED ABS 
endwacia EXPR(4238=0x108e) ABS 
acia_man EXPR(4224=0x1080) ABS 
w_acia_full EXPR(4211=0x1073) ABS 
ascii_home EXPR(4203=0x106b) UNUSED ABS 
print_char_acia EXPR(4200=0x1068) UNUSED ABS 
rxpoll EXPR(4183=0x1057) ABS 
txpoll EXPR(4175=0x104f) ABS 
cleardisplay EXPR(4164=0x1044) UNUSED ABS 
crlf EXPR(4143=0x102f) UNUSED ABS 
print_chara EXPR(4191=0x105f) ABS 
cskipletter EXPR(4137=0x1029) ABS 
print_nybble EXPR(4129=0x1021) ABS 
print_hex_acia EXPR(4120=0x1018) UNUSED ABS 
acia_init EXPR(4107=0x100b) UNUSED ABS 
via_init EXPR(4096=0x1000) UNUSED ABS 
PORTA_OUTPUTPINS EXPR(252=0xfc) EQU 
SD_MISO EXPR(2=0x2) EQU 
SD_MOSI EXPR(4=0x4) EQU 
SD_SCK EXPR(8=0x8) EQU 
SD_CS EXPR(16=0x10) EQU 
LCD_RS EXPR(32=0x20) EQU 
LCD_RW EXPR(64=0x40) EQU 
LCD_E EXPR(128=0x80) EQU 
DDRA EXPR(45059=0xb003) EQU 
DDRB EXPR(45058=0xb002) EQU 
PORTA EXPR(45057=0xb001) EQU 
PORTB EXPR(45056=0xb000) UNUSED EQU 
ebutrocks EXPR(4720=0x1270) ABS 
darn EXPR(3840=0xf00) UNUSED ABS 
freq EXPR(128=0x80) EQU 
flagSeed EXPR(85=0x55) EQU 
SID EXPR(47104=0xb800) EQU 
endbuf EXPR(1536=0x600) UNUSED EQU 
buffer EXPR(1024=0x400) UNUSED EQU 
bytepointer EXPR(102=0x66) EQU 
zp_fat32_variables EXPR(70=0x46) UNUSED EQU 
zp_sd_currentsector EXPR(66=0x42) EQU 
zp_sd_address EXPR(64=0x40) EQU 
flag EXPR(2=0x2) EQU 
sample EXPR(1=0x1) EQU 
done EXPR(0=0x0) EQU 
__RPTCNT EXPR(-1=0xffff) INTERNAL 
__VASM EXPR(0=0x0) INTERNAL 

There have been no errors.
