F00:0001       ; Save test
F00:0002       ; 
F00:0003       ; this code is just for debugging the sd card saving system.
F00:0004       ; i will use ben eater's debugger for this.
F00:0005       
F00:0006       ACIA = $8000
F00:0007       ACIAControl = ACIA+3
F00:0008       ACIACommand = ACIA+2
F00:0009       ACIAStatus = ACIA+1
F00:0010       ACIAData = ACIA
F00:0011       
F00:0012       fat32_workspace = $200      ; two pages
F00:0013       
F00:0014       buffer = $400               ; 512 bytes
F00:0015       endbuf = $600
F00:0016       
F00:0017       irqcount = $00
F00:0018       donefact = $01
F00:0019       
F00:0020       zp_sd_address = $40 ; 2
F00:0021       zp_sd_currentsector = $42 ; 4
F00:0022       zp_fat32_variables = $46 ; 32
F00:0023       
F00:0024       XYLODSAV2 = $64 ; 2
F00:0025       
F00:0026       CR=13
F00:0027       LF=10
F00:0028       
F00:0029         .org $0f00
F00:0030       
F00:0031       reset:
F00:0032         ;jsr sd_init
F00:0033         ;bcs sd_fail
F00:0034         ; sd init done
F00:0035         ;lda #'S'
F00:0036         ;sta ACIAData
F00:0037         ;jsr fat32_init
F00:0038         ;bcs faterror
F00:0039         ; fat32 init done
F00:0040         ;jsr txpoll
F00:0041         ;lda #'F'
F00:0042         ;sta ACIAData
F00:0043       ; Set the last found free cluster to 0.
F00:0044         lda #0
               S01:00000F00:  A9 00
F00:0045         sta fat32_lastfoundfreecluster
               S01:00000F02:  85 5E
F00:0046         sta fat32_lastfoundfreecluster+1
               S01:00000F04:  85 5F
F00:0047         sta fat32_lastfoundfreecluster+2
               S01:00000F06:  85 60
F00:0048         sta fat32_lastfoundfreecluster+3
               S01:00000F08:  85 61
F00:0049         ; init done
F00:0050       initdone:
F00:0051         ; now make a dummy file.
F00:0052         ldx #0
               S01:00000F0A:  A2 00
F00:0053       dummyloop:
F00:0054         txa
               S01:00000F0C:  8A
F00:0055         sta $0600,x
               S01:00000F0D:  9D 00 06
F00:0056         inx
               S01:00000F10:  E8
F00:0057         bne dummyloop
               S01:00000F11:  D0 F9
F00:0058         ; add an EOF
F00:0059         lda #0
               S01:00000F13:  A9 00
F00:0060         sta $0700
               S01:00000F15:  8D 00 07
F00:0061         ;sta $0701
F00:0062         ;sta $0702
F00:0063       
F00:0064         jmp MEMORY_SAVE ; OK, here we go.
               S01:00000F18:  4C 59 19
F00:0065       
F00:0066       faterror:
F00:0067         lda #'f'
               S01:00000F1B:  A9 66
F00:0068         jsr print_chara
               S01:00000F1D:  20 B1 12
F00:0069         jmp doneloop
               S01:00000F20:  4C A6 19
F00:0070       sd_fail:
F00:0071         lda #'s'
               S01:00000F23:  A9 73
F00:0072         jsr print_chara
               S01:00000F25:  20 B1 12
F00:0073         jmp doneloop
               S01:00000F28:  4C A6 19
F00:0074       
F00:0075         .include "errors.s"
F01:0001       error_sound:
F01:0002         lda #$55
               S01:00000F2B:  A9 55
F01:0003         sta donefact
               S01:00000F2D:  85 01
F01:0004         stz irqcount	; reset irq count
               S01:00000F2F:  64 00
F01:0005       
F01:0006       runthesound:
F01:0007         sei		; turn off irqs
               S01:00000F31:  78
F01:0008         lda #<irq
               S01:00000F32:  A9 4F
F01:0009         sta $7ffe
               S01:00000F34:  8D FE 7F
F01:0010         lda #>irq
               S01:00000F37:  A9 0F
F01:0011         sta $7fff	; store vectors
               S01:00000F39:  8D FF 7F
F01:0012         lda #$c0
               S01:00000F3C:  A9 C0
F01:0013         sta $b00e	
               S01:00000F3E:  8D 0E B0
F01:0014         lda #0 ; Song Number
               S01:00000F41:  A9 00
F01:0015         jsr InitSid
               S01:00000F43:  20 76 0F
F01:0016         lda #$40
               S01:00000F46:  A9 40
F01:0017         sta $b00d
               S01:00000F48:  8D 0D B0
F01:0018         cli
               S01:00000F4B:  58
F01:0019         jmp startupsoundloop
               S01:00000F4C:  4C 2F 12
F01:0020       
F01:0021       irq:
F01:0022         lda #$40
               S01:00000F4F:  A9 40
F01:0023         sta $b00d
               S01:00000F51:  8D 0D B0
F01:0024         jsr putbut		; refresh timers
               S01:00000F54:  20 65 0F
F01:0025         inc irqcount		; a irq has occurred
               S01:00000F57:  E6 00
F01:0026         lda irqcount
               S01:00000F59:  A5 00
F01:0027         cmp #$40		; if $32 irqs (end of the error sound)
               S01:00000F5B:  C9 40
F01:0028         bne continue24542 	; end the stream
               S01:00000F5D:  D0 02
F01:0029         stz donefact		; its done, tell the loop
               S01:00000F5F:  64 01
F01:0030       continue24542:
F01:0031         jsr $1006
               S01:00000F61:  20 06 10
F01:0032         rti			; exit
               S01:00000F64:  40
F01:0033       
F01:0034       putbut:
F01:0035         ldx #$9e
               S01:00000F65:  A2 9E
F01:0036         stx $b004
               S01:00000F67:  8E 04 B0
F01:0037         stx $b006
               S01:00000F6A:  8E 06 B0
F01:0038         ldx #$0f  ; 250Hz IRQ
               S01:00000F6D:  A2 0F
F01:0039         stx $b005
               S01:00000F6F:  8E 05 B0
F01:0040         stx $b007
               S01:00000F72:  8E 07 B0
F01:0041         rts
               S01:00000F75:  60
F01:0042       InitSid:
F01:0043         jsr putbut
               S01:00000F76:  20 65 0F
F01:0044         jmp $1103
               S01:00000F79:  4C 03 11
F01:0045       
F01:0046         .org $1006
F01:0047       
F01:0048         .include "errorsound.s"
F02:0001       d400_sVoc1FreqLo = $b800
F02:0002       d404_sVoc1Control = $b804
F02:0003       d40b_sVoc2Control = $b80b
F02:0004       d412_sVoc3Control = $b812
F02:0005       
F02:0006         .org $1006
F02:0007       
F02:0008       PlaySid             ldx #$18
               S02:00001006:  A2 18
F02:0009       L1008               lda $04,x
               S02:00001008:  B5 04
F02:0010                           sta d400_sVoc1FreqLo,x
               S02:0000100A:  9D 00 B8
F02:0011                           dex
               S02:0000100D:  CA
F02:0012                           bpl L1008
               S02:0000100E:  10 F8
F02:0013                           dec $02
               S02:00001010:  C6 02
F02:0014                           bmi L1015
               S02:00001012:  30 01
F02:0015                           rts
               S02:00001014:  60
F02:0016                           
F02:0017       L1015               stx $02
               S02:00001015:  86 02
F02:0018                           lda $03
               S02:00001017:  A5 03
F02:0019                           bne L1033
               S02:00001019:  D0 18
F02:0020                           jsr $001f
               S02:0000101B:  20 1F 00
F02:0021                           beq L1038
               S02:0000101E:  F0 18
F02:0022                           cmp #$a0
               S02:00001020:  C9 A0
F02:0023                           bcs L102e
               S02:00001022:  B0 0A
F02:0024                           sta $2a
               S02:00001024:  85 2A
F02:0025                           jsr $001f
               S02:00001026:  20 1F 00
F02:0026                           sta $29
               S02:00001029:  85 29
F02:0027                           jmp L1076
               S02:0000102B:  4C 76 10
F02:0028                           
F02:0029       L102e               sec
               S02:0000102E:  38
F02:0030                           sbc #$9f
               S02:0000102F:  E9 9F
F02:0031                           sta $03
               S02:00001031:  85 03
F02:0032       L1033               dec $03
               S02:00001033:  C6 03
F02:0033                           jmp L1076
               S02:00001035:  4C 76 10
F02:0034                           
F02:0035       L1038               jsr $001f
               S02:00001038:  20 1F 00
F02:0036                           cmp #$fd
               S02:0000103B:  C9 FD
F02:0037                           beq L106b
               S02:0000103D:  F0 2C
F02:0038                           cmp #$fe
               S02:0000103F:  C9 FE
F02:0039                           beq L1060
               S02:00001041:  F0 1D
F02:0040                           cmp #$ff
               S02:00001043:  C9 FF
F02:0041                           beq L104a
               S02:00001045:  F0 03
F02:0042                           sta $02
               S02:00001047:  85 02
F02:0043                           rts
               S02:00001049:  60
F02:0044                           
F02:0045       L104a               lda #$00
               S02:0000104A:  A9 00
F02:0046                           sta d404_sVoc1Control
               S02:0000104C:  8D 04 B8
F02:0047                           sta d40b_sVoc2Control
               S02:0000104F:  8D 0B B8
F02:0048                           sta d412_sVoc3Control
               S02:00001052:  8D 12 B8
F02:0049                           lda #$5e
               S02:00001055:  A9 5E
F02:0050                           sta $26
               S02:00001057:  85 26
F02:0051                           lda #$10
               S02:00001059:  A9 10
F02:0052                           sta $27
               S02:0000105B:  85 27
F02:0053                           rts
               S02:0000105D:  60
F02:0054                           
F02:0055                             .byte $ff, $00 
               S02:0000105E:  FF
               S02:0000105F:  00
F02:0056       L1060               lda $1d
               S02:00001060:  A5 1D
F02:0057                           sta $26
               S02:00001062:  85 26
F02:0058                           lda $1e
               S02:00001064:  A5 1E
F02:0059                           sta $27
               S02:00001066:  85 27
F02:0060                           jmp L1015
               S02:00001068:  4C 15 10
F02:0061                           
F02:0062       L106b               lda $26
               S02:0000106B:  A5 26
F02:0063                           sta $1d
               S02:0000106D:  85 1D
F02:0064                           lda $27
               S02:0000106F:  A5 27
F02:0065                           sta $1e
               S02:00001071:  85 1E
F02:0066                           jmp L1015
               S02:00001073:  4C 15 10
F02:0067                           
F02:0068       L1076               jsr S10a1
               S02:00001076:  20 A1 10
F02:0069                           lda #$f8
               S02:00001079:  A9 F8
F02:0070       L107b               clc
               S02:0000107B:  18
F02:0071                           adc #$07
               S02:0000107C:  69 07
F02:0072                           pha
               S02:0000107E:  48
F02:0073                           tax
               S02:0000107F:  AA
F02:0074                           jsr $001f
               S02:00001080:  20 1F 00
F02:0075                           lsr a
               S02:00001083:  4A
F02:0076                           php
               S02:00001084:  08
F02:0077       L1085               inx
               S02:00001085:  E8
F02:0078                           lsr a
               S02:00001086:  4A
F02:0079                           bcs L1093
               S02:00001087:  B0 0A
F02:0080                           bne L1085
               S02:00001089:  D0 FA
F02:0081                           plp
               S02:0000108B:  28
F02:0082                           pla
               S02:0000108C:  68
F02:0083                           bcs L107b
               S02:0000108D:  B0 EC
F02:0084                           jsr S10a1
               S02:0000108F:  20 A1 10
F02:0085                           rts
               S02:00001092:  60
F02:0086                           
F02:0087       L1093               pha
               S02:00001093:  48
F02:0088                           ldy $ffff,x
               S02:00001094:  BC FF FF
F02:0089                           jsr $001f
               S02:00001097:  20 1F 00
F02:0090                           sta $0004,y
               S02:0000109A:  99 04 00
F02:0091                           pla
               S02:0000109D:  68
F02:0092                           jmp L1085
               S02:0000109E:  4C 85 10
F02:0093                           
F02:0094       S10a1               ldy $26
               S02:000010A1:  A4 26
F02:0095                           ldx $29
               S02:000010A3:  A6 29
F02:0096                           sty $29
               S02:000010A5:  84 29
F02:0097                           stx $26
               S02:000010A7:  86 26
F02:0098                           ldy $27
               S02:000010A9:  A4 27
F02:0099                           ldx $2a
               S02:000010AB:  A6 2A
F02:0100                           sty $2a
               S02:000010AD:  84 2A
F02:0101                           stx $27
               S02:000010AF:  86 27
F02:0102                           rts
               S02:000010B1:  60
F02:0103                           
F02:0104       L10b2               sty $26
               S02:000010B2:  84 26
F02:0105                           stx $27
               S02:000010B4:  86 27
F02:0106                           ldx #$06
               S02:000010B6:  A2 06
F02:0107       L10b8               lda $10c6,x
               S02:000010B8:  BD C6 10
F02:0108                           sta $1f,x
               S02:000010BB:  95 1F
F02:0109                           dex
               S02:000010BD:  CA
F02:0110                           bpl L10b8
               S02:000010BE:  10 F8
F02:0111                           lda #$60
               S02:000010C0:  A9 60
F02:0112                           sta $28
               S02:000010C2:  85 28
F02:0113                           bne L10d0
               S02:000010C4:  D0 0A
F02:0114                           inc $26
               S02:000010C6:  E6 26
F02:0115                           bne L10cc
               S02:000010C8:  D0 02
F02:0116                           inc $27
               S02:000010CA:  E6 27
F02:0117       L10cc               lda $ffff
               S02:000010CC:  AD FF FF
F02:0118                           rts
               S02:000010CF:  60
F02:0119                           
F02:0120       L10d0               jsr $001f
               S02:000010D0:  20 1F 00
F02:0121                           sta $dc04
               S02:000010D3:  8D 04 DC
F02:0122                           jsr $001f
               S02:000010D6:  20 1F 00
F02:0123                           sta $dc05
               S02:000010D9:  8D 05 DC
F02:0124                           jsr $001f
               S02:000010DC:  20 1F 00
F02:0125                           sta $29
               S02:000010DF:  85 29
F02:0126                           jsr $001f
               S02:000010E1:  20 1F 00
F02:0127                           sta $2a
               S02:000010E4:  85 2A
F02:0128                           inc $26
               S02:000010E6:  E6 26
F02:0129                           bne L10ec
               S02:000010E8:  D0 02
F02:0130                           inc $27
               S02:000010EA:  E6 27
F02:0131       L10ec               lda $26
               S02:000010EC:  A5 26
F02:0132                           sta $1095
               S02:000010EE:  8D 95 10
F02:0133                           lda $27
               S02:000010F1:  A5 27
F02:0134                           sta $1096
               S02:000010F3:  8D 96 10
F02:0135                           ldx #$1c
               S02:000010F6:  A2 1C
F02:0136                           lda #$00
               S02:000010F8:  A9 00
F02:0137       L10fa               sta $02,x
               S02:000010FA:  95 02
F02:0138                           dex
               S02:000010FC:  CA
F02:0139                           bpl L10fa
               S02:000010FD:  10 FB
F02:0140                           jsr S10a1
               S02:000010FF:  20 A1 10
F02:0141                           rts
               S02:00001102:  60
F02:0142                           
F02:0143       InitSid2            ldy #$09
               S02:00001103:  A0 09
F02:0144                           ldx #$11
               S02:00001105:  A2 11
F02:0145                           jmp L10b2
               S02:00001107:  4C B2 10
F02:0146       
F02:0147         .binary "errorsound.bin"
               S02:0000110A:  F0 0F 77 11 01 00 12 0D 04 05 0B 14 08 09 07 06
               S02:0000111A:  0C 03 0E 0F 10 11 17 13 0A 15 16 18 02 00 B6 00
F02:0148       ;          ^^^^^^^^^^^
F02:0149       ; put your data file here.
F02:0150       
F02:0151       
F01:0049       
F01:0050       startupsoundloop:	
F01:0051         lda donefact		; loop only if the sound is not done
               S02:0000122F:  A5 01
F01:0052         bne startupsoundloop
               S02:00001231:  D0 FC
F01:0053         stz $b00e		; if done disable irqs
               S02:00001233:  9C 0E B0
F01:0054         stz $b00d
               S02:00001236:  9C 0D B0
F01:0055         sei
               S02:00001239:  78
F01:0056         lda $c0		; clear irq vectors
               S02:0000123A:  A5 C0
F01:0057         sta $7fff
               S02:0000123C:  8D FF 7F
F01:0058         stz $7ffe
               S02:0000123F:  9C FE 7F
F01:0059         jsr clear_sid
               S02:00001242:  20 49 12
F01:0060         rts
               S02:00001245:  60
F01:0061         rts
               S02:00001246:  60
F01:0062         rts
               S02:00001247:  60
F01:0063         rts
               S02:00001248:  60
F01:0064       
F01:0065       clear_sid
F01:0066         ldx #$17 ; 17 cuz no pop
               S02:00001249:  A2 17
F01:0067       csid
F01:0068         stz $b800,x
               S02:0000124B:  9E 00 B8
F01:0069         dex
               S02:0000124E:  CA
F01:0070         bne csid
               S02:0000124F:  D0 FA
F01:0071         rts
               S02:00001251:  60
F01:0072       
F01:0073       
F00:0076         .include "hwconfig.s"
F03:0001       PORTB = $b000
F03:0002       PORTA = $b001
F03:0003       DDRB = $b002
F03:0004       DDRA = $b003
F03:0005       
F03:0006       LCD_E  = %10000000
F03:0007       LCD_RW = %01000000
F03:0008       LCD_RS = %00100000
F03:0009       
F03:0010       SD_CS   = %00010000
F03:0011       SD_SCK  = %00001000
F03:0012       SD_MOSI = %00000100
F03:0013       SD_MISO = %00000010
F03:0014       
F03:0015       PORTA_OUTPUTPINS = LCD_E | LCD_RW | LCD_RS | SD_CS | SD_SCK | SD_MOSI
F03:0016       
F03:0017       via_init:
F03:0018         lda #%11111111          ; Set all pins on port B to output
               S02:00001252:  A9 FF
F03:0019         sta DDRB
               S02:00001254:  8D 02 B0
F03:0020         lda #PORTA_OUTPUTPINS   ; Set various pins on port A to output
               S02:00001257:  A9 FC
F03:0021         sta DDRA
               S02:00001259:  8D 03 B0
F03:0022         rts
               S02:0000125C:  60
F03:0023       
F03:0024       
F00:0077         .include "libacia.s"
F04:0001       ;       ------------------ 6551 ACIA Subroutine Library -------------------
F04:0002       ; Includes:
F04:0003       ; acia_init       - Initializes the ACIA
F04:0004       ; print_hex_acia  - Prints a hex value in A
F04:0005       ; crlf		  - Prints <CR> followed by <LF>
F04:0006       ; clear_display   - Sends a <CLS> command
F04:0007       ; txpoll          - Polls the TX bit to see if the ACIA is ready
F04:0008       ; print_chara     - Prints a Character that is stored in A
F04:0009       ; print_char_acia - Same as print_chara
F04:0010       ; ascii_home      - Home the cursor
F04:0011       ; w_acia_full     - Print a NULL-Termintated String with >HIGH in Y and <LOW in X
F04:0012       
F04:0013       acia_init:
F04:0014         pha
               S02:0000125D:  48
F04:0015         lda #%00001011          ; No parity, no echo, no interrupt
               S02:0000125E:  A9 0B
F04:0016         sta $8002
               S02:00001260:  8D 02 80
F04:0017         lda #%00011111          ; 1 stop bit, 8 data bits, 19200 baud
               S02:00001263:  A9 1F
F04:0018         sta $8003
               S02:00001265:  8D 03 80
F04:0019         pla
               S02:00001268:  68
F04:0020         rts
               S02:00001269:  60
F04:0021       
F04:0022       print_hex_acia:
F04:0023         pha
               S02:0000126A:  48
F04:0024         ror
               S02:0000126B:  6A
F04:0025         ror
               S02:0000126C:  6A
F04:0026         ror
               S02:0000126D:  6A
F04:0027         ror
               S02:0000126E:  6A
F04:0028         jsr print_nybble   ; This is just som usful hex cod
               S02:0000126F:  20 73 12
F04:0029         pla
               S02:00001272:  68
F04:0030       print_nybble:
F04:0031         and #15
               S02:00001273:  29 0F
F04:0032         cmp #10
               S02:00001275:  C9 0A
F04:0033         bmi cskipletter
               S02:00001277:  30 02
F04:0034         adc #6
               S02:00001279:  69 06
F04:0035       cskipletter:
F04:0036         adc #48
               S02:0000127B:  69 30
F04:0037        ; jsr print_char
F04:0038         jsr print_chara
               S02:0000127D:  20 B1 12
F04:0039         rts
               S02:00001280:  60
F04:0040       
F04:0041       crlf:
F04:0042         pha
               S02:00001281:  48
F04:0043         txa
               S02:00001282:  8A
F04:0044         pha
               S02:00001283:  48
F04:0045         tya
               S02:00001284:  98
F04:0046         pha
               S02:00001285:  48
F04:0047         lda #$0d
               S02:00001286:  A9 0D
F04:0048         jsr print_chara
               S02:00001288:  20 B1 12
F04:0049         lda #$0a
               S02:0000128B:  A9 0A
F04:0050         jsr print_chara
               S02:0000128D:  20 B1 12
F04:0051         pla
               S02:00001290:  68
F04:0052         tay
               S02:00001291:  A8
F04:0053         pla
               S02:00001292:  68
F04:0054         tax
               S02:00001293:  AA
F04:0055         pla
               S02:00001294:  68
F04:0056         rts
               S02:00001295:  60
F04:0057       
F04:0058       cleardisplay:
F04:0059         pha
               S02:00001296:  48
F04:0060         jsr txpoll  ; Poll the TX bit
               S02:00001297:  20 A1 12
F04:0061         lda #12     ; Print decimal 12 (CLS)
               S02:0000129A:  A9 0C
F04:0062         sta $8000
               S02:0000129C:  8D 00 80
F04:0063         pla
               S02:0000129F:  68
F04:0064         rts
               S02:000012A0:  60
F04:0065       
F04:0066       txpoll:
F04:0067         lda $8001
               S02:000012A1:  AD 01 80
F04:0068         and #$10    ; Poll the TX bit
               S02:000012A4:  29 10
F04:0069         beq txpoll
               S02:000012A6:  F0 F9
F04:0070         rts
               S02:000012A8:  60
F04:0071       
F04:0072       rxpoll:
F04:0073         lda $8001
               S02:000012A9:  AD 01 80
F04:0074         and #$08    ; Poll the RX bit
               S02:000012AC:  29 08
F04:0075         beq rxpoll
               S02:000012AE:  F0 F9
F04:0076         rts
               S02:000012B0:  60
F04:0077       
F04:0078       
F04:0079       print_chara:
F04:0080         pha
               S02:000012B1:  48
F04:0081         jsr txpoll  ; Poll the TX bit
               S02:000012B2:  20 A1 12
F04:0082         pla
               S02:000012B5:  68
F04:0083         sta $8000   ; Print character from A
               S02:000012B6:  8D 00 80
F04:0084         rts
               S02:000012B9:  60
F04:0085       
F04:0086       print_char_acia:
F04:0087         jmp print_chara  ; Same as "print_chara"
               S02:000012BA:  4C B1 12
F04:0088       
F04:0089       ascii_home:
F04:0090         pha
               S02:000012BD:  48
F04:0091         lda #1
               S02:000012BE:  A9 01
F04:0092         jsr print_chara  ; Print 1 (HOME)
               S02:000012C0:  20 B1 12
F04:0093         pla
               S02:000012C3:  68
F04:0094         rts
               S02:000012C4:  60
F04:0095       
F04:0096       w_acia_full:
F04:0097         pha
               S02:000012C5:  48
F04:0098         lda $ff
               S02:000012C6:  A5 FF
F04:0099         pha        ; Push Previous States onto the stack
               S02:000012C8:  48
F04:0100         lda $fe
               S02:000012C9:  A5 FE
F04:0101         pha
               S02:000012CB:  48
F04:0102         sty $ff    ; Set Y as the Upper Address (8-15)
               S02:000012CC:  84 FF
F04:0103         stx $fe    ; Set X as the Lower Adderss (0-7)
               S02:000012CE:  86 FE
F04:0104         ldy #0
               S02:000012D0:  A0 00
F04:0105       acia_man:
F04:0106         jsr txpoll   ; Poll TX
               S02:000012D2:  20 A1 12
F04:0107         lda ($fe),y  ; Load the Address
               S02:000012D5:  B1 FE
F04:0108         sta $8000    ; Print what is at the address
               S02:000012D7:  8D 00 80
F04:0109         beq endwacia ; If Done, End
               S02:000012DA:  F0 04
F04:0110         iny          ; Next Character
               S02:000012DC:  C8
F04:0111         jmp acia_man ; Back to the top
               S02:000012DD:  4C D2 12
F04:0112       endwacia:
F04:0113         pla
               S02:000012E0:  68
F04:0114         sta $fe
               S02:000012E1:  85 FE
F04:0115         pla          ; Restore Variables
               S02:000012E3:  68
F04:0116         sta $ff
               S02:000012E4:  85 FF
F04:0117         pla
               S02:000012E6:  68
F04:0118         rts
               S02:000012E7:  60
F04:0119       
F00:0078         .include "libsd.s"
F05:0001       ; SD card interface module
F05:0002       ;
F05:0003       ; Requires zero-page variable storage:
F05:0004       ;   zp_sd_address - 2 bytes
F05:0005       ;   zp_sd_currentsector - 4 bytes
F05:0006       
F05:0007       
F05:0008       sd_init:
F05:0009         ; Let the SD card boot up, by pumping the clock with SD CS disabled
F05:0010       
F05:0011         ; We need to apply around 80 clock pulses with CS and MOSI high.
F05:0012         ; Normally MOSI doesn't matter when CS is high, but the card is
F05:0013         ; not yet is SPI mode, and in this non-SPI state it does care.
F05:0014       
F05:0015         lda #SD_CS | SD_MOSI
               S02:000012E8:  A9 14
F05:0016         ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
               S02:000012EA:  A2 A0
F05:0017       .preinitloop:
F05:0018         eor #SD_SCK
               S02:000012EC:  49 08
F05:0019         sta PORTA
               S02:000012EE:  8D 01 B0
F05:0020         dex
               S02:000012F1:  CA
F05:0021         bne .preinitloop
               S02:000012F2:  D0 F8
F05:0022         
F05:0023       
F05:0024       .cmd0 ; GO_IDLE_STATE - resets card to idle state, and SPI mode
F05:0025         lda #<sd_cmd0_bytes
               S02:000012F4:  A9 5B
F05:0026         sta zp_sd_address
               S02:000012F6:  85 40
F05:0027         lda #>sd_cmd0_bytes
               S02:000012F8:  A9 13
F05:0028         sta zp_sd_address+1
               S02:000012FA:  85 41
F05:0029       
F05:0030         jsr sd_sendcommand
               S02:000012FC:  20 AD 13
F05:0031       
F05:0032         ; Expect status response $01 (not initialized)
F05:0033         cmp #$01
               S02:000012FF:  C9 01
F05:0034         bne .initfailed
               S02:00001301:  D0 50
F05:0035       
F05:0036       .cmd8 ; SEND_IF_COND - tell the card how we want it to operate (3.3V, etc)
F05:0037         lda #<sd_cmd8_bytes
               S02:00001303:  A9 61
F05:0038         sta zp_sd_address
               S02:00001305:  85 40
F05:0039         lda #>sd_cmd8_bytes
               S02:00001307:  A9 13
F05:0040         sta zp_sd_address+1
               S02:00001309:  85 41
F05:0041       
F05:0042         jsr sd_sendcommand
               S02:0000130B:  20 AD 13
F05:0043       
F05:0044         ; Expect status response $01 (not initialized)
F05:0045         cmp #$01
               S02:0000130E:  C9 01
F05:0046         bne .initfailed
               S02:00001310:  D0 41
F05:0047       
F05:0048         ; Read 32-bit return value, but ignore it
F05:0049         jsr sd_readbyte
               S02:00001312:  20 73 13
F05:0050         jsr sd_readbyte
               S02:00001315:  20 73 13
F05:0051         jsr sd_readbyte
               S02:00001318:  20 73 13
F05:0052         jsr sd_readbyte
               S02:0000131B:  20 73 13
F05:0053       
F05:0054       .cmd55 ; APP_CMD - required prefix for ACMD commands
F05:0055         lda #<sd_cmd55_bytes
               S02:0000131E:  A9 67
F05:0056         sta zp_sd_address
               S02:00001320:  85 40
F05:0057         lda #>sd_cmd55_bytes
               S02:00001322:  A9 13
F05:0058         sta zp_sd_address+1
               S02:00001324:  85 41
F05:0059       
F05:0060         jsr sd_sendcommand
               S02:00001326:  20 AD 13
F05:0061       
F05:0062         ; Expect status response $01 (not initialized)
F05:0063         cmp #$01
               S02:00001329:  C9 01
F05:0064         bne .initfailed
               S02:0000132B:  D0 26
F05:0065       
F05:0066       .cmd41 ; APP_SEND_OP_COND - send operating conditions, initialize card
F05:0067         lda #<sd_cmd41_bytes
               S02:0000132D:  A9 6D
F05:0068         sta zp_sd_address
               S02:0000132F:  85 40
F05:0069         lda #>sd_cmd41_bytes
               S02:00001331:  A9 13
F05:0070         sta zp_sd_address+1
               S02:00001333:  85 41
F05:0071       
F05:0072         jsr sd_sendcommand
               S02:00001335:  20 AD 13
F05:0073       
F05:0074         ; Status response $00 means initialised
F05:0075         cmp #$00
               S02:00001338:  C9 00
F05:0076         beq .initialized
               S02:0000133A:  F0 11
F05:0077       
F05:0078         ; Otherwise expect status response $01 (not initialized)
F05:0079         cmp #$01
               S02:0000133C:  C9 01
F05:0080         bne .initfailed
               S02:0000133E:  D0 13
F05:0081       
F05:0082         ; Not initialized yet, so wait a while then try again.
F05:0083         ; This retry is important, to give the card time to initialize.
F05:0084       
F05:0085         ldx #0
               S02:00001340:  A2 00
F05:0086         ldy #0
               S02:00001342:  A0 00
F05:0087       .delayloop
F05:0088         dey
               S02:00001344:  88
F05:0089         bne .delayloop
               S02:00001345:  D0 FD
F05:0090         dex
               S02:00001347:  CA
F05:0091         bne .delayloop
               S02:00001348:  D0 FA
F05:0092       
F05:0093         jmp .cmd55
               S02:0000134A:  4C 1E 13
F05:0094       
F05:0095       
F05:0096       .initialized
F05:0097         lda #'Y'
               S02:0000134D:  A9 59
F05:0098         jsr print_chara
               S02:0000134F:  20 B1 12
F05:0099         rts
               S02:00001352:  60
F05:0100       
F05:0101       .initfailed
F05:0102         lda #'X'
               S02:00001353:  A9 58
F05:0103         jsr print_chara
               S02:00001355:  20 B1 12
F05:0104       .loop
F05:0105         jmp .loop
               S02:00001358:  4C 58 13
F05:0106       
F05:0107       
F05:0108       sd_cmd0_bytes
F05:0109         .byte $40, $00, $00, $00, $00, $95
               S02:0000135B:  40
               S02:0000135C:  00
               S02:0000135D:  00
               S02:0000135E:  00
               S02:0000135F:  00
               S02:00001360:  95
F05:0110       sd_cmd8_bytes
F05:0111         .byte $48, $00, $00, $01, $aa, $87
               S02:00001361:  48
               S02:00001362:  00
               S02:00001363:  00
               S02:00001364:  01
               S02:00001365:  AA
               S02:00001366:  87
F05:0112       sd_cmd55_bytes
F05:0113         .byte $77, $00, $00, $00, $00, $01
               S02:00001367:  77
               S02:00001368:  00
               S02:00001369:  00
               S02:0000136A:  00
               S02:0000136B:  00
               S02:0000136C:  01
F05:0114       sd_cmd41_bytes
F05:0115         .byte $69, $40, $00, $00, $00, $01
               S02:0000136D:  69
               S02:0000136E:  40
               S02:0000136F:  00
               S02:00001370:  00
               S02:00001371:  00
               S02:00001372:  01
F05:0116       
F05:0117       
F05:0118       
F05:0119       sd_readbyte:
F05:0120         ; Enable the card and tick the clock 8 times with MOSI high, 
F05:0121         ; capturing bits from MISO and returning them
F05:0122       
F05:0123         ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
               S02:00001373:  A2 FE
F05:0124       
F05:0125       .loop:
F05:0126       
F05:0127         lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
               S02:00001375:  A9 04
F05:0128         sta PORTA
               S02:00001377:  8D 01 B0
F05:0129       
F05:0130         lda #SD_MOSI | SD_SCK       ; toggle the clock high
               S02:0000137A:  A9 0C
F05:0131         sta PORTA
               S02:0000137C:  8D 01 B0
F05:0132       
F05:0133         lda PORTA                   ; read next bit
               S02:0000137F:  AD 01 B0
F05:0134         and #SD_MISO
               S02:00001382:  29 02
F05:0135       
F05:0136         clc                         ; default to clearing the bottom bit
               S02:00001384:  18
F05:0137         beq .bitnotset              ; unless MISO was set
               S02:00001385:  F0 01
F05:0138         sec                         ; in which case get ready to set the bottom bit
               S02:00001387:  38
F05:0139       .bitnotset:
F05:0140       
F05:0141         txa                         ; transfer partial result from X
               S02:00001388:  8A
F05:0142         rol                         ; rotate carry bit into read result, and loop bit into carry
               S02:00001389:  2A
F05:0143         tax                         ; save partial result back to X
               S02:0000138A:  AA
F05:0144         
F05:0145         bcs .loop                   ; loop if we need to read more bits
               S02:0000138B:  B0 E8
F05:0146       
F05:0147         rts
               S02:0000138D:  60
F05:0148       
F05:0149       
F05:0150       sd_writebyte:
F05:0151         ; Tick the clock 8 times with descending bits on MOSI
F05:0152         ; SD communication is mostly half-duplex so we ignore anything it sends back here
F05:0153       
F05:0154         ldx #8                      ; send 8 bits
               S02:0000138E:  A2 08
F05:0155       
F05:0156       .loop:
F05:0157         asl                         ; shift next bit into carry
               S02:00001390:  0A
F05:0158         tay                         ; save remaining bits for later
               S02:00001391:  A8
F05:0159       
F05:0160         lda #0
               S02:00001392:  A9 00
F05:0161         bcc .sendbit                ; if carry clear, don't set MOSI for this bit
               S02:00001394:  90 02
F05:0162         ora #SD_MOSI
               S02:00001396:  09 04
F05:0163       
F05:0164       .sendbit:
F05:0165         sta PORTA                   ; set MOSI (or not) first with SCK low
               S02:00001398:  8D 01 B0
F05:0166         eor #SD_SCK
               S02:0000139B:  49 08
F05:0167         sta PORTA                   ; raise SCK keeping MOSI the same, to send the bit
               S02:0000139D:  8D 01 B0
F05:0168       
F05:0169         tya                         ; restore remaining bits to send
               S02:000013A0:  98
F05:0170       
F05:0171         dex
               S02:000013A1:  CA
F05:0172         bne .loop                   ; loop if there are more bits to send
               S02:000013A2:  D0 EC
F05:0173       
F05:0174         rts
               S02:000013A4:  60
F05:0175       
F05:0176       
F05:0177       sd_waitresult:
F05:0178         ; Wait for the SD card to return something other than $ff
F05:0179         jsr sd_readbyte
               S02:000013A5:  20 73 13
F05:0180         cmp #$ff
               S02:000013A8:  C9 FF
F05:0181         beq sd_waitresult
               S02:000013AA:  F0 F9
F05:0182         rts
               S02:000013AC:  60
F05:0183       
F05:0184       
F05:0185       sd_sendcommand:
F05:0186         ; Debug print which command is being executed
F05:0187         jsr cleardisplay
               S02:000013AD:  20 96 12
F05:0188       
F05:0189         lda #'c'
               S02:000013B0:  A9 63
F05:0190         jsr print_chara
               S02:000013B2:  20 B1 12
F05:0191         ldx #0
               S02:000013B5:  A2 00
F05:0192         lda (zp_sd_address,x)
               S02:000013B7:  A1 40
F05:0193         jsr print_hex_acia
               S02:000013B9:  20 6A 12
F05:0194       
F05:0195         lda #SD_MOSI           ; pull CS low to begin command
               S02:000013BC:  A9 04
F05:0196         sta PORTA
               S02:000013BE:  8D 01 B0
F05:0197       
F05:0198         ldy #0
               S02:000013C1:  A0 00
F05:0199         lda (zp_sd_address),y    ; command byte
               S02:000013C3:  B1 40
F05:0200         jsr sd_writebyte
               S02:000013C5:  20 8E 13
F05:0201         ldy #1
               S02:000013C8:  A0 01
F05:0202         lda (zp_sd_address),y    ; data 1
               S02:000013CA:  B1 40
F05:0203         jsr sd_writebyte
               S02:000013CC:  20 8E 13
F05:0204         ldy #2
               S02:000013CF:  A0 02
F05:0205         lda (zp_sd_address),y    ; data 2
               S02:000013D1:  B1 40
F05:0206         jsr sd_writebyte
               S02:000013D3:  20 8E 13
F05:0207         ldy #3
               S02:000013D6:  A0 03
F05:0208         lda (zp_sd_address),y    ; data 3
               S02:000013D8:  B1 40
F05:0209         jsr sd_writebyte
               S02:000013DA:  20 8E 13
F05:0210         ldy #4
               S02:000013DD:  A0 04
F05:0211         lda (zp_sd_address),y    ; data 4
               S02:000013DF:  B1 40
F05:0212         jsr sd_writebyte
               S02:000013E1:  20 8E 13
F05:0213         ldy #5
               S02:000013E4:  A0 05
F05:0214         lda (zp_sd_address),y    ; crc
               S02:000013E6:  B1 40
F05:0215         jsr sd_writebyte
               S02:000013E8:  20 8E 13
F05:0216       
F05:0217         jsr sd_waitresult
               S02:000013EB:  20 A5 13
F05:0218         pha
               S02:000013EE:  48
F05:0219       
F05:0220         ; Debug print the result code
F05:0221         jsr print_hex_acia
               S02:000013EF:  20 6A 12
F05:0222       
F05:0223         ; End command
F05:0224         lda #SD_CS | SD_MOSI   ; set CS high again
               S02:000013F2:  A9 14
F05:0225         sta PORTA
               S02:000013F4:  8D 01 B0
F05:0226       
F05:0227         pla   ; restore result code
               S02:000013F7:  68
F05:0228         rts
               S02:000013F8:  60
F05:0229       
F05:0230       
F05:0231       sd_readsector:
F05:0232         ; Read a sector from the SD card.  A sector is 512 bytes.
F05:0233         ;
F05:0234         ; Parameters:
F05:0235         ;    zp_sd_currentsector   32-bit sector number
F05:0236         ;    zp_sd_address     address of buffer to receive data
F05:0237         
F05:0238         lda #SD_MOSI
               S02:000013F9:  A9 04
F05:0239         sta PORTA
               S02:000013FB:  8D 01 B0
F05:0240       
F05:0241         ; Command 17, arg is sector number, crc not checked
F05:0242         lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S02:000013FE:  A9 51
F05:0243         jsr sd_writebyte
               S02:00001400:  20 8E 13
F05:0244         lda zp_sd_currentsector+3   ; sector 24:31
               S02:00001403:  A5 45
F05:0245         jsr sd_writebyte
               S02:00001405:  20 8E 13
F05:0246         lda zp_sd_currentsector+2   ; sector 16:23
               S02:00001408:  A5 44
F05:0247         jsr sd_writebyte
               S02:0000140A:  20 8E 13
F05:0248         lda zp_sd_currentsector+1   ; sector 8:15
               S02:0000140D:  A5 43
F05:0249         jsr sd_writebyte
               S02:0000140F:  20 8E 13
F05:0250         lda zp_sd_currentsector     ; sector 0:7
               S02:00001412:  A5 42
F05:0251         jsr sd_writebyte
               S02:00001414:  20 8E 13
F05:0252         lda #$01                    ; crc (not checked)
               S02:00001417:  A9 01
F05:0253         jsr sd_writebyte
               S02:00001419:  20 8E 13
F05:0254       
F05:0255         jsr sd_waitresult
               S02:0000141C:  20 A5 13
F05:0256         cmp #$00
               S02:0000141F:  C9 00
F05:0257         bne .fail
               S02:00001421:  D0 17
F05:0258       
F05:0259         ; wait for data
F05:0260         jsr sd_waitresult
               S02:00001423:  20 A5 13
F05:0261         cmp #$fe
               S02:00001426:  C9 FE
F05:0262         bne .fail
               S02:00001428:  D0 10
F05:0263       
F05:0264         ; Need to read 512 bytes - two pages of 256 bytes each
F05:0265         jsr .readpage
               S02:0000142A:  20 4C 14
F05:0266         inc zp_sd_address+1
               S02:0000142D:  E6 41
F05:0267         jsr .readpage
               S02:0000142F:  20 4C 14
F05:0268         dec zp_sd_address+1
               S02:00001432:  C6 41
F05:0269       
F05:0270         ; End command
F05:0271         lda #SD_CS | SD_MOSI
               S02:00001434:  A9 14
F05:0272         sta PORTA
               S02:00001436:  8D 01 B0
F05:0273       
F05:0274         rts
               S02:00001439:  60
F05:0275       
F05:0276       
F05:0277       .fail
F05:0278         lda #'s'
               S02:0000143A:  A9 73
F05:0279         jsr print_chara
               S02:0000143C:  20 B1 12
F05:0280         lda #':'
               S02:0000143F:  A9 3A
F05:0281         jsr print_chara
               S02:00001441:  20 B1 12
F05:0282         lda #'f'
               S02:00001444:  A9 66
F05:0283         jsr print_chara
               S02:00001446:  20 B1 12
F05:0284       .failloop
F05:0285         jmp .failloop
               S02:00001449:  4C 49 14
F05:0286       
F05:0287       .readpage
F05:0288         ; Read 256 bytes to the address at zp_sd_address
F05:0289         ldy #0
               S02:0000144C:  A0 00
F05:0290       .readloop
F05:0291         jsr sd_readbyte
               S02:0000144E:  20 73 13
F05:0292         sta (zp_sd_address),y
               S02:00001451:  91 40
F05:0293         iny
               S02:00001453:  C8
F05:0294         bne .readloop
               S02:00001454:  D0 F8
F05:0295         rts
               S02:00001456:  60
F05:0296       
F05:0297       
F05:0298       sd_writesector:
F05:0299         ; Write a sector to the SD card.  A sector is 512 bytes.
F05:0300         ;
F05:0301         ; Parameters:
F05:0302         ;    zp_sd_currentsector   32-bit sector number
F05:0303         ;    zp_sd_address     address of buffer to take data from
F05:0304         
F05:0305         lda #SD_MISO
               S02:00001457:  A9 02
F05:0306         sta PORTA
               S02:00001459:  8D 01 B0
F05:0307       
F05:0308         ; Command 24, arg is sector number, crc not checked
F05:0309         lda #$58                    ; CMD24 - WRITE_BLOCK
               S02:0000145C:  A9 58
F05:0310         jsr sd_writebyte
               S02:0000145E:  20 8E 13
F05:0311         lda zp_sd_currentsector+3   ; sector 24:31
               S02:00001461:  A5 45
F05:0312         jsr sd_writebyte
               S02:00001463:  20 8E 13
F05:0313         lda zp_sd_currentsector+2   ; sector 16:23
               S02:00001466:  A5 44
F05:0314         jsr sd_writebyte
               S02:00001468:  20 8E 13
F05:0315         lda zp_sd_currentsector+1   ; sector 8:15
               S02:0000146B:  A5 43
F05:0316         jsr sd_writebyte
               S02:0000146D:  20 8E 13
F05:0317         lda zp_sd_currentsector     ; sector 0:7
               S02:00001470:  A5 42
F05:0318         jsr sd_writebyte
               S02:00001472:  20 8E 13
F05:0319         lda #$01                    ; crc (not checked)
               S02:00001475:  A9 01
F05:0320         jsr sd_writebyte
               S02:00001477:  20 8E 13
F05:0321       
F05:0322         jsr sd_waitresult
               S02:0000147A:  20 A5 13
F05:0323         cmp #$00
               S02:0000147D:  C9 00
F05:0324         bne .fail
               S02:0000147F:  D0 1A
F05:0325       
F05:0326         ; Need to write 512 bytes - two pages of 256 bytes each
F05:0327         jsr .writepage
               S02:00001481:  20 9D 14
F05:0328         inc zp_sd_address+1
               S02:00001484:  E6 41
F05:0329         jsr .writepage
               S02:00001486:  20 9D 14
F05:0330         dec zp_sd_address+1
               S02:00001489:  C6 41
F05:0331       
F05:0332         ; wait for data
F05:0333         jsr sd_waitresult
               S02:0000148B:  20 A5 13
F05:0334         and #$1f
               S02:0000148E:  29 1F
F05:0335         cmp #$05
               S02:00001490:  C9 05
F05:0336         bne .fail
               S02:00001492:  D0 07
F05:0337       
F05:0338         ; End command
F05:0339         lda #SD_CS | SD_MOSI ; set cs and mosi high (disconnected)
               S02:00001494:  A9 14
F05:0340         sta PORTA
               S02:00001496:  8D 01 B0
F05:0341       
F05:0342         clc
               S02:00001499:  18
F05:0343         rts
               S02:0000149A:  60
F05:0344       
F05:0345       .fail:
F05:0346         sec
               S02:0000149B:  38
F05:0347         rts
               S02:0000149C:  60
F05:0348       
F05:0349       .writepage:
F05:0350         ; Write 256 bytes fom zp_sd_address
F05:0351         ldy #0
               S02:0000149D:  A0 00
F05:0352       .writeloop:
F05:0353         lda (zp_sd_address),y
               S02:0000149F:  B1 40
F05:0354         jsr sd_writebyte
               S02:000014A1:  20 8E 13
F05:0355         iny
               S02:000014A4:  C8
F05:0356         bne .writeloop
               S02:000014A5:  D0 F8
F05:0357         rts
               S02:000014A7:  60
F05:0358       
F05:0359       
F05:0360       
F05:0361       
F00:0079         .include "libfat32.s"
F06:0001       ; FAT32/SD interface library
F06:0002       ;
F06:0003       ; This module requires some RAM workspace to be defined elsewhere:
F06:0004       ; 
F06:0005       ; fat32_workspace    - a large page-aligned 512-byte workspace
F06:0006       ; zp_fat32_variables - 24 bytes of zero-page storage for variables etc
F06:0007       
F06:0008       fat32_readbuffer = fat32_workspace
F06:0009       
F06:0010       fat32_fatstart          	= zp_fat32_variables + $00  ; 4 bytes
F06:0011       fat32_datastart         	= zp_fat32_variables + $04  ; 4 bytes
F06:0012       fat32_rootcluster       	= zp_fat32_variables + $08  ; 4 bytes
F06:0013       fat32_sectorspercluster 	= zp_fat32_variables + $0c  ; 1 byte
F06:0014       fat32_pendingsectors    	= zp_fat32_variables + $0d  ; 1 byte
F06:0015       fat32_address           	= zp_fat32_variables + $0e  ; 2 bytes
F06:0016       fat32_nextcluster       	= zp_fat32_variables + $10  ; 4 bytes
F06:0017       fat32_bytesremaining    	= zp_fat32_variables + $14  ; 4 bytes   	
F06:0018       fat32_lastfoundfreecluster	= zp_fat32_variables + $18  ; 4 bytes
F06:0019       fat32_sectorsperfat		= zp_fat32_variables + $1c  ; 2 bytes
F06:0020       ;fat32_fsinfosector		= zp_fat32_variables + $1e  ; 2 bytes
F06:0021       fat32_lastcluster		= zp_fat32_variables + $1e  ; 4 bytes
F06:0022       
F06:0023       fat32_errorstage            = fat32_bytesremaining  ; only used during initialization
F06:0024       fat32_filenamepointer       = fat32_bytesremaining  ; only used when searching for a file
F06:0025       fat32_lba		            = fat32_bytesremaining  ; only used when making a dirent
F06:0026       
F06:0027       ; TODO add cluster chain creation (saving the next cluster at the previous cluster, and adding a end-of-chain marker.)
F06:0028       
F06:0029       fat32_init:
F06:0030         ; Initialize the module - read the MBR etc, find the partition,
F06:0031         ; and set up the variables ready for navigating the filesystem
F06:0032       
F06:0033         ; Read the MBR and extract pertinent information
F06:0034       
F06:0035         lda #0
               S02:000014A8:  A9 00
F06:0036         sta fat32_errorstage
               S02:000014AA:  85 5A
F06:0037       
F06:0038         ; Sector 0
F06:0039         lda #0
               S02:000014AC:  A9 00
F06:0040         sta zp_sd_currentsector
               S02:000014AE:  85 42
F06:0041         sta zp_sd_currentsector+1
               S02:000014B0:  85 43
F06:0042         sta zp_sd_currentsector+2
               S02:000014B2:  85 44
F06:0043         sta zp_sd_currentsector+3
               S02:000014B4:  85 45
F06:0044       
F06:0045         ; Target buffer
F06:0046         lda #<fat32_readbuffer
               S02:000014B6:  A9 00
F06:0047         sta zp_sd_address
               S02:000014B8:  85 40
F06:0048         lda #>fat32_readbuffer
               S02:000014BA:  A9 02
F06:0049         sta zp_sd_address+1
               S02:000014BC:  85 41
F06:0050       
F06:0051         ; Do the read
F06:0052         jsr sd_readsector
               S02:000014BE:  20 F9 13
F06:0053       
F06:0054       
F06:0055         inc fat32_errorstage ; stage 1 = boot sector signature check
               S02:000014C1:  E6 5A
F06:0056       
F06:0057         ; Check some things
F06:0058         lda fat32_readbuffer+510 ; Boot sector signature 55
               S02:000014C3:  AD FE 03
F06:0059         cmp #$55
               S02:000014C6:  C9 55
F06:0060         bne .fail
               S02:000014C8:  D0 2D
F06:0061         lda fat32_readbuffer+511 ; Boot sector signature aa
               S02:000014CA:  AD FF 03
F06:0062         cmp #$aa
               S02:000014CD:  C9 AA
F06:0063         bne .fail
               S02:000014CF:  D0 26
F06:0064       
F06:0065       
F06:0066         inc fat32_errorstage ; stage 2 = finding partition
               S02:000014D1:  E6 5A
F06:0067       
F06:0068         ; Find a FAT32 partition
F06:0069       .FSTYPE_FAT32 = 12
F06:0070         ldx #0
               S02:000014D3:  A2 00
F06:0071         lda fat32_readbuffer+$1c2,x
               S02:000014D5:  BD C2 03
F06:0072         cmp #.FSTYPE_FAT32
               S02:000014D8:  C9 0C
F06:0073         beq .foundpart
               S02:000014DA:  F0 1E
F06:0074         ldx #16
               S02:000014DC:  A2 10
F06:0075         lda fat32_readbuffer+$1c2,x
               S02:000014DE:  BD C2 03
F06:0076         cmp #.FSTYPE_FAT32
               S02:000014E1:  C9 0C
F06:0077         beq .foundpart
               S02:000014E3:  F0 15
F06:0078         ldx #32
               S02:000014E5:  A2 20
F06:0079         lda fat32_readbuffer+$1c2,x
               S02:000014E7:  BD C2 03
F06:0080         cmp #.FSTYPE_FAT32
               S02:000014EA:  C9 0C
F06:0081         beq .foundpart
               S02:000014EC:  F0 0C
F06:0082         ldx #48
               S02:000014EE:  A2 30
F06:0083         lda fat32_readbuffer+$1c2,x
               S02:000014F0:  BD C2 03
F06:0084         cmp #.FSTYPE_FAT32
               S02:000014F3:  C9 0C
F06:0085         beq .foundpart
               S02:000014F5:  F0 03
F06:0086       
F06:0087       .fail:
F06:0088         jmp .error
               S02:000014F7:  4C B8 15
F06:0089       
F06:0090       .foundpart:
F06:0091       
F06:0092         ; Read the FAT32 BPB
F06:0093         lda fat32_readbuffer+$1c6,x
               S02:000014FA:  BD C6 03
F06:0094         sta zp_sd_currentsector
               S02:000014FD:  85 42
F06:0095         lda fat32_readbuffer+$1c7,x
               S02:000014FF:  BD C7 03
F06:0096         sta zp_sd_currentsector+1
               S02:00001502:  85 43
F06:0097         lda fat32_readbuffer+$1c8,x
               S02:00001504:  BD C8 03
F06:0098         sta zp_sd_currentsector+2
               S02:00001507:  85 44
F06:0099         lda fat32_readbuffer+$1c9,x
               S02:00001509:  BD C9 03
F06:0100         sta zp_sd_currentsector+3
               S02:0000150C:  85 45
F06:0101       
F06:0102         jsr sd_readsector
               S02:0000150E:  20 F9 13
F06:0103       
F06:0104       
F06:0105         inc fat32_errorstage ; stage 3 = BPB signature check
               S02:00001511:  E6 5A
F06:0106       
F06:0107         ; Check some things
F06:0108         lda fat32_readbuffer+510 ; BPB sector signature 55
               S02:00001513:  AD FE 03
F06:0109         cmp #$55
               S02:00001516:  C9 55
F06:0110         bne .fail
               S02:00001518:  D0 DD
F06:0111         lda fat32_readbuffer+511 ; BPB sector signature aa
               S02:0000151A:  AD FF 03
F06:0112         cmp #$aa
               S02:0000151D:  C9 AA
F06:0113         bne .fail
               S02:0000151F:  D0 D6
F06:0114       
F06:0115         inc fat32_errorstage ; stage 4 = RootEntCnt check
               S02:00001521:  E6 5A
F06:0116       
F06:0117         lda fat32_readbuffer+17 ; RootEntCnt should be 0 for FAT32
               S02:00001523:  AD 11 02
F06:0118         ora fat32_readbuffer+18
               S02:00001526:  0D 12 02
F06:0119         bne .fail
               S02:00001529:  D0 CC
F06:0120       
F06:0121         inc fat32_errorstage ; stage 5 = TotSec16 check
               S02:0000152B:  E6 5A
F06:0122       
F06:0123         lda fat32_readbuffer+19 ; TotSec16 should be 0 for FAT32
               S02:0000152D:  AD 13 02
F06:0124         ora fat32_readbuffer+20
               S02:00001530:  0D 14 02
F06:0125         bne .fail
               S02:00001533:  D0 C2
F06:0126       
F06:0127         inc fat32_errorstage ; stage 6 = SectorsPerCluster check
               S02:00001535:  E6 5A
F06:0128       
F06:0129         ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
F06:0130         lda fat32_readbuffer+11 ; low byte should be zero
               S02:00001537:  AD 0B 02
F06:0131         bne .fail
               S02:0000153A:  D0 BB
F06:0132         lda fat32_readbuffer+12 ; high byte is 2 (512), 4, 8, or 16
               S02:0000153C:  AD 0C 02
F06:0133         cmp #2
               S02:0000153F:  C9 02
F06:0134         bne .fail
               S02:00001541:  D0 B4
F06:0135       
F06:0136         ; Save sectors per FAT
F06:0137       
F06:0138         lda fat32_readbuffer+22
               S02:00001543:  AD 16 02
F06:0139         sta fat32_sectorsperfat
               S02:00001546:  85 62
F06:0140         lda fat32_readbuffer+23
               S02:00001548:  AD 17 02
F06:0141         sta fat32_sectorsperfat+1
               S02:0000154B:  85 63
F06:0142       
F06:0143         ; Calculate the starting sector of the FAT
F06:0144         clc
               S02:0000154D:  18
F06:0145         lda zp_sd_currentsector
               S02:0000154E:  A5 42
F06:0146         adc fat32_readbuffer+14    ; reserved sectors lo
               S02:00001550:  6D 0E 02
F06:0147         sta fat32_fatstart
               S02:00001553:  85 46
F06:0148         sta fat32_datastart
               S02:00001555:  85 4A
F06:0149         lda zp_sd_currentsector+1
               S02:00001557:  A5 43
F06:0150         adc fat32_readbuffer+15    ; reserved sectors hi
               S02:00001559:  6D 0F 02
F06:0151         sta fat32_fatstart+1
               S02:0000155C:  85 47
F06:0152         sta fat32_datastart+1
               S02:0000155E:  85 4B
F06:0153         lda zp_sd_currentsector+2
               S02:00001560:  A5 44
F06:0154         adc #0
               S02:00001562:  69 00
F06:0155         sta fat32_fatstart+2
               S02:00001564:  85 48
F06:0156         sta fat32_datastart+2
               S02:00001566:  85 4C
F06:0157         lda zp_sd_currentsector+3
               S02:00001568:  A5 45
F06:0158         adc #0
               S02:0000156A:  69 00
F06:0159         sta fat32_fatstart+3
               S02:0000156C:  85 49
F06:0160         sta fat32_datastart+3
               S02:0000156E:  85 4D
F06:0161       
F06:0162         ; Calculate the starting sector of the data area
F06:0163         ldx fat32_readbuffer+16   ; number of FATs
               S02:00001570:  AE 10 02
F06:0164       .skipfatsloop:
F06:0165         clc
               S02:00001573:  18
F06:0166         lda fat32_datastart
               S02:00001574:  A5 4A
F06:0167         adc fat32_readbuffer+36 ; fatsize 0
               S02:00001576:  6D 24 02
F06:0168         sta fat32_datastart
               S02:00001579:  85 4A
F06:0169         lda fat32_datastart+1
               S02:0000157B:  A5 4B
F06:0170         adc fat32_readbuffer+37 ; fatsize 1
               S02:0000157D:  6D 25 02
F06:0171         sta fat32_datastart+1
               S02:00001580:  85 4B
F06:0172         lda fat32_datastart+2
               S02:00001582:  A5 4C
F06:0173         adc fat32_readbuffer+38 ; fatsize 2
               S02:00001584:  6D 26 02
F06:0174         sta fat32_datastart+2
               S02:00001587:  85 4C
F06:0175         lda fat32_datastart+3
               S02:00001589:  A5 4D
F06:0176         adc fat32_readbuffer+39 ; fatsize 3
               S02:0000158B:  6D 27 02
F06:0177         sta fat32_datastart+3
               S02:0000158E:  85 4D
F06:0178         dex
               S02:00001590:  CA
F06:0179         bne .skipfatsloop
               S02:00001591:  D0 E0
F06:0180       
F06:0181         ; Sectors-per-cluster is a power of two from 1 to 128
F06:0182         lda fat32_readbuffer+13
               S02:00001593:  AD 0D 02
F06:0183         sta fat32_sectorspercluster
               S02:00001596:  85 52
F06:0184       
F06:0185         ; Remember FSInfo sector
F06:0186         ;lda fat32_readbuffer+38
F06:0187         ;sta fat32_fsinfosector
F06:0188         ;lda fat32_readbuffer+39
F06:0189         ;sta fat32_fsinfosector+1
F06:0190       
F06:0191         ; Remember the root cluster
F06:0192         lda fat32_readbuffer+44
               S02:00001598:  AD 2C 02
F06:0193         sta fat32_rootcluster
               S02:0000159B:  85 4E
F06:0194         lda fat32_readbuffer+45
               S02:0000159D:  AD 2D 02
F06:0195         sta fat32_rootcluster+1
               S02:000015A0:  85 4F
F06:0196         lda fat32_readbuffer+46
               S02:000015A2:  AD 2E 02
F06:0197         sta fat32_rootcluster+2
               S02:000015A5:  85 50
F06:0198         lda fat32_readbuffer+47
               S02:000015A7:  AD 2F 02
F06:0199         sta fat32_rootcluster+3
               S02:000015AA:  85 51
F06:0200       
F06:0201         ; Set the last found free cluster to 0.
F06:0202         lda #0
               S02:000015AC:  A9 00
F06:0203         sta fat32_lastfoundfreecluster
               S02:000015AE:  85 5E
F06:0204         sta fat32_lastfoundfreecluster+1
               S02:000015B0:  85 5F
F06:0205         sta fat32_lastfoundfreecluster+2
               S02:000015B2:  85 60
F06:0206         sta fat32_lastfoundfreecluster+3
               S02:000015B4:  85 61
F06:0207         clc
               S02:000015B6:  18
F06:0208         rts
               S02:000015B7:  60
F06:0209       
F06:0210       .error:
F06:0211         sec
               S02:000015B8:  38
F06:0212         rts
               S02:000015B9:  60
F06:0213       
F06:0214       
F06:0215       fat32_seekcluster:
F06:0216         ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
F06:0217         
F06:0218         ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
F06:0219         lda fat32_nextcluster
               S02:000015BA:  A5 56
F06:0220         asl
               S02:000015BC:  0A
F06:0221         lda fat32_nextcluster+1
               S02:000015BD:  A5 57
F06:0222         rol
               S02:000015BF:  2A
F06:0223         sta zp_sd_currentsector
               S02:000015C0:  85 42
F06:0224         lda fat32_nextcluster+2
               S02:000015C2:  A5 58
F06:0225         rol
               S02:000015C4:  2A
F06:0226         sta zp_sd_currentsector+1
               S02:000015C5:  85 43
F06:0227         lda fat32_nextcluster+3
               S02:000015C7:  A5 59
F06:0228         rol
               S02:000015C9:  2A
F06:0229         sta zp_sd_currentsector+2
               S02:000015CA:  85 44
F06:0230         ; note: cluster numbers never have the top bit set, so no carry can occur
F06:0231       
F06:0232         ; Add FAT starting sector
F06:0233         lda zp_sd_currentsector
               S02:000015CC:  A5 42
F06:0234         adc fat32_fatstart
               S02:000015CE:  65 46
F06:0235         sta zp_sd_currentsector
               S02:000015D0:  85 42
F06:0236         lda zp_sd_currentsector+1
               S02:000015D2:  A5 43
F06:0237         adc fat32_fatstart+1
               S02:000015D4:  65 47
F06:0238         sta zp_sd_currentsector+1
               S02:000015D6:  85 43
F06:0239         lda zp_sd_currentsector+2
               S02:000015D8:  A5 44
F06:0240         adc fat32_fatstart+2
               S02:000015DA:  65 48
F06:0241         sta zp_sd_currentsector+2
               S02:000015DC:  85 44
F06:0242         lda #0
               S02:000015DE:  A9 00
F06:0243         adc fat32_fatstart+3
               S02:000015E0:  65 49
F06:0244         sta zp_sd_currentsector+3
               S02:000015E2:  85 45
F06:0245       
F06:0246         ; Target buffer
F06:0247         lda #<fat32_readbuffer
               S02:000015E4:  A9 00
F06:0248         sta zp_sd_address
               S02:000015E6:  85 40
F06:0249         lda #>fat32_readbuffer
               S02:000015E8:  A9 02
F06:0250         sta zp_sd_address+1
               S02:000015EA:  85 41
F06:0251       
F06:0252         ; Read the sector from the FAT
F06:0253         jsr sd_readsector
               S02:000015EC:  20 F9 13
F06:0254       
F06:0255         ; Before using this FAT data, set currentsector ready to read the cluster itself
F06:0256         ; We need to multiply the cluster number minus two by the number of sectors per 
F06:0257         ; cluster, then add the data region start sector
F06:0258       
F06:0259         ; Subtract two from cluster number
F06:0260         sec
               S02:000015EF:  38
F06:0261         lda fat32_nextcluster
               S02:000015F0:  A5 56
F06:0262         sbc #2
               S02:000015F2:  E9 02
F06:0263         sta zp_sd_currentsector
               S02:000015F4:  85 42
F06:0264         lda fat32_nextcluster+1
               S02:000015F6:  A5 57
F06:0265         sbc #0
               S02:000015F8:  E9 00
F06:0266         sta zp_sd_currentsector+1
               S02:000015FA:  85 43
F06:0267         lda fat32_nextcluster+2
               S02:000015FC:  A5 58
F06:0268         sbc #0
               S02:000015FE:  E9 00
F06:0269         sta zp_sd_currentsector+2
               S02:00001600:  85 44
F06:0270         lda fat32_nextcluster+3
               S02:00001602:  A5 59
F06:0271         sbc #0
               S02:00001604:  E9 00
F06:0272         sta zp_sd_currentsector+3
               S02:00001606:  85 45
F06:0273         
F06:0274         ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
F06:0275         lda fat32_sectorspercluster
               S02:00001608:  A5 52
F06:0276       .spcshiftloop:
F06:0277         lsr
               S02:0000160A:  4A
F06:0278         bcs .spcshiftloopdone
               S02:0000160B:  B0 0B
F06:0279         asl zp_sd_currentsector
               S02:0000160D:  06 42
F06:0280         rol zp_sd_currentsector+1
               S02:0000160F:  26 43
F06:0281         rol zp_sd_currentsector+2
               S02:00001611:  26 44
F06:0282         rol zp_sd_currentsector+3
               S02:00001613:  26 45
F06:0283         jmp .spcshiftloop
               S02:00001615:  4C 0A 16
F06:0284       .spcshiftloopdone:
F06:0285       
F06:0286         ; Add the data region start sector
F06:0287         clc
               S02:00001618:  18
F06:0288         lda zp_sd_currentsector
               S02:00001619:  A5 42
F06:0289         adc fat32_datastart
               S02:0000161B:  65 4A
F06:0290         sta zp_sd_currentsector
               S02:0000161D:  85 42
F06:0291         lda zp_sd_currentsector+1
               S02:0000161F:  A5 43
F06:0292         adc fat32_datastart+1
               S02:00001621:  65 4B
F06:0293         sta zp_sd_currentsector+1
               S02:00001623:  85 43
F06:0294         lda zp_sd_currentsector+2
               S02:00001625:  A5 44
F06:0295         adc fat32_datastart+2
               S02:00001627:  65 4C
F06:0296         sta zp_sd_currentsector+2
               S02:00001629:  85 44
F06:0297         lda zp_sd_currentsector+3
               S02:0000162B:  A5 45
F06:0298         adc fat32_datastart+3
               S02:0000162D:  65 4D
F06:0299         sta zp_sd_currentsector+3
               S02:0000162F:  85 45
F06:0300       
F06:0301         ; That's now ready for later code to read this sector in - tell it how many consecutive
F06:0302         ; sectors it can now read
F06:0303         lda fat32_sectorspercluster
               S02:00001631:  A5 52
F06:0304         sta fat32_pendingsectors
               S02:00001633:  85 53
F06:0305       
F06:0306         ; Now go back to looking up the next cluster in the chain
F06:0307         ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
F06:0308       
F06:0309         ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
F06:0310         lda fat32_nextcluster
               S02:00001635:  A5 56
F06:0311         and #$7f
               S02:00001637:  29 7F
F06:0312         asl
               S02:00001639:  0A
F06:0313         asl
               S02:0000163A:  0A
F06:0314         tay ; Y = low byte of offset
               S02:0000163B:  A8
F06:0315       
F06:0316         ; Add the potentially carried bit to the high byte of the address
F06:0317         lda zp_sd_address+1
               S02:0000163C:  A5 41
F06:0318         adc #0
               S02:0000163E:  69 00
F06:0319         sta zp_sd_address+1
               S02:00001640:  85 41
F06:0320       
F06:0321         ; Copy out the next cluster in the chain for later use
F06:0322         lda (zp_sd_address),y
               S02:00001642:  B1 40
F06:0323         sta fat32_nextcluster
               S02:00001644:  85 56
F06:0324         iny
               S02:00001646:  C8
F06:0325         lda (zp_sd_address),y
               S02:00001647:  B1 40
F06:0326         sta fat32_nextcluster+1
               S02:00001649:  85 57
F06:0327         iny
               S02:0000164B:  C8
F06:0328         lda (zp_sd_address),y
               S02:0000164C:  B1 40
F06:0329         sta fat32_nextcluster+2
               S02:0000164E:  85 58
F06:0330         iny
               S02:00001650:  C8
F06:0331         lda (zp_sd_address),y
               S02:00001651:  B1 40
F06:0332         and #$0f
               S02:00001653:  29 0F
F06:0333         sta fat32_nextcluster+3
               S02:00001655:  85 59
F06:0334       
F06:0335         ; See if it's the end of the chain
F06:0336         ora #$f0
               S02:00001657:  09 F0
F06:0337         and fat32_nextcluster+2
               S02:00001659:  25 58
F06:0338         and fat32_nextcluster+1
               S02:0000165B:  25 57
F06:0339         cmp #$ff
               S02:0000165D:  C9 FF
F06:0340         bne .notendofchain
               S02:0000165F:  D0 08
F06:0341         lda fat32_nextcluster
               S02:00001661:  A5 56
F06:0342         cmp #$f8
               S02:00001663:  C9 F8
F06:0343         bcc .notendofchain
               S02:00001665:  90 02
F06:0344       
F06:0345         ; It's the end of the chain, set the top bits so that we can tell this later on
F06:0346         sta fat32_nextcluster+3
               S02:00001667:  85 59
F06:0347       .notendofchain:
F06:0348         rts
               S02:00001669:  60
F06:0349       
F06:0350       
F06:0351       fat32_readnextsector:
F06:0352         ; Reads the next sector from a cluster chain into the buffer at fat32_address.
F06:0353         ;
F06:0354         ; Advances the current sector ready for the next read and looks up the next cluster
F06:0355         ; in the chain when necessary.
F06:0356         ;
F06:0357         ; On return, carry is clear if data was read, or set if the cluster chain has ended.
F06:0358       
F06:0359         ; Maybe there are pending sectors in the current cluster
F06:0360         lda fat32_pendingsectors
               S02:0000166A:  A5 53
F06:0361         bne .readsector
               S02:0000166C:  D0 07
F06:0362       
F06:0363         ; No pending sectors, check for end of cluster chain
F06:0364         lda fat32_nextcluster+3
               S02:0000166E:  A5 59
F06:0365         bmi .endofchain
               S02:00001670:  30 20
F06:0366       
F06:0367         ; Prepare to read the next cluster
F06:0368         jsr fat32_seekcluster
               S02:00001672:  20 BA 15
F06:0369       
F06:0370       .readsector:
F06:0371         dec fat32_pendingsectors
               S02:00001675:  C6 53
F06:0372       
F06:0373         ; Set up target address  
F06:0374         lda fat32_address
               S02:00001677:  A5 54
F06:0375         sta zp_sd_address
               S02:00001679:  85 40
F06:0376         lda fat32_address+1
               S02:0000167B:  A5 55
F06:0377         sta zp_sd_address+1
               S02:0000167D:  85 41
F06:0378       
F06:0379         ; Read the sector
F06:0380         jsr sd_readsector
               S02:0000167F:  20 F9 13
F06:0381       
F06:0382         ; Advance to next sector
F06:0383         inc zp_sd_currentsector
               S02:00001682:  E6 42
F06:0384         bne .sectorincrementdone
               S02:00001684:  D0 0A
F06:0385         inc zp_sd_currentsector+1
               S02:00001686:  E6 43
F06:0386         bne .sectorincrementdone
               S02:00001688:  D0 06
F06:0387         inc zp_sd_currentsector+2
               S02:0000168A:  E6 44
F06:0388         bne .sectorincrementdone
               S02:0000168C:  D0 02
F06:0389         inc zp_sd_currentsector+3
               S02:0000168E:  E6 45
F06:0390       .sectorincrementdone:
F06:0391       
F06:0392         ; Success - clear carry and return
F06:0393         clc
               S02:00001690:  18
F06:0394         rts
               S02:00001691:  60
F06:0395       
F06:0396       .endofchain:
F06:0397         ; End of chain - set carry and return
F06:0398         sec
               S02:00001692:  38
F06:0399         rts
               S02:00001693:  60
F06:0400       
F06:0401       fat32_writenextsector:
F06:0402         ; TODO Writes the next sector into the buffer at fat32_address.
F06:0403         ; 
F06:0404         ; Also looks for new clusters and stores them in the FAT.
F06:0405         ;
F06:0406         ; On return, carry is set if its the end of the chain.
F06:0407       
F06:0408         ; Maybe there are pending sectors in the current cluster
F06:0409         lda fat32_pendingsectors
               S02:00001694:  A5 53
F06:0410         bne .writesector
               S02:00001696:  D0 53
F06:0411       
F06:0412         ; No pending sectors, check if this is the last cluster in the chain
F06:0413         cmp fat32_sectorspercluster
               S02:00001698:  C5 52
F06:0414         bcs .notlastcluster	 ; pendingsectors >= sectorspercluster?
               S02:0000169A:  B0 11
F06:0415       
F06:0416         ; It is the last one.
F06:0417       
F06:0418       .lastcluster
F06:0419       
F06:0420         ; Write 0x0FFFFFFF (EOC)
F06:0421         lda #$0f
               S02:0000169C:  A9 0F
F06:0422         sta (zp_sd_address),y
               S02:0000169E:  91 40
F06:0423         dey
               S02:000016A0:  88
F06:0424         lda #$ff
               S02:000016A1:  A9 FF
F06:0425         sta (zp_sd_address),y
               S02:000016A3:  91 40
F06:0426         dey
               S02:000016A5:  88
F06:0427         sta (zp_sd_address),y
               S02:000016A6:  91 40
F06:0428         dey
               S02:000016A8:  88
F06:0429         sta (zp_sd_address),y
               S02:000016A9:  91 40
F06:0430         
F06:0431         ; End of chain - set carry and return
F06:0432         sec
               S02:000016AB:  38
F06:0433         rts
               S02:000016AC:  60
F06:0434       
F06:0435       .notlastcluster
F06:0436         ; Wait! Are there enough sectors left to fit exactly in one cluster?
F06:0437         bne .lastcluster
               S02:000016AD:  D0 ED
F06:0438       
F06:0439         ; Find the next one
F06:0440         jsr fat32_findnextfreecluster
               S02:000016AF:  20 11 18
F06:0441       
F06:0442         ; go back the previous one
F06:0443         lda fat32_lastcluster
               S02:000016B2:  A5 64
F06:0444         sta fat32_nextcluster
               S02:000016B4:  85 56
F06:0445         lda fat32_lastcluster+1
               S02:000016B6:  A5 65
F06:0446         sta fat32_nextcluster+1
               S02:000016B8:  85 57
F06:0447         lda fat32_lastcluster+2
               S02:000016BA:  A5 66
F06:0448         sta fat32_nextcluster+2
               S02:000016BC:  85 58
F06:0449         lda fat32_lastcluster+3
               S02:000016BE:  A5 67
F06:0450         sta fat32_nextcluster+3
               S02:000016C0:  85 59
F06:0451       
F06:0452         jsr fat32_seekcluster
               S02:000016C2:  20 BA 15
F06:0453       
F06:0454         ; Enter the address of the next one here
F06:0455         lda fat32_lastfoundfreecluster+3
               S02:000016C5:  A5 61
F06:0456         sta fat32_lastcluster+3
               S02:000016C7:  85 67
F06:0457         sta (zp_sd_address),y
               S02:000016C9:  91 40
F06:0458         dey
               S02:000016CB:  88
F06:0459         lda fat32_lastfoundfreecluster+2
               S02:000016CC:  A5 60
F06:0460         sta fat32_lastcluster+2
               S02:000016CE:  85 66
F06:0461         sta (zp_sd_address),y
               S02:000016D0:  91 40
F06:0462         dey
               S02:000016D2:  88
F06:0463         lda fat32_lastfoundfreecluster+1
               S02:000016D3:  A5 5F
F06:0464         sta fat32_lastcluster+1
               S02:000016D5:  85 65
F06:0465         sta (zp_sd_address),y
               S02:000016D7:  91 40
F06:0466         dey
               S02:000016D9:  88
F06:0467         lda fat32_lastfoundfreecluster
               S02:000016DA:  A5 5E
F06:0468         sta fat32_lastcluster
               S02:000016DC:  85 64
F06:0469         sta (zp_sd_address),y
               S02:000016DE:  91 40
F06:0470         
F06:0471         ; Target buffer
F06:0472         lda #<fat32_readbuffer
               S02:000016E0:  A9 00
F06:0473         sta zp_sd_address
               S02:000016E2:  85 40
F06:0474         lda #>fat32_readbuffer
               S02:000016E4:  A9 02
F06:0475         sta zp_sd_address+1
               S02:000016E6:  85 41
F06:0476       
F06:0477         ; Write the FAT sector
F06:0478         jsr sd_writesector
               S02:000016E8:  20 57 14
F06:0479       
F06:0480       .writesector:
F06:0481         dec fat32_pendingsectors
               S02:000016EB:  C6 53
F06:0482       
F06:0483         ; Set up target address
F06:0484         lda fat32_address
               S02:000016ED:  A5 54
F06:0485         sta zp_sd_address
               S02:000016EF:  85 40
F06:0486         lda fat32_address+1
               S02:000016F1:  A5 55
F06:0487         sta zp_sd_address+1
               S02:000016F3:  85 41
F06:0488       
F06:0489         ; Write the sector
F06:0490         jsr sd_writesector
               S02:000016F5:  20 57 14
F06:0491       
F06:0492         ; Advance to next sector
F06:0493         inc zp_sd_currentsector
               S02:000016F8:  E6 42
F06:0494         bne .nextsectorincrementdone
               S02:000016FA:  D0 0A
F06:0495         inc zp_sd_currentsector+1
               S02:000016FC:  E6 43
F06:0496         bne .nextsectorincrementdone
               S02:000016FE:  D0 06
F06:0497         inc zp_sd_currentsector+2
               S02:00001700:  E6 44
F06:0498         bne .nextsectorincrementdone
               S02:00001702:  D0 02
F06:0499         inc zp_sd_currentsector+3
               S02:00001704:  E6 45
F06:0500       .nextsectorincrementdone:
F06:0501       
F06:0502         ; Success - clear carry and return
F06:0503         clc
               S02:00001706:  18
F06:0504         rts
               S02:00001707:  60
F06:0505       
F06:0506       
F06:0507       fat32_openroot:
F06:0508         ; Prepare to read the root directory
F06:0509       
F06:0510         lda fat32_rootcluster
               S02:00001708:  A5 4E
F06:0511         sta fat32_nextcluster
               S02:0000170A:  85 56
F06:0512         lda fat32_rootcluster+1
               S02:0000170C:  A5 4F
F06:0513         sta fat32_nextcluster+1
               S02:0000170E:  85 57
F06:0514         lda fat32_rootcluster+2
               S02:00001710:  A5 50
F06:0515         sta fat32_nextcluster+2
               S02:00001712:  85 58
F06:0516         lda fat32_rootcluster+3
               S02:00001714:  A5 51
F06:0517         sta fat32_nextcluster+3
               S02:00001716:  85 59
F06:0518       
F06:0519         jsr fat32_seekcluster
               S02:00001718:  20 BA 15
F06:0520       
F06:0521         ; Set the pointer to a large value so we always read a sector the first time through
F06:0522         lda #$ff
               S02:0000171B:  A9 FF
F06:0523         sta zp_sd_address+1
               S02:0000171D:  85 41
F06:0524       
F06:0525         rts
               S02:0000171F:  60
F06:0526       
F06:0527       fat32_allocatecluster:
F06:0528         ; Allocate a cluster to store a file at.
F06:0529         ; Must be done BEFORE running fat32_opendirent.
F06:0530       
F06:0531         ; Find a free cluster
F06:0532         jsr fat32_findnextfreecluster
               S02:00001720:  20 11 18
F06:0533       
F06:0534         ; Cache the value so we can add the address of the next one later, if any
F06:0535         lda fat32_lastfoundfreecluster
               S02:00001723:  A5 5E
F06:0536         sta fat32_lastcluster
               S02:00001725:  85 64
F06:0537         lda fat32_lastfoundfreecluster+1
               S02:00001727:  A5 5F
F06:0538         sta fat32_lastcluster+1
               S02:00001729:  85 65
F06:0539         lda fat32_lastfoundfreecluster+2
               S02:0000172B:  A5 60
F06:0540         sta fat32_lastcluster+2
               S02:0000172D:  85 66
F06:0541         lda fat32_lastfoundfreecluster+3
               S02:0000172F:  A5 61
F06:0542         sta fat32_lastcluster+3
               S02:00001731:  85 67
F06:0543       
F06:0544         rts
               S02:00001733:  60
F06:0545       
F06:0546       fat32_opendirent:
F06:0547         ; Prepare to read/write a file or directory based on a dirent
F06:0548         ;
F06:0549         ; Point zp_sd_address at the dirent
F06:0550       
F06:0551         ; Remember file size in bytes remaining
F06:0552         ldy #28
               S02:00001734:  A0 1C
F06:0553         lda (zp_sd_address),y
               S02:00001736:  B1 40
F06:0554         sta fat32_bytesremaining
               S02:00001738:  85 5A
F06:0555         iny
               S02:0000173A:  C8
F06:0556         lda (zp_sd_address),y
               S02:0000173B:  B1 40
F06:0557         sta fat32_bytesremaining+1
               S02:0000173D:  85 5B
F06:0558         iny
               S02:0000173F:  C8
F06:0559         lda (zp_sd_address),y
               S02:00001740:  B1 40
F06:0560         sta fat32_bytesremaining+2
               S02:00001742:  85 5C
F06:0561         iny
               S02:00001744:  C8
F06:0562         lda (zp_sd_address),y
               S02:00001745:  B1 40
F06:0563         sta fat32_bytesremaining+3
               S02:00001747:  85 5D
F06:0564       
F06:0565         ; Seek to first cluster
F06:0566         ldy #26
               S02:00001749:  A0 1A
F06:0567         lda (zp_sd_address),y
               S02:0000174B:  B1 40
F06:0568         sta fat32_nextcluster
               S02:0000174D:  85 56
F06:0569         iny
               S02:0000174F:  C8
F06:0570         lda (zp_sd_address),y
               S02:00001750:  B1 40
F06:0571         sta fat32_nextcluster+1
               S02:00001752:  85 57
F06:0572         ldy #20
               S02:00001754:  A0 14
F06:0573         lda (zp_sd_address),y
               S02:00001756:  B1 40
F06:0574         sta fat32_nextcluster+2
               S02:00001758:  85 58
F06:0575         iny
               S02:0000175A:  C8
F06:0576         lda (zp_sd_address),y
               S02:0000175B:  B1 40
F06:0577         sta fat32_nextcluster+3
               S02:0000175D:  85 59
F06:0578       
F06:0579         jsr fat32_seekcluster
               S02:0000175F:  20 BA 15
F06:0580       
F06:0581         ; Set the pointer to a large value so we always read a sector the first time through
F06:0582         lda #$ff
               S02:00001762:  A9 FF
F06:0583         sta zp_sd_address+1
               S02:00001764:  85 41
F06:0584       
F06:0585         rts
               S02:00001766:  60
F06:0586       
F06:0587       fat32_writedirent:
F06:0588         ; TODO Write a directory entry from the open directory
F06:0589         ; requires:
F06:0590         ;   fat32bytesremaining (2 bytes) = file size in bytes (little endian)
F06:0591         ;   and the processes of:
F06:0592         ;     fat32_finddirent
F06:0593         ;     fat32_findnextfreecluster
F06:0594       
F06:0595         ; Increment pointer by 32 to point to next entry
F06:0596         clc
               S02:00001767:  18
F06:0597         lda zp_sd_address
               S02:00001768:  A5 40
F06:0598         adc #32
               S02:0000176A:  69 20
F06:0599         sta zp_sd_address
               S02:0000176C:  85 40
F06:0600         lda zp_sd_address+1
               S02:0000176E:  A5 41
F06:0601         adc #0
               S02:00001770:  69 00
F06:0602         sta zp_sd_address+1
               S02:00001772:  85 41
F06:0603       
F06:0604         ; If it's not at the end of the buffer, we have data already
F06:0605         cmp #>(fat32_readbuffer+$200)
               S02:00001774:  C9 04
F06:0606         bcc .gotdirrent
               S02:00001776:  90 0F
F06:0607       
F06:0608         ; Read another sector
F06:0609         lda #<fat32_readbuffer
               S02:00001778:  A9 00
F06:0610         sta fat32_address
               S02:0000177A:  85 54
F06:0611         lda #>fat32_readbuffer
               S02:0000177C:  A9 02
F06:0612         sta fat32_address+1
               S02:0000177E:  85 55
F06:0613       
F06:0614         jsr fat32_readnextsector
               S02:00001780:  20 6A 16
F06:0615         bcc .gotdirrent
               S02:00001783:  90 02
F06:0616       
F06:0617       .endofdirectorywrite:
F06:0618         sec
               S02:00001785:  38
F06:0619         rts
               S02:00001786:  60
F06:0620       
F06:0621       .gotdirrent:
F06:0622         ; Check first character
F06:0623         clc
               S02:00001787:  18
F06:0624         ldy #0
               S02:00001788:  A0 00
F06:0625         lda (zp_sd_address),y
               S02:0000178A:  B1 40
F06:0626         bne fat32_writedirent ; go again
               S02:0000178C:  D0 D9
F06:0627         ; End of directory. Now make a new entry.
F06:0628       .dloop:
F06:0629         lda (fat32_filenamepointer),y	; copy filename
               S02:0000178E:  B1 5A
F06:0630         sta (zp_sd_address),y
               S02:00001790:  91 40
F06:0631         iny
               S02:00001792:  C8
F06:0632         cpy #$0b
               S02:00001793:  C0 0B
F06:0633         bne .dloop
               S02:00001795:  D0 F7
F06:0634         ; The full Short filename is #11 bytes long so,
F06:0635         ; this start at 0x0b - File type
F06:0636         lda #$20		; File Type: ARCHIVE
               S02:00001797:  A9 20
F06:0637         sta (zp_sd_address),y
               S02:00001799:  91 40
F06:0638         iny ; 0x0c - Checksum/File accsess password
               S02:0000179B:  C8
F06:0639         lda #$10		            ; No checksum or password
               S02:0000179C:  A9 10
F06:0640         sta (zp_sd_address),y
               S02:0000179E:  91 40
F06:0641         pla	; 0x0d - Previous byte at 0x00
               S02:000017A0:  68
F06:0642         sta (zp_sd_address),y
               S02:000017A1:  91 40
F06:0643         iny	; 0x0e-0x11 - File creation time/date
               S02:000017A3:  C8
F06:0644         lda #0
               S02:000017A4:  A9 00
F06:0645         sta (zp_sd_address),y	; No time/date because I don't have an RTC
               S02:000017A6:  91 40
F06:0646         iny
               S02:000017A8:  C8
F06:0647         sta (zp_sd_address),y
               S02:000017A9:  91 40
F06:0648         iny
               S02:000017AB:  C8
F06:0649         sta (zp_sd_address),y
               S02:000017AC:  91 40
F06:0650         iny
               S02:000017AE:  C8
F06:0651         sta (zp_sd_address),y
               S02:000017AF:  91 40
F06:0652         ; if you have an RTC, refer to https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#File_Allocation_Table 
F06:0653         ; look at "Directory entry" at 0x0E onward on the table.
F06:0654         iny ; 0x12-0x13 - User ID
               S02:000017B1:  C8
F06:0655         lda #0
               S02:000017B2:  A9 00
F06:0656         sta (zp_sd_address),y	; No ID
               S02:000017B4:  91 40
F06:0657         iny
               S02:000017B6:  C8
F06:0658         sta (zp_sd_address),y
               S02:000017B7:  91 40
F06:0659         iny ; 0x14-0x15 - File start cluster (high word)
               S02:000017B9:  C8
F06:0660         lda fat32_lastfoundfreecluster+2
               S02:000017BA:  A5 60
F06:0661         sta (zp_sd_address),y
               S02:000017BC:  91 40
F06:0662         iny
               S02:000017BE:  C8
F06:0663         lda fat32_lastfoundfreecluster+3
               S02:000017BF:  A5 61
F06:0664         sta (zp_sd_address),y
               S02:000017C1:  91 40
F06:0665         iny ; 0x16-0x19 - File modifiaction date
               S02:000017C3:  C8
F06:0666         lda #0
               S02:000017C4:  A9 00
F06:0667         sta (zp_sd_address),y
               S02:000017C6:  91 40
F06:0668         iny
               S02:000017C8:  C8
F06:0669         sta (zp_sd_address),y   ; no rtc aaaaa
               S02:000017C9:  91 40
F06:0670         iny
               S02:000017CB:  C8
F06:0671         sta (zp_sd_address),y
               S02:000017CC:  91 40
F06:0672         iny
               S02:000017CE:  C8
F06:0673         sta (zp_sd_address),y
               S02:000017CF:  91 40
F06:0674         iny ; 0x1a-0x1b - File start cluster (low word)
               S02:000017D1:  C8
F06:0675         lda fat32_lastfoundfreecluster
               S02:000017D2:  A5 5E
F06:0676         sta (zp_sd_address),y
               S02:000017D4:  91 40
F06:0677         iny
               S02:000017D6:  C8
F06:0678         lda fat32_lastfoundfreecluster+1
               S02:000017D7:  A5 5F
F06:0679         sta (zp_sd_address),y
               S02:000017D9:  91 40
F06:0680         iny ; 0x1c-0x1f File size in bytes
               S02:000017DB:  C8
F06:0681         lda fat32_bytesremaining
               S02:000017DC:  A5 5A
F06:0682         sta (zp_sd_address),y
               S02:000017DE:  91 40
F06:0683         iny
               S02:000017E0:  C8
F06:0684         lda fat32_bytesremaining+1
               S02:000017E1:  A5 5B
F06:0685         sta (zp_sd_address),y
               S02:000017E3:  91 40
F06:0686         iny
               S02:000017E5:  C8
F06:0687         lda #0
               S02:000017E6:  A9 00
F06:0688         sta (zp_sd_address),y ; Not bigger that 64k
               S02:000017E8:  91 40
F06:0689         iny
               S02:000017EA:  C8
F06:0690         sta (zp_sd_address),y
               S02:000017EB:  91 40
F06:0691         iny
               S02:000017ED:  C8
F06:0692         ; are we over the buffer?
F06:0693         lda zp_sd_address+1
               S02:000017EE:  A5 41
F06:0694         cmp #>(fat32_readbuffer+$200)
               S02:000017F0:  C9 04
F06:0695         bcc .overbuffer
               S02:000017F2:  90 12
F06:0696         jsr fat32_writenextsector ; if so, write the current sector
               S02:000017F4:  20 94 16
F06:0697         jsr fat32_readnextsector  ; then read the next one.
               S02:000017F7:  20 6A 16
F06:0698         bcs .dfail
               S02:000017FA:  B0 13
F06:0699         ldy #0
               S02:000017FC:  A0 00
F06:0700         lda #<fat32_readbuffer
               S02:000017FE:  A9 00
F06:0701         sta zp_sd_address
               S02:00001800:  85 40
F06:0702         lda #>fat32_readbuffer
               S02:00001802:  A9 02
F06:0703         sta zp_sd_address+1
               S02:00001804:  85 41
F06:0704       .overbuffer:
F06:0705         ; next entry is 0 (end of dir)
F06:0706         lda #0
               S02:00001806:  A9 00
F06:0707         sta (zp_sd_address),y
               S02:00001808:  91 40
F06:0708         jsr fat32_writenextsector ; write all the data...
               S02:0000180A:  20 94 16
F06:0709         clc
               S02:0000180D:  18
F06:0710         rts
               S02:0000180E:  60
F06:0711       
F06:0712       .dfail:
F06:0713         ; Card Full
F06:0714         sec
               S02:0000180F:  38
F06:0715         rts
               S02:00001810:  60
F06:0716       
F06:0717       fat32_findnextfreecluster:
F06:0718       ; Find next free cluster
F06:0719       ; 
F06:0720       ; This program will search the FAT for an empty entry, and
F06:0721       ; save the 32-bit cluster number at fat32_lastfoundfreecluter.
F06:0722       ;
F06:0723       ; Also sets the carry bit if the SD card is full.
F06:0724       ;
F06:0725       ; TODO CHECK FOR BUGS
F06:0726       
F06:0727         ; Find a free cluster and store it's location in fat32_lastfoundfreecluster
F06:0728       
F06:0729         lda #0
               S02:00001811:  A9 00
F06:0730         sta fat32_nextcluster
               S02:00001813:  85 56
F06:0731         sta fat32_lastfoundfreecluster
               S02:00001815:  85 5E
F06:0732         sta fat32_nextcluster+1
               S02:00001817:  85 57
F06:0733         sta fat32_lastfoundfreecluster+1
               S02:00001819:  85 5F
F06:0734         sta fat32_nextcluster+2
               S02:0000181B:  85 58
F06:0735         sta fat32_lastfoundfreecluster+2
               S02:0000181D:  85 60
F06:0736         sta fat32_nextcluster+3
               S02:0000181F:  85 59
F06:0737         sta fat32_lastfoundfreecluster+3
               S02:00001821:  85 61
F06:0738       
F06:0739       .searchclusters
F06:0740       
F06:0741         ; Seek cluster
F06:0742         jsr fat32_seekcluster
               S02:00001823:  20 BA 15
F06:0743       
F06:0744         ; Is the cluster free?
F06:0745         lda fat32_nextcluster
               S02:00001826:  A5 56
F06:0746         and #$0f
               S02:00001828:  29 0F
F06:0747         ora fat32_nextcluster+1
               S02:0000182A:  05 57
F06:0748         ora fat32_nextcluster+2
               S02:0000182C:  05 58
F06:0749         ora fat32_nextcluster+3
               S02:0000182E:  05 59
F06:0750         beq .foundcluster
               S02:00001830:  F0 21
F06:0751       
F06:0752         ; No, increment and loop back
F06:0753         inc fat32_lastfoundfreecluster
               S02:00001832:  E6 5E
F06:0754         bne .searchclusters
               S02:00001834:  D0 ED
F06:0755         inc fat32_lastfoundfreecluster+1
               S02:00001836:  E6 5F
F06:0756         bne .searchclusters
               S02:00001838:  D0 E9
F06:0757         inc fat32_lastfoundfreecluster+2
               S02:0000183A:  E6 60
F06:0758         bne .searchclusters
               S02:0000183C:  D0 E5
F06:0759         inc fat32_lastfoundfreecluster+3
               S02:0000183E:  E6 61
F06:0760         jmp .searchclusters
               S02:00001840:  4C 23 18
F06:0761       
F06:0762         lda fat32_lastfoundfreecluster
               S02:00001843:  A5 5E
F06:0763         sta fat32_nextcluster
               S02:00001845:  85 56
F06:0764         lda fat32_lastfoundfreecluster+1
               S02:00001847:  A5 5F
F06:0765         sta fat32_nextcluster+1
               S02:00001849:  85 57
F06:0766         lda fat32_lastfoundfreecluster+2
               S02:0000184B:  A5 60
F06:0767         sta fat32_nextcluster+2
               S02:0000184D:  85 58
F06:0768         lda fat32_lastfoundfreecluster+3
               S02:0000184F:  A5 61
F06:0769         sta fat32_nextcluster+3
               S02:00001851:  85 59
F06:0770       
F06:0771       .foundcluster
F06:0772         ; done.
F06:0773         rts
               S02:00001853:  60
F06:0774       
F06:0775       fat32_readdirent:
F06:0776         ; Read a directory entry from the open directory
F06:0777         ;
F06:0778         ; On exit the carry is set if there were no more directory entries.
F06:0779         ;
F06:0780         ; Otherwise, A is set to the file's attribute byte and
F06:0781         ; zp_sd_address points at the returned directory entry.
F06:0782         ; LFNs and empty entries are ignored automatically.
F06:0783       
F06:0784         ; Increment pointer by 32 to point to next entry
F06:0785         clc
               S02:00001854:  18
F06:0786         lda zp_sd_address
               S02:00001855:  A5 40
F06:0787         adc #32
               S02:00001857:  69 20
F06:0788         sta zp_sd_address
               S02:00001859:  85 40
F06:0789         lda zp_sd_address+1
               S02:0000185B:  A5 41
F06:0790         adc #0
               S02:0000185D:  69 00
F06:0791         sta zp_sd_address+1
               S02:0000185F:  85 41
F06:0792       
F06:0793         ; If it's not at the end of the buffer, we have data already
F06:0794         cmp #>(fat32_readbuffer+$200)
               S02:00001861:  C9 04
F06:0795         bcc .gotdata
               S02:00001863:  90 0F
F06:0796       
F06:0797         ; Read another sector
F06:0798         lda #<fat32_readbuffer
               S02:00001865:  A9 00
F06:0799         sta fat32_address
               S02:00001867:  85 54
F06:0800         lda #>fat32_readbuffer
               S02:00001869:  A9 02
F06:0801         sta fat32_address+1
               S02:0000186B:  85 55
F06:0802       
F06:0803         jsr fat32_readnextsector
               S02:0000186D:  20 6A 16
F06:0804         bcc .gotdata
               S02:00001870:  90 02
F06:0805       
F06:0806       .endofdirectory:
F06:0807         sec
               S02:00001872:  38
F06:0808         rts
               S02:00001873:  60
F06:0809       
F06:0810       .gotdata:
F06:0811         ; Check first character
F06:0812         ldy #0
               S02:00001874:  A0 00
F06:0813         lda (zp_sd_address),y
               S02:00001876:  B1 40
F06:0814       
F06:0815         ; End of directory => abort
F06:0816         beq .endofdirectory
               S02:00001878:  F0 F8
F06:0817       
F06:0818         ; Empty entry => start again
F06:0819         cmp #$e5
               S02:0000187A:  C9 E5
F06:0820         beq fat32_readdirent
               S02:0000187C:  F0 D6
F06:0821       
F06:0822         ; Check attributes
F06:0823         ldy #11
               S02:0000187E:  A0 0B
F06:0824         lda (zp_sd_address),y
               S02:00001880:  B1 40
F06:0825         and #$3f
               S02:00001882:  29 3F
F06:0826         cmp #$0f ; LFN => start again
               S02:00001884:  C9 0F
F06:0827         beq fat32_readdirent
               S02:00001886:  F0 CC
F06:0828       
F06:0829         ; Yield this result
F06:0830         clc
               S02:00001888:  18
F06:0831         rts
               S02:00001889:  60
F06:0832       
F06:0833       
F06:0834       fat32_finddirent:
F06:0835         ; Finds a particular directory entry. X,Y point to the 11-character filename to seek.
F06:0836         ; The directory should already be open for iteration.
F06:0837       
F06:0838         ; Form ZP pointer to user's filename
F06:0839         stx fat32_filenamepointer
               S02:0000188A:  86 5A
F06:0840         sty fat32_filenamepointer+1
               S02:0000188C:  84 5B
F06:0841         
F06:0842         ; Iterate until name is found or end of directory
F06:0843       .direntloop:
F06:0844         jsr fat32_readdirent
               S02:0000188E:  20 54 18
F06:0845         ldy #10
               S02:00001891:  A0 0A
F06:0846         bcc .comparenameloop
               S02:00001893:  90 01
F06:0847         rts ; with carry set
               S02:00001895:  60
F06:0848       
F06:0849       .comparenameloop:
F06:0850         lda (zp_sd_address),y
               S02:00001896:  B1 40
F06:0851         cmp (fat32_filenamepointer),y
               S02:00001898:  D1 5A
F06:0852         bne .direntloop ; no match
               S02:0000189A:  D0 F2
F06:0853         dey
               S02:0000189C:  88
F06:0854         bpl .comparenameloop
               S02:0000189D:  10 F7
F06:0855       
F06:0856         ; Found it
F06:0857         clc
               S02:0000189F:  18
F06:0858         rts
               S02:000018A0:  60
F06:0859       
F06:0860       
F06:0861       fat32_file_readbyte:
F06:0862         ; Read a byte from an open file
F06:0863         ;
F06:0864         ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
F06:0865       
F06:0866         sec
               S02:000018A1:  38
F06:0867       
F06:0868         ; Is there any data to read at all?
F06:0869         lda fat32_bytesremaining
               S02:000018A2:  A5 5A
F06:0870         ora fat32_bytesremaining+1
               S02:000018A4:  05 5B
F06:0871         ora fat32_bytesremaining+2
               S02:000018A6:  05 5C
F06:0872         ora fat32_bytesremaining+3
               S02:000018A8:  05 5D
F06:0873         beq .rts
               S02:000018AA:  F0 3D
F06:0874       
F06:0875         ; Decrement the remaining byte count
F06:0876         lda fat32_bytesremaining
               S02:000018AC:  A5 5A
F06:0877         sbc #1
               S02:000018AE:  E9 01
F06:0878         sta fat32_bytesremaining
               S02:000018B0:  85 5A
F06:0879         lda fat32_bytesremaining+1
               S02:000018B2:  A5 5B
F06:0880         sbc #0
               S02:000018B4:  E9 00
F06:0881         sta fat32_bytesremaining+1
               S02:000018B6:  85 5B
F06:0882         lda fat32_bytesremaining+2
               S02:000018B8:  A5 5C
F06:0883         sbc #0
               S02:000018BA:  E9 00
F06:0884         sta fat32_bytesremaining+2
               S02:000018BC:  85 5C
F06:0885         lda fat32_bytesremaining+3
               S02:000018BE:  A5 5D
F06:0886         sbc #0
               S02:000018C0:  E9 00
F06:0887         sta fat32_bytesremaining+3
               S02:000018C2:  85 5D
F06:0888         
F06:0889         ; Need to read a new sector?
F06:0890         lda zp_sd_address+1
               S02:000018C4:  A5 41
F06:0891         cmp #>(fat32_readbuffer+$200)
               S02:000018C6:  C9 04
F06:0892         bcc .gotdata
               S02:000018C8:  90 0D
F06:0893       
F06:0894         ; Read another sector
F06:0895         lda #<fat32_readbuffer
               S02:000018CA:  A9 00
F06:0896         sta fat32_address
               S02:000018CC:  85 54
F06:0897         lda #>fat32_readbuffer
               S02:000018CE:  A9 02
F06:0898         sta fat32_address+1
               S02:000018D0:  85 55
F06:0899       
F06:0900         jsr fat32_readnextsector
               S02:000018D2:  20 6A 16
F06:0901         bcs .rts                    ; this shouldn't happen
               S02:000018D5:  B0 12
F06:0902       
F06:0903       .gotdata:
F06:0904         ldy #0
               S02:000018D7:  A0 00
F06:0905         lda (zp_sd_address),y
               S02:000018D9:  B1 40
F06:0906       
F06:0907         inc zp_sd_address
               S02:000018DB:  E6 40
F06:0908         bne .rts
               S02:000018DD:  D0 0A
F06:0909         inc zp_sd_address+1
               S02:000018DF:  E6 41
F06:0910         bne .rts
               S02:000018E1:  D0 06
F06:0911         inc zp_sd_address+2
               S02:000018E3:  E6 42
F06:0912         bne .rts
               S02:000018E5:  D0 02
F06:0913         inc zp_sd_address+3
               S02:000018E7:  E6 43
F06:0914       
F06:0915       .rts:
F06:0916         rts
               S02:000018E9:  60
F06:0917       
F06:0918       
F06:0919       fat32_file_read:
F06:0920         ; Read a whole file into memory.  It's assumed the file has just been opened 
F06:0921         ; and no data has been read yet.
F06:0922         ;
F06:0923         ; Also we read whole sectors, so data in the target region beyond the end of the 
F06:0924         ; file may get overwritten, up to the next 512-byte boundary.
F06:0925         ;
F06:0926         ; And we don't properly support 64k+ files, as it's unnecessary complication given
F06:0927         ; the 6502's small address space
F06:0928       
F06:0929         ; Round the size up to the next whole sector
F06:0930         lda fat32_bytesremaining
               S02:000018EA:  A5 5A
F06:0931         cmp #1                      ; set carry if bottom 8 bits not zero
               S02:000018EC:  C9 01
F06:0932         lda fat32_bytesremaining+1
               S02:000018EE:  A5 5B
F06:0933         adc #0                      ; add carry, if any
               S02:000018F0:  69 00
F06:0934         lsr                         ; divide by 2
               S02:000018F2:  4A
F06:0935         adc #0                      ; round up
               S02:000018F3:  69 00
F06:0936       
F06:0937         ; No data?
F06:0938         beq .done
               S02:000018F5:  F0 12
F06:0939       
F06:0940         ; Store sector count - not a byte count any more
F06:0941         sta fat32_bytesremaining
               S02:000018F7:  85 5A
F06:0942       
F06:0943         ; Read entire sectors to the user-supplied buffer
F06:0944       .wholesectorreadloop:
F06:0945         ; Read a sector to fat32_address
F06:0946         jsr fat32_readnextsector
               S02:000018F9:  20 6A 16
F06:0947       
F06:0948         ; Advance fat32_address by 512 bytes
F06:0949         lda fat32_address+1
               S02:000018FC:  A5 55
F06:0950         adc #2                      ; carry already clear
               S02:000018FE:  69 02
F06:0951         sta fat32_address+1
               S02:00001900:  85 55
F06:0952       
F06:0953         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
               S02:00001902:  A6 5A
F06:0954         dex
               S02:00001904:  CA
F06:0955         stx fat32_bytesremaining    ; note - actually stores sectors remaining
               S02:00001905:  86 5A
F06:0956       
F06:0957         bne .wholesectorreadloop
               S02:00001907:  D0 F0
F06:0958       
F06:0959       .done:
F06:0960         rts
               S02:00001909:  60
F06:0961       
F06:0962       fat32_file_write:
F06:0963         ; Write a whole file from memory.  It's assumed the file has just been opened 
F06:0964         ; and no data has been written yet.
F06:0965         ;
F06:0966         ; Also we write whole sectors, so data in the target region beyond the end of the 
F06:0967         ; file may get overwritten, up to the next 512-byte boundary.
F06:0968         ;
F06:0969         ; And we don't properly support 64k+ files, as it's unnecessary complication given
F06:0970         ; the 6502's small address space
F06:0971       
F06:0972         ; Round the size up to the next whole sector
F06:0973         lda fat32_bytesremaining
               S02:0000190A:  A5 5A
F06:0974         cmp #1                      ; set carry if bottom 8 bits not zero
               S02:0000190C:  C9 01
F06:0975         lda fat32_bytesremaining+1
               S02:0000190E:  A5 5B
F06:0976         adc #0                      ; add carry, if any
               S02:00001910:  69 00
F06:0977         lsr                         ; divide by 2
               S02:00001912:  4A
F06:0978         adc #0                      ; round up
               S02:00001913:  69 00
F06:0979       
F06:0980         ; No data?
F06:0981         beq .done
               S02:00001915:  F0 14
F06:0982       
F06:0983         ; Store sector count - not a byte count any more
F06:0984         sta fat32_bytesremaining
               S02:00001917:  85 5A
F06:0985       
F06:0986         ; Write entire sectors from the user-supplied buffer
F06:0987       .wholesectorwriteloop:
F06:0988         ; Write a sector from fat32_address
F06:0989         jsr fat32_writenextsector
               S02:00001919:  20 94 16
F06:0990         bcs .done	; this shouldn't happen
               S02:0000191C:  B0 0D
F06:0991       
F06:0992         ; Advance fat32_address by 512 bytes
F06:0993         lda fat32_address+1
               S02:0000191E:  A5 55
F06:0994         adc #2                      ; carry already clear
               S02:00001920:  69 02
F06:0995         sta fat32_address+1
               S02:00001922:  85 55
F06:0996       
F06:0997         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
               S02:00001924:  A6 5A
F06:0998         dex
               S02:00001926:  CA
F06:0999         stx fat32_bytesremaining    ; note - actually stores sectors remaining
               S02:00001927:  86 5A
F06:1000       
F06:1001         bne .wholesectorwriteloop
               S02:00001929:  D0 EE
F06:1002       
F06:1003       .done:
F06:1004         rts
               S02:0000192B:  60
F06:1005       
F00:0080       
F00:0081       rootsetup:		; setup <ROOT>
F00:0082       
F00:0083         ; Open root directory
F00:0084         jsr fat32_openroot
               S02:0000192C:  20 08 17
F00:0085       
F00:0086         ; Find the subdirectory by name
F00:0087         ldx #<dirname
               S02:0000192F:  A2 CD
F00:0088         ldy #>dirname
               S02:00001931:  A0 19
F00:0089         jsr fat32_finddirent
               S02:00001933:  20 8A 18
F00:0090         bcc foundsub
               S02:00001936:  90 03
F00:0091       
F00:0092         ; Subdirectory not found
F00:0093         jmp transfer_error
               S02:00001938:  4C 3F 19
F00:0094       
F00:0095       foundsub:
F00:0096       
F00:0097         ; Open subdirectory
F00:0098         jsr fat32_opendirent	; open folder
               S02:0000193B:  20 34 17
F00:0099       	
F00:0100         rts			; done
               S02:0000193E:  60
F00:0101       
F00:0102       transfer_error:
F00:0103         ldy #>errormsg
               S02:0000193F:  A0 19
F00:0104         ldx #<errormsg
               S02:00001941:  A2 D9
F00:0105         jsr w_acia_full
               S02:00001943:  20 C5 12
F00:0106         jsr error_sound
               S02:00001946:  20 2B 0F
F00:0107         jmp doneloop
               S02:00001949:  4C A6 19
F00:0108       
F00:0109       msincremaining:
F00:0110         inc fat32_bytesremaining
               S02:0000194C:  E6 5A
F00:0111         bne msinca
               S02:0000194E:  D0 02
F00:0112         inc fat32_bytesremaining
               S02:00001950:  E6 5A
F00:0113       msinca:
F00:0114         inc XYLODSAV2
               S02:00001952:  E6 64
F00:0115         bne msincb
               S02:00001954:  D0 02
F00:0116         inc XYLODSAV2+1
               S02:00001956:  E6 65
F00:0117       msincb:
F00:0118         rts
               S02:00001958:  60
F00:0119       MEMORY_SAVE:
F00:0120       ; finally. this is what we need to debug.
F00:0121         jsr fat32_allocatecluster
               S02:00001959:  20 20 17
F00:0122         jsr rootsetup
               S02:0000195C:  20 2C 19
F00:0123         jsr fat32_findnextfreecluster
               S02:0000195F:  20 11 18
F00:0124         ldy #>sdbuffer
               S02:00001962:  A0 19
F00:0125         ldx #<sdbuffer
               S02:00001964:  A2 E4
F00:0126         jsr fat32_finddirent
               S02:00001966:  20 8A 18
F00:0127         bcs saveok
               S02:00001969:  B0 05
F00:0128         jsr file_exists
               S02:0000196B:  20 A9 19
F00:0129         bcs doneloop
               S02:0000196E:  B0 36
F00:0130       saveok:
F00:0131       ; Now calculate file size and store it in fat32_bytesremaining.
F00:0132         lda #$00
               S02:00001970:  A9 00
F00:0133         sta XYLODSAV2
               S02:00001972:  85 64
F00:0134         lda #$06
               S02:00001974:  A9 06
F00:0135         sta XYLODSAV2+1
               S02:00001976:  85 65
F00:0136         lda #0
               S02:00001978:  A9 00
F00:0137         sta fat32_bytesremaining
               S02:0000197A:  85 5A
F00:0138         sta fat32_bytesremaining+1
               S02:0000197C:  85 5B
F00:0139         ldy #0
               S02:0000197E:  A0 00
F00:0140       savecalclp:
F00:0141         lda (XYLODSAV2),y
               S02:00001980:  B1 64
F00:0142         beq mszero
               S02:00001982:  F0 06
F00:0143         jsr msincremaining
               S02:00001984:  20 4C 19
F00:0144         jmp savecalclp
               S02:00001987:  4C 80 19
F00:0145       mszero:
F00:0146         ;jsr msincremaining
F00:0147         ;lda (XYLODSAV2),y
F00:0148         ;bne savecalclp
F00:0149         ;jsr msincremaining
F00:0150         ;lda (XYLODSAV2),y
F00:0151         ;bne savecalclp
F00:0152       ; done
F00:0153         jsr fat32_writedirent
               S02:0000198A:  20 67 17
F00:0154         ldx #<savmsg
               S02:0000198D:  A2 27
F00:0155         ldy #>savmsg
               S02:0000198F:  A0 1A
F00:0156         jsr w_acia_full
               S02:00001991:  20 C5 12
F00:0157         lda #$00
               S02:00001994:  A9 00
F00:0158         sta fat32_address
               S02:00001996:  85 54
F00:0159         lda #$06
               S02:00001998:  A9 06
F00:0160         sta fat32_address+1
               S02:0000199A:  85 55
F00:0161         jsr fat32_file_write  ; Yes. It is finally time to save the file.
               S02:0000199C:  20 0A 19
F00:0162         ldx #<SAVE_DONE
               S02:0000199F:  A2 14
F00:0163         ldy #>SAVE_DONE
               S02:000019A1:  A0 1A
F00:0164         jsr w_acia_full
               S02:000019A3:  20 C5 12
F00:0165       doneloop:
F00:0166         ;jmp doneloop
F00:0167         rts
               S02:000019A6:  60
F00:0168         rts
               S02:000019A7:  60
F00:0169         rts
               S02:000019A8:  60
F00:0170       file_exists:
F00:0171         ; clc if 'y'
F00:0172         ; sec if 'n'
F00:0173         ldx #<EXIST_MSG
               S02:000019A9:  A2 EF
F00:0174         ldy #>EXIST_MSG
               S02:000019AB:  A0 19
F00:0175         jsr w_acia_full
               S02:000019AD:  20 C5 12
F00:0176       fexlp:
F00:0177         jsr rxpoll
               S02:000019B0:  20 A9 12
F00:0178         lda ACIAData
               S02:000019B3:  AD 00 80
F00:0179         pha
               S02:000019B6:  48
F00:0180         cmp #'y'
               S02:000019B7:  C9 79
F00:0181         beq exy
               S02:000019B9:  F0 08
F00:0182         cmp #'n'
               S02:000019BB:  C9 6E
F00:0183         beq exn
               S02:000019BD:  F0 09
F00:0184         pla
               S02:000019BF:  68
F00:0185         jmp fexlp
               S02:000019C0:  4C B0 19
F00:0186       exy:
F00:0187         jsr crlf
               S02:000019C3:  20 81 12
F00:0188         clc
               S02:000019C6:  18
F00:0189         rts
               S02:000019C7:  60
F00:0190       exn:
F00:0191         jsr crlf
               S02:000019C8:  20 81 12
F00:0192         sec
               S02:000019CB:  38
F00:0193         rts
               S02:000019CC:  60
F00:0194       
F00:0195       dirname:
F00:0196         .asciiz "FOLDER     "
               S02:000019CD:  46 4F 4C 44 45 52 20 20 20 20 20
F00:0197       errormsg:
F00:0198         .byte CR,LF,"ERROR!",CR,LF
               S02:000019D9:  0D
               S02:000019DA:  0A
               S02:000019DB:  45 52 52 4F 52 21
               S02:000019E1:  0D
               S02:000019E2:  0A
F00:0199         .byte 0
               S02:000019E3:  00
F00:0200       sdbuffer:
F00:0201         .byte "SAVE    BAS" ; save.bas
               S02:000019E4:  53 41 56 45 20 20 20 20 42 41 53
F00:0202       EXIST_MSG:
F00:0203         .byte "File Exists. Overwrite? (y) or (n): ",$00
               S02:000019EF:  46 69 6C 65 20 45 78 69 73 74 73 2E 20 4F 76 65
               S02:000019FF:  72 77 72 69 74 65 3F 20 28 79 29 20 6F 72 20 28
               S02:00001A0F:  00
F00:0204       SAVE_DONE:
F00:0205         .byte	CR,LF,"Save Complete.",CR,LF,$00
               S02:00001A14:  0D
               S02:00001A15:  0A
               S02:00001A16:  53 61 76 65 20 43 6F 6D 70 6C 65 74 65 2E
               S02:00001A24:  0D
               S02:00001A25:  0A
               S02:00001A26:  00
F00:0206       savmsg:
F00:0207         .byte $0d, $0a, "Saving...", $0d, $0a, $00
               S02:00001A27:  0D
               S02:00001A28:  0A
               S02:00001A29:  53 61 76 69 6E 67 2E 2E 2E
               S02:00001A32:  0D
               S02:00001A33:  0A
               S02:00001A34:  00
F00:0208       failedmsg:
F00:0209         .byte "Failed!",CR,LF,$00
               S02:00001A35:  46 61 69 6C 65 64 21
               S02:00001A3C:  0D
               S02:00001A3D:  0A
               S02:00001A3E:  00
F00:0210       


Sections:
S01  segf00
S02  seg1006


Sources:
F00  savetest.s
F01  errors.s
F02  errorsound.s
F03  hwconfig.s
F04  libacia.s
F05  libsd.s
F06  libfat32.s


Symbols:
failedmsg EXPR(6709=0x1a35) UNUSED ABS 
exn EXPR(6600=0x19c8) ABS 
exy EXPR(6595=0x19c3) ABS 
fexlp EXPR(6576=0x19b0) ABS 
EXIST_MSG EXPR(6639=0x19ef) ABS 
SAVE_DONE EXPR(6676=0x1a14) ABS 
savmsg EXPR(6695=0x1a27) ABS 
mszero EXPR(6538=0x198a) ABS 
savecalclp EXPR(6528=0x1980) ABS 
file_exists EXPR(6569=0x19a9) ABS 
saveok EXPR(6512=0x1970) ABS 
sdbuffer EXPR(6628=0x19e4) ABS 
msincb EXPR(6488=0x1958) ABS 
msinca EXPR(6482=0x1952) ABS 
msincremaining EXPR(6476=0x194c) ABS 
errormsg EXPR(6617=0x19d9) ABS 
transfer_error EXPR(6463=0x193f) ABS 
foundsub EXPR(6459=0x193b) ABS 
dirname EXPR(6605=0x19cd) ABS 
rootsetup EXPR(6444=0x192c) ABS 
 fat32_file_write wholesectorwriteloop EXPR(6425=0x1919) ABS 
 fat32_file_write done EXPR(6443=0x192b) ABS 
fat32_file_write EXPR(6410=0x190a) ABS 
 fat32_file_read wholesectorreadloop EXPR(6393=0x18f9) ABS 
 fat32_file_read done EXPR(6409=0x1909) ABS 
fat32_file_read EXPR(6378=0x18ea) UNUSED ABS 
 fat32_file_readbyte gotdata EXPR(6359=0x18d7) ABS 
 fat32_file_readbyte rts EXPR(6377=0x18e9) ABS 
fat32_file_readbyte EXPR(6305=0x18a1) UNUSED ABS 
 fat32_finddirent comparenameloop EXPR(6294=0x1896) ABS 
 fat32_finddirent direntloop EXPR(6286=0x188e) ABS 
fat32_finddirent EXPR(6282=0x188a) ABS 
 fat32_readdirent endofdirectory EXPR(6258=0x1872) ABS 
 fat32_readdirent gotdata EXPR(6260=0x1874) ABS 
fat32_readdirent EXPR(6228=0x1854) ABS 
 fat32_findnextfreecluster foundcluster EXPR(6227=0x1853) ABS 
 fat32_findnextfreecluster searchclusters EXPR(6179=0x1823) ABS 
 fat32_writedirent dfail EXPR(6159=0x180f) ABS 
 fat32_writedirent overbuffer EXPR(6150=0x1806) ABS 
 fat32_writedirent dloop EXPR(6030=0x178e) ABS 
 fat32_writedirent endofdirectorywrite EXPR(6021=0x1785) UNUSED ABS 
 fat32_writedirent gotdirrent EXPR(6023=0x1787) ABS 
fat32_writedirent EXPR(5991=0x1767) ABS 
fat32_opendirent EXPR(5940=0x1734) ABS 
fat32_allocatecluster EXPR(5920=0x1720) ABS 
fat32_openroot EXPR(5896=0x1708) ABS 
 fat32_writenextsector nextsectorincrementdone EXPR(5894=0x1706) ABS 
fat32_findnextfreecluster EXPR(6161=0x1811) ABS 
 fat32_writenextsector lastcluster EXPR(5788=0x169c) ABS 
 fat32_writenextsector notlastcluster EXPR(5805=0x16ad) ABS 
 fat32_writenextsector writesector EXPR(5867=0x16eb) ABS 
fat32_writenextsector EXPR(5780=0x1694) ABS 
 fat32_readnextsector sectorincrementdone EXPR(5776=0x1690) ABS 
 fat32_readnextsector endofchain EXPR(5778=0x1692) ABS 
 fat32_readnextsector readsector EXPR(5749=0x1675) ABS 
fat32_readnextsector EXPR(5738=0x166a) ABS 
 fat32_seekcluster notendofchain EXPR(5737=0x1669) ABS 
 fat32_seekcluster spcshiftloopdone EXPR(5656=0x1618) ABS 
 fat32_seekcluster spcshiftloop EXPR(5642=0x160a) ABS 
fat32_seekcluster EXPR(5562=0x15ba) ABS 
 fat32_init skipfatsloop EXPR(5491=0x1573) ABS 
 fat32_init error EXPR(5560=0x15b8) ABS 
 fat32_init foundpart EXPR(5370=0x14fa) ABS 
 fat32_init FSTYPE_FAT32 EXPR(12=0xc) EQU 
 fat32_init fail EXPR(5367=0x14f7) ABS 
fat32_init EXPR(5288=0x14a8) UNUSED ABS 
fat32_lba EXPR(90=0x5a) UNUSED EQU 
fat32_filenamepointer EXPR(90=0x5a) EQU 
fat32_errorstage EXPR(90=0x5a) EQU 
fat32_lastcluster EXPR(100=0x64) EQU 
fat32_sectorsperfat EXPR(98=0x62) EQU 
fat32_bytesremaining EXPR(90=0x5a) EQU 
fat32_nextcluster EXPR(86=0x56) EQU 
fat32_address EXPR(84=0x54) EQU 
fat32_pendingsectors EXPR(83=0x53) EQU 
fat32_sectorspercluster EXPR(82=0x52) EQU 
fat32_rootcluster EXPR(78=0x4e) EQU 
fat32_datastart EXPR(74=0x4a) EQU 
fat32_fatstart EXPR(70=0x46) EQU 
fat32_readbuffer EXPR(512=0x200) EQU 
 sd_writesector writeloop EXPR(5279=0x149f) ABS 
 sd_writesector writepage EXPR(5277=0x149d) ABS 
 sd_writesector fail EXPR(5275=0x149b) ABS 
sd_writesector EXPR(5207=0x1457) ABS 
 sd_readsector readloop EXPR(5198=0x144e) ABS 
 sd_readsector failloop EXPR(5193=0x1449) ABS 
 sd_readsector readpage EXPR(5196=0x144c) ABS 
 sd_readsector fail EXPR(5178=0x143a) ABS 
sd_readsector EXPR(5113=0x13f9) ABS 
sd_waitresult EXPR(5029=0x13a5) ABS 
 sd_writebyte sendbit EXPR(5016=0x1398) ABS 
 sd_writebyte loop EXPR(5008=0x1390) ABS 
sd_writebyte EXPR(5006=0x138e) ABS 
 sd_readbyte bitnotset EXPR(5000=0x1388) ABS 
 sd_readbyte loop EXPR(4981=0x1375) ABS 
 sd_init loop EXPR(4952=0x1358) ABS 
 sd_init delayloop EXPR(4932=0x1344) ABS 
 sd_init initialized EXPR(4941=0x134d) ABS 
sd_cmd41_bytes EXPR(4973=0x136d) ABS 
 sd_init cmd41 EXPR(4909=0x132d) UNUSED ABS 
sd_cmd55_bytes EXPR(4967=0x1367) ABS 
 sd_init cmd55 EXPR(4894=0x131e) ABS 
sd_readbyte EXPR(4979=0x1373) ABS 
sd_cmd8_bytes EXPR(4961=0x1361) ABS 
 sd_init cmd8 EXPR(4867=0x1303) UNUSED ABS 
 sd_init initfailed EXPR(4947=0x1353) ABS 
sd_sendcommand EXPR(5037=0x13ad) ABS 
sd_cmd0_bytes EXPR(4955=0x135b) ABS 
 sd_init cmd0 EXPR(4852=0x12f4) UNUSED ABS 
 sd_init preinitloop EXPR(4844=0x12ec) ABS 
sd_init EXPR(4840=0x12e8) UNUSED ABS 
endwacia EXPR(4832=0x12e0) ABS 
acia_man EXPR(4818=0x12d2) ABS 
w_acia_full EXPR(4805=0x12c5) ABS 
ascii_home EXPR(4797=0x12bd) UNUSED ABS 
print_char_acia EXPR(4794=0x12ba) UNUSED ABS 
rxpoll EXPR(4777=0x12a9) ABS 
txpoll EXPR(4769=0x12a1) ABS 
cleardisplay EXPR(4758=0x1296) ABS 
crlf EXPR(4737=0x1281) ABS 
cskipletter EXPR(4731=0x127b) ABS 
print_nybble EXPR(4723=0x1273) ABS 
print_hex_acia EXPR(4714=0x126a) ABS 
acia_init EXPR(4701=0x125d) UNUSED ABS 
via_init EXPR(4690=0x1252) UNUSED ABS 
PORTA_OUTPUTPINS EXPR(252=0xfc) EQU 
SD_MISO EXPR(2=0x2) EQU 
SD_MOSI EXPR(4=0x4) EQU 
SD_SCK EXPR(8=0x8) EQU 
SD_CS EXPR(16=0x10) EQU 
LCD_RS EXPR(32=0x20) EQU 
LCD_RW EXPR(64=0x40) EQU 
LCD_E EXPR(128=0x80) EQU 
DDRA EXPR(45059=0xb003) EQU 
DDRB EXPR(45058=0xb002) EQU 
PORTA EXPR(45057=0xb001) EQU 
PORTB EXPR(45056=0xb000) UNUSED EQU 
csid EXPR(4683=0x124b) ABS 
clear_sid EXPR(4681=0x1249) ABS 
InitSid2 EXPR(4355=0x1103) UNUSED ABS 
L10fa EXPR(4346=0x10fa) ABS 
L10ec EXPR(4332=0x10ec) ABS 
L10cc EXPR(4300=0x10cc) ABS 
L10d0 EXPR(4304=0x10d0) ABS 
L10b8 EXPR(4280=0x10b8) ABS 
L10b2 EXPR(4274=0x10b2) ABS 
L1093 EXPR(4243=0x1093) ABS 
L1085 EXPR(4229=0x1085) ABS 
L107b EXPR(4219=0x107b) ABS 
S10a1 EXPR(4257=0x10a1) ABS 
L104a EXPR(4170=0x104a) ABS 
L1060 EXPR(4192=0x1060) ABS 
L106b EXPR(4203=0x106b) ABS 
L1076 EXPR(4214=0x1076) ABS 
L102e EXPR(4142=0x102e) ABS 
L1038 EXPR(4152=0x1038) ABS 
L1033 EXPR(4147=0x1033) ABS 
L1015 EXPR(4117=0x1015) ABS 
L1008 EXPR(4104=0x1008) ABS 
PlaySid EXPR(4102=0x1006) UNUSED ABS 
d412_sVoc3Control EXPR(47122=0xb812) EQU 
d40b_sVoc2Control EXPR(47115=0xb80b) EQU 
d404_sVoc1Control EXPR(47108=0xb804) EQU 
d400_sVoc1FreqLo EXPR(47104=0xb800) EQU 
continue24542 EXPR(3937=0xf61) ABS 
putbut EXPR(3941=0xf65) ABS 
startupsoundloop EXPR(4655=0x122f) ABS 
InitSid EXPR(3958=0xf76) ABS 
irq EXPR(3919=0xf4f) ABS 
runthesound EXPR(3889=0xf31) UNUSED ABS 
error_sound EXPR(3883=0xf2b) ABS 
sd_fail EXPR(3875=0xf23) UNUSED ABS 
doneloop EXPR(6566=0x19a6) ABS 
print_chara EXPR(4785=0x12b1) ABS 
faterror EXPR(3867=0xf1b) UNUSED ABS 
MEMORY_SAVE EXPR(6489=0x1959) ABS 
dummyloop EXPR(3852=0xf0c) ABS 
initdone EXPR(3850=0xf0a) UNUSED ABS 
fat32_lastfoundfreecluster EXPR(94=0x5e) EQU 
reset EXPR(3840=0xf00) UNUSED ABS 
LF EXPR(10=0xa) EQU 
CR EXPR(13=0xd) EQU 
XYLODSAV2 EXPR(100=0x64) EQU 
zp_fat32_variables EXPR(70=0x46) EQU 
zp_sd_currentsector EXPR(66=0x42) EQU 
zp_sd_address EXPR(64=0x40) EQU 
donefact EXPR(1=0x1) EQU 
irqcount EXPR(0=0x0) EQU 
endbuf EXPR(1536=0x600) UNUSED EQU 
buffer EXPR(1024=0x400) UNUSED EQU 
fat32_workspace EXPR(512=0x200) EQU 
ACIAData EXPR(32768=0x8000) EQU 
ACIAStatus EXPR(32769=0x8001) UNUSED EQU 
ACIACommand EXPR(32770=0x8002) UNUSED EQU 
ACIAControl EXPR(32771=0x8003) UNUSED EQU 
ACIA EXPR(32768=0x8000) EQU 
__RPTCNT EXPR(-1=0xffff) INTERNAL 
__VASM EXPR(0=0x0) INTERNAL 

There have been no errors.
