thing = $00
odd   = $01
buf   = $02
eorr  = $03

  .org $0f00

start:
  jsr via_init		; init VIA
  lda #0
  sta $b00e
  ldx #0
datlop:
  txa
  sta dat,x		; store data that counts
  inx
  bne datlop

  ldx #<msg
  ldy #>msg		; press rec and play
  jsr w_acia_full

check:
  jsr rxpoll
  lda $8000		; space?
  sec
  sbc #$20
  bne check
  
  jsr inout		; intro sound

  jsr zero
  jsr one

  ldy #1
  sty thing		; first bit
wop:
  lda dat,x		; load data
  and thing		; mask it
  bne jsrone		; one
  jsr zero		; or zero
oner:
  lda thing		; load the bitmask
  sec
  sbc #$80		; end of byte?
  beq noo
  asl thing		; no, bitshift left
  jmp wop		; next bit
jsrone:
  jsr one		; a one
  jmp oner
noo:
  lda #1		; byte done
  sta thing
  jsr zero		; end prev. byte, start new byte
  jsr one
  inx			; next byte
  bne wop

  jsr inout		; we are done, ending sound  

  ; done
  ldx #<msg2
  ldy #>msg2		; "Done!"
  jsr w_acia_full
  rts
  rts
  rts			; return
  rts
  rts



; subs

inout:
  pha
  phx
  stz PORTA
  ldx #50		; ff-50 times make the sound
starter:
  jsr one		; sound
  inx
  bne starter
  plx
  pla
  rts

one:			; 2349 hz sound 8x (aprox. 3.33ms)
  pha
  phx
  lda #$55		; asl thing
  sta odd
  lda #0
  sta PORTA		; 0
  ldx #8		; cycle 8 times
loop1:
  stz $b00b
  lda #$a7
  sta $b004		; freq
  lda #$01
  sta $b005
intro:
  bit $b00d		; delay complete?
  bvc intro
  lda odd
  sec
  sbc #$55		; odd?
  bne decer		; if so, 0 in PA
  lda #1		; if even, 1 in PA
  sta PORTA
  asl odd		; shift odd
  jmp loop1
decer:
  stz PORTA
  asl odd		; shift even
  dex			; a cycle is done
  bne loop1
  plx
  pla
  rts

zero:
  pha 
  phx
  lda #$55
  sta odd
  lda #0
  sta PORTA
  ldx #4
loop2:
  stz $b00b
  lda #$50
  sta $b004
  lda #$03
  sta $b005
intro2:
  bit $b00d
  bvc intro2

  lda odd
  sec
  sbc #$55
  bne decer2
  lda #1
  sta PORTA
  asl odd
  jmp loop2
decer2:
  stz PORTA
  asl odd
  dex
  bne loop2
  plx
  pla
  rts


  .include "hwtape.s"
  .include "libacia.s"
msg:
  .byte "Pres Record And play on Tape, then Press Space.", $0d, $0a, $00
msg2:
  .byte "Done!", $0d, $0a, $00
dat:
  .byte $00

  .org $1200

clear:
  ldx #0
clearlop:
  stz dat,x
  dex
  bne clearlop
  ldx #<clearmsg
  ldy #>clearmsg
  jsr w_acia_full
  rts
  rts
  rts
  rts

clearmsg:
  .byte "Cleared!", $0d, $0a, $00

  .org $1300

load:
  stz DDRA
  jsr wait1
  jsr wait0		; header
  jsr wait1
  jsr readbits 
  sta dat
  ldx #1
loadloop
  jsr wait0
  jsr 3cyc
  jsr wait1
  jsr 7cyc
  jsr readbits
  sta dat,x
  inx
  bne loadloop
  

darn:
  rts
  rts
  rts
  rts
; subs

irqsetup1:
  stz $b00b
  lda #$b0	; a little more for good measure
  sta $b004
  lda #$01
  sta $b005
  rts

wait1:
  pha
  phx
  phy
h:
  lda PORTA
  beq h
  jsr irqsetup1
isit:
  bit $b00d
  bvc isit
qq1:
  lda PORTA
  bne h
  jsr irqsetup1			; it is the right freq..?
itss:
  bit $b00d
  bvc itss
  lda PORTA
  beq qq1
  sec
  ply
  plx
  pla
  rts				; it is.

huh:
  jmp $c000

irqsetup0:
  stz $b00b
  lda #$60	; a little more for good measure
  sta $b004
  lda #$03
  sta $b005
  rts

wait0:
  pha
  phx
  phy
h0:
  lda PORTA
  beq h0
  jsr irqsetup0
isit0:
  bit $b00d
  bvc isit0
qq:
  lda PORTA
  bne h0
  jsr irqsetup0 		; it is the right freq..?
itss0:
  bit $b00d
  bvc itss0
  lda PORTA
  beq qq
  ply
  plx
  pla
  rts				; it is.

read:
  pha
  phx
  phy
hr:
  lda PORTA
  beq hr
  jsr irqsetup1
isitr:
  bit $b00d
  bvc isitr
  lda PORTA
  bne notiq
  jsr irqsetup1			; it is the right freq..?
itssr:
  bit $b00d
  bvc itssr
  lda PORTA
  beq notiq
  sec
  ply
  plx
  pla
  rts				; it is.
notiq:
  clc
  ply
  plx 
  pla
  rts

readbits:
  phx
  phy
  stz buf
  lda #$fe
  sta thing
ag:
  jsr read
  bcs itsa1
itsa0:
  lda buf
  and thing
  sta buf
  jsr 3cyc
  jmp nxt
itsa1:
  lda thing
  eor #$ff
  sta eorr
  lda buf
  ora eorr
  sta buf
  jsr 7cyc
nxt:
  asl thing
  lda thing
  sec
  sbc #$7f
  bne ag
  ply
  plx
  rts

3cyc:
  jsr wait1
  jsr wait1
  jsr wait1
  rts

7cyc:
  jsr wait1os
  jsr wait1
  jsr wait1
  jsr wait1
  jsr wait1
  jsr wait1
  jsr wait1  
  rts
