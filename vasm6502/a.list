F00:0001       done = $00
F00:0002       sample = $01
F00:0003       flag = $02
F00:0004       zp_sd_address = $40         ; 2 bytes
F00:0005       zp_sd_currentsector = $42   ; 4 bytes
F00:0006       zp_fat32_variables = $46    ; 32 bytes
F00:0007       
F00:0008       bytepointer = $66	    ; 4 bytes
F00:0009       
F00:0010       buffer = $400               ; 512 bytes
F00:0011       endbuf = $600
F00:0012       
F00:0013       SID = $b800
F00:0014       
F00:0015       flagSeed = $55           ; flag seed, 8kHz
F00:0016       freq     = $80           ; CIA NMI timer delay, 8kHz
F00:0017       ;flagSeed = $00          ; flag seed, 4Hz
F00:0018       ;freq    = $100          ; CIA NMI timer delay, 4kHz
F00:0019       
F00:0020       	.org $0f00
F00:0021       darn
F00:0022       	jmp ebutrocks
               S01:00000F00:  4C 89 11
F00:0023       
F00:0024       ;datname:
F00:0025       ;  .asciiz "FASTCMC RAW"  ; music file on SD card
F00:0026       ;dirname:
F00:0027       ;  .asciiz "FOLDER     "  ; folder
F00:0028       
F00:0029       	.org $1000
F00:0030       
F00:0031       	.include "hwconfig.s"
F01:0001       PORTB = $b000
F01:0002       PORTA = $b001
F01:0003       DDRB = $b002
F01:0004       DDRA = $b003
F01:0005       
F01:0006       LCD_E  = %10000000
F01:0007       LCD_RW = %01000000
F01:0008       LCD_RS = %00100000
F01:0009       
F01:0010       SD_CS   = %00010000
F01:0011       SD_SCK  = %00001000
F01:0012       SD_MOSI = %00000100
F01:0013       SD_MISO = %00000010
F01:0014       
F01:0015       PORTA_OUTPUTPINS = LCD_E | LCD_RW | LCD_RS | SD_CS | SD_SCK | SD_MOSI
F01:0016       
F01:0017       via_init:
F01:0018         lda #%11111111          ; Set all pins on port B to output
               S02:00001000:  A9 FF
F01:0019         sta DDRB
               S02:00001002:  8D 02 B0
F01:0020         lda #PORTA_OUTPUTPINS   ; Set various pins on port A to output
               S02:00001005:  A9 FC
F01:0021         sta DDRA
               S02:00001007:  8D 03 B0
F01:0022         rts
               S02:0000100A:  60
F01:0023       
F01:0024       
F00:0032       	.include "libsd.s" ; ah ye sd tim
F02:0001       ; SD card interface module
F02:0002       ;
F02:0003       ; Requires zero-page variable storage:
F02:0004       ;   zp_sd_address - 2 bytes
F02:0005       ;   zp_sd_currentsector - 4 bytes
F02:0006       
F02:0007       cmsg:
F02:0008         .byte "Command: ", $00
               S02:0000100B:  43 6F 6D 6D 61 6E 64 3A 20
               S02:00001014:  00
F02:0009       
F02:0010       sd_init:
F02:0011         ; Let the SD card boot up, by pumping the clock with SD CS disabled
F02:0012       
F02:0013         ; We need to apply around 80 clock pulses with CS and MOSI high.
F02:0014         ; Normally MOSI doesn't matter when CS is high, but the card is
F02:0015         ; not yet is SPI mode, and in this non-SPI state it does care.
F02:0016       
F02:0017         lda #SD_CS | SD_MOSI
               S02:00001015:  A9 14
F02:0018         ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
               S02:00001017:  A2 A0
F02:0019       .preinitloop:
F02:0020         eor #SD_SCK
               S02:00001019:  49 08
F02:0021         sta PORTA
               S02:0000101B:  8D 01 B0
F02:0022         dex
               S02:0000101E:  CA
F02:0023         bne .preinitloop
               S02:0000101F:  D0 F8
F02:0024         
F02:0025       
F02:0026       .cmd0 ; GO_IDLE_STATE - resets card to idle state, and SPI mode
F02:0027         lda #<sd_cmd0_bytes
               S02:00001021:  A9 79
F02:0028         sta zp_sd_address
               S02:00001023:  85 40
F02:0029         lda #>sd_cmd0_bytes
               S02:00001025:  A9 10
F02:0030         sta zp_sd_address+1
               S02:00001027:  85 41
F02:0031       
F02:0032         jsr sd_sendcommand
               S02:00001029:  20 CB 10
F02:0033       
F02:0034         ; Expect status response $01 (not initialized)
F02:0035        ; cmp #$01
F02:0036        ; bne .initfailed
F02:0037       
F02:0038       .cmd8 ; SEND_IF_COND - tell the card how we want it to operate (3.3V, etc)
F02:0039         lda #<sd_cmd8_bytes
               S02:0000102C:  A9 7F
F02:0040         sta zp_sd_address
               S02:0000102E:  85 40
F02:0041         lda #>sd_cmd8_bytes
               S02:00001030:  A9 10
F02:0042         sta zp_sd_address+1
               S02:00001032:  85 41
F02:0043       
F02:0044         jsr sd_sendcommand ; BUG location in teraterm.log
               S02:00001034:  20 CB 10
F02:0045       
F02:0046         ; Expect status response $01 (not initialized)
F02:0047         cmp #$01
               S02:00001037:  C9 01
F02:0048         bne .initfailed
               S02:00001039:  D0 3B
F02:0049       
F02:0050         ; Read 32-bit return value, but ignore it
F02:0051         jsr sd_readbyte
               S02:0000103B:  20 91 10
F02:0052         jsr sd_readbyte
               S02:0000103E:  20 91 10
F02:0053         jsr sd_readbyte
               S02:00001041:  20 91 10
F02:0054         jsr sd_readbyte
               S02:00001044:  20 91 10
F02:0055       
F02:0056       .cmd55 ; APP_CMD - required prefix for ACMD commands
F02:0057         lda #<sd_cmd55_bytes
               S02:00001047:  A9 85
F02:0058         sta zp_sd_address
               S02:00001049:  85 40
F02:0059         lda #>sd_cmd55_bytes
               S02:0000104B:  A9 10
F02:0060         sta zp_sd_address+1
               S02:0000104D:  85 41
F02:0061       
F02:0062         jsr sd_sendcommand
               S02:0000104F:  20 CB 10
F02:0063       
F02:0064         ; Expect status response $01 (not initialized)
F02:0065         cmp #$01
               S02:00001052:  C9 01
F02:0066         bne .initfailed
               S02:00001054:  D0 20
F02:0067       
F02:0068       .cmd41 ; APP_SEND_OP_COND - send operating conditions, initialize card
F02:0069         lda #<sd_cmd41_bytes
               S02:00001056:  A9 8B
F02:0070         sta zp_sd_address
               S02:00001058:  85 40
F02:0071         lda #>sd_cmd41_bytes
               S02:0000105A:  A9 10
F02:0072         sta zp_sd_address+1
               S02:0000105C:  85 41
F02:0073       
F02:0074         jsr sd_sendcommand
               S02:0000105E:  20 CB 10
F02:0075       
F02:0076         ; Status response $00 means initialised
F02:0077         cmp #$00
               S02:00001061:  C9 00
F02:0078         beq .initialized
               S02:00001063:  F0 11
F02:0079       
F02:0080         ; Otherwise expect status response $01 (not initialized)
F02:0081         cmp #$01
               S02:00001065:  C9 01
F02:0082         bne .initfailed
               S02:00001067:  D0 0D
F02:0083       
F02:0084         ; Not initialized yet, so wait a while then try again.
F02:0085         ; This retry is important, to give the card time to initialize.
F02:0086       
F02:0087         ldx #0
               S02:00001069:  A2 00
F02:0088         ldy #0
               S02:0000106B:  A0 00
F02:0089       .delayloop
F02:0090         dey
               S02:0000106D:  88
F02:0091         bne .delayloop
               S02:0000106E:  D0 FD
F02:0092         dex
               S02:00001070:  CA
F02:0093         bne .delayloop
               S02:00001071:  D0 FA
F02:0094       
F02:0095         jmp .cmd55
               S02:00001073:  4C 47 10
F02:0096       
F02:0097       
F02:0098       .initialized
F02:0099       ;  ldy #>initmsg
F02:0100       ;  ldx #<initmsg
F02:0101       ;  jsr w_acia_full
F02:0102       ;  rts
F02:0103       
F02:0104       .initfailed
F02:0105       ;  ldy #>initfailedmsg
F02:0106       ;  ldx #<initfailedmsg
F02:0107       ;  jsr w_acia_full
F02:0108       .loop
F02:0109         jmp .loop
               S02:00001076:  4C 76 10
F02:0110       
F02:0111       
F02:0112       sd_cmd0_bytes
F02:0113         .byte $40, $00, $00, $00, $00, $95
               S02:00001079:  40
               S02:0000107A:  00
               S02:0000107B:  00
               S02:0000107C:  00
               S02:0000107D:  00
               S02:0000107E:  95
F02:0114       sd_cmd8_bytes
F02:0115         .byte $48, $00, $00, $01, $aa, $87
               S02:0000107F:  48
               S02:00001080:  00
               S02:00001081:  00
               S02:00001082:  01
               S02:00001083:  AA
               S02:00001084:  87
F02:0116       sd_cmd55_bytes
F02:0117         .byte $77, $00, $00, $00, $00, $01
               S02:00001085:  77
               S02:00001086:  00
               S02:00001087:  00
               S02:00001088:  00
               S02:00001089:  00
               S02:0000108A:  01
F02:0118       sd_cmd41_bytes
F02:0119         .byte $69, $40, $00, $00, $00, $01
               S02:0000108B:  69
               S02:0000108C:  40
               S02:0000108D:  00
               S02:0000108E:  00
               S02:0000108F:  00
               S02:00001090:  01
F02:0120       
F02:0121       
F02:0122       
F02:0123       sd_readbyte:
F02:0124         ; Enable the card and tick the clock 8 times with MOSI high, 
F02:0125         ; capturing bits from MISO and returning them
F02:0126       
F02:0127         ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
               S02:00001091:  A2 FE
F02:0128       
F02:0129       .loop:
F02:0130       
F02:0131         lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
               S02:00001093:  A9 04
F02:0132         sta PORTA
               S02:00001095:  8D 01 B0
F02:0133       
F02:0134         lda #SD_MOSI | SD_SCK       ; toggle the clock high
               S02:00001098:  A9 0C
F02:0135         sta PORTA
               S02:0000109A:  8D 01 B0
F02:0136       
F02:0137         lda PORTA                   ; read next bit
               S02:0000109D:  AD 01 B0
F02:0138         and #SD_MISO
               S02:000010A0:  29 02
F02:0139       
F02:0140         clc                         ; default to clearing the bottom bit
               S02:000010A2:  18
F02:0141         beq .bitnotset              ; unless MISO was set
               S02:000010A3:  F0 01
F02:0142         sec                         ; in which case get ready to set the bottom bit
               S02:000010A5:  38
F02:0143       .bitnotset:
F02:0144       
F02:0145         txa                         ; transfer partial result from X
               S02:000010A6:  8A
F02:0146         rol                         ; rotate carry bit into read result, and loop bit into carry
               S02:000010A7:  2A
F02:0147         tax                         ; save partial result back to X
               S02:000010A8:  AA
F02:0148         
F02:0149         bcs .loop                   ; loop if we need to read more bits
               S02:000010A9:  B0 E8
F02:0150       
F02:0151         rts
               S02:000010AB:  60
F02:0152       
F02:0153       
F02:0154       sd_writebyte:
F02:0155         ; Tick the clock 8 times with descending bits on MOSI
F02:0156         ; SD communication is mostly half-duplex so we ignore anything it sends back here
F02:0157       
F02:0158         ldx #8                      ; send 8 bits
               S02:000010AC:  A2 08
F02:0159       
F02:0160       .loop:
F02:0161         asl                         ; shift next bit into carry
               S02:000010AE:  0A
F02:0162         tay                         ; save remaining bits for later
               S02:000010AF:  A8
F02:0163       
F02:0164         lda #0
               S02:000010B0:  A9 00
F02:0165         bcc .sendbit                ; if carry clear, don't set MOSI for this bit
               S02:000010B2:  90 02
F02:0166         ora #SD_MOSI
               S02:000010B4:  09 04
F02:0167       
F02:0168       .sendbit:
F02:0169         sta PORTA                   ; set MOSI (or not) first with SCK low
               S02:000010B6:  8D 01 B0
F02:0170         eor #SD_SCK
               S02:000010B9:  49 08
F02:0171         sta PORTA                   ; raise SCK keeping MOSI the same, to send the bit
               S02:000010BB:  8D 01 B0
F02:0172       
F02:0173         tya                         ; restore remaining bits to send
               S02:000010BE:  98
F02:0174       
F02:0175         dex
               S02:000010BF:  CA
F02:0176         bne .loop                   ; loop if there are more bits to send
               S02:000010C0:  D0 EC
F02:0177       
F02:0178         rts
               S02:000010C2:  60
F02:0179       
F02:0180       
F02:0181       sd_waitresult:
F02:0182         ; Wait for the SD card to return something other than $ff
F02:0183         jsr sd_readbyte
               S02:000010C3:  20 91 10
F02:0184         cmp #$ff
               S02:000010C6:  C9 FF
F02:0185         beq sd_waitresult
               S02:000010C8:  F0 F9
F02:0186         rts
               S02:000010CA:  60
F02:0187       
F02:0188       
F02:0189       sd_sendcommand:
F02:0190         ; Debug print which command is being executed
F02:0191        ; jsr lcd_cleardisplay
F02:0192        ; jsr cleardisplay
F02:0193       
F02:0194       ;  phx
F02:0195       ;  phy
F02:0196       ;  ldx #<cmsg
F02:0197       ;  ldy #>cmsg
F02:0198       ;  jsr w_acia_full
F02:0199       ;  ply
F02:0200       ;  plx
F02:0201       
F02:0202       ;  ldx #0
F02:0203       ;  lda (zp_sd_address,x)
F02:0204       ;  jsr print_hex_acia
F02:0205       
F02:0206       ;  lda #$20
F02:0207       ;  jsr print_chara
F02:0208       ;  
F02:0209       ;  lda #$20
F02:0210       ;  jsr print_chara
F02:0211       
F02:0212         lda #SD_MOSI           ; pull CS low to begin command
               S02:000010CB:  A9 04
F02:0213         sta PORTA
               S02:000010CD:  8D 01 B0
F02:0214       
F02:0215         ldy #0
               S02:000010D0:  A0 00
F02:0216         lda (zp_sd_address),y    ; command byte
               S02:000010D2:  B1 40
F02:0217         jsr sd_writebyte
               S02:000010D4:  20 AC 10
F02:0218         ldy #1
               S02:000010D7:  A0 01
F02:0219         lda (zp_sd_address),y    ; data 1
               S02:000010D9:  B1 40
F02:0220         jsr sd_writebyte
               S02:000010DB:  20 AC 10
F02:0221         ldy #2
               S02:000010DE:  A0 02
F02:0222         lda (zp_sd_address),y    ; data 2
               S02:000010E0:  B1 40
F02:0223         jsr sd_writebyte
               S02:000010E2:  20 AC 10
F02:0224         ldy #3
               S02:000010E5:  A0 03
F02:0225         lda (zp_sd_address),y    ; data 3
               S02:000010E7:  B1 40
F02:0226         jsr sd_writebyte
               S02:000010E9:  20 AC 10
F02:0227         ldy #4
               S02:000010EC:  A0 04
F02:0228         lda (zp_sd_address),y    ; data 4
               S02:000010EE:  B1 40
F02:0229         jsr sd_writebyte
               S02:000010F0:  20 AC 10
F02:0230         ldy #5
               S02:000010F3:  A0 05
F02:0231         lda (zp_sd_address),y    ; crc
               S02:000010F5:  B1 40
F02:0232         jsr sd_writebyte
               S02:000010F7:  20 AC 10
F02:0233       
F02:0234         jsr sd_waitresult
               S02:000010FA:  20 C3 10
F02:0235         pha
               S02:000010FD:  48
F02:0236       
F02:0237       ;  phy
F02:0238       ;  phx
F02:0239       ;  ldy #>respmsg
F02:0240       ;  ldx #<respmsg
F02:0241       ;  jsr w_acia_full
F02:0242       ;  ply
F02:0243       ;  plx
F02:0244       
F02:0245         ; Debug print the result code
F02:0246       ;  jsr print_hex_acia
F02:0247       
F02:0248       ;  lda #$0d
F02:0249       ;  jsr print_chara
F02:0250       ;  
F02:0251       ;  lda #$0a
F02:0252       ;  jsr print_chara
F02:0253       
F02:0254         ; End command
F02:0255         lda #SD_CS | SD_MOSI   ; set CS high again
               S02:000010FE:  A9 14
F02:0256         sta PORTA
               S02:00001100:  8D 01 B0
F02:0257       
F02:0258         pla   ; restore result code
               S02:00001103:  68
F02:0259         rts
               S02:00001104:  60
F02:0260       
F02:0261       
F02:0262       sd_readsector:
F02:0263         ; Read a sector from the SD card.  A sector is 512 bytes.
F02:0264         ;
F02:0265         ; Parameters:
F02:0266         ;    zp_sd_currentsector   32-bit sector number
F02:0267         ;    zp_sd_address     address of buffer to receive data
F02:0268         
F02:0269         lda #SD_MOSI
               S02:00001105:  A9 04
F02:0270         sta PORTA
               S02:00001107:  8D 01 B0
F02:0271       
F02:0272         ; Command 17, arg is sector number, crc not checked
F02:0273         lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S02:0000110A:  A9 51
F02:0274         jsr sd_writebyte
               S02:0000110C:  20 AC 10
F02:0275         lda zp_sd_currentsector+3   ; sector 24:31
               S02:0000110F:  A5 45
F02:0276         jsr sd_writebyte
               S02:00001111:  20 AC 10
F02:0277         lda zp_sd_currentsector+2   ; sector 16:23
               S02:00001114:  A5 44
F02:0278         jsr sd_writebyte
               S02:00001116:  20 AC 10
F02:0279         lda zp_sd_currentsector+1   ; sector 8:15
               S02:00001119:  A5 43
F02:0280         jsr sd_writebyte
               S02:0000111B:  20 AC 10
F02:0281         lda zp_sd_currentsector     ; sector 0:7
               S02:0000111E:  A5 42
F02:0282         jsr sd_writebyte
               S02:00001120:  20 AC 10
F02:0283         lda #$01                    ; crc (not checked)
               S02:00001123:  A9 01
F02:0284         jsr sd_writebyte
               S02:00001125:  20 AC 10
F02:0285       
F02:0286         jsr sd_waitresult
               S02:00001128:  20 C3 10
F02:0287         cmp #$00
               S02:0000112B:  C9 00
F02:0288         bne .fail
               S02:0000112D:  D0 17
F02:0289       
F02:0290         ; wait for data
F02:0291         jsr sd_waitresult
               S02:0000112F:  20 C3 10
F02:0292         cmp #$fe
               S02:00001132:  C9 FE
F02:0293         bne .fail
               S02:00001134:  D0 10
F02:0294       
F02:0295         ; Need to read 512 bytes - two pages of 256 bytes each
F02:0296         jsr .readpage
               S02:00001136:  20 49 11
F02:0297         inc zp_sd_address+1
               S02:00001139:  E6 41
F02:0298         jsr .readpage
               S02:0000113B:  20 49 11
F02:0299         dec zp_sd_address+1
               S02:0000113E:  C6 41
F02:0300       
F02:0301         ; End command
F02:0302         lda #SD_CS | SD_MOSI
               S02:00001140:  A9 14
F02:0303         sta PORTA
               S02:00001142:  8D 01 B0
F02:0304       
F02:0305         rts
               S02:00001145:  60
F02:0306       
F02:0307       
F02:0308       .fail
F02:0309       ;  ldx #<statusmsg
F02:0310       ;  ldy #>statusmsg  ; Status:
F02:0311       ;  jsr w_acia_full
F02:0312       
F02:0313       ;  ldx #<failedmsg
F02:0314       ;  ldy #>failedmsg  ; Failed!
F02:0315       ;  jsr w_acia_full
F02:0316       .failloop
F02:0317         jmp .failloop
               S02:00001146:  4C 46 11
F02:0318       
F02:0319       
F02:0320       .readpage
F02:0321         ; Read 256 bytes to the address at zp_sd_address
F02:0322         ldy #0
               S02:00001149:  A0 00
F02:0323       .readloop
F02:0324         jsr sd_readbyte
               S02:0000114B:  20 91 10
F02:0325         sta (zp_sd_address),y
               S02:0000114E:  91 40
F02:0326         iny
               S02:00001150:  C8
F02:0327         bne .readloop
               S02:00001151:  D0 F8
F02:0328         rts
               S02:00001153:  60
F02:0329       
F02:0330       statusmsg:
F02:0331         .byte "Status: ", $00
               S02:00001154:  53 74 61 74 75 73 3A 20
               S02:0000115C:  00
F02:0332       initfailedmsg:
F02:0333         .byte "Init "
               S02:0000115D:  49 6E 69 74 20
F02:0334       failedmsg:
F02:0335         .byte "Failed!", $0d, $0a, $00
               S02:00001162:  46 61 69 6C 65 64 21
               S02:00001169:  0D
               S02:0000116A:  0A
               S02:0000116B:  00
F02:0336       respmsg:
F02:0337         .byte "Response: ", $00
               S02:0000116C:  52 65 73 70 6F 6E 73 65 3A 20
               S02:00001176:  00
F02:0338       initmsg:
F02:0339         .byte "Initialized!", $0d, $0a, $00
               S02:00001177:  49 6E 69 74 69 61 6C 69 7A 65 64 21
               S02:00001183:  0D
               S02:00001184:  0A
               S02:00001185:  00
F02:0340       
F00:0033       	;.include "libfat32.s"
F00:0034       	; no filesystem
F00:0035       
F00:0036       jmpfailed:
F00:0037       	jmp failed
               S02:00001186:  4C 7C 12
F00:0038       
F00:0039       ebutrocks:
F00:0040       ; init sd card (it was just plugged in)
F00:0041       	jsr sd_init
               S02:00001189:  20 15 10
F00:0042       
F00:0043       	lda #0
               S02:0000118C:  A9 00
F00:0044       	sta bytepointer
               S02:0000118E:  85 66
F00:0045       	sta bytepointer+1
               S02:00001190:  85 67
F00:0046       	sta bytepointer+2
               S02:00001192:  85 68
F00:0047       	sta bytepointer+3
               S02:00001194:  85 69
F00:0048       ;-------------------------------------------------------------------------------
F00:0049       ; Initialize DIGI_Player
F00:0050       
F00:0051               PHA                     ; We need to save both A
               S02:00001196:  48
F00:0052               phx                     ; and X as we use them
               S02:00001197:  DA
F00:0053       
F00:0054               ; disable interrupts
F00:0055               LDA #$00                ; was $7f in the_c64_digi.txt
               S02:00001198:  A9 00
F00:0056               STA $B00D               ; ICR CIA #2
               S02:0000119A:  8D 0D B0
F00:0057                      ; read acks any pending interrupt
F00:0058               LDA $B00D
               S02:0000119D:  AD 0D B0
F00:0059               SEI                     ; disables maskable interrupts
               S02:000011A0:  78
F00:0060       
F00:0061       				; hold on les fix da sd
F00:0062         lda #SD_MOSI
               S02:000011A1:  A9 04
F00:0063         sta PORTA
               S02:000011A3:  8D 01 B0
F00:0064         ; Command 16, arg is sector number, crc not checked
F00:0065         lda #$50                    ; CMD16 - SET_BLOCKLEN
               S02:000011A6:  A9 50
F00:0066         jsr sd_writebyte
               S02:000011A8:  20 AC 10
F00:0067         lda #0		      ; byte 24:31
               S02:000011AB:  A9 00
F00:0068         jsr sd_writebyte
               S02:000011AD:  20 AC 10
F00:0069         lda #0		      ; byte 16:23
               S02:000011B0:  A9 00
F00:0070         jsr sd_writebyte
               S02:000011B2:  20 AC 10
F00:0071         lda #0		      ; byte 8:15
               S02:000011B5:  A9 00
F00:0072         jsr sd_writebyte
               S02:000011B7:  20 AC 10
F00:0073         lda #1                      ; byte 0:7
               S02:000011BA:  A9 01
F00:0074         jsr sd_writebyte
               S02:000011BC:  20 AC 10
F00:0075         lda #$01                    ; crc (not checked)
               S02:000011BF:  A9 01
F00:0076         jsr sd_writebyte
               S02:000011C1:  20 AC 10
F00:0077       
F00:0078         jsr sd_waitresult
               S02:000011C4:  20 C3 10
F00:0079         cmp #$00
               S02:000011C7:  C9 00
F00:0080         bne jmpfailed
               S02:000011C9:  D0 BB
F00:0081         
F00:0082       ;  ; Open root directory
F00:0083       ;  jsr fat32_openroot
F00:0084       ;
F00:0085       ;  ; Find subdirectory by name
F00:0086       ;  ldx #<dirname
F00:0087       ;  ldy #>dirname
F00:0088       ;  jsr fat32_finddirent
F00:0089       ;  bcc foundsubdir
F00:0090       ;
F00:0091       ;error:
F00:0092       ;  plx
F00:0093       ;  pla
F00:0094       ;  rts
F00:0095       ;  rts
F00:0096       ;  rts
F00:0097       ;  rts
F00:0098       ;
F00:0099       ;foundsubdir
F00:0100       ;
F00:0101       ;  ; Open subdirectory
F00:0102       ;  jsr fat32_opendirent
F00:0103       ;				; ok dats don
F00:0104       
F00:0105       
F00:0106               ; initialize SID
F00:0107               LDA #$00                ; zeros out all SID registers
               S02:000011CB:  A9 00
F00:0108               LDX #$00                ;
               S02:000011CD:  A2 00
F00:0109       SIDCLR                          
F00:0110               STA SID,x               ; 
               S02:000011CF:  9D 00 B8
F00:0111               INX                     ;
               S02:000011D2:  E8
F00:0112               BNE SIDCLR             
               S02:000011D3:  D0 FA
F00:0113       
F00:0114               ; SID voices modulated too, increases volume on 8580 SIDs
F00:0115               LDA #$00                ; 
               S02:000011D5:  A9 00
F00:0116               STA SID+$05             ; voice 1 Attach/Decay 
               S02:000011D7:  8D 05 B8
F00:0117               LDA #$F0                ;
               S02:000011DA:  A9 F0
F00:0118               STA SID+$06             ;         Systain/Release 
               S02:000011DC:  8D 06 B8
F00:0119               LDA #$01                ;
               S02:000011DF:  A9 01
F00:0120               STA SID+$04             ;         ctrl 
               S02:000011E1:  8D 04 B8
F00:0121               LDA #$00 
               S02:000011E4:  A9 00
F00:0122               STA SID+$0C             ; voice 2 Attach/Decay 
               S02:000011E6:  8D 0C B8
F00:0123               LDA #$F0                ;
               S02:000011E9:  A9 F0
F00:0124               STA SID+$0D             ;         Systain/Release 
               S02:000011EB:  8D 0D B8
F00:0125               LDA #$01                ;
               S02:000011EE:  A9 01
F00:0126               STA SID+$0B             ;         ctrl 
               S02:000011F0:  8D 0B B8
F00:0127               LDA #$00        
               S02:000011F3:  A9 00
F00:0128               STA SID+$13             ; voice 3 Attach/Decay 
               S02:000011F5:  8D 13 B8
F00:0129               LDA #$F0                ;
               S02:000011F8:  A9 F0
F00:0130               STA SID+$14             ;         Systain/Release 
               S02:000011FA:  8D 14 B8
F00:0131               LDA #$01                ;
               S02:000011FD:  A9 01
F00:0132               STA SID+$12             ;         ctrl 
               S02:000011FF:  8D 12 B8
F00:0133               LDA #$00 
               S02:00001202:  A9 00
F00:0134               STA SID+$15             ; filter  lo 
               S02:00001204:  8D 15 B8
F00:0135               LDA #$10                ;
               S02:00001207:  A9 10
F00:0136               STA SID+$16             ; filter  hi 
               S02:00001209:  8D 16 B8
F00:0137               LDA #$F7                ;
               S02:0000120C:  A9 F7
F00:0138               STA SID+$17             ; filter  voices+reso 
               S02:0000120E:  8D 17 B8
F00:0139       
F00:0140               ; point to our player routine
F00:0141               LDA #<NMI_HANDLER       ; set NMI handler address low byte
               S02:00001211:  A9 82
F00:0142               STA $7FFF               ;
               S02:00001213:  8D FF 7F
F00:0143               LDA #>NMI_HANDLER       ; set NMI handler address hi byte
               S02:00001216:  A9 12
F00:0144               STA $7FFE               ;
               S02:00001218:  8D FE 7F
F00:0145       
F00:0146               ;LDA #<DATASTART         ; low byte
F00:0147       	;STA fat32_address
F00:0148               ;LDA #>DATASTART         ; high byte
F00:0149       	;STA fat32_address+1
F00:0150       
F00:0151               LDA #flagSeed           ; initialize flag used for
               S02:0000121B:  A9 55
F00:0152               STA flag                ; indicating which nibble to play
               S02:0000121D:  85 02
F00:0153       	
F00:0154       	;; get the missle
F00:0155       	;LDX #<datname		; low byte
F00:0156       	;LDY #>datname		; high byte
F00:0157       	;JSR fat32_finddirent	; do it
F00:0158       	;JSR fat32_opendirent	; ignore errors >:)
F00:0159       	;JSR fat32_file_readbyte ; one. yes just one bomb for now.
F00:0160       
F00:0161       	; Command 17, arg is sector number, crc not checked
F00:0162         	lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S02:0000121F:  A9 51
F00:0163         	jsr sd_writebyte
               S02:00001221:  20 AC 10
F00:0164         	lda bytepointer+3	    ; sector 24:31
               S02:00001224:  A5 69
F00:0165         	jsr sd_writebyte
               S02:00001226:  20 AC 10
F00:0166         	lda bytepointer+2	    ; sector 16:23
               S02:00001229:  A5 68
F00:0167         	jsr sd_writebyte
               S02:0000122B:  20 AC 10
F00:0168         	lda bytepointer+1	    ; sector 8:15
               S02:0000122E:  A5 67
F00:0169        	jsr sd_writebyte
               S02:00001230:  20 AC 10
F00:0170        	lda bytepointer+0           ; sector 0:7
               S02:00001233:  A5 66
F00:0171        	jsr sd_writebyte
               S02:00001235:  20 AC 10
F00:0172        	lda #$01                    ; crc (not checked)
               S02:00001238:  A9 01
F00:0173        	jsr sd_writebyte
               S02:0000123A:  20 AC 10
F00:0174       
F00:0175       	jsr sd_waitresult
               S02:0000123D:  20 C3 10
F00:0176       	cmp #$00
               S02:00001240:  C9 00
F00:0177       	bne failed
               S02:00001242:  D0 38
F00:0178       
F00:0179       	jsr sd_readbyte
               S02:00001244:  20 91 10
F00:0180       
F00:0181       	STA DATASTART		; load the missle
               S02:00001247:  8D FE 12
F00:0182       	STA sample		; all right.
               S02:0000124A:  85 01
F00:0183       	JSR wee			; prepare the cannons.
               S02:0000124C:  20 67 12
F00:0184       
F00:0185               LDA #$40                ; ICR set to TMR A underflow
               S02:0000124F:  A9 40
F00:0186               STA $B00D               ; ICR CIA #2
               S02:00001251:  8D 0D B0
F00:0187               LDA #$c0                ;
               S02:00001254:  A9 C0
F00:0188               STA $B00E               ; CRA interrupt enable
               S02:00001256:  8D 0E B0
F00:0189       
F00:0190       	cli
               S02:00001259:  58
F00:0191       
F00:0192               LDA #$00                ;
               S02:0000125A:  A9 00
F00:0193               STA done                ; reset player done flag
               S02:0000125C:  85 00
F00:0194       
F00:0195       pause
F00:0196               LDA done                ; player sets'done' flag when finished, pause
               S02:0000125E:  A5 00
F00:0197               BEQ pause               ; until then for clean return to BASIC
               S02:00001260:  F0 FC
F00:0198       
F00:0199               PLA                     ; Let's get our saved
               S02:00001262:  68
F00:0200               TAX                     ; X register and
               S02:00001263:  AA
F00:0201               PLA                     ; A register back
               S02:00001264:  68
F00:0202               SEI                     ; set interuppts again
               S02:00001265:  78
F00:0203               RTS                     ; and return
               S02:00001266:  60
F00:0204       wee
F00:0205               ; setup VIA, watch out as it will lunch da cannon!!
F00:0206               LDA #<freq              ; interrupt freq
               S02:00001267:  A9 80
F00:0207               STA $B004               ; TA LO
               S02:00001269:  8D 04 B0
F00:0208               LDA #>freq              ;
               S02:0000126C:  A9 00
F00:0209               STA $B005               ; TA HI
               S02:0000126E:  8D 05 B0
F00:0210               LDA #<freq              ; interrupt freq
               S02:00001271:  A9 80
F00:0211               STA $B006               ; TA LO
               S02:00001273:  8D 06 B0
F00:0212               LDA #>freq              ;
               S02:00001276:  A9 00
F00:0213               STA $B007               ; TA HI
               S02:00001278:  8D 07 B0
F00:0214       	RTS
               S02:0000127B:  60
F00:0215       
F00:0216       failed:
F00:0217         plx
               S02:0000127C:  FA
F00:0218         pla
               S02:0000127D:  68
F00:0219         rts
               S02:0000127E:  60
F00:0220         rts
               S02:0000127F:  60
F00:0221         rts
               S02:00001280:  60
F00:0222         rts
               S02:00001281:  60
F00:0223       
F00:0224       ;-------------------------------------------------------------------------------
F00:0225       ; NMI handler routine, plays one 4bit sample per pass
F00:0226       ; Path A -> Play Lower, shift upper down. 3+19+13+23=58 cycles
F00:0227       ; Path B -> Play upper, load new sample. 3+19+8+25=55 cycles
F00:0228       ; Path C -> Play upper. load sample, new page. 3+19+8+14+21=65 cycles
F00:0229       ; Sample's lower nybble holds the 4-bit sample to played on the "even" NMIs
F00:0230       ; The upper nybble holds the next nybble to be played on "odd" NMIs
F00:0231       NMI_HANDLER        
F00:0232               ; start with saving state       
F00:0233               PHA                     ; 3- (3) will restore when returning
               S02:00001282:  48
F00:0234       
F00:0235       	lda #$40
               S02:00001283:  A9 40
F00:0236       	sta $b00d		; ack
               S02:00001285:  8D 0D B0
F00:0237       
F00:0238       	JSR wee			; prepare next missle
               S02:00001288:  20 67 12
F00:0239       
F00:0240               ; play 4-bit sample, first sample byte saved during Init
F00:0241               LDA sample              ; 3- load sample byte
               S02:0000128B:  A5 01
F00:0242               ORA #$10                ; 2- make sure wee no ded filter settings
               S02:0000128D:  09 10
F00:0243               AND #$1F                ; 2- git rid of any put bits
               S02:0000128F:  29 1F
F00:0244               STA SID+$18             ; 4- save to ta regsiter
               S02:00001291:  8D 18 B8
F00:0245               LDA $B00D               ; 4- (19)clear gobut
               S02:00001294:  AD 0D B0
F00:0246       
F00:0247               ; flag init to $AA or $55, We shift alternating pattern though flag byte
F00:0248               ASL flag                ; 5- shift patten left thru flag byte
               S02:00001297:  06 02
F00:0249               BCC loadnew             ; 2-3 
               S02:00001299:  90 0C
F00:0250               INC flag                ; 5 (8-13) so skip ahead to load new byte
               S02:0000129B:  E6 02
F00:0251          
F00:0252       shftupr
F00:0253               LDA sample              ; 3- *1 shift upper nibble down
               S02:0000129D:  A5 01
F00:0254               LSR a                   ; 2-
               S02:0000129F:  4A
F00:0255               LSR a                   ; 2-
               S02:000012A0:  4A
F00:0256               LSR a                   ; 2-
               S02:000012A1:  4A
F00:0257               LSR a                   ; 2-
               S02:000012A2:  4A
F00:0258               STA sample              ; 3- store it back to play next pass
               S02:000012A3:  85 01
F00:0259       
F00:0260               PLA                     ; 3- local exit code is smaller and 
               S02:000012A5:  68
F00:0261               RTI                     ; 6- (23) faster than jumps/branches
               S02:000012A6:  40
F00:0262       
F00:0263               ; loadnew+1,+2 is self-modifying ptr to sample, gets set in init
F00:0264       loadnew
F00:0265       	; manny! read da bite.
F00:0266        	lda #SD_MOSI
               S02:000012A7:  A9 04
F00:0267         	sta PORTA
               S02:000012A9:  8D 01 B0
F00:0268       
F00:0269       	inc bytepointer
               S02:000012AC:  E6 66
F00:0270       	bne newcontinue
               S02:000012AE:  D0 0A
F00:0271       	inc bytepointer+1
               S02:000012B0:  E6 67
F00:0272       	bne newcontinue
               S02:000012B2:  D0 06
F00:0273       	inc bytepointer+2
               S02:000012B4:  E6 68
F00:0274       	bne newcontinue
               S02:000012B6:  D0 02
F00:0275       	inc bytepointer+3
               S02:000012B8:  E6 69
F00:0276       
F00:0277       newcontinue:
F00:0278       
F00:0279         	; Command 17, arg is sector number, crc not checked
F00:0280         	lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
               S02:000012BA:  A9 51
F00:0281         	jsr sd_writebyte
               S02:000012BC:  20 AC 10
F00:0282         	lda bytepointer+3	    ; sector 24:31
               S02:000012BF:  A5 69
F00:0283         	jsr sd_writebyte
               S02:000012C1:  20 AC 10
F00:0284         	lda bytepointer+2	    ; sector 16:23
               S02:000012C4:  A5 68
F00:0285         	jsr sd_writebyte
               S02:000012C6:  20 AC 10
F00:0286         	lda bytepointer+1	    ; sector 8:15
               S02:000012C9:  A5 67
F00:0287        	jsr sd_writebyte
               S02:000012CB:  20 AC 10
F00:0288        	lda bytepointer+0           ; sector 0:7
               S02:000012CE:  A5 66
F00:0289        	jsr sd_writebyte
               S02:000012D0:  20 AC 10
F00:0290        	lda #$01                    ; crc (not checked)
               S02:000012D3:  A9 01
F00:0291        	jsr sd_writebyte
               S02:000012D5:  20 AC 10
F00:0292       
F00:0293       	jsr sd_waitresult
               S02:000012D8:  20 C3 10
F00:0294       	cmp #$00
               S02:000012DB:  C9 00
F00:0295       	bne stop
               S02:000012DD:  D0 0A
F00:0296       
F00:0297       	jsr sd_readbyte
               S02:000012DF:  20 91 10
F00:0298               STA sample              ; 3- save to temp location
               S02:000012E2:  85 01
F00:0299       	STA DATASTART
               S02:000012E4:  8D FE 12
F00:0300               ;BCS stop               ; 2-3- if thats it then stop
F00:0301       	; BUG cannot stop sample when reading sd RAW
F00:0302               PLA                     ; 3- local exit code is smaller and
               S02:000012E7:  68
F00:0303               RTI                     ; 6- (14-25)faster than jumps/branches
               S02:000012E8:  40
F00:0304       
F00:0305       
F00:0306       stop
F00:0307               LDA #$08                ; 2- turn off NMI (IRQ AAAAAA)
               S02:000012E9:  A9 08
F00:0308               STA $B00E               ; 4- timer A stop-CRA, CIA #1 DC0E
               S02:000012EB:  8D 0E B0
F00:0309               LDA #$4F                ; 2- disable all CIA-2 NMIs 
               S02:000012EE:  A9 4F
F00:0310               STA $B00D               ; 4- ICR - interrupt control / status
               S02:000012F0:  8D 0D B0
F00:0311               LDA $B00D               ; 4- (16) sta/lda to ack any pending int
               S02:000012F3:  AD 0D B0
F00:0312       
F00:0313               LDA #$37                ; 2- reset kernal banking
               S02:000012F6:  A9 37
F00:0314               STA $01                 ; 3- (5)
               S02:000012F8:  85 01
F00:0315       
F00:0316               INC done                ; set player done flag
               S02:000012FA:  E6 00
F00:0317               
F00:0318               PLA                     ; 3- local exit code is smaller and
               S02:000012FC:  68
F00:0319               RTI                     ; 6- faster than jumps/branches
               S02:000012FD:  40
F00:0320       
F00:0321       DATASTART 
F00:0322       	.byte $00		; smol... ah ye its actually many MB. haha
               S02:000012FE:  00
F00:0323       DATASTOP  
F00:0324       


Sections:
S01  segf00
S02  seg1000


Sources:
F00  stream.s
F01  hwconfig.s
F02  libsd.s


Symbols:
DATASTOP EXPR(4863=0x12ff) UNUSED ABS 
stop EXPR(4841=0x12e9) ABS 
newcontinue EXPR(4794=0x12ba) ABS 
shftupr EXPR(4765=0x129d) UNUSED ABS 
loadnew EXPR(4775=0x12a7) ABS 
pause EXPR(4702=0x125e) ABS 
wee EXPR(4711=0x1267) ABS 
DATASTART EXPR(4862=0x12fe) ABS 
NMI_HANDLER EXPR(4738=0x1282) ABS 
SIDCLR EXPR(4559=0x11cf) ABS 
failed EXPR(4732=0x127c) ABS 
jmpfailed EXPR(4486=0x1186) ABS 
initmsg EXPR(4471=0x1177) UNUSED ABS 
respmsg EXPR(4460=0x116c) UNUSED ABS 
failedmsg EXPR(4450=0x1162) UNUSED ABS 
initfailedmsg EXPR(4445=0x115d) UNUSED ABS 
statusmsg EXPR(4436=0x1154) UNUSED ABS 
 sd_readsector readloop EXPR(4427=0x114b) ABS 
 sd_readsector failloop EXPR(4422=0x1146) ABS 
 sd_readsector readpage EXPR(4425=0x1149) ABS 
 sd_readsector fail EXPR(4422=0x1146) ABS 
sd_readsector EXPR(4357=0x1105) UNUSED ABS 
sd_waitresult EXPR(4291=0x10c3) ABS 
 sd_writebyte sendbit EXPR(4278=0x10b6) ABS 
 sd_writebyte loop EXPR(4270=0x10ae) ABS 
sd_writebyte EXPR(4268=0x10ac) ABS 
 sd_readbyte bitnotset EXPR(4262=0x10a6) ABS 
 sd_readbyte loop EXPR(4243=0x1093) ABS 
 sd_init loop EXPR(4214=0x1076) ABS 
 sd_init delayloop EXPR(4205=0x106d) ABS 
 sd_init initialized EXPR(4214=0x1076) ABS 
sd_cmd41_bytes EXPR(4235=0x108b) ABS 
 sd_init cmd41 EXPR(4182=0x1056) UNUSED ABS 
sd_cmd55_bytes EXPR(4229=0x1085) ABS 
 sd_init cmd55 EXPR(4167=0x1047) ABS 
sd_readbyte EXPR(4241=0x1091) ABS 
 sd_init initfailed EXPR(4214=0x1076) ABS 
sd_cmd8_bytes EXPR(4223=0x107f) ABS 
 sd_init cmd8 EXPR(4140=0x102c) UNUSED ABS 
sd_sendcommand EXPR(4299=0x10cb) ABS 
sd_cmd0_bytes EXPR(4217=0x1079) ABS 
 sd_init cmd0 EXPR(4129=0x1021) UNUSED ABS 
 sd_init preinitloop EXPR(4121=0x1019) ABS 
sd_init EXPR(4117=0x1015) ABS 
cmsg EXPR(4107=0x100b) UNUSED ABS 
via_init EXPR(4096=0x1000) UNUSED ABS 
PORTA_OUTPUTPINS EXPR(252=0xfc) EQU 
SD_MISO EXPR(2=0x2) EQU 
SD_MOSI EXPR(4=0x4) EQU 
SD_SCK EXPR(8=0x8) EQU 
SD_CS EXPR(16=0x10) EQU 
LCD_RS EXPR(32=0x20) EQU 
LCD_RW EXPR(64=0x40) EQU 
LCD_E EXPR(128=0x80) EQU 
DDRA EXPR(45059=0xb003) EQU 
DDRB EXPR(45058=0xb002) EQU 
PORTA EXPR(45057=0xb001) EQU 
PORTB EXPR(45056=0xb000) UNUSED EQU 
ebutrocks EXPR(4489=0x1189) ABS 
darn EXPR(3840=0xf00) UNUSED ABS 
freq EXPR(128=0x80) EQU 
flagSeed EXPR(85=0x55) EQU 
SID EXPR(47104=0xb800) EQU 
endbuf EXPR(1536=0x600) UNUSED EQU 
buffer EXPR(1024=0x400) UNUSED EQU 
bytepointer EXPR(102=0x66) EQU 
zp_fat32_variables EXPR(70=0x46) UNUSED EQU 
zp_sd_currentsector EXPR(66=0x42) EQU 
zp_sd_address EXPR(64=0x40) EQU 
flag EXPR(2=0x2) EQU 
sample EXPR(1=0x1) EQU 
done EXPR(0=0x0) EQU 
__RPTCNT EXPR(-1=0xffff) INTERNAL 
__VASM EXPR(0=0x0) INTERNAL 

There have been no errors.
